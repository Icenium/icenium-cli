///<reference path=".d.ts"/>
"use strict";

import yok = require("../lib/common/yok");

import Future = require("fibers/future");
import stubs = require("./stubs");
import temp = require("temp");
temp.track();
import util = require("util");
var assert = require("chai").assert;
var fileSys = require("fs");

var fileSystemFile = require("../lib/common/file-system");
var hashServiceFile = require("../lib/services/hash-service");

function createTestInjector(): IInjector {
	var testInjector = new yok.Yok();

	testInjector.register("fs", fileSystemFile.FileSystem);
	testInjector.register("hashService", hashServiceFile.HashService);
	testInjector.register("logger", stubs.LoggerStub);
	testInjector.register("errors", ErrorsNoFailStub);
	return testInjector;
}

function createTempFile(data: string): IFuture<string> {
	var future = new Future<string>();
	var myData = data; // "Some data that has to be uploaded.";
	var pathToTempFile: string;
	temp.open("tempHashServiceTestsFile", function(err, info) {
		if(!err) {
			fileSys.write(info.fd, myData);
			pathToTempFile = info.path;
			future.return(pathToTempFile);
		} else {
			future.throw(err);
		}
	});

	return future;
}

var failed = false;

class ErrorsNoFailStub implements IErrors {
	fail(formatStr: string, ...args: any[]): void;
	fail(opts: { formatStr?: string; errorCode?: number; suppressCommandHelp?: boolean }, ...args: any[]): void;

	fail(...args: any[]) { failed = true; throw new Error(args[0]); }
	failWithoutHelp(message: string, ...args: any[]): void {
		throw new Error();
	}

	beginCommand(action: () => IFuture<boolean>, printHelpCommand: () => IFuture<boolean>): IFuture<boolean> {
		return (() => {
			try {
				var result = action().wait();
			} catch(ex) {
				return false;
			}

			return result;
		}).future<boolean>()();
	}

	executeAction(action: Function): any {
		return action();
	}

	verifyHeap(message: string): void { }
}

describe("hash service", () => {
	describe("getFileHash", () => {
		// As the current autogenerated code for uploadChunk method is unusable for us,
		// this test verifies that we are calling our own uploadChunk method.
		it("fails when file doesn't exist", () => {
			failed = false;
			var expectedErrorMessage = "Specified file thisFileDoesNotExist does not exist.";
			var testInjector = createTestInjector();
			var hashService: IHashService = testInjector.resolve("hashService");
			try {
				hashService.getFileHash("thisFileDoesNotExist", "utf8", "sha512", "base64").wait();
			} catch(e) {
				assert.isTrue(failed);
				assert.isTrue(e.message.indexOf(expectedErrorMessage) > -1);
			}
		});

		it("fails when input file encoding is not correct", () => {
			failed = false;
			var expectedErrorMessage = "Specified input file encoding not valid is not valid.";
			var testInjector = createTestInjector();
			var hashService: IHashService = testInjector.resolve("hashService");
			var filePath = createTempFile("testFile").wait();
			try {
				hashService.getFileHash(filePath, "not valid", "sha512", "base64").wait();
			} catch(e) {
				assert.isTrue(failed);
				assert.isTrue(e.message.indexOf(expectedErrorMessage) > -1);
			}
		});

		it("fails when input hash algorithm is not correct", () => {
			failed = false;
			var expectedErrorMessage = "Specified hash algorithm not valid is not valid. Valid algorithms are";
			var testInjector = createTestInjector();
			var hashService: IHashService = testInjector.resolve("hashService");
			var filePath = createTempFile("testFile").wait();
			try {
				hashService.getFileHash(filePath, "utf8", "not valid", "base64").wait();
			} catch(e) {
				assert.isTrue(failed);
				assert.isTrue(e.message.indexOf(expectedErrorMessage) > -1);
			}
		});

		it("fails when hash encoding is not correct", () => {
			failed = false;
			var expectedErrorMessage = "Specified hash encoding not valid is not valid. Valid values are";
			var testInjector = createTestInjector();
			var hashService: IHashService = testInjector.resolve("hashService");
			var filePath = createTempFile("testFile").wait();
			try {
				hashService.getFileHash(filePath, "utf8", "sha512", "not valid").wait();
			} catch(e) {
				assert.isTrue(failed);
				assert.isTrue(e.message.indexOf(expectedErrorMessage) > -1);
			}
		});

		it("does not fail when input parameters are correct", () => {
			failed = false;
			
			var testInjector = createTestInjector();
			var hashService: IHashService = testInjector.resolve("hashService");
			// NOTE: in case you change testFile string passed to createTempFile, you should create new hash file as well.
			var filePath = createTempFile("testFile").wait();
			var expectedHash = "kpcHKUXV7JjoyHcXqsVB5EAz+HX1ffWA/X48ozSakHgaNR3OiEctsMKafwewR836Gi4dRyBsjW+GkR+hTQ4Qog=="
			var hash = hashService.getFileHash(filePath, "utf8", "sha512", "base64").wait();
			
			assert.isFalse(failed);
			assert.equal(expectedHash, hash);
		});
	});
});
