/* tslint:disable:class-name */

declare function CGRectMake(x: number, y: number, width: number, height: number): CGRect;
declare function CGPointMake(x: number, y: number): CGPoint;
declare function CGSizeMake(width: number, height: number): CGSize;

declare class NSManagedObjectContext extends NSObject implements NSCoding, NSLocking {
	persistentStoreCoordinator: any;
	parentContext: NSManagedObjectContext;
	name: string;
	undoManager: NSUndoManager;
	hasChanges: boolean;
	userInfo: NSMutableDictionary;
	concurrencyType: number;
	insertedObjects: NSSet;
	updatedObjects: NSSet;
	deletedObjects: NSSet;
	registeredObjects: NSSet;
	propagatesDeletesAtEndOfEvent: boolean;
	retainsRegisteredObjects: boolean;
	stalenessInterval: number;
	mergePolicy: any;
	constructor(ct: number);
	constructor();
	initWithConcurrencyType(ct: number): NSManagedObjectContext;
	performBlock(block: () => void): void;
	performBlockAndWait(block: () => void): void;
	objectRegisteredForID(objectID: any): any;
	objectWithID(objectID: any): any;
	existingObjectWithIDError(objectID: any, error: any): any;
	executeFetchRequestError(request: any, error: any): NSArray;
	countForFetchRequestError(request: any, error: any): number;
	executeRequestError(request: any, error: any): any;
	insertObject(object: any): void;
	deleteObject(object: any): void;
	refreshObjectMergeChanges(object: any, flag: boolean): void;
	detectConflictsForObject(object: any): void;
	processPendingChanges(): void;
	assignObjectToPersistentStore(object: any, store: any): void;
	undo(): void;
	redo(): void;
	reset(): void;
	rollback(): void;
	save(error: any): boolean;
	tryLock(): boolean;
	obtainPermanentIDsForObjectsError(objects: NSArray, error: any): boolean;
	mergeChangesFromContextDidSaveNotification(notification: NSNotification): void;
	init(): NSManagedObjectContext;
	static new(): NSManagedObjectContext;
	static allocWithZone(zone: any): NSManagedObjectContext;
	static alloc(): NSManagedObjectContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	lock(): void;
	unlock(): void;
}
declare class NSManagedObjectModel extends NSObject implements NSCoding, NSCopying, NSFastEnumeration {
	entitiesByName: NSDictionary;
	entities: NSArray;
	configurations: NSArray;
	localizationDictionary: NSDictionary;
	fetchRequestTemplatesByName: NSDictionary;
	versionIdentifiers: NSSet;
	entityVersionHashesByName: NSDictionary;
	constructor(url: NSURL);
	constructor();
	static mergedModelFromBundles(bundles: NSArray): NSManagedObjectModel;
	static modelByMergingModels(models: NSArray): NSManagedObjectModel;
	initWithContentsOfURL(url: NSURL): NSManagedObjectModel;
	entitiesForConfiguration(configuration: string): NSArray;
	setEntitiesForConfiguration(entities: NSArray, configuration: string): void;
	setFetchRequestTemplateForName(fetchRequestTemplate: any, name: string): void;
	fetchRequestTemplateForName(name: string): any;
	fetchRequestFromTemplateWithNameSubstitutionVariables(name: string, variables: NSDictionary): any;
	static mergedModelFromBundlesForStoreMetadata(bundles: NSArray, metadata: NSDictionary): NSManagedObjectModel;
	static modelByMergingModelsForStoreMetadata(models: NSArray, metadata: NSDictionary): NSManagedObjectModel;
	isConfigurationCompatibleWithStoreMetadata(configuration: string, metadata: NSDictionary): boolean;
	init(): NSManagedObjectModel;
	static new(): NSManagedObjectModel;
	static allocWithZone(zone: any): NSManagedObjectModel;
	static alloc(): NSManagedObjectModel;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSObject implements NSObjectProtocol {
	classForCoder: any;
	autoContentAccessingProxy: any;
	observationInfo: any;
	classForKeyedArchiver: any;
	isAccessibilityElement: boolean;
	accessibilityLabel: string;
	accessibilityHint: string;
	accessibilityValue: string;
	accessibilityTraits: number;
	accessibilityFrame: CGRect;
	accessibilityPath: UIBezierPath;
	accessibilityActivationPoint: CGPoint;
	accessibilityLanguage: string;
	accessibilityElementsHidden: boolean;
	accessibilityViewIsModal: boolean;
	shouldGroupAccessibilityChildren: boolean;
	accessibilityNavigationStyle: number;
	accessibilityElements: NSArray;
	accessibilityCustomActions: NSArray;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static load(): void;
	static initialize(): void;
	init(): NSObject;
	static new(): NSObject;
	static allocWithZone(zone: any): NSObject;
	static alloc(): NSObject;
	dealloc(): void;
	finalize(): void;
	copy(): any;
	mutableCopy(): any;
	static copyWithZone(zone: any): any;
	static mutableCopyWithZone(zone: any): any;
	static instancesRespondToSelector(aSelector: any): boolean;
	static conformsToProtocol(protocol: any): boolean;
	methodForSelector(aSelector: any): (arg1: any, arg2: any) => any;
	static instanceMethodForSelector(aSelector: any): (arg1: any, arg2: any) => any;
	doesNotRecognizeSelector(aSelector: any): void;
	forwardingTargetForSelector(aSelector: any): any;
	forwardInvocation(anInvocation: NSInvocation): void;
	methodSignatureForSelector(aSelector: any): NSMethodSignature;
	static instanceMethodSignatureForSelector(aSelector: any): NSMethodSignature;
	static isSubclassOfClass(aClass: any): boolean;
	static resolveClassMethod(sel: any): boolean;
	static resolveInstanceMethod(sel: any): boolean;
	static hash(): number;
	static superclass(): any;
	static class(): any;
	static description(): string;
	static debugDescription(): string;
	static version(): number;
	static setVersion(aVersion: number): void;
	replacementObjectForCoder(aCoder: NSCoder): any;
	awakeAfterUsingCoder(aDecoder: NSCoder): any;
	attemptRecoveryFromErrorOptionIndexDelegateDidRecoverSelectorContextInfo(error: NSError, recoveryOptionIndex: number, delegate: any, didRecoverSelector: any, contextInfo: any): void;
	attemptRecoveryFromErrorOptionIndex(error: NSError, recoveryOptionIndex: number): boolean;
	fileManagerShouldProceedAfterError(fm: NSFileManager, errorInfo: NSDictionary): boolean;
	fileManagerWillProcessPath(fm: NSFileManager, path: string): void;
	static accessInstanceVariablesDirectly(): boolean;
	valueForKey(key: string): any;
	setValueForKey(value: any, key: string): void;
	validateValueForKeyError(ioValue: any, inKey: string, outError: any): boolean;
	mutableArrayValueForKey(key: string): NSMutableArray;
	mutableOrderedSetValueForKey(key: string): NSMutableOrderedSet;
	mutableSetValueForKey(key: string): NSMutableSet;
	valueForKeyPath(keyPath: string): any;
	setValueForKeyPath(value: any, keyPath: string): void;
	validateValueForKeyPathError(ioValue: any, inKeyPath: string, outError: any): boolean;
	mutableArrayValueForKeyPath(keyPath: string): NSMutableArray;
	mutableOrderedSetValueForKeyPath(keyPath: string): NSMutableOrderedSet;
	mutableSetValueForKeyPath(keyPath: string): NSMutableSet;
	valueForUndefinedKey(key: string): any;
	setValueForUndefinedKey(value: any, key: string): void;
	setNilValueForKey(key: string): void;
	dictionaryWithValuesForKeys(keys: NSArray): NSDictionary;
	setValuesForKeysWithDictionary(keyedValues: NSDictionary): void;
	observeValueForKeyPathOfObjectChangeContext(keyPath: string, object: any, change: NSDictionary, context: any): void;
	addObserverForKeyPathOptionsContext(observer: NSObject, keyPath: string, options: number, context: any): void;
	removeObserverForKeyPathContext(observer: NSObject, keyPath: string, context: any): void;
	removeObserverForKeyPath(observer: NSObject, keyPath: string): void;
	willChangeValueForKey(key: string): void;
	didChangeValueForKey(key: string): void;
	willChangeValuesAtIndexesForKey(changeKind: number, indexes: NSIndexSet, key: string): void;
	didChangeValuesAtIndexesForKey(changeKind: number, indexes: NSIndexSet, key: string): void;
	willChangeValueForKeyWithSetMutationUsingObjects(key: string, mutationKind: number, objects: NSSet): void;
	didChangeValueForKeyWithSetMutationUsingObjects(key: string, mutationKind: number, objects: NSSet): void;
	static keyPathsForValuesAffectingValueForKey(key: string): NSSet;
	static automaticallyNotifiesObserversForKey(key: string): boolean;
	replacementObjectForKeyedArchiver(archiver: NSKeyedArchiver): any;
	static classFallbacksForKeyedArchiver(): NSArray;
	static classForKeyedUnarchiver(): any;
	performSelectorWithObjectAfterDelayInModes(aSelector: any, anArgument: any, delay: number, modes: NSArray): void;
	performSelectorWithObjectAfterDelay(aSelector: any, anArgument: any, delay: number): void;
	static cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget: any, aSelector: any, anArgument: any): void;
	static cancelPreviousPerformRequestsWithTarget(aTarget: any): void;
	performSelectorOnMainThreadWithObjectWaitUntilDoneModes(aSelector: any, arg: any, wait: boolean, array: NSArray): void;
	performSelectorOnMainThreadWithObjectWaitUntilDone(aSelector: any, arg: any, wait: boolean): void;
	performSelectorOnThreadWithObjectWaitUntilDoneModes(aSelector: any, thr: NSThread, arg: any, wait: boolean, array: NSArray): void;
	performSelectorOnThreadWithObjectWaitUntilDone(aSelector: any, thr: NSThread, arg: any, wait: boolean): void;
	performSelectorInBackgroundWithObject(aSelector: any, arg: any): void;
	cut(sender: any): void;
	copy(sender: any): void;
	paste(sender: any): void;
	select(sender: any): void;
	selectAll(sender: any): void;
	delete(sender: any): void;
	makeTextWritingDirectionLeftToRight(sender: any): void;
	makeTextWritingDirectionRightToLeft(sender: any): void;
	toggleBoldface(sender: any): void;
	toggleItalics(sender: any): void;
	toggleUnderline(sender: any): void;
	increaseSize(sender: any): void;
	decreaseSize(sender: any): void;
	accessibilityElementCount(): number;
	accessibilityElementAtIndex(index: number): any;
	indexOfAccessibilityElement(element: any): number;
	accessibilityElementDidBecomeFocused(): void;
	accessibilityElementDidLoseFocus(): void;
	accessibilityElementIsFocused(): boolean;
	accessibilityActivate(): boolean;
	accessibilityIncrement(): void;
	accessibilityDecrement(): void;
	accessibilityScroll(direction: number): boolean;
	accessibilityPerformEscape(): boolean;
	accessibilityPerformMagicTap(): boolean;
	awakeFromNib(): void;
	prepareForInterfaceBuilder(): void;
	displayLayer(layer: CALayer): void;
	drawLayerInContext(layer: CALayer, ctx: any): void;
	layoutSublayersOfLayer(layer: CALayer): void;
	actionForLayerForKey(layer: CALayer, event: string): any;
	animationDidStart(anim: CAAnimation): void;
	animationDidStopFinished(anim: CAAnimation, flag: boolean): void;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSEnumerator extends NSObject implements NSFastEnumeration {
	allObjects: NSArray;
	constructor();
	nextObject(): any;
	init(): NSEnumerator;
	static new(): NSEnumerator;
	static allocWithZone(zone: any): NSEnumerator;
	static alloc(): NSEnumerator;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSValue extends NSObject implements NSCopying, NSSecureCoding {
	objCType: string;
	nonretainedObjectValue: any;
	rangeValue: NSRange;
	CATransform3DValue: CATransform3D;
	CMTimeValue: CMTime;
	CMTimeRangeValue: CMTimeRange;
	CMTimeMappingValue: CMTimeMapping;
	MKCoordinateValue: CLLocationCoordinate2D;
	MKCoordinateSpanValue: MKCoordinateSpan;
	constructor(value: any, type: string);
	constructor();
	getValue(value: any): void;
	initWithBytesObjCType(value: any, type: string): NSValue;
	static valueWithBytesObjCType(value: any, type: string): NSValue;
	static valueWithObjCType(value: any, type: string): NSValue;
	static valueWithNonretainedObject(anObject: any): NSValue;
	static valueWithPointer(pointer: any): NSValue;
	pointerValue(): any;
	isEqualToValue(value: NSValue): boolean;
	static valueWithRange(range: NSRange): NSValue;
	static valueWithCGPoint(point: CGPoint): NSValue;
	static valueWithCGVector(vector: CGVector): NSValue;
	static valueWithCGSize(size: CGSize): NSValue;
	static valueWithCGRect(rect: CGRect): NSValue;
	static valueWithCGAffineTransform(transform: CGAffineTransform): NSValue;
	static valueWithUIEdgeInsets(insets: UIEdgeInsets): NSValue;
	static valueWithUIOffset(insets: UIOffset): NSValue;
	CGPointValue(): CGPoint;
	CGVectorValue(): CGVector;
	CGSizeValue(): CGSize;
	CGRectValue(): CGRect;
	CGAffineTransformValue(): CGAffineTransform;
	UIEdgeInsetsValue(): UIEdgeInsets;
	UIOffsetValue(): UIOffset;
	static valueWithCATransform3D(t: CATransform3D): NSValue;
	static valueWithCMTime(time: CMTime): NSValue;
	static valueWithCMTimeRange(timeRange: CMTimeRange): NSValue;
	static valueWithCMTimeMapping(timeMapping: CMTimeMapping): NSValue;
	static valueWithMKCoordinate(coordinate: CLLocationCoordinate2D): NSValue;
	static valueWithMKCoordinateSpan(span: MKCoordinateSpan): NSValue;
	init(): NSValue;
	static new(): NSValue;
	static allocWithZone(zone: any): NSValue;
	static alloc(): NSValue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSNumber extends NSValue implements CKRecordValue {
	charValue: string;
	unsignedCharValue: number;
	shortValue: number;
	unsignedShortValue: number;
	intValue: number;
	unsignedIntValue: number;
	longValue: number;
	unsignedLongValue: number;
	longLongValue: number;
	unsignedLongLongValue: number;
	floatValue: number;
	doubleValue: number;
	boolValue: boolean;
	integerValue: number;
	unsignedIntegerValue: number;
	stringValue: string;
	decimalValue: NSDecimal;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(value: string);
	constructor(value: boolean);
	constructor(value: any, type: string);
	constructor();
	initWithChar(value: string): NSNumber;
	initWithUnsignedChar(value: number): NSNumber;
	initWithShort(value: number): NSNumber;
	initWithUnsignedShort(value: number): NSNumber;
	initWithInt(value: number): NSNumber;
	initWithUnsignedInt(value: number): NSNumber;
	initWithLong(value: number): NSNumber;
	initWithUnsignedLong(value: number): NSNumber;
	initWithLongLong(value: number): NSNumber;
	initWithUnsignedLongLong(value: number): NSNumber;
	initWithFloat(value: number): NSNumber;
	initWithDouble(value: number): NSNumber;
	initWithBool(value: boolean): NSNumber;
	initWithInteger(value: number): NSNumber;
	initWithUnsignedInteger(value: number): NSNumber;
	compare(otherNumber: NSNumber): number;
	isEqualToNumber(number: NSNumber): boolean;
	descriptionWithLocale(locale: any): string;
	static numberWithChar(value: string): NSNumber;
	static numberWithUnsignedChar(value: number): NSNumber;
	static numberWithShort(value: number): NSNumber;
	static numberWithUnsignedShort(value: number): NSNumber;
	static numberWithInt(value: number): NSNumber;
	static numberWithUnsignedInt(value: number): NSNumber;
	static numberWithLong(value: number): NSNumber;
	static numberWithUnsignedLong(value: number): NSNumber;
	static numberWithLongLong(value: number): NSNumber;
	static numberWithUnsignedLongLong(value: number): NSNumber;
	static numberWithFloat(value: number): NSNumber;
	static numberWithDouble(value: number): NSNumber;
	static numberWithBool(value: boolean): NSNumber;
	static numberWithInteger(value: number): NSNumber;
	static numberWithUnsignedInteger(value: number): NSNumber;
	initWithBytesObjCType(value: any, type: string): NSNumber;
	init(): NSNumber;
	static new(): NSNumber;
	static allocWithZone(zone: any): NSNumber;
	static alloc(): NSNumber;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSArray extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration, CKRecordValue {
	count: number;
	firstObject: any;
	lastObject: any;
	sortedArrayHint: NSData;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(objects: any, cnt: number);
	constructor(firstObj: any);
	constructor(array: NSArray);
	constructor(array: NSArray, flag: boolean);
	constructor(path: string);
	constructor(url: NSURL);
	constructor();
	objectAtIndex(index: number): any;
	initWithObjectsCount(objects: any, cnt: number): NSArray;
	arrayByAddingObject(anObject: any): NSArray;
	arrayByAddingObjectsFromArray(otherArray: NSArray): NSArray;
	componentsJoinedByString(separator: string): string;
	containsObject(anObject: any): boolean;
	descriptionWithLocale(locale: any): string;
	descriptionWithLocaleIndent(locale: any, level: number): string;
	firstObjectCommonWithArray(otherArray: NSArray): any;
	getObjectsRange(objects: any, range: NSRange): void;
	indexOfObject(anObject: any): number;
	indexOfObjectInRange(anObject: any, range: NSRange): number;
	indexOfObjectIdenticalTo(anObject: any): number;
	indexOfObjectIdenticalToInRange(anObject: any, range: NSRange): number;
	isEqualToArray(otherArray: NSArray): boolean;
	objectEnumerator(): NSEnumerator;
	reverseObjectEnumerator(): NSEnumerator;
	sortedArrayUsingFunctionContext(comparator: (arg1: any, arg2: any, arg3: any) => number, context: any): NSArray;
	sortedArrayUsingFunctionContextHint(comparator: (arg1: any, arg2: any, arg3: any) => number, context: any, hint: NSData): NSArray;
	sortedArrayUsingSelector(comparator: any): NSArray;
	subarrayWithRange(range: NSRange): NSArray;
	writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;
	writeToURLAtomically(url: NSURL, atomically: boolean): boolean;
	makeObjectsPerformSelector(aSelector: any): void;
	makeObjectsPerformSelectorWithObject(aSelector: any, argument: any): void;
	objectsAtIndexes(indexes: NSIndexSet): NSArray;
	objectAtIndexedSubscript(idx: number): any;
	enumerateObjectsUsingBlock(block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateObjectsWithOptionsUsingBlock(opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateObjectsAtIndexesOptionsUsingBlock(s: NSIndexSet, opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	indexOfObjectPassingTest(predicate: (arg1: any, arg2: number, arg3: any) => boolean): number;
	indexOfObjectWithOptionsPassingTest(opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): number;
	indexOfObjectAtIndexesOptionsPassingTest(s: NSIndexSet, opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): number;
	indexesOfObjectsPassingTest(predicate: (arg1: any, arg2: number, arg3: any) => boolean): NSIndexSet;
	indexesOfObjectsWithOptionsPassingTest(opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): NSIndexSet;
	indexesOfObjectsAtIndexesOptionsPassingTest(s: NSIndexSet, opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): NSIndexSet;
	sortedArrayUsingComparator(cmptr: (arg1: any, arg2: any) => number): NSArray;
	sortedArrayWithOptionsUsingComparator(opts: number, cmptr: (arg1: any, arg2: any) => number): NSArray;
	indexOfObjectInSortedRangeOptionsUsingComparator(obj: any, r: NSRange, opts: number, cmp: (arg1: any, arg2: any) => number): number;
	static array(): NSArray;
	static arrayWithObject(anObject: any): NSArray;
	static arrayWithObjectsCount(objects: any, cnt: number): NSArray;
	static arrayWithObjects(firstObj: any): NSArray;
	static arrayWithArray(array: NSArray): NSArray;
	initWithObjects(firstObj: any): NSArray;
	initWithArray(array: NSArray): NSArray;
	initWithArrayCopyItems(array: NSArray, flag: boolean): NSArray;
	static arrayWithContentsOfFile(path: string): NSArray;
	static arrayWithContentsOfURL(url: NSURL): NSArray;
	initWithContentsOfFile(path: string): NSArray;
	initWithContentsOfURL(url: NSURL): NSArray;
	getObjects(objects: any): void;
	pathsMatchingExtensions(filterTypes: NSArray): NSArray;
	addObserverToObjectsAtIndexesForKeyPathOptionsContext(observer: NSObject, indexes: NSIndexSet, keyPath: string, options: number, context: any): void;
	removeObserverFromObjectsAtIndexesForKeyPathContext(observer: NSObject, indexes: NSIndexSet, keyPath: string, context: any): void;
	removeObserverFromObjectsAtIndexesForKeyPath(observer: NSObject, indexes: NSIndexSet, keyPath: string): void;
	sortedArrayUsingDescriptors(sortDescriptors: NSArray): NSArray;
	filteredArrayUsingPredicate(predicate: NSPredicate): NSArray;
	init(): NSArray;
	static new(): NSArray;
	static allocWithZone(zone: any): NSArray;
	static alloc(): NSArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSMutableArray extends NSArray {
	constructor(numItems: number);
	constructor(objects: any, cnt: number);
	constructor(firstObj: any);
	constructor(array: NSArray);
	constructor(array: NSArray, flag: boolean);
	constructor(path: string);
	constructor(url: NSURL);
	constructor();
	addObject(anObject: any): void;
	insertObjectAtIndex(anObject: any, index: number): void;
	removeLastObject(): void;
	removeObjectAtIndex(index: number): void;
	replaceObjectAtIndexWithObject(index: number, anObject: any): void;
	initWithCapacity(numItems: number): NSMutableArray;
	addObjectsFromArray(otherArray: NSArray): void;
	exchangeObjectAtIndexWithObjectAtIndex(idx1: number, idx2: number): void;
	removeAllObjects(): void;
	removeObjectInRange(anObject: any, range: NSRange): void;
	removeObject(anObject: any): void;
	removeObjectIdenticalToInRange(anObject: any, range: NSRange): void;
	removeObjectIdenticalTo(anObject: any): void;
	removeObjectsFromIndicesNumIndices(indices: any, cnt: number): void;
	removeObjectsInArray(otherArray: NSArray): void;
	removeObjectsInRange(range: NSRange): void;
	replaceObjectsInRangeWithObjectsFromArrayRange(range: NSRange, otherArray: NSArray, otherRange: NSRange): void;
	replaceObjectsInRangeWithObjectsFromArray(range: NSRange, otherArray: NSArray): void;
	setArray(otherArray: NSArray): void;
	sortUsingFunctionContext(compare: (arg1: any, arg2: any, arg3: any) => number, context: any): void;
	sortUsingSelector(comparator: any): void;
	insertObjectsAtIndexes(objects: NSArray, indexes: NSIndexSet): void;
	removeObjectsAtIndexes(indexes: NSIndexSet): void;
	replaceObjectsAtIndexesWithObjects(indexes: NSIndexSet, objects: NSArray): void;
	setObjectAtIndexedSubscript(obj: any, idx: number): void;
	sortUsingComparator(cmptr: (arg1: any, arg2: any) => number): void;
	sortWithOptionsUsingComparator(opts: number, cmptr: (arg1: any, arg2: any) => number): void;
	static arrayWithCapacity(numItems: number): NSMutableArray;
	static arrayWithContentsOfFile(path: string): NSMutableArray;
	static arrayWithContentsOfURL(url: NSURL): NSMutableArray;
	sortUsingDescriptors(sortDescriptors: NSArray): void;
	filterUsingPredicate(predicate: NSPredicate): void;
	initWithObjectsCount(objects: any, cnt: number): NSMutableArray;
	static array(): NSMutableArray;
	static arrayWithObject(anObject: any): NSMutableArray;
	static arrayWithObjectsCount(objects: any, cnt: number): NSMutableArray;
	static arrayWithObjects(firstObj: any): NSMutableArray;
	static arrayWithArray(array: NSArray): NSMutableArray;
	initWithObjects(firstObj: any): NSMutableArray;
	initWithArray(array: NSArray): NSMutableArray;
	initWithArrayCopyItems(array: NSArray, flag: boolean): NSMutableArray;
	initWithContentsOfFile(path: string): NSMutableArray;
	initWithContentsOfURL(url: NSURL): NSMutableArray;
	init(): NSMutableArray;
	static new(): NSMutableArray;
	static allocWithZone(zone: any): NSMutableArray;
	static alloc(): NSMutableArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSAutoreleasePool extends NSObject {
	constructor();
	static addObject(anObject: any): void;
	addObject(anObject: any): void;
	drain(): void;
	init(): NSAutoreleasePool;
	static new(): NSAutoreleasePool;
	static allocWithZone(zone: any): NSAutoreleasePool;
	static alloc(): NSAutoreleasePool;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSBundle extends NSObject {
	loaded: boolean;
	bundleURL: NSURL;
	resourceURL: NSURL;
	executableURL: NSURL;
	privateFrameworksURL: NSURL;
	sharedFrameworksURL: NSURL;
	sharedSupportURL: NSURL;
	builtInPlugInsURL: NSURL;
	appStoreReceiptURL: NSURL;
	bundlePath: string;
	resourcePath: string;
	executablePath: string;
	privateFrameworksPath: string;
	sharedFrameworksPath: string;
	sharedSupportPath: string;
	builtInPlugInsPath: string;
	bundleIdentifier: string;
	infoDictionary: NSDictionary;
	localizedInfoDictionary: NSDictionary;
	principalClass: any;
	preferredLocalizations: NSArray;
	localizations: NSArray;
	developmentLocalization: string;
	executableArchitectures: NSArray;
	constructor(path: string);
	constructor(url: NSURL);
	constructor();
	static mainBundle(): NSBundle;
	static bundleWithPath(path: string): NSBundle;
	initWithPath(path: string): NSBundle;
	static bundleWithURL(url: NSURL): NSBundle;
	initWithURL(url: NSURL): NSBundle;
	static bundleForClass(aClass: any): NSBundle;
	static bundleWithIdentifier(identifier: string): NSBundle;
	static allBundles(): NSArray;
	static allFrameworks(): NSArray;
	load(): boolean;
	unload(): boolean;
	preflightAndReturnError(error: any): boolean;
	loadAndReturnError(error: any): boolean;
	URLForAuxiliaryExecutable(executableName: string): NSURL;
	pathForAuxiliaryExecutable(executableName: string): string;
	static URLForResourceWithExtensionSubdirectoryInBundleWithURL(name: string, ext: string, subpath: string, bundleURL: NSURL): NSURL;
	static URLsForResourcesWithExtensionSubdirectoryInBundleWithURL(ext: string, subpath: string, bundleURL: NSURL): NSArray;
	URLForResourceWithExtension(name: string, ext: string): NSURL;
	URLForResourceWithExtensionSubdirectory(name: string, ext: string, subpath: string): NSURL;
	URLForResourceWithExtensionSubdirectoryLocalization(name: string, ext: string, subpath: string, localizationName: string): NSURL;
	URLsForResourcesWithExtensionSubdirectory(ext: string, subpath: string): NSArray;
	URLsForResourcesWithExtensionSubdirectoryLocalization(ext: string, subpath: string, localizationName: string): NSArray;
	static pathForResourceOfTypeInDirectory(name: string, ext: string, bundlePath: string): string;
	static pathsForResourcesOfTypeInDirectory(ext: string, bundlePath: string): NSArray;
	pathForResourceOfType(name: string, ext: string): string;
	pathForResourceOfTypeInDirectory(name: string, ext: string, subpath: string): string;
	pathForResourceOfTypeInDirectoryForLocalization(name: string, ext: string, subpath: string, localizationName: string): string;
	pathsForResourcesOfTypeInDirectory(ext: string, subpath: string): NSArray;
	pathsForResourcesOfTypeInDirectoryForLocalization(ext: string, subpath: string, localizationName: string): NSArray;
	localizedStringForKeyValueTable(key: string, value: string, tableName: string): string;
	objectForInfoDictionaryKey(key: string): any;
	classNamed(className: string): any;
	static preferredLocalizationsFromArray(localizationsArray: NSArray): NSArray;
	static preferredLocalizationsFromArrayForPreferences(localizationsArray: NSArray, preferencesArray: NSArray): NSArray;
	loadNibNamedOwnerOptions(name: string, owner: any, options: NSDictionary): NSArray;
	init(): NSBundle;
	static new(): NSBundle;
	static allocWithZone(zone: any): NSBundle;
	static alloc(): NSBundle;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSDate extends NSObject implements NSCopying, NSSecureCoding, CKRecordValue {
	timeIntervalSinceReferenceDate: number;
	timeIntervalSinceNow: number;
	timeIntervalSince1970: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(secsToBeAdded: number, date: NSDate);
	constructor();
	initWithTimeIntervalSinceReferenceDate(ti: number): NSDate;
	timeIntervalSinceDate(anotherDate: NSDate): number;
	addTimeInterval(seconds: number): any;
	dateByAddingTimeInterval(ti: number): NSDate;
	earlierDate(anotherDate: NSDate): NSDate;
	laterDate(anotherDate: NSDate): NSDate;
	compare(other: NSDate): number;
	isEqualToDate(otherDate: NSDate): boolean;
	descriptionWithLocale(locale: any): string;
	static timeIntervalSinceReferenceDate(): number;
	static date(): NSDate;
	static dateWithTimeIntervalSinceNow(secs: number): NSDate;
	static dateWithTimeIntervalSinceReferenceDate(ti: number): NSDate;
	static dateWithTimeIntervalSince1970(secs: number): NSDate;
	static dateWithTimeIntervalSinceDate(secsToBeAdded: number, date: NSDate): NSDate;
	static distantFuture(): any;
	static distantPast(): any;
	initWithTimeIntervalSinceNow(secs: number): NSDate;
	initWithTimeIntervalSince1970(secs: number): NSDate;
	initWithTimeIntervalSinceDate(secsToBeAdded: number, date: NSDate): NSDate;
	init(): NSDate;
	static new(): NSDate;
	static allocWithZone(zone: any): NSDate;
	static alloc(): NSDate;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSCalendar extends NSObject implements NSCopying, NSSecureCoding {
	calendarIdentifier: string;
	locale: NSLocale;
	timeZone: NSTimeZone;
	firstWeekday: number;
	minimumDaysInFirstWeek: number;
	eraSymbols: NSArray;
	longEraSymbols: NSArray;
	monthSymbols: NSArray;
	shortMonthSymbols: NSArray;
	veryShortMonthSymbols: NSArray;
	standaloneMonthSymbols: NSArray;
	shortStandaloneMonthSymbols: NSArray;
	veryShortStandaloneMonthSymbols: NSArray;
	weekdaySymbols: NSArray;
	shortWeekdaySymbols: NSArray;
	veryShortWeekdaySymbols: NSArray;
	standaloneWeekdaySymbols: NSArray;
	shortStandaloneWeekdaySymbols: NSArray;
	veryShortStandaloneWeekdaySymbols: NSArray;
	quarterSymbols: NSArray;
	shortQuarterSymbols: NSArray;
	standaloneQuarterSymbols: NSArray;
	shortStandaloneQuarterSymbols: NSArray;
	AMSymbol: string;
	PMSymbol: string;
	constructor(ident: string);
	constructor();
	static currentCalendar(): NSCalendar;
	static autoupdatingCurrentCalendar(): NSCalendar;
	static calendarWithIdentifier(calendarIdentifierConstant: string): NSCalendar;
	initWithCalendarIdentifier(ident: string): NSCalendar;
	minimumRangeOfUnit(unit: number): NSRange;
	maximumRangeOfUnit(unit: number): NSRange;
	rangeOfUnitInUnitForDate(smaller: number, larger: number, date: NSDate): NSRange;
	ordinalityOfUnitInUnitForDate(smaller: number, larger: number, date: NSDate): number;
	rangeOfUnitStartDateIntervalForDate(unit: number, datep: any, tip: any, date: NSDate): boolean;
	dateFromComponents(comps: NSDateComponents): NSDate;
	componentsFromDate(unitFlags: number, date: NSDate): NSDateComponents;
	dateByAddingComponentsToDateOptions(comps: NSDateComponents, date: NSDate, opts: number): NSDate;
	componentsFromDateToDateOptions(unitFlags: number, startingDate: NSDate, resultDate: NSDate, opts: number): NSDateComponents;
	getEraYearMonthDayFromDate(eraValuePointer: any, yearValuePointer: any, monthValuePointer: any, dayValuePointer: any, date: NSDate): void;
	getEraYearForWeekOfYearWeekOfYearWeekdayFromDate(eraValuePointer: any, yearValuePointer: any, weekValuePointer: any, weekdayValuePointer: any, date: NSDate): void;
	getHourMinuteSecondNanosecondFromDate(hourValuePointer: any, minuteValuePointer: any, secondValuePointer: any, nanosecondValuePointer: any, date: NSDate): void;
	componentFromDate(unit: number, date: NSDate): number;
	dateWithEraYearMonthDayHourMinuteSecondNanosecond(eraValue: number, yearValue: number, monthValue: number, dayValue: number, hourValue: number, minuteValue: number, secondValue: number, nanosecondValue: number): NSDate;
	dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond(eraValue: number, yearValue: number, weekValue: number, weekdayValue: number, hourValue: number, minuteValue: number, secondValue: number, nanosecondValue: number): NSDate;
	startOfDayForDate(date: NSDate): NSDate;
	componentsInTimeZoneFromDate(timezone: NSTimeZone, date: NSDate): NSDateComponents;
	compareDateToDateToUnitGranularity(date1: NSDate, date2: NSDate, unit: number): number;
	isDateEqualToDateToUnitGranularity(date1: NSDate, date2: NSDate, unit: number): boolean;
	isDateInSameDayAsDate(date1: NSDate, date2: NSDate): boolean;
	isDateInToday(date: NSDate): boolean;
	isDateInYesterday(date: NSDate): boolean;
	isDateInTomorrow(date: NSDate): boolean;
	isDateInWeekend(date: NSDate): boolean;
	rangeOfWeekendStartDateIntervalContainingDate(datep: any, tip: any, date: NSDate): boolean;
	nextWeekendStartDateIntervalOptionsAfterDate(datep: any, tip: any, options: number, date: NSDate): boolean;
	componentsFromDateComponentsToDateComponentsOptions(unitFlags: number, startingDateComp: NSDateComponents, resultDateComp: NSDateComponents, options: number): NSDateComponents;
	dateByAddingUnitValueToDateOptions(unit: number, value: number, date: NSDate, options: number): NSDate;
	enumerateDatesStartingAfterDateMatchingComponentsOptionsUsingBlock(start: NSDate, comps: NSDateComponents, opts: number, block: (arg1: NSDate, arg2: boolean, arg3: any) => void): void;
	nextDateAfterDateMatchingComponentsOptions(date: NSDate, comps: NSDateComponents, options: number): NSDate;
	nextDateAfterDateMatchingUnitValueOptions(date: NSDate, unit: number, value: number, options: number): NSDate;
	nextDateAfterDateMatchingHourMinuteSecondOptions(date: NSDate, hourValue: number, minuteValue: number, secondValue: number, options: number): NSDate;
	dateBySettingUnitValueOfDateOptions(unit: number, v: number, date: NSDate, opts: number): NSDate;
	dateBySettingHourMinuteSecondOfDateOptions(h: number, m: number, s: number, date: NSDate, opts: number): NSDate;
	dateMatchesComponents(date: NSDate, components: NSDateComponents): boolean;
	init(): NSCalendar;
	static new(): NSCalendar;
	static allocWithZone(zone: any): NSCalendar;
	static alloc(): NSCalendar;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSDateComponents extends NSObject implements NSCopying, NSSecureCoding {
	calendar: NSCalendar;
	timeZone: NSTimeZone;
	era: number;
	year: number;
	month: number;
	day: number;
	hour: number;
	minute: number;
	second: number;
	nanosecond: number;
	weekday: number;
	weekdayOrdinal: number;
	quarter: number;
	weekOfMonth: number;
	weekOfYear: number;
	yearForWeekOfYear: number;
	leapMonth: boolean;
	date: NSDate;
	validDate: boolean;
	constructor();
	week(): number;
	setWeek(v: number): void;
	setValueForComponent(value: number, unit: number): void;
	valueForComponent(unit: number): number;
	isValidDateInCalendar(calendar: NSCalendar): boolean;
	init(): NSDateComponents;
	static new(): NSDateComponents;
	static allocWithZone(zone: any): NSDateComponents;
	static alloc(): NSDateComponents;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSString extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, CKRecordValue {
	length: number;
	doubleValue: number;
	floatValue: number;
	intValue: number;
	integerValue: number;
	longLongValue: number;
	boolValue: boolean;
	uppercaseString: string;
	lowercaseString: string;
	capitalizedString: string;
	fastestEncoding: number;
	smallestEncoding: number;
	decomposedStringWithCanonicalMapping: string;
	precomposedStringWithCanonicalMapping: string;
	decomposedStringWithCompatibilityMapping: string;
	precomposedStringWithCompatibilityMapping: string;
	UTF8String: string;
	pathComponents: NSArray;
	absolutePath: boolean;
	lastPathComponent: string;
	stringByDeletingLastPathComponent: string;
	pathExtension: string;
	stringByDeletingPathExtension: string;
	stringByAbbreviatingWithTildeInPath: string;
	stringByExpandingTildeInPath: string;
	stringByStandardizingPath: string;
	stringByResolvingSymlinksInPath: string;
	fileSystemRepresentation: string;
	stringByRemovingPercentEncoding: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(characters: any, length: number, freeBuffer: boolean);
	constructor(characters: any, length: number);
	constructor(data: NSData, encoding: number);
	constructor(bytes: any, len: number, encoding: number);
	constructor(bytes: any, len: number, encoding: number, freeBuffer: boolean);
	constructor(url: NSURL, enc: number, error: any);
	constructor(path: string, enc: number, error: any);
	constructor(url: NSURL, enc: any, error: any);
	constructor(path: string, enc: any, error: any);
	constructor(url: NSURL);
	constructor(bytes: string, length: number, freeBuffer: boolean);
	constructor();
	characterAtIndex(index: number): string;
	getCharactersRange(buffer: any, aRange: NSRange): void;
	substringFromIndex(from: number): string;
	substringToIndex(to: number): string;
	substringWithRange(range: NSRange): string;
	compare(string: string): number;
	compareOptions(string: string, mask: number): number;
	compareOptionsRange(string: string, mask: number, compareRange: NSRange): number;
	compareOptionsRangeLocale(string: string, mask: number, compareRange: NSRange, locale: any): number;
	caseInsensitiveCompare(string: string): number;
	localizedCompare(string: string): number;
	localizedCaseInsensitiveCompare(string: string): number;
	localizedStandardCompare(string: string): number;
	isEqualToString(aString: string): boolean;
	hasPrefix(aString: string): boolean;
	hasSuffix(aString: string): boolean;
	containsString(aString: string): boolean;
	localizedCaseInsensitiveContainsString(aString: string): boolean;
	rangeOfString(aString: string): NSRange;
	rangeOfStringOptions(aString: string, mask: number): NSRange;
	rangeOfStringOptionsRange(aString: string, mask: number, searchRange: NSRange): NSRange;
	rangeOfStringOptionsRangeLocale(aString: string, mask: number, searchRange: NSRange, locale: NSLocale): NSRange;
	rangeOfCharacterFromSet(aSet: NSCharacterSet): NSRange;
	rangeOfCharacterFromSetOptions(aSet: NSCharacterSet, mask: number): NSRange;
	rangeOfCharacterFromSetOptionsRange(aSet: NSCharacterSet, mask: number, searchRange: NSRange): NSRange;
	rangeOfComposedCharacterSequenceAtIndex(index: number): NSRange;
	rangeOfComposedCharacterSequencesForRange(range: NSRange): NSRange;
	stringByAppendingString(aString: string): string;
	componentsSeparatedByString(separator: string): NSArray;
	componentsSeparatedByCharactersInSet(separator: NSCharacterSet): NSArray;
	commonPrefixWithStringOptions(aString: string, mask: number): string;
	uppercaseStringWithLocale(locale: NSLocale): string;
	lowercaseStringWithLocale(locale: NSLocale): string;
	capitalizedStringWithLocale(locale: NSLocale): string;
	stringByTrimmingCharactersInSet(set: NSCharacterSet): string;
	stringByPaddingToLengthWithStringStartingAtIndex(newLength: number, padString: string, padIndex: number): string;
	getLineStartEndContentsEndForRange(startPtr: any, lineEndPtr: any, contentsEndPtr: any, range: NSRange): void;
	lineRangeForRange(range: NSRange): NSRange;
	getParagraphStartEndContentsEndForRange(startPtr: any, parEndPtr: any, contentsEndPtr: any, range: NSRange): void;
	paragraphRangeForRange(range: NSRange): NSRange;
	enumerateSubstringsInRangeOptionsUsingBlock(range: NSRange, opts: number, block: (arg1: string, arg2: NSRange, arg3: NSRange, arg4: any) => void): void;
	enumerateLinesUsingBlock(block: (arg1: string, arg2: any) => void): void;
	dataUsingEncodingAllowLossyConversion(encoding: number, lossy: boolean): NSData;
	dataUsingEncoding(encoding: number): NSData;
	canBeConvertedToEncoding(encoding: number): boolean;
	cStringUsingEncoding(encoding: number): string;
	getCStringMaxLengthEncoding(buffer: string, maxBufferCount: number, encoding: number): boolean;
	getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange(buffer: any, maxBufferCount: number, usedBufferCount: any, encoding: number, options: number, range: NSRange, leftover: any): boolean;
	maximumLengthOfBytesUsingEncoding(enc: number): number;
	lengthOfBytesUsingEncoding(enc: number): number;
	stringByFoldingWithOptionsLocale(options: number, locale: NSLocale): string;
	stringByReplacingOccurrencesOfStringWithStringOptionsRange(target: string, replacement: string, options: number, searchRange: NSRange): string;
	stringByReplacingOccurrencesOfStringWithString(target: string, replacement: string): string;
	stringByReplacingCharactersInRangeWithString(range: NSRange, replacement: string): string;
	static defaultCStringEncoding(): number;
	static availableStringEncodings(): any;
	static localizedNameOfStringEncoding(encoding: number): string;
	initWithCharactersNoCopyLengthFreeWhenDone(characters: any, length: number, freeBuffer: boolean): NSString;
	initWithCharactersLength(characters: any, length: number): NSString;
	initWithUTF8String(nullTerminatedCString: string): NSString;
	initWithString(aString: string): NSString;
	initWithDataEncoding(data: NSData, encoding: number): NSString;
	initWithBytesLengthEncoding(bytes: any, len: number, encoding: number): NSString;
	initWithBytesNoCopyLengthEncodingFreeWhenDone(bytes: any, len: number, encoding: number, freeBuffer: boolean): NSString;
	static string(): NSString;
	static stringWithString(string: string): NSString;
	static stringWithCharactersLength(characters: any, length: number): NSString;
	static stringWithUTF8String(nullTerminatedCString: string): NSString;
	initWithCStringEncoding(nullTerminatedCString: string, encoding: number): NSString;
	static stringWithCStringEncoding(cString: string, enc: number): NSString;
	initWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSString;
	initWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSString;
	static stringWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSString;
	static stringWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSString;
	initWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSString;
	initWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSString;
	static stringWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSString;
	static stringWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSString;
	writeToURLAtomicallyEncodingError(url: NSURL, useAuxiliaryFile: boolean, enc: number, error: any): boolean;
	writeToFileAtomicallyEncodingError(path: string, useAuxiliaryFile: boolean, enc: number, error: any): boolean;
	static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(data: NSData, opts: NSDictionary, string: any, usedLossyConversion: any): NSString;
	propertyList(): any;
	propertyListFromStringsFileFormat(): NSDictionary;
	cString(): string;
	lossyCString(): string;
	cStringLength(): number;
	getCString(bytes: string): void;
	getCStringMaxLength(bytes: string, maxLength: number): void;
	getCStringMaxLengthRangeRemainingRange(bytes: string, maxLength: number, aRange: NSRange, leftoverRange: any): void;
	writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;
	writeToURLAtomically(url: NSURL, atomically: boolean): boolean;
	initWithContentsOfFile(path: string): NSString;
	initWithContentsOfURL(url: NSURL): NSString;
	static stringWithContentsOfFile(path: string): NSString;
	static stringWithContentsOfURL(url: NSURL): NSString;
	initWithCStringNoCopyLengthFreeWhenDone(bytes: string, length: number, freeBuffer: boolean): NSString;
	initWithCStringLength(bytes: string, length: number): NSString;
	initWithCString(bytes: string): NSString;
	static stringWithCStringLength(bytes: string, length: number): NSString;
	static stringWithCString(bytes: string): NSString;
	getCharacters(buffer: any): void;
	static pathWithComponents(components: NSArray): string;
	stringByAppendingPathComponent(str: string): string;
	stringByAppendingPathExtension(str: string): string;
	stringsByAppendingPaths(paths: NSArray): NSArray;
	completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes(outputName: any, flag: boolean, outputArray: any, filterTypes: NSArray): number;
	getFileSystemRepresentationMaxLength(cname: string, max: number): boolean;
	stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet): string;
	stringByAddingPercentEscapesUsingEncoding(enc: number): string;
	stringByReplacingPercentEscapesUsingEncoding(enc: number): string;
	linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges(range: NSRange, tagScheme: string, opts: number, orthography: NSOrthography, tokenRanges: any): NSArray;
	enumerateLinguisticTagsInRangeSchemeOptionsOrthographyUsingBlock(range: NSRange, tagScheme: string, opts: number, orthography: NSOrthography, block: (arg1: string, arg2: NSRange, arg3: NSRange, arg4: any) => void): void;
	sizeWithFont(font: UIFont): CGSize;
	sizeWithFontForWidthLineBreakMode(font: UIFont, width: number, lineBreakMode: number): CGSize;
	drawAtPointWithFont(point: CGPoint, font: UIFont): CGSize;
	drawAtPointForWidthWithFontLineBreakMode(point: CGPoint, width: number, font: UIFont, lineBreakMode: number): CGSize;
	sizeWithFontConstrainedToSize(font: UIFont, size: CGSize): CGSize;
	sizeWithFontConstrainedToSizeLineBreakMode(font: UIFont, size: CGSize, lineBreakMode: number): CGSize;
	drawInRectWithFont(rect: CGRect, font: UIFont): CGSize;
	drawInRectWithFontLineBreakMode(rect: CGRect, font: UIFont, lineBreakMode: number): CGSize;
	drawInRectWithFontLineBreakModeAlignment(rect: CGRect, font: UIFont, lineBreakMode: number, alignment: number): CGSize;
	sizeWithFontMinFontSizeActualFontSizeForWidthLineBreakMode(font: UIFont, minFontSize: number, actualFontSize: any, width: number, lineBreakMode: number): CGSize;
	drawAtPointForWidthWithFontFontSizeLineBreakModeBaselineAdjustment(point: CGPoint, width: number, font: UIFont, fontSize: number, lineBreakMode: number, baselineAdjustment: number): CGSize;
	drawAtPointForWidthWithFontMinFontSizeActualFontSizeLineBreakModeBaselineAdjustment(point: CGPoint, width: number, font: UIFont, minFontSize: number, actualFontSize: any, lineBreakMode: number, baselineAdjustment: number): CGSize;
	sizeWithAttributes(attrs: NSDictionary): CGSize;
	drawAtPointWithAttributes(point: CGPoint, attrs: NSDictionary): void;
	drawInRectWithAttributes(rect: CGRect, attrs: NSDictionary): void;
	drawWithRectOptionsAttributesContext(rect: CGRect, options: number, attributes: NSDictionary, context: NSStringDrawingContext): void;
	boundingRectWithSizeOptionsAttributesContext(size: CGSize, options: number, attributes: NSDictionary, context: NSStringDrawingContext): CGRect;
	init(): NSString;
	static new(): NSString;
	static allocWithZone(zone: any): NSString;
	static alloc(): NSString;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSMutableString extends NSString {
	constructor(capacity: number);
	constructor(characters: any, length: number, freeBuffer: boolean);
	constructor(characters: any, length: number);
	constructor(data: NSData, encoding: number);
	constructor(bytes: any, len: number, encoding: number);
	constructor(bytes: any, len: number, encoding: number, freeBuffer: boolean);
	constructor(url: NSURL, enc: number, error: any);
	constructor(path: string, enc: number, error: any);
	constructor(url: NSURL, enc: any, error: any);
	constructor(path: string, enc: any, error: any);
	constructor(url: NSURL);
	constructor(bytes: string, length: number, freeBuffer: boolean);
	constructor();
	replaceCharactersInRangeWithString(range: NSRange, aString: string): void;
	insertStringAtIndex(aString: string, loc: number): void;
	deleteCharactersInRange(range: NSRange): void;
	appendString(aString: string): void;
	setString(aString: string): void;
	initWithCapacity(capacity: number): NSMutableString;
	static stringWithCapacity(capacity: number): NSMutableString;
	replaceOccurrencesOfStringWithStringOptionsRange(target: string, replacement: string, options: number, searchRange: NSRange): number;
	initWithCharactersNoCopyLengthFreeWhenDone(characters: any, length: number, freeBuffer: boolean): NSMutableString;
	initWithCharactersLength(characters: any, length: number): NSMutableString;
	initWithUTF8String(nullTerminatedCString: string): NSMutableString;
	initWithString(aString: string): NSMutableString;
	initWithDataEncoding(data: NSData, encoding: number): NSMutableString;
	initWithBytesLengthEncoding(bytes: any, len: number, encoding: number): NSMutableString;
	initWithBytesNoCopyLengthEncodingFreeWhenDone(bytes: any, len: number, encoding: number, freeBuffer: boolean): NSMutableString;
	static string(): NSMutableString;
	static stringWithString(string: string): NSMutableString;
	static stringWithCharactersLength(characters: any, length: number): NSMutableString;
	static stringWithUTF8String(nullTerminatedCString: string): NSMutableString;
	initWithCStringEncoding(nullTerminatedCString: string, encoding: number): NSMutableString;
	static stringWithCStringEncoding(cString: string, enc: number): NSMutableString;
	initWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSMutableString;
	initWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSMutableString;
	static stringWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSMutableString;
	static stringWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSMutableString;
	initWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSMutableString;
	initWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSMutableString;
	static stringWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSMutableString;
	static stringWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSMutableString;
	static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(data: NSData, opts: NSDictionary, string: any, usedLossyConversion: any): NSMutableString;
	initWithContentsOfFile(path: string): NSMutableString;
	initWithContentsOfURL(url: NSURL): NSMutableString;
	static stringWithContentsOfFile(path: string): NSMutableString;
	static stringWithContentsOfURL(url: NSURL): NSMutableString;
	initWithCStringNoCopyLengthFreeWhenDone(bytes: string, length: number, freeBuffer: boolean): NSMutableString;
	initWithCStringLength(bytes: string, length: number): NSMutableString;
	initWithCString(bytes: string): NSMutableString;
	static stringWithCStringLength(bytes: string, length: number): NSMutableString;
	static stringWithCString(bytes: string): NSMutableString;
	init(): NSMutableString;
	static new(): NSMutableString;
	static allocWithZone(zone: any): NSMutableString;
	static alloc(): NSMutableString;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSSimpleCString extends NSString {
	constructor(characters: any, length: number, freeBuffer: boolean);
	constructor(characters: any, length: number);
	constructor(data: NSData, encoding: number);
	constructor(bytes: any, len: number, encoding: number);
	constructor(bytes: any, len: number, encoding: number, freeBuffer: boolean);
	constructor(url: NSURL, enc: number, error: any);
	constructor(path: string, enc: number, error: any);
	constructor(url: NSURL, enc: any, error: any);
	constructor(path: string, enc: any, error: any);
	constructor(url: NSURL);
	constructor(bytes: string, length: number, freeBuffer: boolean);
	constructor();
	initWithCharactersNoCopyLengthFreeWhenDone(characters: any, length: number, freeBuffer: boolean): NSSimpleCString;
	initWithCharactersLength(characters: any, length: number): NSSimpleCString;
	initWithUTF8String(nullTerminatedCString: string): NSSimpleCString;
	initWithString(aString: string): NSSimpleCString;
	initWithDataEncoding(data: NSData, encoding: number): NSSimpleCString;
	initWithBytesLengthEncoding(bytes: any, len: number, encoding: number): NSSimpleCString;
	initWithBytesNoCopyLengthEncodingFreeWhenDone(bytes: any, len: number, encoding: number, freeBuffer: boolean): NSSimpleCString;
	static string(): NSSimpleCString;
	static stringWithString(string: string): NSSimpleCString;
	static stringWithCharactersLength(characters: any, length: number): NSSimpleCString;
	static stringWithUTF8String(nullTerminatedCString: string): NSSimpleCString;
	initWithCStringEncoding(nullTerminatedCString: string, encoding: number): NSSimpleCString;
	static stringWithCStringEncoding(cString: string, enc: number): NSSimpleCString;
	initWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSSimpleCString;
	initWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSSimpleCString;
	static stringWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSSimpleCString;
	static stringWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSSimpleCString;
	initWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSSimpleCString;
	initWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSSimpleCString;
	static stringWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSSimpleCString;
	static stringWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSSimpleCString;
	static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(data: NSData, opts: NSDictionary, string: any, usedLossyConversion: any): NSSimpleCString;
	initWithContentsOfFile(path: string): NSSimpleCString;
	initWithContentsOfURL(url: NSURL): NSSimpleCString;
	static stringWithContentsOfFile(path: string): NSSimpleCString;
	static stringWithContentsOfURL(url: NSURL): NSSimpleCString;
	initWithCStringNoCopyLengthFreeWhenDone(bytes: string, length: number, freeBuffer: boolean): NSSimpleCString;
	initWithCStringLength(bytes: string, length: number): NSSimpleCString;
	initWithCString(bytes: string): NSSimpleCString;
	static stringWithCStringLength(bytes: string, length: number): NSSimpleCString;
	static stringWithCString(bytes: string): NSSimpleCString;
	init(): NSSimpleCString;
	static new(): NSSimpleCString;
	static allocWithZone(zone: any): NSSimpleCString;
	static alloc(): NSSimpleCString;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSConstantString extends NSSimpleCString {
	constructor(characters: any, length: number, freeBuffer: boolean);
	constructor(characters: any, length: number);
	constructor(data: NSData, encoding: number);
	constructor(bytes: any, len: number, encoding: number);
	constructor(bytes: any, len: number, encoding: number, freeBuffer: boolean);
	constructor(url: NSURL, enc: number, error: any);
	constructor(path: string, enc: number, error: any);
	constructor(url: NSURL, enc: any, error: any);
	constructor(path: string, enc: any, error: any);
	constructor(url: NSURL);
	constructor(bytes: string, length: number, freeBuffer: boolean);
	constructor();
	initWithCharactersNoCopyLengthFreeWhenDone(characters: any, length: number, freeBuffer: boolean): NSConstantString;
	initWithCharactersLength(characters: any, length: number): NSConstantString;
	initWithUTF8String(nullTerminatedCString: string): NSConstantString;
	initWithString(aString: string): NSConstantString;
	initWithDataEncoding(data: NSData, encoding: number): NSConstantString;
	initWithBytesLengthEncoding(bytes: any, len: number, encoding: number): NSConstantString;
	initWithBytesNoCopyLengthEncodingFreeWhenDone(bytes: any, len: number, encoding: number, freeBuffer: boolean): NSConstantString;
	static string(): NSConstantString;
	static stringWithString(string: string): NSConstantString;
	static stringWithCharactersLength(characters: any, length: number): NSConstantString;
	static stringWithUTF8String(nullTerminatedCString: string): NSConstantString;
	initWithCStringEncoding(nullTerminatedCString: string, encoding: number): NSConstantString;
	static stringWithCStringEncoding(cString: string, enc: number): NSConstantString;
	initWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSConstantString;
	initWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSConstantString;
	static stringWithContentsOfURLEncodingError(url: NSURL, enc: number, error: any): NSConstantString;
	static stringWithContentsOfFileEncodingError(path: string, enc: number, error: any): NSConstantString;
	initWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSConstantString;
	initWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSConstantString;
	static stringWithContentsOfURLUsedEncodingError(url: NSURL, enc: any, error: any): NSConstantString;
	static stringWithContentsOfFileUsedEncodingError(path: string, enc: any, error: any): NSConstantString;
	static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(data: NSData, opts: NSDictionary, string: any, usedLossyConversion: any): NSConstantString;
	initWithContentsOfFile(path: string): NSConstantString;
	initWithContentsOfURL(url: NSURL): NSConstantString;
	static stringWithContentsOfFile(path: string): NSConstantString;
	static stringWithContentsOfURL(url: NSURL): NSConstantString;
	initWithCStringNoCopyLengthFreeWhenDone(bytes: string, length: number, freeBuffer: boolean): NSConstantString;
	initWithCStringLength(bytes: string, length: number): NSConstantString;
	initWithCString(bytes: string): NSConstantString;
	static stringWithCStringLength(bytes: string, length: number): NSConstantString;
	static stringWithCString(bytes: string): NSConstantString;
	init(): NSConstantString;
	static new(): NSConstantString;
	static allocWithZone(zone: any): NSConstantString;
	static alloc(): NSConstantString;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSCharacterSet extends NSObject implements NSCopying, NSMutableCopying, NSCoding {
	bitmapRepresentation: NSData;
	invertedSet: NSCharacterSet;
	constructor();
	static controlCharacterSet(): NSCharacterSet;
	static whitespaceCharacterSet(): NSCharacterSet;
	static whitespaceAndNewlineCharacterSet(): NSCharacterSet;
	static decimalDigitCharacterSet(): NSCharacterSet;
	static letterCharacterSet(): NSCharacterSet;
	static lowercaseLetterCharacterSet(): NSCharacterSet;
	static uppercaseLetterCharacterSet(): NSCharacterSet;
	static nonBaseCharacterSet(): NSCharacterSet;
	static alphanumericCharacterSet(): NSCharacterSet;
	static decomposableCharacterSet(): NSCharacterSet;
	static illegalCharacterSet(): NSCharacterSet;
	static punctuationCharacterSet(): NSCharacterSet;
	static capitalizedLetterCharacterSet(): NSCharacterSet;
	static symbolCharacterSet(): NSCharacterSet;
	static newlineCharacterSet(): NSCharacterSet;
	static characterSetWithRange(aRange: NSRange): NSCharacterSet;
	static characterSetWithCharactersInString(aString: string): NSCharacterSet;
	static characterSetWithBitmapRepresentation(data: NSData): NSCharacterSet;
	static characterSetWithContentsOfFile(fName: string): NSCharacterSet;
	characterIsMember(aCharacter: string): boolean;
	longCharacterIsMember(theLongChar: number): boolean;
	isSupersetOfSet(theOtherSet: NSCharacterSet): boolean;
	hasMemberInPlane(thePlane: number): boolean;
	static URLUserAllowedCharacterSet(): NSCharacterSet;
	static URLPasswordAllowedCharacterSet(): NSCharacterSet;
	static URLHostAllowedCharacterSet(): NSCharacterSet;
	static URLPathAllowedCharacterSet(): NSCharacterSet;
	static URLQueryAllowedCharacterSet(): NSCharacterSet;
	static URLFragmentAllowedCharacterSet(): NSCharacterSet;
	init(): NSCharacterSet;
	static new(): NSCharacterSet;
	static allocWithZone(zone: any): NSCharacterSet;
	static alloc(): NSCharacterSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSMutableCharacterSet extends NSCharacterSet implements NSCopying, NSMutableCopying {
	constructor();
	addCharactersInRange(aRange: NSRange): void;
	removeCharactersInRange(aRange: NSRange): void;
	addCharactersInString(aString: string): void;
	removeCharactersInString(aString: string): void;
	formUnionWithCharacterSet(otherSet: NSCharacterSet): void;
	formIntersectionWithCharacterSet(otherSet: NSCharacterSet): void;
	invert(): void;
	static controlCharacterSet(): NSMutableCharacterSet;
	static whitespaceCharacterSet(): NSMutableCharacterSet;
	static whitespaceAndNewlineCharacterSet(): NSMutableCharacterSet;
	static decimalDigitCharacterSet(): NSMutableCharacterSet;
	static letterCharacterSet(): NSMutableCharacterSet;
	static lowercaseLetterCharacterSet(): NSMutableCharacterSet;
	static uppercaseLetterCharacterSet(): NSMutableCharacterSet;
	static nonBaseCharacterSet(): NSMutableCharacterSet;
	static alphanumericCharacterSet(): NSMutableCharacterSet;
	static decomposableCharacterSet(): NSMutableCharacterSet;
	static illegalCharacterSet(): NSMutableCharacterSet;
	static punctuationCharacterSet(): NSMutableCharacterSet;
	static capitalizedLetterCharacterSet(): NSMutableCharacterSet;
	static symbolCharacterSet(): NSMutableCharacterSet;
	static newlineCharacterSet(): NSMutableCharacterSet;
	static characterSetWithRange(aRange: NSRange): NSMutableCharacterSet;
	static characterSetWithCharactersInString(aString: string): NSMutableCharacterSet;
	static characterSetWithBitmapRepresentation(data: NSData): NSMutableCharacterSet;
	static characterSetWithContentsOfFile(fName: string): NSMutableCharacterSet;
	init(): NSMutableCharacterSet;
	static new(): NSMutableCharacterSet;
	static allocWithZone(zone: any): NSMutableCharacterSet;
	static alloc(): NSMutableCharacterSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class NSCoder extends NSObject {
	systemVersion: number;
	allowsKeyedCoding: boolean;
	requiresSecureCoding: boolean;
	allowedClasses: NSSet;
	constructor();
	encodeValueOfObjCTypeAt(type: string, addr: any): void;
	encodeDataObject(data: NSData): void;
	decodeValueOfObjCTypeAt(type: string, data: any): void;
	decodeDataObject(): NSData;
	versionForClassName(className: string): number;
	encodeObject(object: any): void;
	encodeRootObject(rootObject: any): void;
	encodeBycopyObject(anObject: any): void;
	encodeByrefObject(anObject: any): void;
	encodeConditionalObject(object: any): void;
	encodeArrayOfObjCTypeCountAt(type: string, count: number, array: any): void;
	encodeBytesLength(byteaddr: any, length: number): void;
	decodeObject(): any;
	decodeArrayOfObjCTypeCountAt(itemType: string, count: number, array: any): void;
	decodeBytesWithReturnedLength(lengthp: any): any;
	setObjectZone(zone: any): void;
	objectZone(): any;
	encodeObjectForKey(objv: any, key: string): void;
	encodeConditionalObjectForKey(objv: any, key: string): void;
	encodeBoolForKey(boolv: boolean, key: string): void;
	encodeIntForKey(intv: number, key: string): void;
	encodeInt32ForKey(intv: number, key: string): void;
	encodeInt64ForKey(intv: number, key: string): void;
	encodeFloatForKey(realv: number, key: string): void;
	encodeDoubleForKey(realv: number, key: string): void;
	encodeBytesLengthForKey(bytesp: string, lenv: number, key: string): void;
	containsValueForKey(key: string): boolean;
	decodeObjectForKey(key: string): any;
	decodeBoolForKey(key: string): boolean;
	decodeIntForKey(key: string): number;
	decodeInt32ForKey(key: string): number;
	decodeInt64ForKey(key: string): number;
	decodeFloatForKey(key: string): number;
	decodeDoubleForKey(key: string): number;
	decodeBytesForKeyReturnedLength(key: string, lengthp: any): string;
	encodeIntegerForKey(intv: number, key: string): void;
	decodeIntegerForKey(key: string): number;
	decodeObjectOfClassForKey(aClass: any, key: string): any;
	decodeObjectOfClassesForKey(classes: NSSet, key: string): any;
	decodePropertyListForKey(key: string): any;
	encodeCGPointForKey(point: CGPoint, key: string): void;
	encodeCGVectorForKey(vector: CGVector, key: string): void;
	encodeCGSizeForKey(size: CGSize, key: string): void;
	encodeCGRectForKey(rect: CGRect, key: string): void;
	encodeCGAffineTransformForKey(transform: CGAffineTransform, key: string): void;
	encodeUIEdgeInsetsForKey(insets: UIEdgeInsets, key: string): void;
	encodeUIOffsetForKey(offset: UIOffset, key: string): void;
	decodeCGPointForKey(key: string): CGPoint;
	decodeCGVectorForKey(key: string): CGVector;
	decodeCGSizeForKey(key: string): CGSize;
	decodeCGRectForKey(key: string): CGRect;
	decodeCGAffineTransformForKey(key: string): CGAffineTransform;
	decodeUIEdgeInsetsForKey(key: string): UIEdgeInsets;
	decodeUIOffsetForKey(key: string): UIOffset;
	encodeCMTimeForKey(time: CMTime, key: string): void;
	decodeCMTimeForKey(key: string): CMTime;
	encodeCMTimeRangeForKey(timeRange: CMTimeRange, key: string): void;
	decodeCMTimeRangeForKey(key: string): CMTimeRange;
	encodeCMTimeMappingForKey(timeMapping: CMTimeMapping, key: string): void;
	decodeCMTimeMappingForKey(key: string): CMTimeMapping;
	init(): NSCoder;
	static new(): NSCoder;
	static allocWithZone(zone: any): NSCoder;
	static alloc(): NSCoder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSData extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, CKRecordValue {
	length: number;
	bytes: any;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(bytes: any, length: number, b: boolean);
	constructor(bytes: any, length: number, deallocator: (arg1: any, arg2: number) => void);
	constructor(path: string, readOptionsMask: number, errorPtr: any);
	constructor(url: NSURL, readOptionsMask: number, errorPtr: any);
	constructor(url: NSURL);
	constructor(data: NSData);
	constructor(base64String: string, options: number);
	constructor(base64Data: NSData, options: number);
	constructor();
	getBytesLength(buffer: any, length: number): void;
	getBytesRange(buffer: any, range: NSRange): void;
	isEqualToData(other: NSData): boolean;
	subdataWithRange(range: NSRange): NSData;
	writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;
	writeToURLAtomically(url: NSURL, atomically: boolean): boolean;
	writeToFileOptionsError(path: string, writeOptionsMask: number, errorPtr: any): boolean;
	writeToURLOptionsError(url: NSURL, writeOptionsMask: number, errorPtr: any): boolean;
	rangeOfDataOptionsRange(dataToFind: NSData, mask: number, searchRange: NSRange): NSRange;
	enumerateByteRangesUsingBlock(block: (arg1: any, arg2: NSRange, arg3: any) => void): void;
	static data(): NSData;
	static dataWithBytesLength(bytes: any, length: number): NSData;
	static dataWithBytesNoCopyLength(bytes: any, length: number): NSData;
	static dataWithBytesNoCopyLengthFreeWhenDone(bytes: any, length: number, b: boolean): NSData;
	static dataWithContentsOfFileOptionsError(path: string, readOptionsMask: number, errorPtr: any): NSData;
	static dataWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: number, errorPtr: any): NSData;
	static dataWithContentsOfFile(path: string): NSData;
	static dataWithContentsOfURL(url: NSURL): NSData;
	initWithBytesLength(bytes: any, length: number): NSData;
	initWithBytesNoCopyLength(bytes: any, length: number): NSData;
	initWithBytesNoCopyLengthFreeWhenDone(bytes: any, length: number, b: boolean): NSData;
	initWithBytesNoCopyLengthDeallocator(bytes: any, length: number, deallocator: (arg1: any, arg2: number) => void): NSData;
	initWithContentsOfFileOptionsError(path: string, readOptionsMask: number, errorPtr: any): NSData;
	initWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: number, errorPtr: any): NSData;
	initWithContentsOfFile(path: string): NSData;
	initWithContentsOfURL(url: NSURL): NSData;
	initWithData(data: NSData): NSData;
	static dataWithData(data: NSData): NSData;
	initWithBase64EncodedStringOptions(base64String: string, options: number): NSData;
	base64EncodedStringWithOptions(options: number): string;
	initWithBase64EncodedDataOptions(base64Data: NSData, options: number): NSData;
	base64EncodedDataWithOptions(options: number): NSData;
	getBytes(buffer: any): void;
	static dataWithContentsOfMappedFile(path: string): any;
	initWithContentsOfMappedFile(path: string): NSData;
	initWithBase64Encoding(base64String: string): NSData;
	base64Encoding(): string;
	init(): NSData;
	static new(): NSData;
	static allocWithZone(zone: any): NSData;
	static alloc(): NSData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSMutableData extends NSData {
	mutableBytes: any;
	length: number;
	constructor(bytes: any, length: number, b: boolean);
	constructor(bytes: any, length: number, deallocator: (arg1: any, arg2: number) => void);
	constructor(path: string, readOptionsMask: number, errorPtr: any);
	constructor(url: NSURL, readOptionsMask: number, errorPtr: any);
	constructor(url: NSURL);
	constructor(data: NSData);
	constructor(base64String: string, options: number);
	constructor(base64Data: NSData, options: number);
	constructor();
	appendBytesLength(bytes: any, length: number): void;
	appendData(other: NSData): void;
	increaseLengthBy(extraLength: number): void;
	replaceBytesInRangeWithBytes(range: NSRange, bytes: any): void;
	resetBytesInRange(range: NSRange): void;
	setData(data: NSData): void;
	replaceBytesInRangeWithBytesLength(range: NSRange, replacementBytes: any, replacementLength: number): void;
	static dataWithCapacity(aNumItems: number): NSMutableData;
	static dataWithLength(length: number): NSMutableData;
	initWithCapacity(capacity: number): NSMutableData;
	initWithLength(length: number): NSMutableData;
	static data(): NSMutableData;
	static dataWithBytesLength(bytes: any, length: number): NSMutableData;
	static dataWithBytesNoCopyLength(bytes: any, length: number): NSMutableData;
	static dataWithBytesNoCopyLengthFreeWhenDone(bytes: any, length: number, b: boolean): NSMutableData;
	static dataWithContentsOfFileOptionsError(path: string, readOptionsMask: number, errorPtr: any): NSMutableData;
	static dataWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: number, errorPtr: any): NSMutableData;
	static dataWithContentsOfFile(path: string): NSMutableData;
	static dataWithContentsOfURL(url: NSURL): NSMutableData;
	initWithBytesLength(bytes: any, length: number): NSMutableData;
	initWithBytesNoCopyLength(bytes: any, length: number): NSMutableData;
	initWithBytesNoCopyLengthFreeWhenDone(bytes: any, length: number, b: boolean): NSMutableData;
	initWithBytesNoCopyLengthDeallocator(bytes: any, length: number, deallocator: (arg1: any, arg2: number) => void): NSMutableData;
	initWithContentsOfFileOptionsError(path: string, readOptionsMask: number, errorPtr: any): NSMutableData;
	initWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: number, errorPtr: any): NSMutableData;
	initWithContentsOfFile(path: string): NSMutableData;
	initWithContentsOfURL(url: NSURL): NSMutableData;
	initWithData(data: NSData): NSMutableData;
	static dataWithData(data: NSData): NSMutableData;
	initWithBase64EncodedStringOptions(base64String: string, options: number): NSMutableData;
	initWithBase64EncodedDataOptions(base64Data: NSData, options: number): NSMutableData;
	initWithContentsOfMappedFile(path: string): NSMutableData;
	initWithBase64Encoding(base64String: string): NSMutableData;
	init(): NSMutableData;
	static new(): NSMutableData;
	static allocWithZone(zone: any): NSMutableData;
	static alloc(): NSMutableData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSPurgeableData extends NSMutableData implements NSDiscardableContent {
	constructor(bytes: any, length: number, b: boolean);
	constructor(bytes: any, length: number, deallocator: (arg1: any, arg2: number) => void);
	constructor(path: string, readOptionsMask: number, errorPtr: any);
	constructor(url: NSURL, readOptionsMask: number, errorPtr: any);
	constructor(url: NSURL);
	constructor(data: NSData);
	constructor(base64String: string, options: number);
	constructor(base64Data: NSData, options: number);
	constructor();
	static dataWithCapacity(aNumItems: number): NSPurgeableData;
	static dataWithLength(length: number): NSPurgeableData;
	initWithCapacity(capacity: number): NSPurgeableData;
	initWithLength(length: number): NSPurgeableData;
	static data(): NSPurgeableData;
	static dataWithBytesLength(bytes: any, length: number): NSPurgeableData;
	static dataWithBytesNoCopyLength(bytes: any, length: number): NSPurgeableData;
	static dataWithBytesNoCopyLengthFreeWhenDone(bytes: any, length: number, b: boolean): NSPurgeableData;
	static dataWithContentsOfFileOptionsError(path: string, readOptionsMask: number, errorPtr: any): NSPurgeableData;
	static dataWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: number, errorPtr: any): NSPurgeableData;
	static dataWithContentsOfFile(path: string): NSPurgeableData;
	static dataWithContentsOfURL(url: NSURL): NSPurgeableData;
	initWithBytesLength(bytes: any, length: number): NSPurgeableData;
	initWithBytesNoCopyLength(bytes: any, length: number): NSPurgeableData;
	initWithBytesNoCopyLengthFreeWhenDone(bytes: any, length: number, b: boolean): NSPurgeableData;
	initWithBytesNoCopyLengthDeallocator(bytes: any, length: number, deallocator: (arg1: any, arg2: number) => void): NSPurgeableData;
	initWithContentsOfFileOptionsError(path: string, readOptionsMask: number, errorPtr: any): NSPurgeableData;
	initWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: number, errorPtr: any): NSPurgeableData;
	initWithContentsOfFile(path: string): NSPurgeableData;
	initWithContentsOfURL(url: NSURL): NSPurgeableData;
	initWithData(data: NSData): NSPurgeableData;
	static dataWithData(data: NSData): NSPurgeableData;
	initWithBase64EncodedStringOptions(base64String: string, options: number): NSPurgeableData;
	initWithBase64EncodedDataOptions(base64Data: NSData, options: number): NSPurgeableData;
	initWithContentsOfMappedFile(path: string): NSPurgeableData;
	initWithBase64Encoding(base64String: string): NSPurgeableData;
	init(): NSPurgeableData;
	static new(): NSPurgeableData;
	static allocWithZone(zone: any): NSPurgeableData;
	static alloc(): NSPurgeableData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	beginContentAccess(): boolean;
	endContentAccess(): void;
	discardContentIfPossible(): void;
	isContentDiscarded(): boolean;
}
declare class NSFormatter extends NSObject implements NSCopying, NSCoding {
	constructor();
	stringForObjectValue(obj: any): string;
	attributedStringForObjectValueWithDefaultAttributes(obj: any, attrs: NSDictionary): NSAttributedString;
	editingStringForObjectValue(obj: any): string;
	getObjectValueForStringErrorDescription(obj: any, string: string, error: any): boolean;
	isPartialStringValidNewEditingStringErrorDescription(partialString: string, newString: any, error: any): boolean;
	isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(partialStringPtr: any, proposedSelRangePtr: any, origString: string, origSelRange: NSRange, error: any): boolean;
	init(): NSFormatter;
	static new(): NSFormatter;
	static allocWithZone(zone: any): NSFormatter;
	static alloc(): NSFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSDateFormatter extends NSFormatter {
	formattingContext: number;
	dateFormat: string;
	dateStyle: number;
	timeStyle: number;
	locale: NSLocale;
	generatesCalendarDates: boolean;
	formatterBehavior: number;
	timeZone: NSTimeZone;
	calendar: NSCalendar;
	lenient: boolean;
	twoDigitStartDate: NSDate;
	defaultDate: NSDate;
	eraSymbols: NSArray;
	monthSymbols: NSArray;
	shortMonthSymbols: NSArray;
	weekdaySymbols: NSArray;
	shortWeekdaySymbols: NSArray;
	AMSymbol: string;
	PMSymbol: string;
	longEraSymbols: NSArray;
	veryShortMonthSymbols: NSArray;
	standaloneMonthSymbols: NSArray;
	shortStandaloneMonthSymbols: NSArray;
	veryShortStandaloneMonthSymbols: NSArray;
	veryShortWeekdaySymbols: NSArray;
	standaloneWeekdaySymbols: NSArray;
	shortStandaloneWeekdaySymbols: NSArray;
	veryShortStandaloneWeekdaySymbols: NSArray;
	quarterSymbols: NSArray;
	shortQuarterSymbols: NSArray;
	standaloneQuarterSymbols: NSArray;
	shortStandaloneQuarterSymbols: NSArray;
	gregorianStartDate: NSDate;
	doesRelativeDateFormatting: boolean;
	constructor();
	getObjectValueForStringRangeError(obj: any, string: string, rangep: any, error: any): boolean;
	stringFromDate(date: NSDate): string;
	dateFromString(string: string): NSDate;
	static localizedStringFromDateDateStyleTimeStyle(date: NSDate, dstyle: number, tstyle: number): string;
	static dateFormatFromTemplateOptionsLocale(tmplate: string, opts: number, locale: NSLocale): string;
	static defaultFormatterBehavior(): number;
	static setDefaultFormatterBehavior(behavior: number): void;
	setLocalizedDateFormatFromTemplate(dateFormatTemplate: string): void;
	init(): NSDateFormatter;
	static new(): NSDateFormatter;
	static allocWithZone(zone: any): NSDateFormatter;
	static alloc(): NSDateFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSDateIntervalFormatter extends NSFormatter {
	locale: NSLocale;
	calendar: NSCalendar;
	timeZone: NSTimeZone;
	dateTemplate: string;
	dateStyle: number;
	timeStyle: number;
	constructor();
	stringFromDateToDate(fromDate: NSDate, toDate: NSDate): string;
	init(): NSDateIntervalFormatter;
	static new(): NSDateIntervalFormatter;
	static allocWithZone(zone: any): NSDateIntervalFormatter;
	static alloc(): NSDateIntervalFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSMassFormatter extends NSFormatter {
	numberFormatter: NSNumberFormatter;
	unitStyle: number;
	forPersonMassUse: boolean;
	constructor();
	stringFromValueUnit(value: number, unit: number): string;
	stringFromKilograms(numberInKilograms: number): string;
	unitStringFromValueUnit(value: number, unit: number): string;
	unitStringFromKilogramsUsedUnit(numberInKilograms: number, unitp: any): string;
	init(): NSMassFormatter;
	static new(): NSMassFormatter;
	static allocWithZone(zone: any): NSMassFormatter;
	static alloc(): NSMassFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSLengthFormatter extends NSFormatter {
	numberFormatter: NSNumberFormatter;
	unitStyle: number;
	forPersonHeightUse: boolean;
	constructor();
	stringFromValueUnit(value: number, unit: number): string;
	stringFromMeters(numberInMeters: number): string;
	unitStringFromValueUnit(value: number, unit: number): string;
	unitStringFromMetersUsedUnit(numberInMeters: number, unitp: any): string;
	init(): NSLengthFormatter;
	static new(): NSLengthFormatter;
	static allocWithZone(zone: any): NSLengthFormatter;
	static alloc(): NSLengthFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSEnergyFormatter extends NSFormatter {
	numberFormatter: NSNumberFormatter;
	unitStyle: number;
	forFoodEnergyUse: boolean;
	constructor();
	stringFromValueUnit(value: number, unit: number): string;
	stringFromJoules(numberInJoules: number): string;
	unitStringFromValueUnit(value: number, unit: number): string;
	unitStringFromJoulesUsedUnit(numberInJoules: number, unitp: any): string;
	init(): NSEnergyFormatter;
	static new(): NSEnergyFormatter;
	static allocWithZone(zone: any): NSEnergyFormatter;
	static alloc(): NSEnergyFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSScanner extends NSObject implements NSCopying {
	string: string;
	scanLocation: number;
	charactersToBeSkipped: NSCharacterSet;
	caseSensitive: boolean;
	locale: any;
	atEnd: boolean;
	constructor(string: string);
	constructor();
	initWithString(string: string): NSScanner;
	scanInt(result: any): boolean;
	scanInteger(result: any): boolean;
	scanLongLong(result: any): boolean;
	scanUnsignedLongLong(result: any): boolean;
	scanFloat(result: any): boolean;
	scanDouble(result: any): boolean;
	scanHexInt(result: any): boolean;
	scanHexLongLong(result: any): boolean;
	scanHexFloat(result: any): boolean;
	scanHexDouble(result: any): boolean;
	scanStringIntoString(string: string, result: any): boolean;
	scanCharactersFromSetIntoString(set: NSCharacterSet, result: any): boolean;
	scanUpToStringIntoString(string: string, result: any): boolean;
	scanUpToCharactersFromSetIntoString(set: NSCharacterSet, result: any): boolean;
	static scannerWithString(string: string): NSScanner;
	static localizedScannerWithString(string: string): any;
	scanDecimal(dcm: any): boolean;
	init(): NSScanner;
	static new(): NSScanner;
	static allocWithZone(zone: any): NSScanner;
	static alloc(): NSScanner;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class NSDictionary extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
	count: number;
	allKeys: NSArray;
	allValues: NSArray;
	descriptionInStringsFileFormat: string;
	constructor(objects: any, keys: any, cnt: number);
	constructor(firstObject: any);
	constructor(otherDictionary: NSDictionary);
	constructor(otherDictionary: NSDictionary, flag: boolean);
	constructor(objects: NSArray, keys: NSArray);
	constructor(path: string);
	constructor(url: NSURL);
	constructor();
	objectForKey(aKey: any): any;
	keyEnumerator(): NSEnumerator;
	initWithObjectsForKeysCount(objects: any, keys: any, cnt: number): NSDictionary;
	allKeysForObject(anObject: any): NSArray;
	descriptionWithLocale(locale: any): string;
	descriptionWithLocaleIndent(locale: any, level: number): string;
	isEqualToDictionary(otherDictionary: NSDictionary): boolean;
	objectEnumerator(): NSEnumerator;
	objectsForKeysNotFoundMarker(keys: NSArray, marker: any): NSArray;
	writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;
	writeToURLAtomically(url: NSURL, atomically: boolean): boolean;
	keysSortedByValueUsingSelector(comparator: any): NSArray;
	getObjectsAndKeys(objects: any, keys: any): void;
	objectForKeyedSubscript(key: any): any;
	enumerateKeysAndObjectsUsingBlock(block: (arg1: any, arg2: any, arg3: any) => void): void;
	enumerateKeysAndObjectsWithOptionsUsingBlock(opts: number, block: (arg1: any, arg2: any, arg3: any) => void): void;
	keysSortedByValueUsingComparator(cmptr: (arg1: any, arg2: any) => number): NSArray;
	keysSortedByValueWithOptionsUsingComparator(opts: number, cmptr: (arg1: any, arg2: any) => number): NSArray;
	keysOfEntriesPassingTest(predicate: (arg1: any, arg2: any, arg3: any) => boolean): NSSet;
	keysOfEntriesWithOptionsPassingTest(opts: number, predicate: (arg1: any, arg2: any, arg3: any) => boolean): NSSet;
	static dictionary(): NSDictionary;
	static dictionaryWithObjectForKey(object: any, key: any): NSDictionary;
	static dictionaryWithObjectsForKeysCount(objects: any, keys: any, cnt: number): NSDictionary;
	static dictionaryWithObjectsAndKeys(firstObject: any): NSDictionary;
	static dictionaryWithDictionary(dict: NSDictionary): NSDictionary;
	static dictionaryWithObjectsForKeys(objects: NSArray, keys: NSArray): NSDictionary;
	initWithObjectsAndKeys(firstObject: any): NSDictionary;
	initWithDictionary(otherDictionary: NSDictionary): NSDictionary;
	initWithDictionaryCopyItems(otherDictionary: NSDictionary, flag: boolean): NSDictionary;
	initWithObjectsForKeys(objects: NSArray, keys: NSArray): NSDictionary;
	static dictionaryWithContentsOfFile(path: string): NSDictionary;
	static dictionaryWithContentsOfURL(url: NSURL): NSDictionary;
	initWithContentsOfFile(path: string): NSDictionary;
	initWithContentsOfURL(url: NSURL): NSDictionary;
	static sharedKeySetForKeys(keys: NSArray): any;
	fileSize(): number;
	fileModificationDate(): NSDate;
	fileType(): string;
	filePosixPermissions(): number;
	fileOwnerAccountName(): string;
	fileGroupOwnerAccountName(): string;
	fileSystemNumber(): number;
	fileSystemFileNumber(): number;
	fileExtensionHidden(): boolean;
	fileHFSCreatorCode(): number;
	fileHFSTypeCode(): number;
	fileIsImmutable(): boolean;
	fileIsAppendOnly(): boolean;
	fileCreationDate(): NSDate;
	fileOwnerAccountID(): NSNumber;
	fileGroupOwnerAccountID(): NSNumber;
	init(): NSDictionary;
	static new(): NSDictionary;
	static allocWithZone(zone: any): NSDictionary;
	static alloc(): NSDictionary;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSMutableDictionary extends NSDictionary {
	constructor(numItems: number);
	constructor(objects: any, keys: any, cnt: number);
	constructor(firstObject: any);
	constructor(otherDictionary: NSDictionary);
	constructor(otherDictionary: NSDictionary, flag: boolean);
	constructor(objects: NSArray, keys: NSArray);
	constructor(path: string);
	constructor(url: NSURL);
	constructor();
	removeObjectForKey(aKey: any): void;
	setObjectForKey(anObject: any, aKey: any): void;
	initWithCapacity(numItems: number): NSMutableDictionary;
	addEntriesFromDictionary(otherDictionary: NSDictionary): void;
	removeAllObjects(): void;
	removeObjectsForKeys(keyArray: NSArray): void;
	setDictionary(otherDictionary: NSDictionary): void;
	setObjectForKeyedSubscript(obj: any, key: any): void;
	static dictionaryWithCapacity(numItems: number): NSMutableDictionary;
	static dictionaryWithContentsOfFile(path: string): NSMutableDictionary;
	static dictionaryWithContentsOfURL(url: NSURL): NSMutableDictionary;
	static dictionaryWithSharedKeySet(keyset: any): NSMutableDictionary;
	initWithObjectsForKeysCount(objects: any, keys: any, cnt: number): NSMutableDictionary;
	static dictionary(): NSMutableDictionary;
	static dictionaryWithObjectForKey(object: any, key: any): NSMutableDictionary;
	static dictionaryWithObjectsForKeysCount(objects: any, keys: any, cnt: number): NSMutableDictionary;
	static dictionaryWithObjectsAndKeys(firstObject: any): NSMutableDictionary;
	static dictionaryWithDictionary(dict: NSDictionary): NSMutableDictionary;
	static dictionaryWithObjectsForKeys(objects: NSArray, keys: NSArray): NSMutableDictionary;
	initWithObjectsAndKeys(firstObject: any): NSMutableDictionary;
	initWithDictionary(otherDictionary: NSDictionary): NSMutableDictionary;
	initWithDictionaryCopyItems(otherDictionary: NSDictionary, flag: boolean): NSMutableDictionary;
	initWithObjectsForKeys(objects: NSArray, keys: NSArray): NSMutableDictionary;
	initWithContentsOfFile(path: string): NSMutableDictionary;
	initWithContentsOfURL(url: NSURL): NSMutableDictionary;
	init(): NSMutableDictionary;
	static new(): NSMutableDictionary;
	static allocWithZone(zone: any): NSMutableDictionary;
	static alloc(): NSMutableDictionary;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSDecimalNumber extends NSNumber {
	constructor(mantissa: number, exponent: number, flag: boolean);
	constructor(dcm: NSDecimal);
	constructor(numberValue: string, locale: any);
	constructor(value: boolean);
	constructor(value: any, type: string);
	constructor();
	initWithMantissaExponentIsNegative(mantissa: number, exponent: number, flag: boolean): NSDecimalNumber;
	initWithDecimal(dcm: NSDecimal): NSDecimalNumber;
	initWithString(numberValue: string): NSDecimalNumber;
	initWithStringLocale(numberValue: string, locale: any): NSDecimalNumber;
	static decimalNumberWithMantissaExponentIsNegative(mantissa: number, exponent: number, flag: boolean): NSDecimalNumber;
	static decimalNumberWithDecimal(dcm: NSDecimal): NSDecimalNumber;
	static decimalNumberWithString(numberValue: string): NSDecimalNumber;
	static decimalNumberWithStringLocale(numberValue: string, locale: any): NSDecimalNumber;
	static zero(): NSDecimalNumber;
	static one(): NSDecimalNumber;
	static minimumDecimalNumber(): NSDecimalNumber;
	static maximumDecimalNumber(): NSDecimalNumber;
	static notANumber(): NSDecimalNumber;
	decimalNumberByAdding(decimalNumber: NSDecimalNumber): NSDecimalNumber;
	decimalNumberByAddingWithBehavior(decimalNumber: NSDecimalNumber, behavior: any): NSDecimalNumber;
	decimalNumberBySubtracting(decimalNumber: NSDecimalNumber): NSDecimalNumber;
	decimalNumberBySubtractingWithBehavior(decimalNumber: NSDecimalNumber, behavior: any): NSDecimalNumber;
	decimalNumberByMultiplyingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;
	decimalNumberByMultiplyingByWithBehavior(decimalNumber: NSDecimalNumber, behavior: any): NSDecimalNumber;
	decimalNumberByDividingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;
	decimalNumberByDividingByWithBehavior(decimalNumber: NSDecimalNumber, behavior: any): NSDecimalNumber;
	decimalNumberByRaisingToPower(power: number): NSDecimalNumber;
	decimalNumberByRaisingToPowerWithBehavior(power: number, behavior: any): NSDecimalNumber;
	decimalNumberByMultiplyingByPowerOf10(power: number): NSDecimalNumber;
	decimalNumberByMultiplyingByPowerOf10WithBehavior(power: number, behavior: any): NSDecimalNumber;
	decimalNumberByRoundingAccordingToBehavior(behavior: any): NSDecimalNumber;
	static setDefaultBehavior(behavior: any): void;
	static defaultBehavior(): any;
	initWithChar(value: string): NSDecimalNumber;
	initWithUnsignedChar(value: number): NSDecimalNumber;
	initWithShort(value: number): NSDecimalNumber;
	initWithUnsignedShort(value: number): NSDecimalNumber;
	initWithInt(value: number): NSDecimalNumber;
	initWithUnsignedInt(value: number): NSDecimalNumber;
	initWithLong(value: number): NSDecimalNumber;
	initWithUnsignedLong(value: number): NSDecimalNumber;
	initWithLongLong(value: number): NSDecimalNumber;
	initWithUnsignedLongLong(value: number): NSDecimalNumber;
	initWithFloat(value: number): NSDecimalNumber;
	initWithDouble(value: number): NSDecimalNumber;
	initWithBool(value: boolean): NSDecimalNumber;
	initWithInteger(value: number): NSDecimalNumber;
	initWithUnsignedInteger(value: number): NSDecimalNumber;
	initWithBytesObjCType(value: any, type: string): NSDecimalNumber;
	init(): NSDecimalNumber;
	static new(): NSDecimalNumber;
	static allocWithZone(zone: any): NSDecimalNumber;
	static alloc(): NSDecimalNumber;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSDecimalNumberHandler extends NSObject implements NSDecimalNumberBehaviors, NSCoding {
	constructor(roundingMode: number, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean);
	constructor();
	static defaultDecimalNumberHandler(): NSDecimalNumberHandler;
	initWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: number, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): NSDecimalNumberHandler;
	static decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: number, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): NSDecimalNumberHandler;
	init(): NSDecimalNumberHandler;
	static new(): NSDecimalNumberHandler;
	static allocWithZone(zone: any): NSDecimalNumberHandler;
	static alloc(): NSDecimalNumberHandler;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	roundingMode(): number;
	scale(): number;
	exceptionDuringOperationErrorLeftOperandRightOperand(operation: any, error: number, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber): NSDecimalNumber;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSError extends NSObject implements NSCopying, NSSecureCoding {
	domain: string;
	code: number;
	userInfo: NSDictionary;
	localizedDescription: string;
	localizedFailureReason: string;
	localizedRecoverySuggestion: string;
	localizedRecoveryOptions: NSArray;
	recoveryAttempter: any;
	helpAnchor: string;
	constructor(domain: string, code: number, dict: NSDictionary);
	constructor();
	initWithDomainCodeUserInfo(domain: string, code: number, dict: NSDictionary): NSError;
	static errorWithDomainCodeUserInfo(domain: string, code: number, dict: NSDictionary): NSError;
	init(): NSError;
	static new(): NSError;
	static allocWithZone(zone: any): NSError;
	static alloc(): NSError;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSException extends NSObject implements NSCopying, NSCoding {
	name: string;
	reason: string;
	userInfo: NSDictionary;
	callStackReturnAddresses: NSArray;
	callStackSymbols: NSArray;
	constructor(aName: string, aReason: string, aUserInfo: NSDictionary);
	constructor();
	static exceptionWithNameReasonUserInfo(name: string, reason: string, userInfo: NSDictionary): NSException;
	initWithNameReasonUserInfo(aName: string, aReason: string, aUserInfo: NSDictionary): NSException;
	raise(): void;
	init(): NSException;
	static new(): NSException;
	static allocWithZone(zone: any): NSException;
	static alloc(): NSException;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSAssertionHandler extends NSObject {
	constructor();
	static currentHandler(): NSAssertionHandler;
	init(): NSAssertionHandler;
	static new(): NSAssertionHandler;
	static allocWithZone(zone: any): NSAssertionHandler;
	static alloc(): NSAssertionHandler;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSFileHandle extends NSObject implements NSSecureCoding {
	availableData: NSData;
	offsetInFile: number;
	readabilityHandler: (arg1: NSFileHandle) => void;
	writeabilityHandler: (arg1: NSFileHandle) => void;
	fileDescriptor: number;
	constructor(fd: number, closeopt: boolean);
	constructor(fd: number);
	constructor();
	readDataToEndOfFile(): NSData;
	readDataOfLength(length: number): NSData;
	writeData(data: NSData): void;
	seekToEndOfFile(): number;
	seekToFileOffset(offset: number): void;
	truncateFileAtOffset(offset: number): void;
	synchronizeFile(): void;
	closeFile(): void;
	initWithFileDescriptorCloseOnDealloc(fd: number, closeopt: boolean): NSFileHandle;
	static fileHandleWithStandardInput(): NSFileHandle;
	static fileHandleWithStandardOutput(): NSFileHandle;
	static fileHandleWithStandardError(): NSFileHandle;
	static fileHandleWithNullDevice(): NSFileHandle;
	static fileHandleForReadingAtPath(path: string): NSFileHandle;
	static fileHandleForWritingAtPath(path: string): NSFileHandle;
	static fileHandleForUpdatingAtPath(path: string): NSFileHandle;
	static fileHandleForReadingFromURLError(url: NSURL, error: any): NSFileHandle;
	static fileHandleForWritingToURLError(url: NSURL, error: any): NSFileHandle;
	static fileHandleForUpdatingURLError(url: NSURL, error: any): NSFileHandle;
	readInBackgroundAndNotifyForModes(modes: NSArray): void;
	readInBackgroundAndNotify(): void;
	readToEndOfFileInBackgroundAndNotifyForModes(modes: NSArray): void;
	readToEndOfFileInBackgroundAndNotify(): void;
	acceptConnectionInBackgroundAndNotifyForModes(modes: NSArray): void;
	acceptConnectionInBackgroundAndNotify(): void;
	waitForDataInBackgroundAndNotifyForModes(modes: NSArray): void;
	waitForDataInBackgroundAndNotify(): void;
	initWithFileDescriptor(fd: number): NSFileHandle;
	init(): NSFileHandle;
	static new(): NSFileHandle;
	static allocWithZone(zone: any): NSFileHandle;
	static alloc(): NSFileHandle;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSPipe extends NSObject {
	fileHandleForReading: NSFileHandle;
	fileHandleForWriting: NSFileHandle;
	constructor();
	static pipe(): NSPipe;
	init(): NSPipe;
	static new(): NSPipe;
	static allocWithZone(zone: any): NSPipe;
	static alloc(): NSPipe;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSFileManager extends NSObject {
	delegate: any;
	currentDirectoryPath: string;
	ubiquityIdentityToken: any;
	constructor();
	static defaultManager(): NSFileManager;
	mountedVolumeURLsIncludingResourceValuesForKeysOptions(propertyKeys: NSArray, options: number): NSArray;
	contentsOfDirectoryAtURLIncludingPropertiesForKeysOptionsError(url: NSURL, keys: NSArray, mask: number, error: any): NSArray;
	URLsForDirectoryInDomains(directory: number, domainMask: number): NSArray;
	URLForDirectoryInDomainAppropriateForURLCreateError(directory: number, domain: number, url: NSURL, shouldCreate: boolean, error: any): NSURL;
	getRelationshipOfDirectoryAtURLToItemAtURLError(outRelationship: any, directoryURL: NSURL, otherURL: NSURL, error: any): boolean;
	getRelationshipOfDirectoryInDomainToItemAtURLError(outRelationship: any, directory: number, domainMask: number, url: NSURL, error: any): boolean;
	createDirectoryAtURLWithIntermediateDirectoriesAttributesError(url: NSURL, createIntermediates: boolean, attributes: NSDictionary, error: any): boolean;
	createSymbolicLinkAtURLWithDestinationURLError(url: NSURL, destURL: NSURL, error: any): boolean;
	setAttributesOfItemAtPathError(attributes: NSDictionary, path: string, error: any): boolean;
	createDirectoryAtPathWithIntermediateDirectoriesAttributesError(path: string, createIntermediates: boolean, attributes: NSDictionary, error: any): boolean;
	contentsOfDirectoryAtPathError(path: string, error: any): NSArray;
	subpathsOfDirectoryAtPathError(path: string, error: any): NSArray;
	attributesOfItemAtPathError(path: string, error: any): NSDictionary;
	attributesOfFileSystemForPathError(path: string, error: any): NSDictionary;
	createSymbolicLinkAtPathWithDestinationPathError(path: string, destPath: string, error: any): boolean;
	destinationOfSymbolicLinkAtPathError(path: string, error: any): string;
	copyItemAtPathToPathError(srcPath: string, dstPath: string, error: any): boolean;
	moveItemAtPathToPathError(srcPath: string, dstPath: string, error: any): boolean;
	linkItemAtPathToPathError(srcPath: string, dstPath: string, error: any): boolean;
	removeItemAtPathError(path: string, error: any): boolean;
	copyItemAtURLToURLError(srcURL: NSURL, dstURL: NSURL, error: any): boolean;
	moveItemAtURLToURLError(srcURL: NSURL, dstURL: NSURL, error: any): boolean;
	linkItemAtURLToURLError(srcURL: NSURL, dstURL: NSURL, error: any): boolean;
	removeItemAtURLError(URL: NSURL, error: any): boolean;
	fileAttributesAtPathTraverseLink(path: string, yorn: boolean): NSDictionary;
	changeFileAttributesAtPath(attributes: NSDictionary, path: string): boolean;
	directoryContentsAtPath(path: string): NSArray;
	fileSystemAttributesAtPath(path: string): NSDictionary;
	pathContentOfSymbolicLinkAtPath(path: string): string;
	createSymbolicLinkAtPathPathContent(path: string, otherpath: string): boolean;
	createDirectoryAtPathAttributes(path: string, attributes: NSDictionary): boolean;
	changeCurrentDirectoryPath(path: string): boolean;
	fileExistsAtPath(path: string): boolean;
	fileExistsAtPathIsDirectory(path: string, isDirectory: any): boolean;
	isReadableFileAtPath(path: string): boolean;
	isWritableFileAtPath(path: string): boolean;
	isExecutableFileAtPath(path: string): boolean;
	isDeletableFileAtPath(path: string): boolean;
	contentsEqualAtPathAndPath(path1: string, path2: string): boolean;
	displayNameAtPath(path: string): string;
	componentsToDisplayForPath(path: string): NSArray;
	enumeratorAtPath(path: string): NSDirectoryEnumerator;
	enumeratorAtURLIncludingPropertiesForKeysOptionsErrorHandler(url: NSURL, keys: NSArray, mask: number, handler: (arg1: NSURL, arg2: NSError) => boolean): NSDirectoryEnumerator;
	subpathsAtPath(path: string): NSArray;
	contentsAtPath(path: string): NSData;
	createFileAtPathContentsAttributes(path: string, data: NSData, attr: NSDictionary): boolean;
	fileSystemRepresentationWithPath(path: string): string;
	stringWithFileSystemRepresentationLength(str: string, len: number): string;
	replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURLError(originalItemURL: NSURL, newItemURL: NSURL, backupItemName: string, options: number, resultingURL: any, error: any): boolean;
	setUbiquitousItemAtURLDestinationURLError(flag: boolean, url: NSURL, destinationURL: NSURL, error: any): boolean;
	isUbiquitousItemAtURL(url: NSURL): boolean;
	startDownloadingUbiquitousItemAtURLError(url: NSURL, error: any): boolean;
	evictUbiquitousItemAtURLError(url: NSURL, error: any): boolean;
	URLForUbiquityContainerIdentifier(containerIdentifier: string): NSURL;
	URLForPublishingUbiquitousItemAtURLExpirationDateError(url: NSURL, outDate: any, error: any): NSURL;
	containerURLForSecurityApplicationGroupIdentifier(groupIdentifier: string): NSURL;
	init(): NSFileManager;
	static new(): NSFileManager;
	static allocWithZone(zone: any): NSFileManager;
	static alloc(): NSFileManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSDirectoryEnumerator extends NSEnumerator {
	fileAttributes: NSDictionary;
	directoryAttributes: NSDictionary;
	level: number;
	constructor();
	skipDescendents(): void;
	skipDescendants(): void;
	init(): NSDirectoryEnumerator;
	static new(): NSDirectoryEnumerator;
	static allocWithZone(zone: any): NSDirectoryEnumerator;
	static alloc(): NSDirectoryEnumerator;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSPointerFunctions extends NSObject implements NSCopying {
	hashFunction: (arg1: any, arg2: (arg1: any) => number) => number;
	isEqualFunction: (arg1: any, arg2: any, arg3: (arg1: any) => number) => boolean;
	sizeFunction: (arg1: any) => number;
	descriptionFunction: (arg1: any) => string;
	relinquishFunction: (arg1: any, arg2: (arg1: any) => number) => void;
	acquireFunction: (arg1: any, arg2: (arg1: any) => number, arg3: boolean) => any;
	usesStrongWriteBarrier: boolean;
	usesWeakReadAndWriteBarriers: boolean;
	constructor(options: number);
	constructor();
	initWithOptions(options: number): NSPointerFunctions;
	static pointerFunctionsWithOptions(options: number): NSPointerFunctions;
	init(): NSPointerFunctions;
	static new(): NSPointerFunctions;
	static allocWithZone(zone: any): NSPointerFunctions;
	static alloc(): NSPointerFunctions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class NSHashTable extends NSObject implements NSCopying, NSCoding, NSFastEnumeration {
	pointerFunctions: NSPointerFunctions;
	count: number;
	allObjects: NSArray;
	anyObject: any;
	setRepresentation: NSSet;
	constructor(options: number, initialCapacity: number);
	constructor(functions: NSPointerFunctions, initialCapacity: number);
	constructor();
	initWithOptionsCapacity(options: number, initialCapacity: number): NSHashTable;
	initWithPointerFunctionsCapacity(functions: NSPointerFunctions, initialCapacity: number): NSHashTable;
	static hashTableWithOptions(options: number): NSHashTable;
	static weakObjectsHashTable(): NSHashTable;
	member(object: any): any;
	objectEnumerator(): NSEnumerator;
	addObject(object: any): void;
	removeObject(object: any): void;
	removeAllObjects(): void;
	containsObject(anObject: any): boolean;
	intersectsHashTable(other: NSHashTable): boolean;
	isEqualToHashTable(other: NSHashTable): boolean;
	isSubsetOfHashTable(other: NSHashTable): boolean;
	intersectHashTable(other: NSHashTable): void;
	unionHashTable(other: NSHashTable): void;
	minusHashTable(other: NSHashTable): void;
	init(): NSHashTable;
	static new(): NSHashTable;
	static allocWithZone(zone: any): NSHashTable;
	static alloc(): NSHashTable;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSHTTPCookie extends NSObject {
	properties: NSDictionary;
	version: number;
	name: string;
	value: string;
	expiresDate: NSDate;
	sessionOnly: boolean;
	domain: string;
	path: string;
	secure: boolean;
	HTTPOnly: boolean;
	comment: string;
	commentURL: NSURL;
	portList: NSArray;
	constructor(properties: NSDictionary);
	constructor();
	initWithProperties(properties: NSDictionary): NSHTTPCookie;
	static cookieWithProperties(properties: NSDictionary): NSHTTPCookie;
	static requestHeaderFieldsWithCookies(cookies: NSArray): NSDictionary;
	static cookiesWithResponseHeaderFieldsForURL(headerFields: NSDictionary, URL: NSURL): NSArray;
	init(): NSHTTPCookie;
	static new(): NSHTTPCookie;
	static allocWithZone(zone: any): NSHTTPCookie;
	static alloc(): NSHTTPCookie;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSHTTPCookieStorage extends NSObject {
	cookies: NSArray;
	cookieAcceptPolicy: number;
	constructor();
	static sharedHTTPCookieStorage(): NSHTTPCookieStorage;
	setCookie(cookie: NSHTTPCookie): void;
	deleteCookie(cookie: NSHTTPCookie): void;
	removeCookiesSinceDate(date: NSDate): void;
	cookiesForURL(URL: NSURL): NSArray;
	setCookiesForURLMainDocumentURL(cookies: NSArray, URL: NSURL, mainDocumentURL: NSURL): void;
	sortedCookiesUsingDescriptors(sortOrder: NSArray): NSArray;
	storeCookiesForTask(cookies: NSArray, task: NSURLSessionTask): void;
	getCookiesForTaskCompletionHandler(task: NSURLSessionTask, completionHandler: (arg1: NSArray) => void): void;
	init(): NSHTTPCookieStorage;
	static new(): NSHTTPCookieStorage;
	static allocWithZone(zone: any): NSHTTPCookieStorage;
	static alloc(): NSHTTPCookieStorage;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSIndexPath extends NSObject implements NSCopying, NSSecureCoding {
	length: number;
	section: number;
	row: number;
	item: number;
	constructor(indexes: any, length: number);
	constructor(index: number);
	constructor();
	static indexPathWithIndex(index: number): NSIndexPath;
	static indexPathWithIndexesLength(indexes: any, length: number): NSIndexPath;
	initWithIndexesLength(indexes: any, length: number): NSIndexPath;
	initWithIndex(index: number): NSIndexPath;
	indexPathByAddingIndex(index: number): NSIndexPath;
	indexPathByRemovingLastIndex(): NSIndexPath;
	indexAtPosition(position: number): number;
	getIndexes(indexes: any): void;
	compare(otherObject: NSIndexPath): number;
	static indexPathForRowInSection(row: number, section: number): NSIndexPath;
	static indexPathForItemInSection(item: number, section: number): NSIndexPath;
	init(): NSIndexPath;
	static new(): NSIndexPath;
	static allocWithZone(zone: any): NSIndexPath;
	static alloc(): NSIndexPath;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSIndexSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
	count: number;
	firstIndex: number;
	lastIndex: number;
	constructor(range: NSRange);
	constructor(indexSet: NSIndexSet);
	constructor(value: number);
	constructor();
	static indexSet(): NSIndexSet;
	static indexSetWithIndex(value: number): NSIndexSet;
	static indexSetWithIndexesInRange(range: NSRange): NSIndexSet;
	initWithIndexesInRange(range: NSRange): NSIndexSet;
	initWithIndexSet(indexSet: NSIndexSet): NSIndexSet;
	initWithIndex(value: number): NSIndexSet;
	isEqualToIndexSet(indexSet: NSIndexSet): boolean;
	indexGreaterThanIndex(value: number): number;
	indexLessThanIndex(value: number): number;
	indexGreaterThanOrEqualToIndex(value: number): number;
	indexLessThanOrEqualToIndex(value: number): number;
	getIndexesMaxCountInIndexRange(indexBuffer: any, bufferSize: number, range: any): number;
	countOfIndexesInRange(range: NSRange): number;
	containsIndex(value: number): boolean;
	containsIndexesInRange(range: NSRange): boolean;
	containsIndexes(indexSet: NSIndexSet): boolean;
	intersectsIndexesInRange(range: NSRange): boolean;
	enumerateIndexesUsingBlock(block: (arg1: number, arg2: any) => void): void;
	enumerateIndexesWithOptionsUsingBlock(opts: number, block: (arg1: number, arg2: any) => void): void;
	enumerateIndexesInRangeOptionsUsingBlock(range: NSRange, opts: number, block: (arg1: number, arg2: any) => void): void;
	indexPassingTest(predicate: (arg1: number, arg2: any) => boolean): number;
	indexWithOptionsPassingTest(opts: number, predicate: (arg1: number, arg2: any) => boolean): number;
	indexInRangeOptionsPassingTest(range: NSRange, opts: number, predicate: (arg1: number, arg2: any) => boolean): number;
	indexesPassingTest(predicate: (arg1: number, arg2: any) => boolean): NSIndexSet;
	indexesWithOptionsPassingTest(opts: number, predicate: (arg1: number, arg2: any) => boolean): NSIndexSet;
	indexesInRangeOptionsPassingTest(range: NSRange, opts: number, predicate: (arg1: number, arg2: any) => boolean): NSIndexSet;
	enumerateRangesUsingBlock(block: (arg1: NSRange, arg2: any) => void): void;
	enumerateRangesWithOptionsUsingBlock(opts: number, block: (arg1: NSRange, arg2: any) => void): void;
	enumerateRangesInRangeOptionsUsingBlock(range: NSRange, opts: number, block: (arg1: NSRange, arg2: any) => void): void;
	init(): NSIndexSet;
	static new(): NSIndexSet;
	static allocWithZone(zone: any): NSIndexSet;
	static alloc(): NSIndexSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSMutableIndexSet extends NSIndexSet {
	constructor(range: NSRange);
	constructor(indexSet: NSIndexSet);
	constructor(value: number);
	constructor();
	addIndexes(indexSet: NSIndexSet): void;
	removeIndexes(indexSet: NSIndexSet): void;
	removeAllIndexes(): void;
	addIndex(value: number): void;
	removeIndex(value: number): void;
	addIndexesInRange(range: NSRange): void;
	removeIndexesInRange(range: NSRange): void;
	shiftIndexesStartingAtIndexBy(index: number, delta: number): void;
	static indexSet(): NSMutableIndexSet;
	static indexSetWithIndex(value: number): NSMutableIndexSet;
	static indexSetWithIndexesInRange(range: NSRange): NSMutableIndexSet;
	initWithIndexesInRange(range: NSRange): NSMutableIndexSet;
	initWithIndexSet(indexSet: NSIndexSet): NSMutableIndexSet;
	initWithIndex(value: number): NSMutableIndexSet;
	init(): NSMutableIndexSet;
	static new(): NSMutableIndexSet;
	static allocWithZone(zone: any): NSMutableIndexSet;
	static alloc(): NSMutableIndexSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSInvocation extends NSObject {
	methodSignature: NSMethodSignature;
	argumentsRetained: boolean;
	target: any;
	selector: any;
	constructor();
	static invocationWithMethodSignature(sig: NSMethodSignature): NSInvocation;
	retainArguments(): NSInvocation;
	getReturnValue(retLoc: any): void;
	setReturnValue(retLoc: any): void;
	getArgumentAtIndex(argumentLocation: any, idx: number): void;
	setArgumentAtIndex(argumentLocation: any, idx: number): void;
	invoke(): void;
	invokeWithTarget(target: any): void;
	init(): NSInvocation;
	static new(): NSInvocation;
	static allocWithZone(zone: any): NSInvocation;
	static alloc(): NSInvocation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSJSONSerialization extends NSObject {
	constructor();
	static isValidJSONObject(obj: any): boolean;
	static dataWithJSONObjectOptionsError(obj: any, opt: number, error: any): NSData;
	static JSONObjectWithDataOptionsError(data: NSData, opt: number, error: any): any;
	static writeJSONObjectToStreamOptionsError(obj: any, stream: NSOutputStream, opt: number, error: any): number;
	static JSONObjectWithStreamOptionsError(stream: NSInputStream, opt: number, error: any): any;
	init(): NSJSONSerialization;
	static new(): NSJSONSerialization;
	static allocWithZone(zone: any): NSJSONSerialization;
	static alloc(): NSJSONSerialization;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSOrderedSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
	count: number;
	firstObject: any;
	lastObject: any;
	reversedOrderedSet: NSOrderedSet;
	array: NSArray;
	set: NSSet;
	constructor(objects: any, cnt: number);
	constructor(set: NSOrderedSet);
	constructor(set: NSOrderedSet, flag: boolean);
	constructor(set: NSOrderedSet, range: NSRange, flag: boolean);
	constructor(array: NSArray);
	constructor(set: NSArray, flag: boolean);
	constructor(set: NSArray, range: NSRange, flag: boolean);
	constructor(set: NSSet);
	constructor(set: NSSet, flag: boolean);
	constructor();
	objectAtIndex(idx: number): any;
	indexOfObject(object: any): number;
	initWithObjectsCount(objects: any, cnt: number): NSOrderedSet;
	getObjectsRange(objects: any, range: NSRange): void;
	objectsAtIndexes(indexes: NSIndexSet): NSArray;
	isEqualToOrderedSet(other: NSOrderedSet): boolean;
	containsObject(object: any): boolean;
	intersectsOrderedSet(other: NSOrderedSet): boolean;
	intersectsSet(set: NSSet): boolean;
	isSubsetOfOrderedSet(other: NSOrderedSet): boolean;
	isSubsetOfSet(set: NSSet): boolean;
	objectAtIndexedSubscript(idx: number): any;
	objectEnumerator(): NSEnumerator;
	reverseObjectEnumerator(): NSEnumerator;
	enumerateObjectsUsingBlock(block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateObjectsWithOptionsUsingBlock(opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateObjectsAtIndexesOptionsUsingBlock(s: NSIndexSet, opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	indexOfObjectPassingTest(predicate: (arg1: any, arg2: number, arg3: any) => boolean): number;
	indexOfObjectWithOptionsPassingTest(opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): number;
	indexOfObjectAtIndexesOptionsPassingTest(s: NSIndexSet, opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): number;
	indexesOfObjectsPassingTest(predicate: (arg1: any, arg2: number, arg3: any) => boolean): NSIndexSet;
	indexesOfObjectsWithOptionsPassingTest(opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): NSIndexSet;
	indexesOfObjectsAtIndexesOptionsPassingTest(s: NSIndexSet, opts: number, predicate: (arg1: any, arg2: number, arg3: any) => boolean): NSIndexSet;
	indexOfObjectInSortedRangeOptionsUsingComparator(object: any, range: NSRange, opts: number, cmp: (arg1: any, arg2: any) => number): number;
	sortedArrayUsingComparator(cmptr: (arg1: any, arg2: any) => number): NSArray;
	sortedArrayWithOptionsUsingComparator(opts: number, cmptr: (arg1: any, arg2: any) => number): NSArray;
	descriptionWithLocale(locale: any): string;
	descriptionWithLocaleIndent(locale: any, level: number): string;
	static orderedSet(): NSOrderedSet;
	static orderedSetWithObject(object: any): NSOrderedSet;
	static orderedSetWithObjectsCount(objects: any, cnt: number): NSOrderedSet;
	static orderedSetWithObjects(firstObj: any): NSOrderedSet;
	static orderedSetWithOrderedSet(set: NSOrderedSet): NSOrderedSet;
	static orderedSetWithOrderedSetRangeCopyItems(set: NSOrderedSet, range: NSRange, flag: boolean): NSOrderedSet;
	static orderedSetWithArray(array: NSArray): NSOrderedSet;
	static orderedSetWithArrayRangeCopyItems(array: NSArray, range: NSRange, flag: boolean): NSOrderedSet;
	static orderedSetWithSet(set: NSSet): NSOrderedSet;
	static orderedSetWithSetCopyItems(set: NSSet, flag: boolean): NSOrderedSet;
	initWithObject(object: any): NSOrderedSet;
	initWithObjects(firstObj: any): NSOrderedSet;
	initWithOrderedSet(set: NSOrderedSet): NSOrderedSet;
	initWithOrderedSetCopyItems(set: NSOrderedSet, flag: boolean): NSOrderedSet;
	initWithOrderedSetRangeCopyItems(set: NSOrderedSet, range: NSRange, flag: boolean): NSOrderedSet;
	initWithArray(array: NSArray): NSOrderedSet;
	initWithArrayCopyItems(set: NSArray, flag: boolean): NSOrderedSet;
	initWithArrayRangeCopyItems(set: NSArray, range: NSRange, flag: boolean): NSOrderedSet;
	initWithSet(set: NSSet): NSOrderedSet;
	initWithSetCopyItems(set: NSSet, flag: boolean): NSOrderedSet;
	sortedArrayUsingDescriptors(sortDescriptors: NSArray): NSArray;
	filteredOrderedSetUsingPredicate(p: NSPredicate): NSOrderedSet;
	init(): NSOrderedSet;
	static new(): NSOrderedSet;
	static allocWithZone(zone: any): NSOrderedSet;
	static alloc(): NSOrderedSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSMutableOrderedSet extends NSOrderedSet {
	constructor(numItems: number);
	constructor(objects: any, cnt: number);
	constructor(set: NSOrderedSet);
	constructor(set: NSOrderedSet, flag: boolean);
	constructor(set: NSOrderedSet, range: NSRange, flag: boolean);
	constructor(array: NSArray);
	constructor(set: NSArray, flag: boolean);
	constructor(set: NSArray, range: NSRange, flag: boolean);
	constructor(set: NSSet);
	constructor(set: NSSet, flag: boolean);
	constructor();
	insertObjectAtIndex(object: any, idx: number): void;
	removeObjectAtIndex(idx: number): void;
	replaceObjectAtIndexWithObject(idx: number, object: any): void;
	initWithCapacity(numItems: number): NSMutableOrderedSet;
	addObject(object: any): void;
	addObjectsCount(objects: any, count: number): void;
	addObjectsFromArray(array: NSArray): void;
	exchangeObjectAtIndexWithObjectAtIndex(idx1: number, idx2: number): void;
	moveObjectsAtIndexesToIndex(indexes: NSIndexSet, idx: number): void;
	insertObjectsAtIndexes(objects: NSArray, indexes: NSIndexSet): void;
	setObjectAtIndex(obj: any, idx: number): void;
	setObjectAtIndexedSubscript(obj: any, idx: number): void;
	replaceObjectsInRangeWithObjectsCount(range: NSRange, objects: any, count: number): void;
	replaceObjectsAtIndexesWithObjects(indexes: NSIndexSet, objects: NSArray): void;
	removeObjectsInRange(range: NSRange): void;
	removeObjectsAtIndexes(indexes: NSIndexSet): void;
	removeAllObjects(): void;
	removeObject(object: any): void;
	removeObjectsInArray(array: NSArray): void;
	intersectOrderedSet(other: NSOrderedSet): void;
	minusOrderedSet(other: NSOrderedSet): void;
	unionOrderedSet(other: NSOrderedSet): void;
	intersectSet(other: NSSet): void;
	minusSet(other: NSSet): void;
	unionSet(other: NSSet): void;
	sortUsingComparator(cmptr: (arg1: any, arg2: any) => number): void;
	sortWithOptionsUsingComparator(opts: number, cmptr: (arg1: any, arg2: any) => number): void;
	sortRangeOptionsUsingComparator(range: NSRange, opts: number, cmptr: (arg1: any, arg2: any) => number): void;
	static orderedSetWithCapacity(numItems: number): NSMutableOrderedSet;
	sortUsingDescriptors(sortDescriptors: NSArray): void;
	filterUsingPredicate(p: NSPredicate): void;
	initWithObjectsCount(objects: any, cnt: number): NSMutableOrderedSet;
	static orderedSet(): NSMutableOrderedSet;
	static orderedSetWithObject(object: any): NSMutableOrderedSet;
	static orderedSetWithObjectsCount(objects: any, cnt: number): NSMutableOrderedSet;
	static orderedSetWithObjects(firstObj: any): NSMutableOrderedSet;
	static orderedSetWithOrderedSet(set: NSOrderedSet): NSMutableOrderedSet;
	static orderedSetWithOrderedSetRangeCopyItems(set: NSOrderedSet, range: NSRange, flag: boolean): NSMutableOrderedSet;
	static orderedSetWithArray(array: NSArray): NSMutableOrderedSet;
	static orderedSetWithArrayRangeCopyItems(array: NSArray, range: NSRange, flag: boolean): NSMutableOrderedSet;
	static orderedSetWithSet(set: NSSet): NSMutableOrderedSet;
	static orderedSetWithSetCopyItems(set: NSSet, flag: boolean): NSMutableOrderedSet;
	initWithObject(object: any): NSMutableOrderedSet;
	initWithObjects(firstObj: any): NSMutableOrderedSet;
	initWithOrderedSet(set: NSOrderedSet): NSMutableOrderedSet;
	initWithOrderedSetCopyItems(set: NSOrderedSet, flag: boolean): NSMutableOrderedSet;
	initWithOrderedSetRangeCopyItems(set: NSOrderedSet, range: NSRange, flag: boolean): NSMutableOrderedSet;
	initWithArray(array: NSArray): NSMutableOrderedSet;
	initWithArrayCopyItems(set: NSArray, flag: boolean): NSMutableOrderedSet;
	initWithArrayRangeCopyItems(set: NSArray, range: NSRange, flag: boolean): NSMutableOrderedSet;
	initWithSet(set: NSSet): NSMutableOrderedSet;
	initWithSetCopyItems(set: NSSet, flag: boolean): NSMutableOrderedSet;
	init(): NSMutableOrderedSet;
	static new(): NSMutableOrderedSet;
	static allocWithZone(zone: any): NSMutableOrderedSet;
	static alloc(): NSMutableOrderedSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
	count: number;
	allObjects: NSArray;
	constructor(objects: any, cnt: number);
	constructor(firstObj: any);
	constructor(set: NSSet);
	constructor(set: NSSet, flag: boolean);
	constructor(array: NSArray);
	constructor();
	member(object: any): any;
	objectEnumerator(): NSEnumerator;
	initWithObjectsCount(objects: any, cnt: number): NSSet;
	anyObject(): any;
	containsObject(anObject: any): boolean;
	descriptionWithLocale(locale: any): string;
	intersectsSet(otherSet: NSSet): boolean;
	isEqualToSet(otherSet: NSSet): boolean;
	isSubsetOfSet(otherSet: NSSet): boolean;
	makeObjectsPerformSelector(aSelector: any): void;
	makeObjectsPerformSelectorWithObject(aSelector: any, argument: any): void;
	setByAddingObject(anObject: any): NSSet;
	setByAddingObjectsFromSet(other: NSSet): NSSet;
	setByAddingObjectsFromArray(other: NSArray): NSSet;
	enumerateObjectsUsingBlock(block: (arg1: any, arg2: any) => void): void;
	enumerateObjectsWithOptionsUsingBlock(opts: number, block: (arg1: any, arg2: any) => void): void;
	objectsPassingTest(predicate: (arg1: any, arg2: any) => boolean): NSSet;
	objectsWithOptionsPassingTest(opts: number, predicate: (arg1: any, arg2: any) => boolean): NSSet;
	static set(): NSSet;
	static setWithObject(object: any): NSSet;
	static setWithObjectsCount(objects: any, cnt: number): NSSet;
	static setWithObjects(firstObj: any): NSSet;
	static setWithSet(set: NSSet): NSSet;
	static setWithArray(array: NSArray): NSSet;
	initWithObjects(firstObj: any): NSSet;
	initWithSet(set: NSSet): NSSet;
	initWithSetCopyItems(set: NSSet, flag: boolean): NSSet;
	initWithArray(array: NSArray): NSSet;
	sortedArrayUsingDescriptors(sortDescriptors: NSArray): NSArray;
	filteredSetUsingPredicate(predicate: NSPredicate): NSSet;
	init(): NSSet;
	static new(): NSSet;
	static allocWithZone(zone: any): NSSet;
	static alloc(): NSSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSMutableSet extends NSSet {
	constructor(numItems: number);
	constructor(objects: any, cnt: number);
	constructor(firstObj: any);
	constructor(set: NSSet);
	constructor(set: NSSet, flag: boolean);
	constructor(array: NSArray);
	constructor();
	addObject(object: any): void;
	removeObject(object: any): void;
	initWithCapacity(numItems: number): NSMutableSet;
	addObjectsFromArray(array: NSArray): void;
	intersectSet(otherSet: NSSet): void;
	minusSet(otherSet: NSSet): void;
	removeAllObjects(): void;
	unionSet(otherSet: NSSet): void;
	setSet(otherSet: NSSet): void;
	static setWithCapacity(numItems: number): NSMutableSet;
	filterUsingPredicate(predicate: NSPredicate): void;
	initWithObjectsCount(objects: any, cnt: number): NSMutableSet;
	static set(): NSMutableSet;
	static setWithObject(object: any): NSMutableSet;
	static setWithObjectsCount(objects: any, cnt: number): NSMutableSet;
	static setWithObjects(firstObj: any): NSMutableSet;
	static setWithSet(set: NSSet): NSMutableSet;
	static setWithArray(array: NSArray): NSMutableSet;
	initWithObjects(firstObj: any): NSMutableSet;
	initWithSet(set: NSSet): NSMutableSet;
	initWithSetCopyItems(set: NSSet, flag: boolean): NSMutableSet;
	initWithArray(array: NSArray): NSMutableSet;
	init(): NSMutableSet;
	static new(): NSMutableSet;
	static allocWithZone(zone: any): NSMutableSet;
	static alloc(): NSMutableSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSCountedSet extends NSMutableSet {
	constructor(numItems: number);
	constructor(objects: any, cnt: number);
	constructor(firstObj: any);
	constructor(set: NSSet);
	constructor(set: NSSet, flag: boolean);
	constructor(array: NSArray);
	constructor();
	countForObject(object: any): number;
	initWithCapacity(numItems: number): NSCountedSet;
	static setWithCapacity(numItems: number): NSCountedSet;
	initWithObjectsCount(objects: any, cnt: number): NSCountedSet;
	static set(): NSCountedSet;
	static setWithObject(object: any): NSCountedSet;
	static setWithObjectsCount(objects: any, cnt: number): NSCountedSet;
	static setWithObjects(firstObj: any): NSCountedSet;
	static setWithSet(set: NSSet): NSCountedSet;
	static setWithArray(array: NSArray): NSCountedSet;
	initWithObjects(firstObj: any): NSCountedSet;
	initWithSet(set: NSSet): NSCountedSet;
	initWithSetCopyItems(set: NSSet, flag: boolean): NSCountedSet;
	initWithArray(array: NSArray): NSCountedSet;
	init(): NSCountedSet;
	static new(): NSCountedSet;
	static allocWithZone(zone: any): NSCountedSet;
	static alloc(): NSCountedSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSPropertyListSerialization extends NSObject {
	constructor();
	static propertyListIsValidForFormat(plist: any, format: number): boolean;
	static dataWithPropertyListFormatOptionsError(plist: any, format: number, opt: number, error: any): NSData;
	static writePropertyListToStreamFormatOptionsError(plist: any, stream: NSOutputStream, format: number, opt: number, error: any): number;
	static propertyListWithDataOptionsFormatError(data: NSData, opt: number, format: any, error: any): any;
	static propertyListWithStreamOptionsFormatError(stream: NSInputStream, opt: number, format: any, error: any): any;
	static dataFromPropertyListFormatErrorDescription(plist: any, format: number, errorString: any): NSData;
	static propertyListFromDataMutabilityOptionFormatErrorDescription(data: NSData, opt: number, format: any, errorString: any): any;
	init(): NSPropertyListSerialization;
	static new(): NSPropertyListSerialization;
	static allocWithZone(zone: any): NSPropertyListSerialization;
	static alloc(): NSPropertyListSerialization;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSKeyedArchiver extends NSCoder {
	delegate: any;
	outputFormat: number;
	constructor(data: NSMutableData);
	constructor();
	static archivedDataWithRootObject(rootObject: any): NSData;
	static archiveRootObjectToFile(rootObject: any, path: string): boolean;
	initForWritingWithMutableData(data: NSMutableData): NSKeyedArchiver;
	finishEncoding(): void;
	static setClassNameForClass(codedName: string, cls: any): void;
	setClassNameForClass(codedName: string, cls: any): void;
	static classNameForClass(cls: any): string;
	classNameForClass(cls: any): string;
	setRequiresSecureCoding(b: boolean): void;
	init(): NSKeyedArchiver;
	static new(): NSKeyedArchiver;
	static allocWithZone(zone: any): NSKeyedArchiver;
	static alloc(): NSKeyedArchiver;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSKeyedUnarchiver extends NSCoder {
	delegate: any;
	constructor(data: NSData);
	constructor();
	static unarchiveObjectWithData(data: NSData): any;
	static unarchiveObjectWithFile(path: string): any;
	initForReadingWithData(data: NSData): NSKeyedUnarchiver;
	finishDecoding(): void;
	static setClassForClassName(cls: any, codedName: string): void;
	setClassForClassName(cls: any, codedName: string): void;
	static classForClassName(codedName: string): any;
	classForClassName(codedName: string): any;
	setRequiresSecureCoding(b: boolean): void;
	init(): NSKeyedUnarchiver;
	static new(): NSKeyedUnarchiver;
	static allocWithZone(zone: any): NSKeyedUnarchiver;
	static alloc(): NSKeyedUnarchiver;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSLocale extends NSObject implements NSCopying, NSSecureCoding {
	localeIdentifier: string;
	constructor(string: string);
	constructor();
	objectForKey(key: any): any;
	displayNameForKeyValue(key: any, value: any): string;
	initWithLocaleIdentifier(string: string): NSLocale;
	static autoupdatingCurrentLocale(): NSLocale;
	static currentLocale(): NSLocale;
	static systemLocale(): NSLocale;
	static localeWithLocaleIdentifier(ident: string): NSLocale;
	static availableLocaleIdentifiers(): NSArray;
	static ISOLanguageCodes(): NSArray;
	static ISOCountryCodes(): NSArray;
	static ISOCurrencyCodes(): NSArray;
	static commonISOCurrencyCodes(): NSArray;
	static preferredLanguages(): NSArray;
	static componentsFromLocaleIdentifier(string: string): NSDictionary;
	static localeIdentifierFromComponents(dict: NSDictionary): string;
	static canonicalLocaleIdentifierFromString(string: string): string;
	static canonicalLanguageIdentifierFromString(string: string): string;
	static localeIdentifierFromWindowsLocaleCode(lcid: number): string;
	static windowsLocaleCodeFromLocaleIdentifier(localeIdentifier: string): number;
	static characterDirectionForLanguage(isoLangCode: string): number;
	static lineDirectionForLanguage(isoLangCode: string): number;
	init(): NSLocale;
	static new(): NSLocale;
	static allocWithZone(zone: any): NSLocale;
	static alloc(): NSLocale;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSLock extends NSObject implements NSLocking {
	name: string;
	constructor();
	tryLock(): boolean;
	lockBeforeDate(limit: NSDate): boolean;
	init(): NSLock;
	static new(): NSLock;
	static allocWithZone(zone: any): NSLock;
	static alloc(): NSLock;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	lock(): void;
	unlock(): void;
}
declare class NSConditionLock extends NSObject implements NSLocking {
	condition: number;
	name: string;
	constructor(condition: number);
	constructor();
	initWithCondition(condition: number): NSConditionLock;
	lockWhenCondition(condition: number): void;
	tryLock(): boolean;
	tryLockWhenCondition(condition: number): boolean;
	unlockWithCondition(condition: number): void;
	lockBeforeDate(limit: NSDate): boolean;
	lockWhenConditionBeforeDate(condition: number, limit: NSDate): boolean;
	init(): NSConditionLock;
	static new(): NSConditionLock;
	static allocWithZone(zone: any): NSConditionLock;
	static alloc(): NSConditionLock;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	lock(): void;
	unlock(): void;
}
declare class NSRecursiveLock extends NSObject implements NSLocking {
	name: string;
	constructor();
	tryLock(): boolean;
	lockBeforeDate(limit: NSDate): boolean;
	init(): NSRecursiveLock;
	static new(): NSRecursiveLock;
	static allocWithZone(zone: any): NSRecursiveLock;
	static alloc(): NSRecursiveLock;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	lock(): void;
	unlock(): void;
}
declare class NSCondition extends NSObject implements NSLocking {
	name: string;
	constructor();
	wait(): void;
	waitUntilDate(limit: NSDate): boolean;
	signal(): void;
	broadcast(): void;
	init(): NSCondition;
	static new(): NSCondition;
	static allocWithZone(zone: any): NSCondition;
	static alloc(): NSCondition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	lock(): void;
	unlock(): void;
}
declare class NSMapTable extends NSObject implements NSCopying, NSCoding, NSFastEnumeration {
	keyPointerFunctions: NSPointerFunctions;
	valuePointerFunctions: NSPointerFunctions;
	count: number;
	constructor(keyOptions: number, valueOptions: number, initialCapacity: number);
	constructor(keyFunctions: NSPointerFunctions, valueFunctions: NSPointerFunctions, initialCapacity: number);
	constructor();
	initWithKeyOptionsValueOptionsCapacity(keyOptions: number, valueOptions: number, initialCapacity: number): NSMapTable;
	initWithKeyPointerFunctionsValuePointerFunctionsCapacity(keyFunctions: NSPointerFunctions, valueFunctions: NSPointerFunctions, initialCapacity: number): NSMapTable;
	static mapTableWithKeyOptionsValueOptions(keyOptions: number, valueOptions: number): NSMapTable;
	static strongToStrongObjectsMapTable(): NSMapTable;
	static weakToStrongObjectsMapTable(): NSMapTable;
	static strongToWeakObjectsMapTable(): NSMapTable;
	static weakToWeakObjectsMapTable(): NSMapTable;
	objectForKey(aKey: any): any;
	removeObjectForKey(aKey: any): void;
	setObjectForKey(anObject: any, aKey: any): void;
	keyEnumerator(): NSEnumerator;
	objectEnumerator(): NSEnumerator;
	removeAllObjects(): void;
	dictionaryRepresentation(): NSDictionary;
	init(): NSMapTable;
	static new(): NSMapTable;
	static allocWithZone(zone: any): NSMapTable;
	static alloc(): NSMapTable;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class NSMethodSignature extends NSObject {
	numberOfArguments: number;
	frameLength: number;
	methodReturnType: string;
	methodReturnLength: number;
	constructor();
	static signatureWithObjCTypes(types: string): NSMethodSignature;
	getArgumentTypeAtIndex(idx: number): string;
	isOneway(): boolean;
	init(): NSMethodSignature;
	static new(): NSMethodSignature;
	static allocWithZone(zone: any): NSMethodSignature;
	static alloc(): NSMethodSignature;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSNotification extends NSObject implements NSCopying, NSCoding {
	name: string;
	object: any;
	userInfo: NSDictionary;
	constructor(name: string, object: any, userInfo: NSDictionary);
	constructor();
	initWithNameObjectUserInfo(name: string, object: any, userInfo: NSDictionary): NSNotification;
	static notificationWithNameObject(aName: string, anObject: any): NSNotification;
	static notificationWithNameObjectUserInfo(aName: string, anObject: any, aUserInfo: NSDictionary): NSNotification;
	init(): NSNotification;
	static new(): NSNotification;
	static allocWithZone(zone: any): NSNotification;
	static alloc(): NSNotification;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSNotificationCenter extends NSObject {
	constructor();
	static defaultCenter(): NSNotificationCenter;
	addObserverSelectorNameObject(observer: any, aSelector: any, aName: string, anObject: any): void;
	postNotification(notification: NSNotification): void;
	postNotificationNameObject(aName: string, anObject: any): void;
	postNotificationNameObjectUserInfo(aName: string, anObject: any, aUserInfo: NSDictionary): void;
	removeObserver(observer: any): void;
	removeObserverNameObject(observer: any, aName: string, anObject: any): void;
	addObserverForNameObjectQueueUsingBlock(name: string, obj: any, queue: NSOperationQueue, block: (arg1: NSNotification) => void): any;
	init(): NSNotificationCenter;
	static new(): NSNotificationCenter;
	static allocWithZone(zone: any): NSNotificationCenter;
	static alloc(): NSNotificationCenter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSNotificationQueue extends NSObject {
	constructor(notificationCenter: NSNotificationCenter);
	constructor();
	static defaultQueue(): NSNotificationQueue;
	initWithNotificationCenter(notificationCenter: NSNotificationCenter): NSNotificationQueue;
	enqueueNotificationPostingStyle(notification: NSNotification, postingStyle: number): void;
	enqueueNotificationPostingStyleCoalesceMaskForModes(notification: NSNotification, postingStyle: number, coalesceMask: number, modes: NSArray): void;
	dequeueNotificationsMatchingCoalesceMask(notification: NSNotification, coalesceMask: number): void;
	init(): NSNotificationQueue;
	static new(): NSNotificationQueue;
	static allocWithZone(zone: any): NSNotificationQueue;
	static alloc(): NSNotificationQueue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSNull extends NSObject implements NSCopying, NSSecureCoding {
	constructor();
	static null(): NSNull;
	init(): NSNull;
	static new(): NSNull;
	static allocWithZone(zone: any): NSNull;
	static alloc(): NSNull;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSNumberFormatter extends NSFormatter {
	formattingContext: number;
	numberStyle: number;
	locale: NSLocale;
	generatesDecimalNumbers: boolean;
	formatterBehavior: number;
	negativeFormat: string;
	textAttributesForNegativeValues: NSDictionary;
	positiveFormat: string;
	textAttributesForPositiveValues: NSDictionary;
	allowsFloats: boolean;
	decimalSeparator: string;
	alwaysShowsDecimalSeparator: boolean;
	currencyDecimalSeparator: string;
	usesGroupingSeparator: boolean;
	groupingSeparator: string;
	zeroSymbol: string;
	textAttributesForZero: NSDictionary;
	nilSymbol: string;
	textAttributesForNil: NSDictionary;
	notANumberSymbol: string;
	textAttributesForNotANumber: NSDictionary;
	positiveInfinitySymbol: string;
	textAttributesForPositiveInfinity: NSDictionary;
	negativeInfinitySymbol: string;
	textAttributesForNegativeInfinity: NSDictionary;
	positivePrefix: string;
	positiveSuffix: string;
	negativePrefix: string;
	negativeSuffix: string;
	currencyCode: string;
	currencySymbol: string;
	internationalCurrencySymbol: string;
	percentSymbol: string;
	perMillSymbol: string;
	minusSign: string;
	plusSign: string;
	exponentSymbol: string;
	groupingSize: number;
	secondaryGroupingSize: number;
	multiplier: NSNumber;
	formatWidth: number;
	paddingCharacter: string;
	paddingPosition: number;
	roundingMode: number;
	roundingIncrement: NSNumber;
	minimumIntegerDigits: number;
	maximumIntegerDigits: number;
	minimumFractionDigits: number;
	maximumFractionDigits: number;
	minimum: NSNumber;
	maximum: NSNumber;
	currencyGroupingSeparator: string;
	lenient: boolean;
	usesSignificantDigits: boolean;
	minimumSignificantDigits: number;
	maximumSignificantDigits: number;
	partialStringValidationEnabled: boolean;
	constructor();
	getObjectValueForStringRangeError(obj: any, string: string, rangep: any, error: any): boolean;
	stringFromNumber(number: NSNumber): string;
	numberFromString(string: string): NSNumber;
	static localizedStringFromNumberNumberStyle(num: NSNumber, nstyle: number): string;
	static defaultFormatterBehavior(): number;
	static setDefaultFormatterBehavior(behavior: number): void;
	init(): NSNumberFormatter;
	static new(): NSNumberFormatter;
	static allocWithZone(zone: any): NSNumberFormatter;
	static alloc(): NSNumberFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSOperation extends NSObject {
	cancelled: boolean;
	executing: boolean;
	finished: boolean;
	concurrent: boolean;
	asynchronous: boolean;
	ready: boolean;
	dependencies: NSArray;
	queuePriority: number;
	completionBlock: () => void;
	threadPriority: number;
	qualityOfService: number;
	name: string;
	constructor();
	start(): void;
	main(): void;
	cancel(): void;
	addDependency(op: NSOperation): void;
	removeDependency(op: NSOperation): void;
	waitUntilFinished(): void;
	init(): NSOperation;
	static new(): NSOperation;
	static allocWithZone(zone: any): NSOperation;
	static alloc(): NSOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSBlockOperation extends NSOperation {
	executionBlocks: NSArray;
	constructor();
	static blockOperationWithBlock(block: () => void): NSBlockOperation;
	addExecutionBlock(block: () => void): void;
	init(): NSBlockOperation;
	static new(): NSBlockOperation;
	static allocWithZone(zone: any): NSBlockOperation;
	static alloc(): NSBlockOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSInvocationOperation extends NSOperation {
	invocation: NSInvocation;
	result: any;
	constructor(target: any, sel: any, arg: any);
	constructor(inv: NSInvocation);
	constructor();
	initWithTargetSelectorObject(target: any, sel: any, arg: any): NSInvocationOperation;
	initWithInvocation(inv: NSInvocation): NSInvocationOperation;
	init(): NSInvocationOperation;
	static new(): NSInvocationOperation;
	static allocWithZone(zone: any): NSInvocationOperation;
	static alloc(): NSInvocationOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSOperationQueue extends NSObject {
	operations: NSArray;
	operationCount: number;
	maxConcurrentOperationCount: number;
	suspended: boolean;
	name: string;
	qualityOfService: number;
	underlyingQueue: NSObject;
	constructor();
	addOperation(op: NSOperation): void;
	addOperationsWaitUntilFinished(ops: NSArray, wait: boolean): void;
	addOperationWithBlock(block: () => void): void;
	cancelAllOperations(): void;
	waitUntilAllOperationsAreFinished(): void;
	static currentQueue(): NSOperationQueue;
	static mainQueue(): NSOperationQueue;
	init(): NSOperationQueue;
	static new(): NSOperationQueue;
	static allocWithZone(zone: any): NSOperationQueue;
	static alloc(): NSOperationQueue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSOrthography extends NSObject implements NSCopying, NSCoding {
	dominantScript: string;
	languageMap: NSDictionary;
	dominantLanguage: string;
	allScripts: NSArray;
	allLanguages: NSArray;
	constructor(script: string, map: NSDictionary);
	constructor();
	initWithDominantScriptLanguageMap(script: string, map: NSDictionary): NSOrthography;
	languagesForScript(script: string): NSArray;
	dominantLanguageForScript(script: string): string;
	static orthographyWithDominantScriptLanguageMap(script: string, map: NSDictionary): NSOrthography;
	init(): NSOrthography;
	static new(): NSOrthography;
	static allocWithZone(zone: any): NSOrthography;
	static alloc(): NSOrthography;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSPointerArray extends NSObject implements NSFastEnumeration, NSCopying, NSCoding {
	pointerFunctions: NSPointerFunctions;
	count: number;
	allObjects: NSArray;
	constructor(options: number);
	constructor(functions: NSPointerFunctions);
	constructor();
	initWithOptions(options: number): NSPointerArray;
	initWithPointerFunctions(functions: NSPointerFunctions): NSPointerArray;
	static pointerArrayWithOptions(options: number): NSPointerArray;
	static pointerArrayWithPointerFunctions(functions: NSPointerFunctions): NSPointerArray;
	pointerAtIndex(index: number): any;
	addPointer(pointer: any): void;
	removePointerAtIndex(index: number): void;
	insertPointerAtIndex(item: any, index: number): void;
	replacePointerAtIndexWithPointer(index: number, item: any): void;
	compact(): void;
	static strongObjectsPointerArray(): NSPointerArray;
	static weakObjectsPointerArray(): NSPointerArray;
	init(): NSPointerArray;
	static new(): NSPointerArray;
	static allocWithZone(zone: any): NSPointerArray;
	static alloc(): NSPointerArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSPort extends NSObject implements NSCopying, NSCoding {
	valid: boolean;
	reservedSpaceLength: number;
	constructor();
	static port(): NSPort;
	invalidate(): void;
	setDelegate(anObject: any): void;
	delegate(): any;
	scheduleInRunLoopForMode(runLoop: NSRunLoop, mode: string): void;
	removeFromRunLoopForMode(runLoop: NSRunLoop, mode: string): void;
	sendBeforeDateComponentsFromReserved(limitDate: NSDate, components: NSMutableArray, receivePort: NSPort, headerSpaceReserved: number): boolean;
	sendBeforeDateMsgidComponentsFromReserved(limitDate: NSDate, msgID: number, components: NSMutableArray, receivePort: NSPort, headerSpaceReserved: number): boolean;
	init(): NSPort;
	static new(): NSPort;
	static allocWithZone(zone: any): NSPort;
	static alloc(): NSPort;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSMachPort extends NSPort {
	machPort: number;
	constructor(machPort: number);
	constructor(machPort: number, f: number);
	constructor();
	static portWithMachPort(machPort: number): NSPort;
	initWithMachPort(machPort: number): NSMachPort;
	static portWithMachPortOptions(machPort: number, f: number): NSPort;
	initWithMachPortOptions(machPort: number, f: number): NSMachPort;
	init(): NSMachPort;
	static new(): NSMachPort;
	static allocWithZone(zone: any): NSMachPort;
	static alloc(): NSMachPort;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSMessagePort extends NSPort {
	constructor();
	init(): NSMessagePort;
	static new(): NSMessagePort;
	static allocWithZone(zone: any): NSMessagePort;
	static alloc(): NSMessagePort;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSProcessInfo extends NSObject {
	environment: NSDictionary;
	arguments: NSArray;
	hostName: string;
	processName: string;
	processIdentifier: number;
	globallyUniqueString: string;
	operatingSystemVersionString: string;
	operatingSystemVersion: NSOperatingSystemVersion;
	processorCount: number;
	activeProcessorCount: number;
	physicalMemory: number;
	systemUptime: number;
	constructor();
	static processInfo(): NSProcessInfo;
	operatingSystem(): number;
	operatingSystemName(): string;
	isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;
	beginActivityWithOptionsReason(options: number, reason: string): any;
	endActivity(activity: any): void;
	performActivityWithOptionsReasonUsingBlock(options: number, reason: string, block: () => void): void;
	init(): NSProcessInfo;
	static new(): NSProcessInfo;
	static allocWithZone(zone: any): NSProcessInfo;
	static alloc(): NSProcessInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSProxy implements NSObjectProtocol {
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	static alloc(): NSProxy;
	static allocWithZone(zone: any): NSProxy;
	static class(): any;
	forwardInvocation(invocation: NSInvocation): void;
	methodSignatureForSelector(sel: any): NSMethodSignature;
	dealloc(): void;
	finalize(): void;
	static respondsToSelector(aSelector: any): boolean;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSTextCheckingResult extends NSObject implements NSCopying, NSCoding {
	resultType: number;
	range: NSRange;
	orthography: NSOrthography;
	grammarDetails: NSArray;
	date: NSDate;
	timeZone: NSTimeZone;
	duration: number;
	components: NSDictionary;
	URL: NSURL;
	replacementString: string;
	alternativeStrings: NSArray;
	regularExpression: NSRegularExpression;
	phoneNumber: string;
	addressComponents: NSDictionary;
	numberOfRanges: number;
	constructor();
	rangeAtIndex(idx: number): NSRange;
	resultByAdjustingRangesWithOffset(offset: number): NSTextCheckingResult;
	static orthographyCheckingResultWithRangeOrthography(range: NSRange, orthography: NSOrthography): NSTextCheckingResult;
	static spellCheckingResultWithRange(range: NSRange): NSTextCheckingResult;
	static grammarCheckingResultWithRangeDetails(range: NSRange, details: NSArray): NSTextCheckingResult;
	static dateCheckingResultWithRangeDate(range: NSRange, date: NSDate): NSTextCheckingResult;
	static dateCheckingResultWithRangeDateTimeZoneDuration(range: NSRange, date: NSDate, timeZone: NSTimeZone, duration: number): NSTextCheckingResult;
	static addressCheckingResultWithRangeComponents(range: NSRange, components: NSDictionary): NSTextCheckingResult;
	static linkCheckingResultWithRangeURL(range: NSRange, url: NSURL): NSTextCheckingResult;
	static quoteCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
	static dashCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
	static replacementCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
	static correctionCheckingResultWithRangeReplacementString(range: NSRange, replacementString: string): NSTextCheckingResult;
	static correctionCheckingResultWithRangeReplacementStringAlternativeStrings(range: NSRange, replacementString: string, alternativeStrings: NSArray): NSTextCheckingResult;
	static regularExpressionCheckingResultWithRangesCountRegularExpression(ranges: any, count: number, regularExpression: NSRegularExpression): NSTextCheckingResult;
	static phoneNumberCheckingResultWithRangePhoneNumber(range: NSRange, phoneNumber: string): NSTextCheckingResult;
	static transitInformationCheckingResultWithRangeComponents(range: NSRange, components: NSDictionary): NSTextCheckingResult;
	init(): NSTextCheckingResult;
	static new(): NSTextCheckingResult;
	static allocWithZone(zone: any): NSTextCheckingResult;
	static alloc(): NSTextCheckingResult;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSRegularExpression extends NSObject implements NSCopying, NSCoding {
	pattern: string;
	options: number;
	numberOfCaptureGroups: number;
	constructor(pattern: string, options: number, error: any);
	constructor();
	static regularExpressionWithPatternOptionsError(pattern: string, options: number, error: any): NSRegularExpression;
	initWithPatternOptionsError(pattern: string, options: number, error: any): NSRegularExpression;
	static escapedPatternForString(string: string): string;
	enumerateMatchesInStringOptionsRangeUsingBlock(string: string, options: number, range: NSRange, block: (arg1: NSTextCheckingResult, arg2: number, arg3: any) => void): void;
	matchesInStringOptionsRange(string: string, options: number, range: NSRange): NSArray;
	numberOfMatchesInStringOptionsRange(string: string, options: number, range: NSRange): number;
	firstMatchInStringOptionsRange(string: string, options: number, range: NSRange): NSTextCheckingResult;
	rangeOfFirstMatchInStringOptionsRange(string: string, options: number, range: NSRange): NSRange;
	stringByReplacingMatchesInStringOptionsRangeWithTemplate(string: string, options: number, range: NSRange, templ: string): string;
	replaceMatchesInStringOptionsRangeWithTemplate(string: NSMutableString, options: number, range: NSRange, templ: string): number;
	replacementStringForResultInStringOffsetTemplate(result: NSTextCheckingResult, string: string, offset: number, templ: string): string;
	static escapedTemplateForString(string: string): string;
	init(): NSRegularExpression;
	static new(): NSRegularExpression;
	static allocWithZone(zone: any): NSRegularExpression;
	static alloc(): NSRegularExpression;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSDataDetector extends NSRegularExpression {
	checkingTypes: number;
	constructor(checkingTypes: number, error: any);
	constructor(pattern: string, options: number, error: any);
	constructor();
	static dataDetectorWithTypesError(checkingTypes: number, error: any): NSDataDetector;
	initWithTypesError(checkingTypes: number, error: any): NSDataDetector;
	initWithPatternOptionsError(pattern: string, options: number, error: any): NSDataDetector;
	init(): NSDataDetector;
	static new(): NSDataDetector;
	static allocWithZone(zone: any): NSDataDetector;
	static alloc(): NSDataDetector;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSRunLoop extends NSObject {
	currentMode: string;
	constructor();
	static currentRunLoop(): NSRunLoop;
	static mainRunLoop(): NSRunLoop;
	getCFRunLoop(): any;
	addTimerForMode(timer: NSTimer, mode: string): void;
	addPortForMode(aPort: NSPort, mode: string): void;
	removePortForMode(aPort: NSPort, mode: string): void;
	limitDateForMode(mode: string): NSDate;
	acceptInputForModeBeforeDate(mode: string, limitDate: NSDate): void;
	run(): void;
	runUntilDate(limitDate: NSDate): void;
	runModeBeforeDate(mode: string, limitDate: NSDate): boolean;
	performSelectorTargetArgumentOrderModes(aSelector: any, target: any, arg: any, order: number, modes: NSArray): void;
	cancelPerformSelectorTargetArgument(aSelector: any, target: any, arg: any): void;
	cancelPerformSelectorsWithTarget(target: any): void;
	init(): NSRunLoop;
	static new(): NSRunLoop;
	static allocWithZone(zone: any): NSRunLoop;
	static alloc(): NSRunLoop;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSSortDescriptor extends NSObject implements NSSecureCoding, NSCopying {
	key: string;
	ascending: boolean;
	selector: any;
	comparator: (arg1: any, arg2: any) => number;
	reversedSortDescriptor: any;
	constructor(key: string, ascending: boolean);
	constructor(key: string, ascending: boolean, selector: any);
	constructor(key: string, ascending: boolean, cmptr: (arg1: any, arg2: any) => number);
	constructor();
	static sortDescriptorWithKeyAscending(key: string, ascending: boolean): NSSortDescriptor;
	static sortDescriptorWithKeyAscendingSelector(key: string, ascending: boolean, selector: any): NSSortDescriptor;
	initWithKeyAscending(key: string, ascending: boolean): NSSortDescriptor;
	initWithKeyAscendingSelector(key: string, ascending: boolean, selector: any): NSSortDescriptor;
	allowEvaluation(): void;
	static sortDescriptorWithKeyAscendingComparator(key: string, ascending: boolean, cmptr: (arg1: any, arg2: any) => number): NSSortDescriptor;
	initWithKeyAscendingComparator(key: string, ascending: boolean, cmptr: (arg1: any, arg2: any) => number): NSSortDescriptor;
	compareObjectToObject(object1: any, object2: any): number;
	init(): NSSortDescriptor;
	static new(): NSSortDescriptor;
	static allocWithZone(zone: any): NSSortDescriptor;
	static alloc(): NSSortDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSStream extends NSObject {
	delegate: any;
	streamStatus: number;
	streamError: NSError;
	constructor();
	open(): void;
	close(): void;
	propertyForKey(key: string): any;
	setPropertyForKey(property: any, key: string): boolean;
	scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	static getStreamsToHostWithNamePortInputStreamOutputStream(hostname: string, port: number, inputStream: any, outputStream: any): void;
	static getBoundStreamsWithBufferSizeInputStreamOutputStream(bufferSize: number, inputStream: any, outputStream: any): void;
	init(): NSStream;
	static new(): NSStream;
	static allocWithZone(zone: any): NSStream;
	static alloc(): NSStream;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSInputStream extends NSStream {
	hasBytesAvailable: boolean;
	constructor(data: NSData);
	constructor(url: NSURL);
	constructor(path: string);
	constructor();
	readMaxLength(buffer: string, len: number): number;
	getBufferLength(buffer: any, len: any): boolean;
	initWithData(data: NSData): NSInputStream;
	initWithURL(url: NSURL): NSInputStream;
	initWithFileAtPath(path: string): NSInputStream;
	static inputStreamWithData(data: NSData): NSInputStream;
	static inputStreamWithFileAtPath(path: string): NSInputStream;
	static inputStreamWithURL(url: NSURL): NSInputStream;
	init(): NSInputStream;
	static new(): NSInputStream;
	static allocWithZone(zone: any): NSInputStream;
	static alloc(): NSInputStream;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSOutputStream extends NSStream {
	hasSpaceAvailable: boolean;
	constructor(buffer: string, capacity: number);
	constructor(url: NSURL, shouldAppend: boolean);
	constructor(path: string, shouldAppend: boolean);
	writeMaxLength(buffer: string, len: number): number;
	initToMemory(): NSOutputStream;
	initToBufferCapacity(buffer: string, capacity: number): NSOutputStream;
	initWithURLAppend(url: NSURL, shouldAppend: boolean): NSOutputStream;
	initToFileAtPathAppend(path: string, shouldAppend: boolean): NSOutputStream;
	static outputStreamToMemory(): NSOutputStream;
	static outputStreamToBufferCapacity(buffer: string, capacity: number): NSOutputStream;
	static outputStreamToFileAtPathAppend(path: string, shouldAppend: boolean): NSOutputStream;
	static outputStreamWithURLAppend(url: NSURL, shouldAppend: boolean): NSOutputStream;
	init(): NSOutputStream;
	static new(): NSOutputStream;
	static allocWithZone(zone: any): NSOutputStream;
	static alloc(): NSOutputStream;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSThread extends NSObject {
	threadDictionary: NSMutableDictionary;
	threadPriority: number;
	qualityOfService: number;
	name: string;
	stackSize: number;
	isMainThread: boolean;
	executing: boolean;
	finished: boolean;
	cancelled: boolean;
	constructor(target: any, selector: any, argument: any);
	constructor();
	static currentThread(): NSThread;
	static detachNewThreadSelectorToTargetWithObject(selector: any, target: any, argument: any): void;
	static isMultiThreaded(): boolean;
	static sleepUntilDate(date: NSDate): void;
	static sleepForTimeInterval(ti: number): void;
	static exit(): void;
	static threadPriority(): number;
	static setThreadPriority(p: number): boolean;
	static callStackReturnAddresses(): NSArray;
	static callStackSymbols(): NSArray;
	static isMainThread(): boolean;
	static mainThread(): NSThread;
	initWithTargetSelectorObject(target: any, selector: any, argument: any): NSThread;
	cancel(): void;
	start(): void;
	main(): void;
	init(): NSThread;
	static new(): NSThread;
	static allocWithZone(zone: any): NSThread;
	static alloc(): NSThread;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSTimeZone extends NSObject implements NSCopying, NSSecureCoding {
	name: string;
	data: NSData;
	secondsFromGMT: number;
	abbreviation: string;
	daylightSavingTime: boolean;
	daylightSavingTimeOffset: number;
	nextDaylightSavingTimeTransition: NSDate;
	constructor(tzName: string);
	constructor(tzName: string, aData: NSData);
	constructor();
	secondsFromGMTForDate(aDate: NSDate): number;
	abbreviationForDate(aDate: NSDate): string;
	isDaylightSavingTimeForDate(aDate: NSDate): boolean;
	daylightSavingTimeOffsetForDate(aDate: NSDate): number;
	nextDaylightSavingTimeTransitionAfterDate(aDate: NSDate): NSDate;
	static systemTimeZone(): NSTimeZone;
	static resetSystemTimeZone(): void;
	static defaultTimeZone(): NSTimeZone;
	static setDefaultTimeZone(aTimeZone: NSTimeZone): void;
	static localTimeZone(): NSTimeZone;
	static knownTimeZoneNames(): NSArray;
	static abbreviationDictionary(): NSDictionary;
	static setAbbreviationDictionary(dict: NSDictionary): void;
	static timeZoneDataVersion(): string;
	isEqualToTimeZone(aTimeZone: NSTimeZone): boolean;
	localizedNameLocale(style: number, locale: NSLocale): string;
	static timeZoneWithName(tzName: string): NSTimeZone;
	static timeZoneWithNameData(tzName: string, aData: NSData): NSTimeZone;
	initWithName(tzName: string): NSTimeZone;
	initWithNameData(tzName: string, aData: NSData): NSTimeZone;
	static timeZoneForSecondsFromGMT(seconds: number): NSTimeZone;
	static timeZoneWithAbbreviation(abbreviation: string): NSTimeZone;
	init(): NSTimeZone;
	static new(): NSTimeZone;
	static allocWithZone(zone: any): NSTimeZone;
	static alloc(): NSTimeZone;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSTimer extends NSObject {
	fireDate: NSDate;
	timeInterval: number;
	tolerance: number;
	valid: boolean;
	userInfo: any;
	constructor(date: NSDate, ti: number, t: any, s: any, ui: any, rep: boolean);
	constructor();
	static timerWithTimeIntervalInvocationRepeats(ti: number, invocation: NSInvocation, yesOrNo: boolean): NSTimer;
	static scheduledTimerWithTimeIntervalInvocationRepeats(ti: number, invocation: NSInvocation, yesOrNo: boolean): NSTimer;
	static timerWithTimeIntervalTargetSelectorUserInfoRepeats(ti: number, aTarget: any, aSelector: any, userInfo: any, yesOrNo: boolean): NSTimer;
	static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(ti: number, aTarget: any, aSelector: any, userInfo: any, yesOrNo: boolean): NSTimer;
	initWithFireDateIntervalTargetSelectorUserInfoRepeats(date: NSDate, ti: number, t: any, s: any, ui: any, rep: boolean): NSTimer;
	fire(): void;
	invalidate(): void;
	init(): NSTimer;
	static new(): NSTimer;
	static allocWithZone(zone: any): NSTimer;
	static alloc(): NSTimer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURL extends NSObject implements NSSecureCoding, NSCopying, QLPreviewItem {
	absoluteString: string;
	relativeString: string;
	baseURL: NSURL;
	absoluteURL: NSURL;
	scheme: string;
	resourceSpecifier: string;
	host: string;
	port: NSNumber;
	user: string;
	password: string;
	path: string;
	fragment: string;
	parameterString: string;
	query: string;
	relativePath: string;
	fileSystemRepresentation: string;
	fileURL: boolean;
	standardizedURL: NSURL;
	filePathURL: NSURL;
	pathComponents: NSArray;
	lastPathComponent: string;
	pathExtension: string;
	URLByDeletingLastPathComponent: NSURL;
	URLByDeletingPathExtension: NSURL;
	URLByStandardizingPath: NSURL;
	URLByResolvingSymlinksInPath: NSURL;
	previewItemURL: NSURL;
	previewItemTitle: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(scheme: string, host: string, path: string);
	constructor(path: string, isDir: boolean);
	constructor(path: string, isDir: boolean, baseURL: NSURL);
	constructor(URLString: string, baseURL: NSURL);
	constructor(bookmarkData: NSData, options: number, relativeURL: NSURL, isStale: any, error: any);
	constructor();
	initWithSchemeHostPath(scheme: string, host: string, path: string): NSURL;
	initFileURLWithPathIsDirectory(path: string, isDir: boolean): NSURL;
	initFileURLWithPath(path: string): NSURL;
	static fileURLWithPathIsDirectory(path: string, isDir: boolean): NSURL;
	static fileURLWithPath(path: string): NSURL;
	initFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(path: string, isDir: boolean, baseURL: NSURL): NSURL;
	static fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(path: string, isDir: boolean, baseURL: NSURL): NSURL;
	initWithString(URLString: string): NSURL;
	initWithStringRelativeToURL(URLString: string, baseURL: NSURL): NSURL;
	static URLWithString(URLString: string): NSURL;
	static URLWithStringRelativeToURL(URLString: string, baseURL: NSURL): NSURL;
	getFileSystemRepresentationMaxLength(buffer: string, maxBufferLength: number): boolean;
	checkResourceIsReachableAndReturnError(error: any): boolean;
	isFileReferenceURL(): boolean;
	fileReferenceURL(): NSURL;
	getResourceValueForKeyError(value: any, key: string, error: any): boolean;
	resourceValuesForKeysError(keys: NSArray, error: any): NSDictionary;
	setResourceValueForKeyError(value: any, key: string, error: any): boolean;
	setResourceValuesError(keyedValues: NSDictionary, error: any): boolean;
	removeCachedResourceValueForKey(key: string): void;
	removeAllCachedResourceValues(): void;
	setTemporaryResourceValueForKey(value: any, key: string): void;
	bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURLError(options: number, keys: NSArray, relativeURL: NSURL, error: any): NSData;
	initByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError(bookmarkData: NSData, options: number, relativeURL: NSURL, isStale: any, error: any): NSURL;
	static URLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError(bookmarkData: NSData, options: number, relativeURL: NSURL, isStale: any, error: any): NSURL;
	static resourceValuesForKeysFromBookmarkData(keys: NSArray, bookmarkData: NSData): NSDictionary;
	static writeBookmarkDataToURLOptionsError(bookmarkData: NSData, bookmarkFileURL: NSURL, options: number, error: any): boolean;
	static bookmarkDataWithContentsOfURLError(bookmarkFileURL: NSURL, error: any): NSData;
	static URLByResolvingAliasFileAtURLOptionsError(url: NSURL, options: number, error: any): NSURL;
	startAccessingSecurityScopedResource(): boolean;
	stopAccessingSecurityScopedResource(): void;
	getPromisedItemResourceValueForKeyError(value: any, key: string, error: any): boolean;
	promisedItemResourceValuesForKeysError(keys: NSArray, error: any): NSDictionary;
	checkPromisedItemIsReachableAndReturnError(error: any): boolean;
	static fileURLWithPathComponents(components: NSArray): NSURL;
	URLByAppendingPathComponent(pathComponent: string): NSURL;
	URLByAppendingPathComponentIsDirectory(pathComponent: string, isDirectory: boolean): NSURL;
	URLByAppendingPathExtension(pathExtension: string): NSURL;
	init(): NSURL;
	static new(): NSURL;
	static allocWithZone(zone: any): NSURL;
	static alloc(): NSURL;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class NSURLQueryItem extends NSObject implements NSSecureCoding, NSCopying {
	name: string;
	value: string;
	constructor(name: string, value: string);
	constructor();
	initWithNameValue(name: string, value: string): NSURLQueryItem;
	static queryItemWithNameValue(name: string, value: string): NSURLQueryItem;
	init(): NSURLQueryItem;
	static new(): NSURLQueryItem;
	static allocWithZone(zone: any): NSURLQueryItem;
	static alloc(): NSURLQueryItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSURLComponents extends NSObject implements NSCopying {
	URL: NSURL;
	string: string;
	scheme: string;
	user: string;
	password: string;
	host: string;
	port: NSNumber;
	path: string;
	query: string;
	fragment: string;
	percentEncodedUser: string;
	percentEncodedPassword: string;
	percentEncodedHost: string;
	percentEncodedPath: string;
	percentEncodedQuery: string;
	percentEncodedFragment: string;
	queryItems: NSArray;
	constructor(url: NSURL, resolve: boolean);
	constructor(URLString: string);
	constructor();
	initWithURLResolvingAgainstBaseURL(url: NSURL, resolve: boolean): NSURLComponents;
	static componentsWithURLResolvingAgainstBaseURL(url: NSURL, resolve: boolean): NSURLComponents;
	initWithString(URLString: string): NSURLComponents;
	static componentsWithString(URLString: string): NSURLComponents;
	URLRelativeToURL(baseURL: NSURL): NSURL;
	init(): NSURLComponents;
	static new(): NSURLComponents;
	static allocWithZone(zone: any): NSURLComponents;
	static alloc(): NSURLComponents;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class NSFileSecurity extends NSObject implements NSCopying, NSCoding {
	constructor();
	init(): NSFileSecurity;
	static new(): NSFileSecurity;
	static allocWithZone(zone: any): NSFileSecurity;
	static alloc(): NSFileSecurity;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSURLAuthenticationChallenge extends NSObject implements NSSecureCoding {
	protectionSpace: NSURLProtectionSpace;
	proposedCredential: NSURLCredential;
	previousFailureCount: number;
	failureResponse: NSURLResponse;
	error: NSError;
	sender: any;
	constructor(space: NSURLProtectionSpace, credential: NSURLCredential, previousFailureCount: number, response: NSURLResponse, error: NSError, sender: any);
	constructor(challenge: NSURLAuthenticationChallenge, sender: any);
	constructor();
	initWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender(space: NSURLProtectionSpace, credential: NSURLCredential, previousFailureCount: number, response: NSURLResponse, error: NSError, sender: any): NSURLAuthenticationChallenge;
	initWithAuthenticationChallengeSender(challenge: NSURLAuthenticationChallenge, sender: any): NSURLAuthenticationChallenge;
	init(): NSURLAuthenticationChallenge;
	static new(): NSURLAuthenticationChallenge;
	static allocWithZone(zone: any): NSURLAuthenticationChallenge;
	static alloc(): NSURLAuthenticationChallenge;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSCachedURLResponse extends NSObject implements NSSecureCoding, NSCopying {
	response: NSURLResponse;
	data: NSData;
	userInfo: NSDictionary;
	storagePolicy: number;
	constructor(response: NSURLResponse, data: NSData);
	constructor(response: NSURLResponse, data: NSData, userInfo: NSDictionary, storagePolicy: number);
	constructor();
	initWithResponseData(response: NSURLResponse, data: NSData): NSCachedURLResponse;
	initWithResponseDataUserInfoStoragePolicy(response: NSURLResponse, data: NSData, userInfo: NSDictionary, storagePolicy: number): NSCachedURLResponse;
	init(): NSCachedURLResponse;
	static new(): NSCachedURLResponse;
	static allocWithZone(zone: any): NSCachedURLResponse;
	static alloc(): NSCachedURLResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSURLCache extends NSObject {
	memoryCapacity: number;
	diskCapacity: number;
	currentMemoryUsage: number;
	currentDiskUsage: number;
	constructor(memoryCapacity: number, diskCapacity: number, path: string);
	constructor();
	static sharedURLCache(): NSURLCache;
	static setSharedURLCache(cache: NSURLCache): void;
	initWithMemoryCapacityDiskCapacityDiskPath(memoryCapacity: number, diskCapacity: number, path: string): NSURLCache;
	cachedResponseForRequest(request: NSURLRequest): NSCachedURLResponse;
	storeCachedResponseForRequest(cachedResponse: NSCachedURLResponse, request: NSURLRequest): void;
	removeCachedResponseForRequest(request: NSURLRequest): void;
	removeAllCachedResponses(): void;
	removeCachedResponsesSinceDate(date: NSDate): void;
	storeCachedResponseForDataTask(cachedResponse: NSCachedURLResponse, dataTask: NSURLSessionDataTask): void;
	getCachedResponseForDataTaskCompletionHandler(dataTask: NSURLSessionDataTask, completionHandler: (arg1: NSCachedURLResponse) => void): void;
	removeCachedResponseForDataTask(dataTask: NSURLSessionDataTask): void;
	init(): NSURLCache;
	static new(): NSURLCache;
	static allocWithZone(zone: any): NSURLCache;
	static alloc(): NSURLCache;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLConnection extends NSObject {
	originalRequest: NSURLRequest;
	currentRequest: NSURLRequest;
	newsstandAssetDownload: any;
	constructor(request: NSURLRequest, delegate: any, startImmediately: boolean);
	constructor(request: NSURLRequest, delegate: any);
	constructor();
	initWithRequestDelegateStartImmediately(request: NSURLRequest, delegate: any, startImmediately: boolean): NSURLConnection;
	initWithRequestDelegate(request: NSURLRequest, delegate: any): NSURLConnection;
	static connectionWithRequestDelegate(request: NSURLRequest, delegate: any): NSURLConnection;
	start(): void;
	cancel(): void;
	scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	unscheduleFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	setDelegateQueue(queue: NSOperationQueue): void;
	static canHandleRequest(request: NSURLRequest): boolean;
	static sendSynchronousRequestReturningResponseError(request: NSURLRequest, response: any, error: any): NSData;
	static sendAsynchronousRequestQueueCompletionHandler(request: NSURLRequest, queue: NSOperationQueue, handler: (arg1: NSURLResponse, arg2: NSData, arg3: NSError) => void): void;
	init(): NSURLConnection;
	static new(): NSURLConnection;
	static allocWithZone(zone: any): NSURLConnection;
	static alloc(): NSURLConnection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLCredential extends NSObject implements NSSecureCoding, NSCopying {
	persistence: number;
	user: string;
	password: string;
	hasPassword: boolean;
	identity: any;
	certificates: NSArray;
	constructor(user: string, password: string, persistence: number);
	constructor(identity: any, certArray: NSArray, persistence: number);
	constructor(trust: any);
	constructor();
	initWithUserPasswordPersistence(user: string, password: string, persistence: number): NSURLCredential;
	static credentialWithUserPasswordPersistence(user: string, password: string, persistence: number): NSURLCredential;
	initWithIdentityCertificatesPersistence(identity: any, certArray: NSArray, persistence: number): NSURLCredential;
	static credentialWithIdentityCertificatesPersistence(identity: any, certArray: NSArray, persistence: number): NSURLCredential;
	initWithTrust(trust: any): NSURLCredential;
	static credentialForTrust(trust: any): NSURLCredential;
	init(): NSURLCredential;
	static new(): NSURLCredential;
	static allocWithZone(zone: any): NSURLCredential;
	static alloc(): NSURLCredential;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSURLCredentialStorage extends NSObject {
	allCredentials: NSDictionary;
	constructor();
	static sharedCredentialStorage(): NSURLCredentialStorage;
	credentialsForProtectionSpace(space: NSURLProtectionSpace): NSDictionary;
	setCredentialForProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
	removeCredentialForProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
	removeCredentialForProtectionSpaceOptions(credential: NSURLCredential, space: NSURLProtectionSpace, options: NSDictionary): void;
	defaultCredentialForProtectionSpace(space: NSURLProtectionSpace): NSURLCredential;
	setDefaultCredentialForProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;
	getCredentialsForProtectionSpaceTaskCompletionHandler(protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: (arg1: NSDictionary) => void): void;
	setCredentialForProtectionSpaceTask(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;
	removeCredentialForProtectionSpaceOptionsTask(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, options: NSDictionary, task: NSURLSessionTask): void;
	getDefaultCredentialForProtectionSpaceTaskCompletionHandler(space: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: (arg1: NSURLCredential) => void): void;
	setDefaultCredentialForProtectionSpaceTask(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;
	init(): NSURLCredentialStorage;
	static new(): NSURLCredentialStorage;
	static allocWithZone(zone: any): NSURLCredentialStorage;
	static alloc(): NSURLCredentialStorage;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLProtectionSpace extends NSObject implements NSSecureCoding, NSCopying {
	realm: string;
	receivesCredentialSecurely: boolean;
	isProxyProperty: boolean;
	host: string;
	port: number;
	proxyType: string;
	protocol: string;
	authenticationMethod: string;
	distinguishedNames: NSArray;
	serverTrust: any;
	constructor();
	initWithHostPortProtocolRealmAuthenticationMethod(host: string, port: number, protocol: string, realm: string, authenticationMethod: string): NSURLProtectionSpace;
	initWithProxyHostPortTypeRealmAuthenticationMethod(host: string, port: number, type: string, realm: string, authenticationMethod: string): NSURLProtectionSpace;
	init(): NSURLProtectionSpace;
	static new(): NSURLProtectionSpace;
	static allocWithZone(zone: any): NSURLProtectionSpace;
	static alloc(): NSURLProtectionSpace;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSURLProtocol extends NSObject {
	client: any;
	request: NSURLRequest;
	cachedResponse: NSCachedURLResponse;
	task: NSURLSessionTask;
	constructor(request: NSURLRequest, cachedResponse: NSCachedURLResponse, client: any);
	constructor(task: NSURLSessionTask, cachedResponse: NSCachedURLResponse, client: any);
	constructor();
	initWithRequestCachedResponseClient(request: NSURLRequest, cachedResponse: NSCachedURLResponse, client: any): NSURLProtocol;
	static canInitWithRequest(request: NSURLRequest): boolean;
	static canonicalRequestForRequest(request: NSURLRequest): NSURLRequest;
	static requestIsCacheEquivalentToRequest(a: NSURLRequest, b: NSURLRequest): boolean;
	startLoading(): void;
	stopLoading(): void;
	static propertyForKeyInRequest(key: string, request: NSURLRequest): any;
	static setPropertyForKeyInRequest(value: any, key: string, request: NSMutableURLRequest): void;
	static removePropertyForKeyInRequest(key: string, request: NSMutableURLRequest): void;
	static registerClass(protocolClass: any): boolean;
	static unregisterClass(protocolClass: any): void;
	static canInitWithTask(task: NSURLSessionTask): boolean;
	initWithTaskCachedResponseClient(task: NSURLSessionTask, cachedResponse: NSCachedURLResponse, client: any): NSURLProtocol;
	init(): NSURLProtocol;
	static new(): NSURLProtocol;
	static allocWithZone(zone: any): NSURLProtocol;
	static alloc(): NSURLProtocol;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLRequest extends NSObject implements NSSecureCoding, NSCopying, NSMutableCopying {
	URL: NSURL;
	cachePolicy: number;
	timeoutInterval: number;
	mainDocumentURL: NSURL;
	networkServiceType: number;
	allowsCellularAccess: boolean;
	HTTPMethod: string;
	allHTTPHeaderFields: NSDictionary;
	HTTPBody: NSData;
	HTTPBodyStream: NSInputStream;
	HTTPShouldHandleCookies: boolean;
	HTTPShouldUsePipelining: boolean;
	constructor(URL: NSURL);
	constructor(URL: NSURL, cachePolicy: number, timeoutInterval: number);
	constructor();
	static requestWithURL(URL: NSURL): NSURLRequest;
	static requestWithURLCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: number, timeoutInterval: number): NSURLRequest;
	initWithURL(URL: NSURL): NSURLRequest;
	initWithURLCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: number, timeoutInterval: number): NSURLRequest;
	valueForHTTPHeaderField(field: string): string;
	init(): NSURLRequest;
	static new(): NSURLRequest;
	static allocWithZone(zone: any): NSURLRequest;
	static alloc(): NSURLRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class NSMutableURLRequest extends NSURLRequest {
	URL: NSURL;
	cachePolicy: number;
	timeoutInterval: number;
	mainDocumentURL: NSURL;
	networkServiceType: number;
	allowsCellularAccess: boolean;
	HTTPMethod: string;
	allHTTPHeaderFields: NSDictionary;
	HTTPBody: NSData;
	HTTPBodyStream: NSInputStream;
	HTTPShouldHandleCookies: boolean;
	HTTPShouldUsePipelining: boolean;
	constructor(URL: NSURL);
	constructor(URL: NSURL, cachePolicy: number, timeoutInterval: number);
	constructor();
	setValueForHTTPHeaderField(value: string, field: string): void;
	addValueForHTTPHeaderField(value: string, field: string): void;
	static requestWithURL(URL: NSURL): NSMutableURLRequest;
	static requestWithURLCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: number, timeoutInterval: number): NSMutableURLRequest;
	initWithURL(URL: NSURL): NSMutableURLRequest;
	initWithURLCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: number, timeoutInterval: number): NSMutableURLRequest;
	init(): NSMutableURLRequest;
	static new(): NSMutableURLRequest;
	static allocWithZone(zone: any): NSMutableURLRequest;
	static alloc(): NSMutableURLRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLResponse extends NSObject implements NSSecureCoding, NSCopying {
	URL: NSURL;
	MIMEType: string;
	expectedContentLength: number;
	textEncodingName: string;
	suggestedFilename: string;
	constructor(URL: NSURL, MIMEType: string, length: number, name: string);
	constructor();
	initWithURLMIMETypeExpectedContentLengthTextEncodingName(URL: NSURL, MIMEType: string, length: number, name: string): NSURLResponse;
	init(): NSURLResponse;
	static new(): NSURLResponse;
	static allocWithZone(zone: any): NSURLResponse;
	static alloc(): NSURLResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSHTTPURLResponse extends NSURLResponse {
	statusCode: number;
	allHeaderFields: NSDictionary;
	constructor(url: NSURL, statusCode: number, HTTPVersion: string, headerFields: NSDictionary);
	constructor(URL: NSURL, MIMEType: string, length: number, name: string);
	constructor();
	initWithURLStatusCodeHTTPVersionHeaderFields(url: NSURL, statusCode: number, HTTPVersion: string, headerFields: NSDictionary): NSHTTPURLResponse;
	static localizedStringForStatusCode(statusCode: number): string;
	initWithURLMIMETypeExpectedContentLengthTextEncodingName(URL: NSURL, MIMEType: string, length: number, name: string): NSHTTPURLResponse;
	init(): NSHTTPURLResponse;
	static new(): NSHTTPURLResponse;
	static allocWithZone(zone: any): NSHTTPURLResponse;
	static alloc(): NSHTTPURLResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSUserDefaults extends NSObject {
	volatileDomainNames: NSArray;
	constructor();
	static standardUserDefaults(): NSUserDefaults;
	static resetStandardUserDefaults(): void;
	initWithSuiteName(suitename: string): NSUserDefaults;
	initWithUser(username: string): NSUserDefaults;
	objectForKey(defaultName: string): any;
	setObjectForKey(value: any, defaultName: string): void;
	removeObjectForKey(defaultName: string): void;
	stringForKey(defaultName: string): string;
	arrayForKey(defaultName: string): NSArray;
	dictionaryForKey(defaultName: string): NSDictionary;
	dataForKey(defaultName: string): NSData;
	stringArrayForKey(defaultName: string): NSArray;
	integerForKey(defaultName: string): number;
	floatForKey(defaultName: string): number;
	doubleForKey(defaultName: string): number;
	boolForKey(defaultName: string): boolean;
	URLForKey(defaultName: string): NSURL;
	setIntegerForKey(value: number, defaultName: string): void;
	setFloatForKey(value: number, defaultName: string): void;
	setDoubleForKey(value: number, defaultName: string): void;
	setBoolForKey(value: boolean, defaultName: string): void;
	setURLForKey(url: NSURL, defaultName: string): void;
	registerDefaults(registrationDictionary: NSDictionary): void;
	addSuiteNamed(suiteName: string): void;
	removeSuiteNamed(suiteName: string): void;
	dictionaryRepresentation(): NSDictionary;
	volatileDomainForName(domainName: string): NSDictionary;
	setVolatileDomainForName(domain: NSDictionary, domainName: string): void;
	removeVolatileDomainForName(domainName: string): void;
	persistentDomainNames(): NSArray;
	persistentDomainForName(domainName: string): NSDictionary;
	setPersistentDomainForName(domain: NSDictionary, domainName: string): void;
	removePersistentDomainForName(domainName: string): void;
	synchronize(): boolean;
	objectIsForcedForKey(key: string): boolean;
	objectIsForcedForKeyInDomain(key: string, domain: string): boolean;
	init(): NSUserDefaults;
	static new(): NSUserDefaults;
	static allocWithZone(zone: any): NSUserDefaults;
	static alloc(): NSUserDefaults;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSValueTransformer extends NSObject {
	constructor();
	static setValueTransformerForName(transformer: NSValueTransformer, name: string): void;
	static valueTransformerForName(name: string): NSValueTransformer;
	static valueTransformerNames(): NSArray;
	static transformedValueClass(): any;
	static allowsReverseTransformation(): boolean;
	transformedValue(value: any): any;
	reverseTransformedValue(value: any): any;
	init(): NSValueTransformer;
	static new(): NSValueTransformer;
	static allocWithZone(zone: any): NSValueTransformer;
	static alloc(): NSValueTransformer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSXMLParser extends NSObject {
	delegate: any;
	shouldProcessNamespaces: boolean;
	shouldReportNamespacePrefixes: boolean;
	externalEntityResolvingPolicy: number;
	allowedExternalEntityURLs: NSSet;
	parserError: NSError;
	shouldResolveExternalEntities: boolean;
	publicID: string;
	systemID: string;
	lineNumber: number;
	columnNumber: number;
	constructor(url: NSURL);
	constructor(data: NSData);
	constructor(stream: NSInputStream);
	constructor();
	initWithContentsOfURL(url: NSURL): NSXMLParser;
	initWithData(data: NSData): NSXMLParser;
	initWithStream(stream: NSInputStream): NSXMLParser;
	parse(): boolean;
	abortParsing(): void;
	init(): NSXMLParser;
	static new(): NSXMLParser;
	static allocWithZone(zone: any): NSXMLParser;
	static alloc(): NSXMLParser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSAttributedString extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
	string: string;
	length: number;
	constructor(str: string);
	constructor(str: string, attrs: NSDictionary);
	constructor(attrStr: NSAttributedString);
	constructor(url: NSURL, options: NSDictionary, dict: any, error: any);
	constructor(data: NSData, options: NSDictionary, dict: any, error: any);
	constructor();
	attributesAtIndexEffectiveRange(location: number, range: any): NSDictionary;
	attributeAtIndexEffectiveRange(attrName: string, location: number, range: any): any;
	attributedSubstringFromRange(range: NSRange): NSAttributedString;
	attributesAtIndexLongestEffectiveRangeInRange(location: number, range: any, rangeLimit: NSRange): NSDictionary;
	attributeAtIndexLongestEffectiveRangeInRange(attrName: string, location: number, range: any, rangeLimit: NSRange): any;
	isEqualToAttributedString(other: NSAttributedString): boolean;
	initWithString(str: string): NSAttributedString;
	initWithStringAttributes(str: string, attrs: NSDictionary): NSAttributedString;
	initWithAttributedString(attrStr: NSAttributedString): NSAttributedString;
	enumerateAttributesInRangeOptionsUsingBlock(enumerationRange: NSRange, opts: number, block: (arg1: NSDictionary, arg2: NSRange, arg3: any) => void): void;
	enumerateAttributeInRangeOptionsUsingBlock(attrName: string, enumerationRange: NSRange, opts: number, block: (arg1: any, arg2: NSRange, arg3: any) => void): void;
	initWithFileURLOptionsDocumentAttributesError(url: NSURL, options: NSDictionary, dict: any, error: any): NSAttributedString;
	initWithDataOptionsDocumentAttributesError(data: NSData, options: NSDictionary, dict: any, error: any): NSAttributedString;
	dataFromRangeDocumentAttributesError(range: NSRange, dict: NSDictionary, error: any): NSData;
	fileWrapperFromRangeDocumentAttributesError(range: NSRange, dict: NSDictionary, error: any): NSFileWrapper;
	size(): CGSize;
	drawAtPoint(point: CGPoint): void;
	drawInRect(rect: CGRect): void;
	drawWithRectOptionsContext(rect: CGRect, options: number, context: NSStringDrawingContext): void;
	boundingRectWithSizeOptionsContext(size: CGSize, options: number, context: NSStringDrawingContext): CGRect;
	static attributedStringWithAttachment(attachment: NSTextAttachment): NSAttributedString;
	init(): NSAttributedString;
	static new(): NSAttributedString;
	static allocWithZone(zone: any): NSAttributedString;
	static alloc(): NSAttributedString;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSMutableAttributedString extends NSAttributedString {
	mutableString: NSMutableString;
	constructor(str: string);
	constructor(str: string, attrs: NSDictionary);
	constructor(attrStr: NSAttributedString);
	constructor(url: NSURL, options: NSDictionary, dict: any, error: any);
	constructor(data: NSData, options: NSDictionary, dict: any, error: any);
	constructor();
	replaceCharactersInRangeWithString(range: NSRange, str: string): void;
	setAttributesRange(attrs: NSDictionary, range: NSRange): void;
	addAttributeValueRange(name: string, value: any, range: NSRange): void;
	addAttributesRange(attrs: NSDictionary, range: NSRange): void;
	removeAttributeRange(name: string, range: NSRange): void;
	replaceCharactersInRangeWithAttributedString(range: NSRange, attrString: NSAttributedString): void;
	insertAttributedStringAtIndex(attrString: NSAttributedString, loc: number): void;
	appendAttributedString(attrString: NSAttributedString): void;
	deleteCharactersInRange(range: NSRange): void;
	setAttributedString(attrString: NSAttributedString): void;
	beginEditing(): void;
	endEditing(): void;
	fixAttributesInRange(range: NSRange): void;
	readFromFileURLOptionsDocumentAttributesError(url: NSURL, opts: NSDictionary, dict: any, error: any): boolean;
	readFromDataOptionsDocumentAttributesError(data: NSData, opts: NSDictionary, dict: any, error: any): boolean;
	initWithString(str: string): NSMutableAttributedString;
	initWithStringAttributes(str: string, attrs: NSDictionary): NSMutableAttributedString;
	initWithAttributedString(attrStr: NSAttributedString): NSMutableAttributedString;
	initWithFileURLOptionsDocumentAttributesError(url: NSURL, options: NSDictionary, dict: any, error: any): NSMutableAttributedString;
	initWithDataOptionsDocumentAttributesError(data: NSData, options: NSDictionary, dict: any, error: any): NSMutableAttributedString;
	init(): NSMutableAttributedString;
	static new(): NSMutableAttributedString;
	static allocWithZone(zone: any): NSMutableAttributedString;
	static alloc(): NSMutableAttributedString;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSByteCountFormatter extends NSFormatter {
	allowedUnits: number;
	countStyle: number;
	allowsNonnumericFormatting: boolean;
	includesUnit: boolean;
	includesCount: boolean;
	includesActualByteCount: boolean;
	adaptive: boolean;
	zeroPadsFractionDigits: boolean;
	formattingContext: number;
	constructor();
	static stringFromByteCountCountStyle(byteCount: number, countStyle: number): NSByteCountFormatter;
	stringFromByteCount(byteCount: number): string;
	init(): NSByteCountFormatter;
	static new(): NSByteCountFormatter;
	static allocWithZone(zone: any): NSByteCountFormatter;
	static alloc(): NSByteCountFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSCache extends NSObject {
	name: string;
	delegate: any;
	totalCostLimit: number;
	countLimit: number;
	evictsObjectsWithDiscardedContent: boolean;
	constructor();
	objectForKey(key: any): any;
	setObjectForKey(obj: any, key: any): void;
	setObjectForKeyCost(obj: any, key: any, g: number): void;
	removeObjectForKey(key: any): void;
	removeAllObjects(): void;
	init(): NSCache;
	static new(): NSCache;
	static allocWithZone(zone: any): NSCache;
	static alloc(): NSCache;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSPredicate extends NSObject implements NSSecureCoding, NSCopying {
	predicateFormat: string;
	constructor();
	static predicateWithFormatArgumentArray(predicateFormat: string, args: NSArray): NSPredicate;
	static predicateWithValue(value: boolean): NSPredicate;
	static predicateWithBlock(block: (arg1: any, arg2: NSDictionary) => boolean): NSPredicate;
	predicateWithSubstitutionVariables(variables: NSDictionary): NSPredicate;
	evaluateWithObject(object: any): boolean;
	evaluateWithObjectSubstitutionVariables(object: any, bindings: NSDictionary): boolean;
	allowEvaluation(): void;
	init(): NSPredicate;
	static new(): NSPredicate;
	static allocWithZone(zone: any): NSPredicate;
	static alloc(): NSPredicate;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSComparisonPredicate extends NSPredicate {
	predicateOperatorType: number;
	comparisonPredicateModifier: number;
	leftExpression: NSExpression;
	rightExpression: NSExpression;
	customSelector: any;
	options: number;
	constructor(lhs: NSExpression, rhs: NSExpression, modifier: number, type: number, options: number);
	constructor(lhs: NSExpression, rhs: NSExpression, selector: any);
	constructor();
	static predicateWithLeftExpressionRightExpressionModifierTypeOptions(lhs: NSExpression, rhs: NSExpression, modifier: number, type: number, options: number): NSComparisonPredicate;
	static predicateWithLeftExpressionRightExpressionCustomSelector(lhs: NSExpression, rhs: NSExpression, selector: any): NSComparisonPredicate;
	initWithLeftExpressionRightExpressionModifierTypeOptions(lhs: NSExpression, rhs: NSExpression, modifier: number, type: number, options: number): NSComparisonPredicate;
	initWithLeftExpressionRightExpressionCustomSelector(lhs: NSExpression, rhs: NSExpression, selector: any): NSComparisonPredicate;
	predicateWithSubstitutionVariables(variables: NSDictionary): NSComparisonPredicate;
	init(): NSComparisonPredicate;
	static new(): NSComparisonPredicate;
	static allocWithZone(zone: any): NSComparisonPredicate;
	static alloc(): NSComparisonPredicate;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSCompoundPredicate extends NSPredicate {
	compoundPredicateType: number;
	subpredicates: NSArray;
	constructor(type: number, subpredicates: NSArray);
	constructor();
	initWithTypeSubpredicates(type: number, subpredicates: NSArray): NSCompoundPredicate;
	static andPredicateWithSubpredicates(subpredicates: NSArray): NSCompoundPredicate;
	static orPredicateWithSubpredicates(subpredicates: NSArray): NSCompoundPredicate;
	static notPredicateWithSubpredicate(predicate: NSPredicate): NSCompoundPredicate;
	predicateWithSubstitutionVariables(variables: NSDictionary): NSCompoundPredicate;
	init(): NSCompoundPredicate;
	static new(): NSCompoundPredicate;
	static allocWithZone(zone: any): NSCompoundPredicate;
	static alloc(): NSCompoundPredicate;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSDateComponentsFormatter extends NSFormatter {
	unitsStyle: number;
	allowedUnits: number;
	zeroFormattingBehavior: number;
	calendar: NSCalendar;
	allowsFractionalUnits: boolean;
	maximumUnitCount: number;
	collapsesLargestUnit: boolean;
	includesApproximationPhrase: boolean;
	includesTimeRemainingPhrase: boolean;
	formattingContext: number;
	constructor();
	stringFromDateComponents(components: NSDateComponents): string;
	stringFromDateToDate(startDate: NSDate, endDate: NSDate): string;
	stringFromTimeInterval(ti: number): string;
	static localizedStringFromDateComponentsUnitsStyle(components: NSDateComponents, unitsStyle: number): string;
	init(): NSDateComponentsFormatter;
	static new(): NSDateComponentsFormatter;
	static allocWithZone(zone: any): NSDateComponentsFormatter;
	static alloc(): NSDateComponentsFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSExpression extends NSObject implements NSSecureCoding, NSCopying {
	expressionType: number;
	constantValue: any;
	keyPath: string;
	function: string;
	variable: string;
	operand: NSExpression;
	arguments: NSArray;
	collection: any;
	predicate: NSPredicate;
	leftExpression: NSExpression;
	rightExpression: NSExpression;
	expressionBlock: (arg1: any, arg2: NSArray, arg3: NSMutableDictionary) => any;
	constructor(type: number);
	constructor();
	static expressionWithFormatArgumentArray(expressionFormat: string, args: NSArray): NSExpression;
	static expressionForConstantValue(obj: any): NSExpression;
	static expressionForEvaluatedObject(): NSExpression;
	static expressionForVariable(string: string): NSExpression;
	static expressionForKeyPath(keyPath: string): NSExpression;
	static expressionForFunctionArguments(name: string, parameters: NSArray): NSExpression;
	static expressionForAggregate(subexpressions: NSArray): NSExpression;
	static expressionForUnionSetWith(left: NSExpression, right: NSExpression): NSExpression;
	static expressionForIntersectSetWith(left: NSExpression, right: NSExpression): NSExpression;
	static expressionForMinusSetWith(left: NSExpression, right: NSExpression): NSExpression;
	static expressionForSubqueryUsingIteratorVariablePredicate(expression: NSExpression, variable: string, predicate: any): NSExpression;
	static expressionForFunctionSelectorNameArguments(target: NSExpression, name: string, parameters: NSArray): NSExpression;
	static expressionForAnyKey(): NSExpression;
	static expressionForBlockArguments(block: (arg1: any, arg2: NSArray, arg3: NSMutableDictionary) => any, args: NSArray): NSExpression;
	initWithExpressionType(type: number): NSExpression;
	expressionValueWithObjectContext(object: any, context: NSMutableDictionary): any;
	allowEvaluation(): void;
	init(): NSExpression;
	static new(): NSExpression;
	static allocWithZone(zone: any): NSExpression;
	static alloc(): NSExpression;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NSExtensionContext extends NSObject {
	inputItems: NSArray;
	constructor();
	completeRequestReturningItemsCompletionHandler(items: NSArray, completionHandler: (arg1: boolean) => void): void;
	cancelRequestWithError(error: NSError): void;
	openURLCompletionHandler(URL: NSURL, completionHandler: (arg1: boolean) => void): void;
	init(): NSExtensionContext;
	static new(): NSExtensionContext;
	static allocWithZone(zone: any): NSExtensionContext;
	static alloc(): NSExtensionContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSItemProvider extends NSObject implements NSCopying {
	registeredTypeIdentifiers: NSArray;
	previewImageHandler: (arg1: (arg1: any, arg2: NSError) => void, arg2: any, arg3: NSDictionary) => void;
	constructor(item: any, typeIdentifier: string);
	constructor(fileURL: NSURL);
	constructor();
	initWithItemTypeIdentifier(item: any, typeIdentifier: string): NSItemProvider;
	initWithContentsOfURL(fileURL: NSURL): NSItemProvider;
	registerItemForTypeIdentifierLoadHandler(typeIdentifier: string, loadHandler: (arg1: (arg1: any, arg2: NSError) => void, arg2: any, arg3: NSDictionary) => void): void;
	hasItemConformingToTypeIdentifier(typeIdentifier: string): boolean;
	loadItemForTypeIdentifierOptionsCompletionHandler(typeIdentifier: string, options: NSDictionary, completionHandler: (arg1: any, arg2: NSError) => void): void;
	loadPreviewImageWithOptionsCompletionHandler(options: NSDictionary, completionHandler: (arg1: any, arg2: NSError) => void): void;
	init(): NSItemProvider;
	static new(): NSItemProvider;
	static allocWithZone(zone: any): NSItemProvider;
	static alloc(): NSItemProvider;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class NSExtensionItem extends NSObject implements NSCopying, NSSecureCoding {
	attributedTitle: NSAttributedString;
	attributedContentText: NSAttributedString;
	attachments: NSArray;
	userInfo: NSDictionary;
	constructor();
	init(): NSExtensionItem;
	static new(): NSExtensionItem;
	static allocWithZone(zone: any): NSExtensionItem;
	static alloc(): NSExtensionItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSFileAccessIntent extends NSObject {
	URL: NSURL;
	constructor();
	static readingIntentWithURLOptions(url: NSURL, options: number): NSFileAccessIntent;
	static writingIntentWithURLOptions(url: NSURL, options: number): NSFileAccessIntent;
	init(): NSFileAccessIntent;
	static new(): NSFileAccessIntent;
	static allocWithZone(zone: any): NSFileAccessIntent;
	static alloc(): NSFileAccessIntent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSFileCoordinator extends NSObject {
	purposeIdentifier: string;
	constructor(filePresenterOrNil: any);
	constructor();
	static addFilePresenter(filePresenter: any): void;
	static removeFilePresenter(filePresenter: any): void;
	static filePresenters(): NSArray;
	initWithFilePresenter(filePresenterOrNil: any): NSFileCoordinator;
	coordinateAccessWithIntentsQueueByAccessor(intents: NSArray, queue: NSOperationQueue, accessor: (arg1: NSError) => void): void;
	coordinateReadingItemAtURLOptionsErrorByAccessor(url: NSURL, options: number, outError: any, reader: (arg1: NSURL) => void): void;
	coordinateWritingItemAtURLOptionsErrorByAccessor(url: NSURL, options: number, outError: any, writer: (arg1: NSURL) => void): void;
	coordinateReadingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor(readingURL: NSURL, readingOptions: number, writingURL: NSURL, writingOptions: number, outError: any, readerWriter: (arg1: NSURL, arg2: NSURL) => void): void;
	coordinateWritingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor(url1: NSURL, options1: number, url2: NSURL, options2: number, outError: any, writer: (arg1: NSURL, arg2: NSURL) => void): void;
	prepareForReadingItemsAtURLsOptionsWritingItemsAtURLsOptionsErrorByAccessor(readingURLs: NSArray, readingOptions: number, writingURLs: NSArray, writingOptions: number, outError: any, batchAccessor: (arg1: () => void) => void): void;
	itemAtURLWillMoveToURL(oldURL: NSURL, newURL: NSURL): void;
	itemAtURLDidMoveToURL(oldURL: NSURL, newURL: NSURL): void;
	cancel(): void;
	init(): NSFileCoordinator;
	static new(): NSFileCoordinator;
	static allocWithZone(zone: any): NSFileCoordinator;
	static alloc(): NSFileCoordinator;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSFileVersion extends NSObject {
	URL: NSURL;
	localizedName: string;
	localizedNameOfSavingComputer: string;
	modificationDate: NSDate;
	persistentIdentifier: any;
	conflict: boolean;
	resolved: boolean;
	hasLocalContents: boolean;
	hasThumbnail: boolean;
	constructor();
	static currentVersionOfItemAtURL(url: NSURL): NSFileVersion;
	static otherVersionsOfItemAtURL(url: NSURL): NSArray;
	static unresolvedConflictVersionsOfItemAtURL(url: NSURL): NSArray;
	static getNonlocalVersionsOfItemAtURLCompletionHandler(url: NSURL, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	static versionOfItemAtURLForPersistentIdentifier(url: NSURL, persistentIdentifier: any): NSFileVersion;
	replaceItemAtURLOptionsError(url: NSURL, options: number, error: any): NSURL;
	removeAndReturnError(outError: any): boolean;
	static removeOtherVersionsOfItemAtURLError(url: NSURL, outError: any): boolean;
	init(): NSFileVersion;
	static new(): NSFileVersion;
	static allocWithZone(zone: any): NSFileVersion;
	static alloc(): NSFileVersion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSFileWrapper extends NSObject implements NSCoding {
	directory: boolean;
	regularFile: boolean;
	symbolicLink: boolean;
	preferredFilename: string;
	filename: string;
	fileAttributes: NSDictionary;
	serializedRepresentation: NSData;
	fileWrappers: NSDictionary;
	regularFileContents: NSData;
	symbolicLinkDestinationURL: NSURL;
	constructor(url: NSURL, options: number, outError: any);
	constructor(childrenByPreferredName: NSDictionary);
	constructor(url: NSURL);
	constructor();
	initWithURLOptionsError(url: NSURL, options: number, outError: any): NSFileWrapper;
	initDirectoryWithFileWrappers(childrenByPreferredName: NSDictionary): NSFileWrapper;
	initRegularFileWithContents(contents: NSData): NSFileWrapper;
	initSymbolicLinkWithDestinationURL(url: NSURL): NSFileWrapper;
	initWithSerializedRepresentation(serializeRepresentation: NSData): NSFileWrapper;
	matchesContentsOfURL(url: NSURL): boolean;
	readFromURLOptionsError(url: NSURL, options: number, outError: any): boolean;
	writeToURLOptionsOriginalContentsURLError(url: NSURL, options: number, originalContentsURL: NSURL, outError: any): boolean;
	addFileWrapper(child: NSFileWrapper): string;
	addRegularFileWithContentsPreferredFilename(data: NSData, fileName: string): string;
	removeFileWrapper(child: NSFileWrapper): void;
	keyForFileWrapper(child: NSFileWrapper): string;
	init(): NSFileWrapper;
	static new(): NSFileWrapper;
	static allocWithZone(zone: any): NSFileWrapper;
	static alloc(): NSFileWrapper;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSLinguisticTagger extends NSObject {
	tagSchemes: NSArray;
	string: string;
	constructor(tagSchemes: NSArray, opts: number);
	constructor();
	initWithTagSchemesOptions(tagSchemes: NSArray, opts: number): NSLinguisticTagger;
	static availableTagSchemesForLanguage(language: string): NSArray;
	setOrthographyRange(orthography: NSOrthography, range: NSRange): void;
	orthographyAtIndexEffectiveRange(charIndex: number, effectiveRange: any): NSOrthography;
	stringEditedInRangeChangeInLength(newRange: NSRange, delta: number): void;
	enumerateTagsInRangeSchemeOptionsUsingBlock(range: NSRange, tagScheme: string, opts: number, block: (arg1: string, arg2: NSRange, arg3: NSRange, arg4: any) => void): void;
	sentenceRangeForRange(range: NSRange): NSRange;
	tagAtIndexSchemeTokenRangeSentenceRange(charIndex: number, tagScheme: string, tokenRange: any, sentenceRange: any): string;
	tagsInRangeSchemeOptionsTokenRanges(range: NSRange, tagScheme: string, opts: number, tokenRanges: any): NSArray;
	possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores(charIndex: number, tagScheme: string, tokenRange: any, sentenceRange: any, scores: any): NSArray;
	init(): NSLinguisticTagger;
	static new(): NSLinguisticTagger;
	static allocWithZone(zone: any): NSLinguisticTagger;
	static alloc(): NSLinguisticTagger;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSMetadataQuery extends NSObject {
	delegate: any;
	predicate: NSPredicate;
	sortDescriptors: NSArray;
	valueListAttributes: NSArray;
	groupingAttributes: NSArray;
	notificationBatchingInterval: number;
	searchScopes: NSArray;
	searchItems: NSArray;
	operationQueue: NSOperationQueue;
	started: boolean;
	gathering: boolean;
	stopped: boolean;
	resultCount: number;
	results: NSArray;
	valueLists: NSDictionary;
	groupedResults: NSArray;
	constructor();
	startQuery(): boolean;
	stopQuery(): void;
	disableUpdates(): void;
	enableUpdates(): void;
	resultAtIndex(idx: number): any;
	enumerateResultsUsingBlock(block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateResultsWithOptionsUsingBlock(opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	indexOfResult(result: any): number;
	valueOfAttributeForResultAtIndex(attrName: string, idx: number): any;
	init(): NSMetadataQuery;
	static new(): NSMetadataQuery;
	static allocWithZone(zone: any): NSMetadataQuery;
	static alloc(): NSMetadataQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSMetadataItem extends NSObject {
	attributes: NSArray;
	constructor();
	valueForAttribute(key: string): any;
	valuesForAttributes(keys: NSArray): NSDictionary;
	init(): NSMetadataItem;
	static new(): NSMetadataItem;
	static allocWithZone(zone: any): NSMetadataItem;
	static alloc(): NSMetadataItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSMetadataQueryAttributeValueTuple extends NSObject {
	attribute: string;
	value: any;
	count: number;
	constructor();
	init(): NSMetadataQueryAttributeValueTuple;
	static new(): NSMetadataQueryAttributeValueTuple;
	static allocWithZone(zone: any): NSMetadataQueryAttributeValueTuple;
	static alloc(): NSMetadataQueryAttributeValueTuple;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSMetadataQueryResultGroup extends NSObject {
	attribute: string;
	value: any;
	subgroups: NSArray;
	resultCount: number;
	results: NSArray;
	constructor();
	resultAtIndex(idx: number): any;
	init(): NSMetadataQueryResultGroup;
	static new(): NSMetadataQueryResultGroup;
	static allocWithZone(zone: any): NSMetadataQueryResultGroup;
	static alloc(): NSMetadataQueryResultGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSNetService extends NSObject {
	delegate: any;
	includesPeerToPeer: boolean;
	name: string;
	type: string;
	domain: string;
	hostName: string;
	addresses: NSArray;
	port: number;
	constructor(domain: string, type: string, name: string, port: number);
	constructor(domain: string, type: string, name: string);
	constructor();
	initWithDomainTypeNamePort(domain: string, type: string, name: string, port: number): NSNetService;
	initWithDomainTypeName(domain: string, type: string, name: string): NSNetService;
	scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	publish(): void;
	publishWithOptions(options: number): void;
	resolve(): void;
	stop(): void;
	static dictionaryFromTXTRecordData(txtData: NSData): NSDictionary;
	static dataFromTXTRecordDictionary(txtDictionary: NSDictionary): NSData;
	resolveWithTimeout(timeout: number): void;
	getInputStreamOutputStream(inputStream: any, outputStream: any): boolean;
	setTXTRecordData(recordData: NSData): boolean;
	TXTRecordData(): NSData;
	startMonitoring(): void;
	stopMonitoring(): void;
	init(): NSNetService;
	static new(): NSNetService;
	static allocWithZone(zone: any): NSNetService;
	static alloc(): NSNetService;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSNetServiceBrowser extends NSObject {
	delegate: any;
	includesPeerToPeer: boolean;
	constructor();
	scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;
	searchForBrowsableDomains(): void;
	searchForRegistrationDomains(): void;
	searchForServicesOfTypeInDomain(type: string, domainString: string): void;
	stop(): void;
	init(): NSNetServiceBrowser;
	static new(): NSNetServiceBrowser;
	static allocWithZone(zone: any): NSNetServiceBrowser;
	static alloc(): NSNetServiceBrowser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSProgress extends NSObject {
	totalUnitCount: number;
	completedUnitCount: number;
	localizedDescription: string;
	localizedAdditionalDescription: string;
	cancellable: boolean;
	pausable: boolean;
	cancelled: boolean;
	paused: boolean;
	cancellationHandler: () => void;
	pausingHandler: () => void;
	indeterminate: boolean;
	fractionCompleted: number;
	userInfo: NSDictionary;
	kind: string;
	constructor(parentProgressOrNil: NSProgress, userInfoOrNil: NSDictionary);
	constructor();
	static currentProgress(): NSProgress;
	static progressWithTotalUnitCount(unitCount: number): NSProgress;
	initWithParentUserInfo(parentProgressOrNil: NSProgress, userInfoOrNil: NSDictionary): NSProgress;
	becomeCurrentWithPendingUnitCount(unitCount: number): void;
	resignCurrent(): void;
	setUserInfoObjectForKey(objectOrNil: any, key: string): void;
	cancel(): void;
	pause(): void;
	init(): NSProgress;
	static new(): NSProgress;
	static allocWithZone(zone: any): NSProgress;
	static alloc(): NSProgress;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSUbiquitousKeyValueStore extends NSObject {
	dictionaryRepresentation: NSDictionary;
	constructor();
	static defaultStore(): NSUbiquitousKeyValueStore;
	objectForKey(aKey: string): any;
	setObjectForKey(anObject: any, aKey: string): void;
	removeObjectForKey(aKey: string): void;
	stringForKey(aKey: string): string;
	arrayForKey(aKey: string): NSArray;
	dictionaryForKey(aKey: string): NSDictionary;
	dataForKey(aKey: string): NSData;
	longLongForKey(aKey: string): number;
	doubleForKey(aKey: string): number;
	boolForKey(aKey: string): boolean;
	setStringForKey(aString: string, aKey: string): void;
	setDataForKey(aData: NSData, aKey: string): void;
	setArrayForKey(anArray: NSArray, aKey: string): void;
	setDictionaryForKey(aDictionary: NSDictionary, aKey: string): void;
	setLongLongForKey(value: number, aKey: string): void;
	setDoubleForKey(value: number, aKey: string): void;
	setBoolForKey(value: boolean, aKey: string): void;
	synchronize(): boolean;
	init(): NSUbiquitousKeyValueStore;
	static new(): NSUbiquitousKeyValueStore;
	static allocWithZone(zone: any): NSUbiquitousKeyValueStore;
	static alloc(): NSUbiquitousKeyValueStore;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSUndoManager extends NSObject {
	groupingLevel: number;
	undoRegistrationEnabled: boolean;
	groupsByEvent: boolean;
	levelsOfUndo: number;
	runLoopModes: NSArray;
	canUndo: boolean;
	canRedo: boolean;
	undoing: boolean;
	redoing: boolean;
	undoActionIsDiscardable: boolean;
	redoActionIsDiscardable: boolean;
	undoActionName: string;
	redoActionName: string;
	undoMenuItemTitle: string;
	redoMenuItemTitle: string;
	constructor();
	beginUndoGrouping(): void;
	endUndoGrouping(): void;
	disableUndoRegistration(): void;
	enableUndoRegistration(): void;
	undo(): void;
	redo(): void;
	undoNestedGroup(): void;
	removeAllActions(): void;
	removeAllActionsWithTarget(target: any): void;
	registerUndoWithTargetSelectorObject(target: any, selector: any, anObject: any): void;
	prepareWithInvocationTarget(target: any): any;
	setActionIsDiscardable(discardable: boolean): void;
	setActionName(actionName: string): void;
	undoMenuTitleForUndoActionName(actionName: string): string;
	redoMenuTitleForUndoActionName(actionName: string): string;
	init(): NSUndoManager;
	static new(): NSUndoManager;
	static allocWithZone(zone: any): NSUndoManager;
	static alloc(): NSUndoManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLSession extends NSObject {
	delegateQueue: NSOperationQueue;
	delegate: any;
	configuration: NSURLSessionConfiguration;
	sessionDescription: string;
	constructor();
	static sharedSession(): NSURLSession;
	static sessionWithConfiguration(configuration: NSURLSessionConfiguration): NSURLSession;
	static sessionWithConfigurationDelegateDelegateQueue(configuration: NSURLSessionConfiguration, delegate: any, queue: NSOperationQueue): NSURLSession;
	finishTasksAndInvalidate(): void;
	invalidateAndCancel(): void;
	resetWithCompletionHandler(completionHandler: () => void): void;
	flushWithCompletionHandler(completionHandler: () => void): void;
	getTasksWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSArray, arg3: NSArray) => void): void;
	dataTaskWithRequest(request: NSURLRequest): NSURLSessionDataTask;
	dataTaskWithURL(url: NSURL): NSURLSessionDataTask;
	uploadTaskWithRequestFromFile(request: NSURLRequest, fileURL: NSURL): NSURLSessionUploadTask;
	uploadTaskWithRequestFromData(request: NSURLRequest, bodyData: NSData): NSURLSessionUploadTask;
	uploadTaskWithStreamedRequest(request: NSURLRequest): NSURLSessionUploadTask;
	downloadTaskWithRequest(request: NSURLRequest): NSURLSessionDownloadTask;
	downloadTaskWithURL(url: NSURL): NSURLSessionDownloadTask;
	downloadTaskWithResumeData(resumeData: NSData): NSURLSessionDownloadTask;
	dataTaskWithRequestCompletionHandler(request: NSURLRequest, completionHandler: (arg1: NSData, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionDataTask;
	dataTaskWithURLCompletionHandler(url: NSURL, completionHandler: (arg1: NSData, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionDataTask;
	uploadTaskWithRequestFromFileCompletionHandler(request: NSURLRequest, fileURL: NSURL, completionHandler: (arg1: NSData, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionUploadTask;
	uploadTaskWithRequestFromDataCompletionHandler(request: NSURLRequest, bodyData: NSData, completionHandler: (arg1: NSData, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionUploadTask;
	downloadTaskWithRequestCompletionHandler(request: NSURLRequest, completionHandler: (arg1: NSURL, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionDownloadTask;
	downloadTaskWithURLCompletionHandler(url: NSURL, completionHandler: (arg1: NSURL, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionDownloadTask;
	downloadTaskWithResumeDataCompletionHandler(resumeData: NSData, completionHandler: (arg1: NSURL, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionDownloadTask;
	dataTaskWithHTTPGetRequest(url: NSURL): NSURLSessionDataTask;
	dataTaskWithHTTPGetRequestCompletionHandler(url: NSURL, completionHandler: (arg1: NSData, arg2: NSURLResponse, arg3: NSError) => void): NSURLSessionDataTask;
	init(): NSURLSession;
	static new(): NSURLSession;
	static allocWithZone(zone: any): NSURLSession;
	static alloc(): NSURLSession;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLSessionTask extends NSObject implements NSCopying {
	taskIdentifier: number;
	originalRequest: NSURLRequest;
	currentRequest: NSURLRequest;
	response: NSURLResponse;
	countOfBytesReceived: number;
	countOfBytesSent: number;
	countOfBytesExpectedToSend: number;
	countOfBytesExpectedToReceive: number;
	taskDescription: string;
	state: number;
	error: NSError;
	priority: number;
	constructor();
	cancel(): void;
	suspend(): void;
	resume(): void;
	init(): NSURLSessionTask;
	static new(): NSURLSessionTask;
	static allocWithZone(zone: any): NSURLSessionTask;
	static alloc(): NSURLSessionTask;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class NSURLSessionDataTask extends NSURLSessionTask {
	constructor();
	init(): NSURLSessionDataTask;
	static new(): NSURLSessionDataTask;
	static allocWithZone(zone: any): NSURLSessionDataTask;
	static alloc(): NSURLSessionDataTask;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLSessionUploadTask extends NSURLSessionDataTask {
	constructor();
	init(): NSURLSessionUploadTask;
	static new(): NSURLSessionUploadTask;
	static allocWithZone(zone: any): NSURLSessionUploadTask;
	static alloc(): NSURLSessionUploadTask;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLSessionDownloadTask extends NSURLSessionTask {
	constructor();
	cancelByProducingResumeData(completionHandler: (arg1: NSData) => void): void;
	init(): NSURLSessionDownloadTask;
	static new(): NSURLSessionDownloadTask;
	static allocWithZone(zone: any): NSURLSessionDownloadTask;
	static alloc(): NSURLSessionDownloadTask;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSURLSessionConfiguration extends NSObject implements NSCopying {
	identifier: string;
	requestCachePolicy: number;
	timeoutIntervalForRequest: number;
	timeoutIntervalForResource: number;
	networkServiceType: number;
	allowsCellularAccess: boolean;
	discretionary: boolean;
	sharedContainerIdentifier: string;
	sessionSendsLaunchEvents: boolean;
	connectionProxyDictionary: NSDictionary;
	TLSMinimumSupportedProtocol: number;
	TLSMaximumSupportedProtocol: number;
	HTTPShouldUsePipelining: boolean;
	HTTPShouldSetCookies: boolean;
	HTTPCookieAcceptPolicy: number;
	HTTPAdditionalHeaders: NSDictionary;
	HTTPMaximumConnectionsPerHost: number;
	HTTPCookieStorage: NSHTTPCookieStorage;
	URLCredentialStorage: NSURLCredentialStorage;
	URLCache: NSURLCache;
	protocolClasses: NSArray;
	constructor();
	static defaultSessionConfiguration(): NSURLSessionConfiguration;
	static ephemeralSessionConfiguration(): NSURLSessionConfiguration;
	static backgroundSessionConfigurationWithIdentifier(identifier: string): NSURLSessionConfiguration;
	static backgroundSessionConfiguration(identifier: string): NSURLSessionConfiguration;
	init(): NSURLSessionConfiguration;
	static new(): NSURLSessionConfiguration;
	static allocWithZone(zone: any): NSURLSessionConfiguration;
	static alloc(): NSURLSessionConfiguration;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class NSUserActivity extends NSObject {
	activityType: string;
	title: string;
	userInfo: NSDictionary;
	needsSave: boolean;
	webpageURL: NSURL;
	supportsContinuationStreams: boolean;
	delegate: any;
	constructor(activityType: string);
	constructor();
	initWithActivityType(activityType: string): NSUserActivity;
	addUserInfoEntriesFromDictionary(otherDictionary: NSDictionary): void;
	becomeCurrent(): void;
	invalidate(): void;
	getContinuationStreamsWithCompletionHandler(completionHandler: (arg1: NSInputStream, arg2: NSOutputStream, arg3: NSError) => void): void;
	init(): NSUserActivity;
	static new(): NSUserActivity;
	static allocWithZone(zone: any): NSUserActivity;
	static alloc(): NSUserActivity;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSUUID extends NSObject implements NSCopying, NSSecureCoding {
	UUIDString: string;
	constructor(string: string);
	constructor(bytes: number[]);
	constructor();
	static UUID(): NSUUID;
	initWithUUIDString(string: string): NSUUID;
	initWithUUIDBytes(bytes: number[]): NSUUID;
	getUUIDBytes(uuid: number[]): void;
	init(): NSUUID;
	static new(): NSUUID;
	static allocWithZone(zone: any): NSUUID;
	static alloc(): NSUUID;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class ACAccount extends NSObject {
	identifier: string;
	accountType: ACAccountType;
	accountDescription: string;
	username: string;
	userFullName: string;
	credential: ACAccountCredential;
	constructor(type: ACAccountType);
	constructor();
	initWithAccountType(type: ACAccountType): ACAccount;
	init(): ACAccount;
	static new(): ACAccount;
	static allocWithZone(zone: any): ACAccount;
	static alloc(): ACAccount;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ACAccountType extends NSObject {
	accountTypeDescription: string;
	identifier: string;
	accessGranted: boolean;
	constructor();
	init(): ACAccountType;
	static new(): ACAccountType;
	static allocWithZone(zone: any): ACAccountType;
	static alloc(): ACAccountType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ACAccountCredential extends NSObject {
	oauthToken: string;
	constructor(token: string, secret: string);
	constructor(token: string, refreshToken: string, expiryDate: NSDate);
	constructor();
	initWithOAuthTokenTokenSecret(token: string, secret: string): ACAccountCredential;
	initWithOAuth2TokenRefreshTokenExpiryDate(token: string, refreshToken: string, expiryDate: NSDate): ACAccountCredential;
	init(): ACAccountCredential;
	static new(): ACAccountCredential;
	static allocWithZone(zone: any): ACAccountCredential;
	static alloc(): ACAccountCredential;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ACAccountStore extends NSObject {
	accounts: NSArray;
	constructor();
	accountWithIdentifier(identifier: string): ACAccount;
	accountTypeWithAccountTypeIdentifier(typeIdentifier: string): ACAccountType;
	accountsWithAccountType(accountType: ACAccountType): NSArray;
	saveAccountWithCompletionHandler(account: ACAccount, completionHandler: (arg1: boolean, arg2: NSError) => void): void;
	requestAccessToAccountsWithTypeWithCompletionHandler(accountType: ACAccountType, handler: (arg1: boolean, arg2: NSError) => void): void;
	requestAccessToAccountsWithTypeOptionsCompletion(accountType: ACAccountType, options: NSDictionary, completion: (arg1: boolean, arg2: NSError) => void): void;
	renewCredentialsForAccountCompletion(account: ACAccount, completionHandler: (arg1: number, arg2: NSError) => void): void;
	removeAccountWithCompletionHandler(account: ACAccount, completionHandler: (arg1: boolean, arg2: NSError) => void): void;
	init(): ACAccountStore;
	static new(): ACAccountStore;
	static allocWithZone(zone: any): ACAccountStore;
	static alloc(): ACAccountStore;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIResponder extends NSObject {
	undoManager: NSUndoManager;
	keyCommands: NSArray;
	inputView: UIView;
	inputAccessoryView: UIView;
	inputViewController: UIInputViewController;
	inputAccessoryViewController: UIInputViewController;
	textInputMode: UITextInputMode;
	textInputContextIdentifier: string;
	userActivity: NSUserActivity;
	constructor();
	nextResponder(): UIResponder;
	canBecomeFirstResponder(): boolean;
	becomeFirstResponder(): boolean;
	canResignFirstResponder(): boolean;
	resignFirstResponder(): boolean;
	isFirstResponder(): boolean;
	touchesBeganWithEvent(touches: NSSet, event: UIEvent): void;
	touchesMovedWithEvent(touches: NSSet, event: UIEvent): void;
	touchesEndedWithEvent(touches: NSSet, event: UIEvent): void;
	touchesCancelledWithEvent(touches: NSSet, event: UIEvent): void;
	motionBeganWithEvent(motion: number, event: UIEvent): void;
	motionEndedWithEvent(motion: number, event: UIEvent): void;
	motionCancelledWithEvent(motion: number, event: UIEvent): void;
	remoteControlReceivedWithEvent(event: UIEvent): void;
	canPerformActionWithSender(action: any, sender: any): boolean;
	targetForActionWithSender(action: any, sender: any): any;
	static clearTextInputContextIdentifier(identifier: string): void;
	reloadInputViews(): void;
	updateUserActivityState(activity: NSUserActivity): void;
	restoreUserActivityState(activity: NSUserActivity): void;
	init(): UIResponder;
	static new(): UIResponder;
	static allocWithZone(zone: any): UIResponder;
	static alloc(): UIResponder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIKeyCommand extends NSObject implements NSCopying, NSSecureCoding {
	input: string;
	modifierFlags: number;
	constructor();
	static keyCommandWithInputModifierFlagsAction(input: string, modifierFlags: number, action: any): UIKeyCommand;
	init(): UIKeyCommand;
	static new(): UIKeyCommand;
	static allocWithZone(zone: any): UIKeyCommand;
	static alloc(): UIKeyCommand;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIColor extends NSObject implements NSSecureCoding, NSCopying {
	CGColor: any;
	CIColor: CIColor;
	constructor(white: number, alpha: number);
	constructor(cgColor: any);
	constructor(image: UIImage);
	constructor(ciColor: CIColor);
	constructor();
	static colorWithWhiteAlpha(white: number, alpha: number): UIColor;
	static colorWithHueSaturationBrightnessAlpha(hue: number, saturation: number, brightness: number, alpha: number): UIColor;
	static colorWithRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): UIColor;
	static colorWithCGColor(cgColor: any): UIColor;
	static colorWithPatternImage(image: UIImage): UIColor;
	static colorWithCIColor(ciColor: CIColor): UIColor;
	initWithWhiteAlpha(white: number, alpha: number): UIColor;
	initWithHueSaturationBrightnessAlpha(hue: number, saturation: number, brightness: number, alpha: number): UIColor;
	initWithRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): UIColor;
	initWithCGColor(cgColor: any): UIColor;
	initWithPatternImage(image: UIImage): UIColor;
	initWithCIColor(ciColor: CIColor): UIColor;
	static blackColor(): UIColor;
	static darkGrayColor(): UIColor;
	static lightGrayColor(): UIColor;
	static whiteColor(): UIColor;
	static grayColor(): UIColor;
	static redColor(): UIColor;
	static greenColor(): UIColor;
	static blueColor(): UIColor;
	static cyanColor(): UIColor;
	static yellowColor(): UIColor;
	static magentaColor(): UIColor;
	static orangeColor(): UIColor;
	static purpleColor(): UIColor;
	static brownColor(): UIColor;
	static clearColor(): UIColor;
	set(): void;
	setFill(): void;
	setStroke(): void;
	getWhiteAlpha(white: any, alpha: any): boolean;
	getHueSaturationBrightnessAlpha(hue: any, saturation: any, brightness: any, alpha: any): boolean;
	getRedGreenBlueAlpha(red: any, green: any, blue: any, alpha: any): boolean;
	colorWithAlphaComponent(alpha: number): UIColor;
	static lightTextColor(): UIColor;
	static darkTextColor(): UIColor;
	static groupTableViewBackgroundColor(): UIColor;
	static viewFlipsideBackgroundColor(): UIColor;
	static scrollViewTexturedBackgroundColor(): UIColor;
	static underPageBackgroundColor(): UIColor;
	init(): UIColor;
	static new(): UIColor;
	static allocWithZone(zone: any): UIColor;
	static alloc(): UIColor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class UIFontDescriptor extends NSObject implements NSCopying, NSCoding {
	postscriptName: string;
	pointSize: number;
	matrix: CGAffineTransform;
	symbolicTraits: number;
	constructor(attributes: NSDictionary);
	constructor();
	objectForKey(anAttribute: string): any;
	fontAttributes(): NSDictionary;
	matchingFontDescriptorsWithMandatoryKeys(mandatoryKeys: NSSet): NSArray;
	static fontDescriptorWithFontAttributes(attributes: NSDictionary): UIFontDescriptor;
	static fontDescriptorWithNameSize(fontName: string, size: number): UIFontDescriptor;
	static fontDescriptorWithNameMatrix(fontName: string, matrix: CGAffineTransform): UIFontDescriptor;
	static preferredFontDescriptorWithTextStyle(style: string): UIFontDescriptor;
	initWithFontAttributes(attributes: NSDictionary): UIFontDescriptor;
	fontDescriptorByAddingAttributes(attributes: NSDictionary): UIFontDescriptor;
	fontDescriptorWithSymbolicTraits(symbolicTraits: number): UIFontDescriptor;
	fontDescriptorWithSize(newPointSize: number): UIFontDescriptor;
	fontDescriptorWithMatrix(matrix: CGAffineTransform): UIFontDescriptor;
	fontDescriptorWithFace(newFace: string): UIFontDescriptor;
	fontDescriptorWithFamily(newFamily: string): UIFontDescriptor;
	init(): UIFontDescriptor;
	static new(): UIFontDescriptor;
	static allocWithZone(zone: any): UIFontDescriptor;
	static alloc(): UIFontDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIFont extends NSObject implements NSCopying {
	familyName: string;
	fontName: string;
	pointSize: number;
	ascender: number;
	descender: number;
	capHeight: number;
	xHeight: number;
	lineHeight: number;
	leading: number;
	constructor();
	static preferredFontForTextStyle(style: string): UIFont;
	static fontWithNameSize(fontName: string, fontSize: number): UIFont;
	static familyNames(): NSArray;
	static fontNamesForFamilyName(familyName: string): NSArray;
	static systemFontOfSize(fontSize: number): UIFont;
	static boldSystemFontOfSize(fontSize: number): UIFont;
	static italicSystemFontOfSize(fontSize: number): UIFont;
	fontWithSize(fontSize: number): UIFont;
	static fontWithDescriptorSize(descriptor: UIFontDescriptor, pointSize: number): UIFont;
	fontDescriptor(): UIFontDescriptor;
	static labelFontSize(): number;
	static buttonFontSize(): number;
	static smallSystemFontSize(): number;
	static systemFontSize(): number;
	init(): UIFont;
	static new(): UIFont;
	static allocWithZone(zone: any): UIFont;
	static alloc(): UIFont;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class UIDevice extends NSObject {
	name: string;
	model: string;
	localizedModel: string;
	systemName: string;
	systemVersion: string;
	orientation: number;
	identifierForVendor: NSUUID;
	generatesDeviceOrientationNotifications: boolean;
	batteryMonitoringEnabled: boolean;
	batteryState: number;
	batteryLevel: number;
	proximityMonitoringEnabled: boolean;
	proximityState: boolean;
	multitaskingSupported: boolean;
	userInterfaceIdiom: number;
	constructor();
	static currentDevice(): UIDevice;
	beginGeneratingDeviceOrientationNotifications(): void;
	endGeneratingDeviceOrientationNotifications(): void;
	playInputClick(): void;
	init(): UIDevice;
	static new(): UIDevice;
	static allocWithZone(zone: any): UIDevice;
	static alloc(): UIDevice;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDynamicBehavior extends NSObject {
	childBehaviors: NSArray;
	action: () => void;
	dynamicAnimator: UIDynamicAnimator;
	constructor();
	addChildBehavior(behavior: UIDynamicBehavior): void;
	removeChildBehavior(behavior: UIDynamicBehavior): void;
	willMoveToAnimator(dynamicAnimator: UIDynamicAnimator): void;
	init(): UIDynamicBehavior;
	static new(): UIDynamicBehavior;
	static allocWithZone(zone: any): UIDynamicBehavior;
	static alloc(): UIDynamicBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSLayoutConstraint extends NSObject {
	priority: number;
	shouldBeArchived: boolean;
	firstItem: any;
	firstAttribute: number;
	relation: number;
	secondItem: any;
	secondAttribute: number;
	multiplier: number;
	constant: number;
	active: boolean;
	identifier: string;
	constructor();
	static constraintsWithVisualFormatOptionsMetricsViews(format: string, opts: number, metrics: NSDictionary, views: NSDictionary): NSArray;
	static constraintWithItemAttributeRelatedByToItemAttributeMultiplierConstant(view1: any, attr1: number, relation: number, view2: any, attr2: number, multiplier: number, c: number): NSLayoutConstraint;
	static activateConstraints(constraints: NSArray): void;
	static deactivateConstraints(constraints: NSArray): void;
	init(): NSLayoutConstraint;
	static new(): NSLayoutConstraint;
	static allocWithZone(zone: any): NSLayoutConstraint;
	static alloc(): NSLayoutConstraint;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITraitCollection extends NSObject implements NSCopying, NSSecureCoding {
	userInterfaceIdiom: number;
	displayScale: number;
	horizontalSizeClass: number;
	verticalSizeClass: number;
	constructor();
	containsTraitsInCollection(trait: UITraitCollection): boolean;
	static traitCollectionWithTraitsFromCollections(traitCollections: NSArray): UITraitCollection;
	static traitCollectionWithUserInterfaceIdiom(idiom: number): UITraitCollection;
	static traitCollectionWithDisplayScale(scale: number): UITraitCollection;
	static traitCollectionWithHorizontalSizeClass(horizontalSizeClass: number): UITraitCollection;
	static traitCollectionWithVerticalSizeClass(verticalSizeClass: number): UITraitCollection;
	init(): UITraitCollection;
	static new(): UITraitCollection;
	static allocWithZone(zone: any): UITraitCollection;
	static alloc(): UITraitCollection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIView extends UIResponder implements NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIAccessibilityIdentification {
	userInteractionEnabled: boolean;
	tag: number;
	layer: CALayer;
	frame: CGRect;
	bounds: CGRect;
	contentScaleFactor: number;
	multipleTouchEnabled: boolean;
	exclusiveTouch: boolean;
	autoresizesSubviews: boolean;
	autoresizingMask: number;
	superview: UIView;
	subviews: NSArray;
	window: UIWindow;
	layoutMargins: UIEdgeInsets;
	preservesSuperviewLayoutMargins: boolean;
	clipsToBounds: boolean;
	backgroundColor: UIColor;
	alpha: number;
	opaque: boolean;
	clearsContextBeforeDrawing: boolean;
	hidden: boolean;
	contentMode: number;
	contentStretch: CGRect;
	maskView: UIView;
	tintColor: UIColor;
	tintAdjustmentMode: number;
	gestureRecognizers: NSArray;
	motionEffects: NSArray;
	restorationIdentifier: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	center: CGPoint;
	transform: CGAffineTransform;
	traitCollection: UITraitCollection;
	accessibilityIdentifier: string;
	constructor(frame: CGRect);
	constructor();
	static layerClass(): any;
	initWithFrame(frame: CGRect): UIView;
	hitTestWithEvent(point: CGPoint, event: UIEvent): UIView;
	pointInsideWithEvent(point: CGPoint, event: UIEvent): boolean;
	convertPointToView(point: CGPoint, view: UIView): CGPoint;
	convertPointFromView(point: CGPoint, view: UIView): CGPoint;
	convertRectToView(rect: CGRect, view: UIView): CGRect;
	convertRectFromView(rect: CGRect, view: UIView): CGRect;
	sizeThatFits(size: CGSize): CGSize;
	sizeToFit(): void;
	removeFromSuperview(): void;
	insertSubviewAtIndex(view: UIView, index: number): void;
	exchangeSubviewAtIndexWithSubviewAtIndex(index1: number, index2: number): void;
	addSubview(view: UIView): void;
	insertSubviewBelowSubview(view: UIView, siblingSubview: UIView): void;
	insertSubviewAboveSubview(view: UIView, siblingSubview: UIView): void;
	bringSubviewToFront(view: UIView): void;
	sendSubviewToBack(view: UIView): void;
	didAddSubview(subview: UIView): void;
	willRemoveSubview(subview: UIView): void;
	willMoveToSuperview(newSuperview: UIView): void;
	didMoveToSuperview(): void;
	willMoveToWindow(newWindow: UIWindow): void;
	didMoveToWindow(): void;
	isDescendantOfView(view: UIView): boolean;
	viewWithTag(tag: number): UIView;
	setNeedsLayout(): void;
	layoutIfNeeded(): void;
	layoutSubviews(): void;
	layoutMarginsDidChange(): void;
	drawRect(rect: CGRect): void;
	setNeedsDisplay(): void;
	setNeedsDisplayInRect(rect: CGRect): void;
	tintColorDidChange(): void;
	static beginAnimationsContext(animationID: string, context: any): void;
	static commitAnimations(): void;
	static setAnimationDelegate(delegate: any): void;
	static setAnimationWillStartSelector(selector: any): void;
	static setAnimationDidStopSelector(selector: any): void;
	static setAnimationDuration(duration: number): void;
	static setAnimationDelay(delay: number): void;
	static setAnimationStartDate(startDate: NSDate): void;
	static setAnimationCurve(curve: number): void;
	static setAnimationRepeatCount(repeatCount: number): void;
	static setAnimationRepeatAutoreverses(repeatAutoreverses: boolean): void;
	static setAnimationBeginsFromCurrentState(fromCurrentState: boolean): void;
	static setAnimationTransitionForViewCache(transition: number, view: UIView, cache: boolean): void;
	static setAnimationsEnabled(enabled: boolean): void;
	static areAnimationsEnabled(): boolean;
	static performWithoutAnimation(actionsWithoutAnimation: () => void): void;
	static animateWithDurationDelayOptionsAnimationsCompletion(duration: number, delay: number, options: number, animations: () => void, completion: (arg1: boolean) => void): void;
	static animateWithDurationAnimationsCompletion(duration: number, animations: () => void, completion: (arg1: boolean) => void): void;
	static animateWithDurationAnimations(duration: number, animations: () => void): void;
	static animateWithDurationDelayUsingSpringWithDampingInitialSpringVelocityOptionsAnimationsCompletion(duration: number, delay: number, dampingRatio: number, velocity: number, options: number, animations: () => void, completion: (arg1: boolean) => void): void;
	static transitionWithViewDurationOptionsAnimationsCompletion(view: UIView, duration: number, options: number, animations: () => void, completion: (arg1: boolean) => void): void;
	static transitionFromViewToViewDurationOptionsCompletion(fromView: UIView, toView: UIView, duration: number, options: number, completion: (arg1: boolean) => void): void;
	static performSystemAnimationOnViewsOptionsAnimationsCompletion(animation: number, views: NSArray, options: number, parallelAnimations: () => void, completion: (arg1: boolean) => void): void;
	static animateKeyframesWithDurationDelayOptionsAnimationsCompletion(duration: number, delay: number, options: number, animations: () => void, completion: (arg1: boolean) => void): void;
	static addKeyframeWithRelativeStartTimeRelativeDurationAnimations(frameStartTime: number, frameDuration: number, animations: () => void): void;
	addGestureRecognizer(gestureRecognizer: UIGestureRecognizer): void;
	removeGestureRecognizer(gestureRecognizer: UIGestureRecognizer): void;
	gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer): boolean;
	addMotionEffect(effect: UIMotionEffect): void;
	removeMotionEffect(effect: UIMotionEffect): void;
	constraints(): NSArray;
	addConstraint(constraint: NSLayoutConstraint): void;
	addConstraints(constraints: NSArray): void;
	removeConstraint(constraint: NSLayoutConstraint): void;
	removeConstraints(constraints: NSArray): void;
	updateConstraintsIfNeeded(): void;
	updateConstraints(): void;
	needsUpdateConstraints(): boolean;
	setNeedsUpdateConstraints(): void;
	translatesAutoresizingMaskIntoConstraints(): boolean;
	setTranslatesAutoresizingMaskIntoConstraints(flag: boolean): void;
	static requiresConstraintBasedLayout(): boolean;
	alignmentRectForFrame(frame: CGRect): CGRect;
	frameForAlignmentRect(alignmentRect: CGRect): CGRect;
	alignmentRectInsets(): UIEdgeInsets;
	viewForBaselineLayout(): UIView;
	intrinsicContentSize(): CGSize;
	invalidateIntrinsicContentSize(): void;
	contentHuggingPriorityForAxis(axis: number): number;
	setContentHuggingPriorityForAxis(priority: number, axis: number): void;
	contentCompressionResistancePriorityForAxis(axis: number): number;
	setContentCompressionResistancePriorityForAxis(priority: number, axis: number): void;
	systemLayoutSizeFittingSize(targetSize: CGSize): CGSize;
	systemLayoutSizeFittingSizeWithHorizontalFittingPriorityVerticalFittingPriority(targetSize: CGSize, horizontalFittingPriority: number, verticalFittingPriority: number): CGSize;
	constraintsAffectingLayoutForAxis(axis: number): NSArray;
	hasAmbiguousLayout(): boolean;
	exerciseAmbiguityInLayout(): void;
	encodeRestorableStateWithCoder(coder: NSCoder): void;
	decodeRestorableStateWithCoder(coder: NSCoder): void;
	snapshotViewAfterScreenUpdates(afterUpdates: boolean): UIView;
	resizableSnapshotViewFromRectAfterScreenUpdatesWithCapInsets(rect: CGRect, afterUpdates: boolean, capInsets: UIEdgeInsets): UIView;
	drawViewHierarchyInRectAfterScreenUpdates(rect: CGRect, afterUpdates: boolean): boolean;
	endEditing(force: boolean): boolean;
	viewPrintFormatter(): UIViewPrintFormatter;
	drawRectForViewPrintFormatter(rect: CGRect, formatter: UIViewPrintFormatter): void;
	init(): UIView;
	static new(): UIView;
	static allocWithZone(zone: any): UIView;
	static alloc(): UIView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	static appearance(): any;
	static appearanceWhenContainedIn(ContainerClass: any): any;
	static appearanceForTraitCollection(trait: UITraitCollection): any;
	static appearanceForTraitCollectionWhenContainedIn(trait: UITraitCollection, ContainerClass: any): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	traitCollectionDidChange(previousTraitCollection: UITraitCollection): void;
	convertPointToCoordinateSpace(point: CGPoint, coordinateSpace: any): CGPoint;
	convertPointFromCoordinateSpace(point: CGPoint, coordinateSpace: any): CGPoint;
	convertRectToCoordinateSpace(rect: CGRect, coordinateSpace: any): CGRect;
	convertRectFromCoordinateSpace(rect: CGRect, coordinateSpace: any): CGRect;
}
declare class UIControl extends UIView {
	enabled: boolean;
	selected: boolean;
	highlighted: boolean;
	contentVerticalAlignment: number;
	contentHorizontalAlignment: number;
	state: number;
	tracking: boolean;
	touchInside: boolean;
	constructor(frame: CGRect);
	constructor();
	beginTrackingWithTouchWithEvent(touch: UITouch, event: UIEvent): boolean;
	continueTrackingWithTouchWithEvent(touch: UITouch, event: UIEvent): boolean;
	endTrackingWithTouchWithEvent(touch: UITouch, event: UIEvent): void;
	cancelTrackingWithEvent(event: UIEvent): void;
	addTargetActionForControlEvents(target: any, action: any, controlEvents: number): void;
	removeTargetActionForControlEvents(target: any, action: any, controlEvents: number): void;
	allTargets(): NSSet;
	allControlEvents(): number;
	actionsForTargetForControlEvent(target: any, controlEvent: number): NSArray;
	sendActionToForEvent(action: any, target: any, event: UIEvent): void;
	sendActionsForControlEvents(controlEvents: number): void;
	initWithFrame(frame: CGRect): UIControl;
	init(): UIControl;
	static new(): UIControl;
	static allocWithZone(zone: any): UIControl;
	static alloc(): UIControl;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSTextTab extends NSObject implements NSCopying, NSCoding {
	alignment: number;
	location: number;
	options: NSDictionary;
	constructor(alignment: number, loc: number, options: NSDictionary);
	constructor();
	initWithTextAlignmentLocationOptions(alignment: number, loc: number, options: NSDictionary): NSTextTab;
	static columnTerminatorsForLocale(aLocale: NSLocale): NSCharacterSet;
	init(): NSTextTab;
	static new(): NSTextTab;
	static allocWithZone(zone: any): NSTextTab;
	static alloc(): NSTextTab;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSParagraphStyle extends NSObject implements NSCopying, NSMutableCopying, NSCoding {
	lineSpacing: number;
	paragraphSpacing: number;
	alignment: number;
	headIndent: number;
	tailIndent: number;
	firstLineHeadIndent: number;
	minimumLineHeight: number;
	maximumLineHeight: number;
	lineBreakMode: number;
	baseWritingDirection: number;
	lineHeightMultiple: number;
	paragraphSpacingBefore: number;
	hyphenationFactor: number;
	tabStops: NSArray;
	defaultTabInterval: number;
	constructor();
	static defaultParagraphStyle(): NSParagraphStyle;
	static defaultWritingDirectionForLanguage(languageName: string): number;
	init(): NSParagraphStyle;
	static new(): NSParagraphStyle;
	static allocWithZone(zone: any): NSParagraphStyle;
	static alloc(): NSParagraphStyle;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSMutableParagraphStyle extends NSParagraphStyle {
	lineSpacing: number;
	paragraphSpacing: number;
	alignment: number;
	firstLineHeadIndent: number;
	headIndent: number;
	tailIndent: number;
	lineBreakMode: number;
	minimumLineHeight: number;
	maximumLineHeight: number;
	baseWritingDirection: number;
	lineHeightMultiple: number;
	paragraphSpacingBefore: number;
	hyphenationFactor: number;
	tabStops: NSArray;
	defaultTabInterval: number;
	constructor();
	init(): NSMutableParagraphStyle;
	static new(): NSMutableParagraphStyle;
	static allocWithZone(zone: any): NSMutableParagraphStyle;
	static alloc(): NSMutableParagraphStyle;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDictationPhrase extends NSObject {
	text: string;
	alternativeInterpretations: NSArray;
	constructor();
	init(): UIDictationPhrase;
	static new(): UIDictationPhrase;
	static allocWithZone(zone: any): UIDictationPhrase;
	static alloc(): UIDictationPhrase;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITextPosition extends NSObject {
	constructor();
	init(): UITextPosition;
	static new(): UITextPosition;
	static allocWithZone(zone: any): UITextPosition;
	static alloc(): UITextPosition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITextRange extends NSObject {
	empty: boolean;
	start: UITextPosition;
	end: UITextPosition;
	constructor();
	init(): UITextRange;
	static new(): UITextRange;
	static allocWithZone(zone: any): UITextRange;
	static alloc(): UITextRange;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITextSelectionRect extends NSObject {
	rect: CGRect;
	writingDirection: number;
	containsStart: boolean;
	containsEnd: boolean;
	isVertical: boolean;
	constructor();
	init(): UITextSelectionRect;
	static new(): UITextSelectionRect;
	static allocWithZone(zone: any): UITextSelectionRect;
	static alloc(): UITextSelectionRect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITextInputStringTokenizer extends NSObject implements UITextInputTokenizer {
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(textInput: UIResponder);
	constructor();
	initWithTextInput(textInput: UIResponder): UITextInputStringTokenizer;
	init(): UITextInputStringTokenizer;
	static new(): UITextInputStringTokenizer;
	static allocWithZone(zone: any): UITextInputStringTokenizer;
	static alloc(): UITextInputStringTokenizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	rangeEnclosingPositionWithGranularityInDirection(position: UITextPosition, granularity: number, direction: number): UITextRange;
	isPositionAtBoundaryInDirection(position: UITextPosition, granularity: number, direction: number): boolean;
	positionFromPositionToBoundaryInDirection(position: UITextPosition, granularity: number, direction: number): UITextPosition;
	isPositionWithinTextUnitInDirection(position: UITextPosition, granularity: number, direction: number): boolean;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UITextInputMode extends NSObject implements NSSecureCoding {
	primaryLanguage: string;
	constructor();
	static currentInputMode(): UITextInputMode;
	static activeInputModes(): NSArray;
	init(): UITextInputMode;
	static new(): UITextInputMode;
	static allocWithZone(zone: any): UITextInputMode;
	static alloc(): UITextInputMode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UITextField extends UIControl implements UITextInput, NSCoding {
	text: string;
	attributedText: NSAttributedString;
	textColor: UIColor;
	font: UIFont;
	textAlignment: number;
	borderStyle: number;
	defaultTextAttributes: NSDictionary;
	placeholder: string;
	attributedPlaceholder: NSAttributedString;
	clearsOnBeginEditing: boolean;
	adjustsFontSizeToFitWidth: boolean;
	minimumFontSize: number;
	delegate: any;
	background: UIImage;
	disabledBackground: UIImage;
	editing: boolean;
	allowsEditingTextAttributes: boolean;
	typingAttributes: NSDictionary;
	clearButtonMode: number;
	leftView: UIView;
	leftViewMode: number;
	rightView: UIView;
	rightViewMode: number;
	inputView: UIView;
	inputAccessoryView: UIView;
	clearsOnInsertion: boolean;
	selectedTextRange: UITextRange;
	markedTextRange: UITextRange;
	markedTextStyle: NSDictionary;
	beginningOfDocument: UITextPosition;
	endOfDocument: UITextPosition;
	inputDelegate: any;
	tokenizer: any;
	textInputView: UIView;
	selectionAffinity: number;
	autocapitalizationType: number;
	autocorrectionType: number;
	spellCheckingType: number;
	keyboardType: number;
	keyboardAppearance: number;
	returnKeyType: number;
	enablesReturnKeyAutomatically: boolean;
	secureTextEntry: boolean;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(frame: CGRect);
	constructor();
	borderRectForBounds(bounds: CGRect): CGRect;
	textRectForBounds(bounds: CGRect): CGRect;
	placeholderRectForBounds(bounds: CGRect): CGRect;
	editingRectForBounds(bounds: CGRect): CGRect;
	clearButtonRectForBounds(bounds: CGRect): CGRect;
	leftViewRectForBounds(bounds: CGRect): CGRect;
	rightViewRectForBounds(bounds: CGRect): CGRect;
	drawTextInRect(rect: CGRect): void;
	drawPlaceholderInRect(rect: CGRect): void;
	initWithFrame(frame: CGRect): UITextField;
	init(): UITextField;
	static new(): UITextField;
	static allocWithZone(zone: any): UITextField;
	static alloc(): UITextField;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	textInRange(range: UITextRange): string;
	replaceRangeWithText(range: UITextRange, text: string): void;
	setMarkedTextSelectedRange(markedText: string, selectedRange: NSRange): void;
	unmarkText(): void;
	textRangeFromPositionToPosition(fromPosition: UITextPosition, toPosition: UITextPosition): UITextRange;
	positionFromPositionOffset(position: UITextPosition, offset: number): UITextPosition;
	positionFromPositionInDirectionOffset(position: UITextPosition, direction: number, offset: number): UITextPosition;
	comparePositionToPosition(position: UITextPosition, other: UITextPosition): number;
	offsetFromPositionToPosition(from: UITextPosition, toPosition: UITextPosition): number;
	positionWithinRangeFarthestInDirection(range: UITextRange, direction: number): UITextPosition;
	characterRangeByExtendingPositionInDirection(position: UITextPosition, direction: number): UITextRange;
	baseWritingDirectionForPositionInDirection(position: UITextPosition, direction: number): number;
	setBaseWritingDirectionForRange(writingDirection: number, range: UITextRange): void;
	firstRectForRange(range: UITextRange): CGRect;
	caretRectForPosition(position: UITextPosition): CGRect;
	selectionRectsForRange(range: UITextRange): NSArray;
	closestPositionToPoint(point: CGPoint): UITextPosition;
	closestPositionToPointWithinRange(point: CGPoint, range: UITextRange): UITextPosition;
	characterRangeAtPoint(point: CGPoint): UITextRange;
	hasText(): boolean;
	insertText(text: string): void;
	deleteBackward(): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIActionSheet extends UIView {
	delegate: any;
	title: string;
	actionSheetStyle: number;
	numberOfButtons: number;
	cancelButtonIndex: number;
	destructiveButtonIndex: number;
	firstOtherButtonIndex: number;
	visible: boolean;
	constructor(title: string, delegate: any, cancelButtonTitle: string, destructiveButtonTitle: string, otherButtonTitles: string);
	constructor(frame: CGRect);
	constructor();
	initWithTitleDelegateCancelButtonTitleDestructiveButtonTitleOtherButtonTitles(title: string, delegate: any, cancelButtonTitle: string, destructiveButtonTitle: string, otherButtonTitles: string): UIActionSheet;
	addButtonWithTitle(title: string): number;
	buttonTitleAtIndex(buttonIndex: number): string;
	showFromToolbar(view: UIToolbar): void;
	showFromTabBar(view: UITabBar): void;
	showFromBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): void;
	showFromRectInViewAnimated(rect: CGRect, view: UIView, animated: boolean): void;
	showInView(view: UIView): void;
	dismissWithClickedButtonIndexAnimated(buttonIndex: number, animated: boolean): void;
	initWithFrame(frame: CGRect): UIActionSheet;
	init(): UIActionSheet;
	static new(): UIActionSheet;
	static allocWithZone(zone: any): UIActionSheet;
	static alloc(): UIActionSheet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIAlertView extends UIView {
	delegate: any;
	title: string;
	message: string;
	numberOfButtons: number;
	cancelButtonIndex: number;
	firstOtherButtonIndex: number;
	visible: boolean;
	alertViewStyle: number;
	constructor(title: string, message: string, delegate: any, cancelButtonTitle: string, otherButtonTitles: string);
	constructor(frame: CGRect);
	constructor();
	initWithTitleMessageDelegateCancelButtonTitleOtherButtonTitles(title: string, message: string, delegate: any, cancelButtonTitle: string, otherButtonTitles: string): UIAlertView;
	addButtonWithTitle(title: string): number;
	buttonTitleAtIndex(buttonIndex: number): string;
	show(): void;
	dismissWithClickedButtonIndexAnimated(buttonIndex: number, animated: boolean): void;
	textFieldAtIndex(textFieldIndex: number): UITextField;
	initWithFrame(frame: CGRect): UIAlertView;
	init(): UIAlertView;
	static new(): UIAlertView;
	static allocWithZone(zone: any): UIAlertView;
	static alloc(): UIAlertView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIApplication extends UIResponder implements UIActionSheetDelegate {
	delegate: any;
	idleTimerDisabled: boolean;
	keyWindow: UIWindow;
	windows: NSArray;
	networkActivityIndicatorVisible: boolean;
	statusBarStyle: number;
	statusBarHidden: boolean;
	statusBarOrientation: number;
	statusBarOrientationAnimationDuration: number;
	statusBarFrame: CGRect;
	applicationIconBadgeNumber: number;
	applicationSupportsShakeToEdit: boolean;
	applicationState: number;
	backgroundTimeRemaining: number;
	backgroundRefreshStatus: number;
	protectedDataAvailable: boolean;
	userInterfaceLayoutDirection: number;
	preferredContentSizeCategory: string;
	scheduledLocalNotifications: NSArray;
	proximitySensingEnabled: boolean;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static sharedApplication(): UIApplication;
	beginIgnoringInteractionEvents(): void;
	endIgnoringInteractionEvents(): void;
	isIgnoringInteractionEvents(): boolean;
	openURL(url: NSURL): boolean;
	canOpenURL(url: NSURL): boolean;
	sendEvent(event: UIEvent): void;
	sendActionToFromForEvent(action: any, target: any, sender: any, event: UIEvent): boolean;
	setStatusBarStyleAnimated(statusBarStyle: number, animated: boolean): void;
	setStatusBarHiddenWithAnimation(hidden: boolean, animation: number): void;
	setStatusBarOrientationAnimated(interfaceOrientation: number, animated: boolean): void;
	supportedInterfaceOrientationsForWindow(window: UIWindow): number;
	beginBackgroundTaskWithExpirationHandler(handler: () => void): number;
	beginBackgroundTaskWithNameExpirationHandler(taskName: string, handler: () => void): number;
	endBackgroundTask(identifier: number): void;
	setMinimumBackgroundFetchInterval(minimumBackgroundFetchInterval: number): void;
	setKeepAliveTimeoutHandler(timeout: number, keepAliveHandler: () => void): boolean;
	clearKeepAliveTimeout(): void;
	registerForRemoteNotifications(): void;
	unregisterForRemoteNotifications(): void;
	isRegisteredForRemoteNotifications(): boolean;
	registerForRemoteNotificationTypes(types: number): void;
	enabledRemoteNotificationTypes(): number;
	presentLocalNotificationNow(notification: UILocalNotification): void;
	scheduleLocalNotification(notification: UILocalNotification): void;
	cancelLocalNotification(notification: UILocalNotification): void;
	cancelAllLocalNotifications(): void;
	registerUserNotificationSettings(notificationSettings: UIUserNotificationSettings): void;
	currentUserNotificationSettings(): UIUserNotificationSettings;
	beginReceivingRemoteControlEvents(): void;
	endReceivingRemoteControlEvents(): void;
	setNewsstandIconImage(image: UIImage): void;
	extendStateRestoration(): void;
	completeStateRestoration(): void;
	ignoreSnapshotOnNextApplicationLaunch(): void;
	static registerObjectForStateRestorationRestorationIdentifier(object: any, restorationIdentifier: string): void;
	setStatusBarHiddenAnimated(hidden: boolean, animated: boolean): void;
	init(): UIApplication;
	static new(): UIApplication;
	static allocWithZone(zone: any): UIApplication;
	static alloc(): UIApplication;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIViewController extends UIResponder implements NSCoding, UIAppearanceContainer, UITraitEnvironment, UIContentContainer, UIStateRestoring, NSExtensionRequestHandling {
	view: UIView;
	nibName: string;
	nibBundle: NSBundle;
	storyboard: UIStoryboard;
	title: string;
	parentViewController: UIViewController;
	modalViewController: UIViewController;
	presentedViewController: UIViewController;
	presentingViewController: UIViewController;
	definesPresentationContext: boolean;
	providesPresentationContextTransitionStyle: boolean;
	modalTransitionStyle: number;
	modalPresentationStyle: number;
	modalPresentationCapturesStatusBarAppearance: boolean;
	wantsFullScreenLayout: boolean;
	edgesForExtendedLayout: number;
	extendedLayoutIncludesOpaqueBars: boolean;
	automaticallyAdjustsScrollViewInsets: boolean;
	preferredContentSize: CGSize;
	interfaceOrientation: number;
	editing: boolean;
	searchDisplayController: UISearchDisplayController;
	childViewControllers: NSArray;
	restorationIdentifier: string;
	restorationClass: any;
	transitioningDelegate: any;
	topLayoutGuide: any;
	bottomLayoutGuide: any;
	extensionContext: NSExtensionContext;
	presentationController: UIPresentationController;
	popoverPresentationController: UIPopoverPresentationController;
	navigationItem: UINavigationItem;
	hidesBottomBarWhenPushed: boolean;
	navigationController: UINavigationController;
	toolbarItems: NSArray;
	modalInPopover: boolean;
	contentSizeForViewInPopover: CGSize;
	splitViewController: UISplitViewController;
	tabBarItem: UITabBarItem;
	tabBarController: UITabBarController;
	interstitialPresentationPolicy: number;
	canDisplayBannerAds: boolean;
	originalContentView: UIView;
	presentingFullScreenAd: boolean;
	displayingBannerAd: boolean;
	shouldPresentInterstitialAd: boolean;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	traitCollection: UITraitCollection;
	restorationParent: any;
	objectRestorationClass: any;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIViewController;
	loadView(): void;
	viewWillUnload(): void;
	viewDidUnload(): void;
	viewDidLoad(): void;
	isViewLoaded(): boolean;
	performSegueWithIdentifierSender(identifier: string, sender: any): void;
	shouldPerformSegueWithIdentifierSender(identifier: string, sender: any): boolean;
	prepareForSegueSender(segue: UIStoryboardSegue, sender: any): void;
	canPerformUnwindSegueActionFromViewControllerWithSender(action: any, fromViewController: UIViewController, sender: any): boolean;
	viewControllerForUnwindSegueActionFromViewControllerWithSender(action: any, fromViewController: UIViewController, sender: any): UIViewController;
	segueForUnwindingToViewControllerFromViewControllerIdentifier(toViewController: UIViewController, fromViewController: UIViewController, identifier: string): UIStoryboardSegue;
	viewWillAppear(animated: boolean): void;
	viewDidAppear(animated: boolean): void;
	viewWillDisappear(animated: boolean): void;
	viewDidDisappear(animated: boolean): void;
	viewWillLayoutSubviews(): void;
	viewDidLayoutSubviews(): void;
	didReceiveMemoryWarning(): void;
	isBeingPresented(): boolean;
	isBeingDismissed(): boolean;
	isMovingToParentViewController(): boolean;
	isMovingFromParentViewController(): boolean;
	presentViewControllerAnimatedCompletion(viewControllerToPresent: UIViewController, flag: boolean, completion: () => void): void;
	dismissViewControllerAnimatedCompletion(flag: boolean, completion: () => void): void;
	presentModalViewControllerAnimated(modalViewController: UIViewController, animated: boolean): void;
	dismissModalViewControllerAnimated(animated: boolean): void;
	disablesAutomaticKeyboardDismissal(): boolean;
	preferredStatusBarStyle(): number;
	prefersStatusBarHidden(): boolean;
	preferredStatusBarUpdateAnimation(): number;
	setNeedsStatusBarAppearanceUpdate(): void;
	targetViewControllerForActionSender(action: any, sender: any): UIViewController;
	showViewControllerSender(vc: UIViewController, sender: any): void;
	showDetailViewControllerSender(vc: UIViewController, sender: any): void;
	static attemptRotationToDeviceOrientation(): void;
	shouldAutorotateToInterfaceOrientation(toInterfaceOrientation: number): boolean;
	shouldAutorotate(): boolean;
	supportedInterfaceOrientations(): number;
	preferredInterfaceOrientationForPresentation(): number;
	rotatingHeaderView(): UIView;
	rotatingFooterView(): UIView;
	willRotateToInterfaceOrientationDuration(toInterfaceOrientation: number, duration: number): void;
	didRotateFromInterfaceOrientation(fromInterfaceOrientation: number): void;
	willAnimateRotationToInterfaceOrientationDuration(toInterfaceOrientation: number, duration: number): void;
	willAnimateFirstHalfOfRotationToInterfaceOrientationDuration(toInterfaceOrientation: number, duration: number): void;
	didAnimateFirstHalfOfRotationToInterfaceOrientation(toInterfaceOrientation: number): void;
	willAnimateSecondHalfOfRotationFromInterfaceOrientationDuration(fromInterfaceOrientation: number, duration: number): void;
	setEditingAnimated(editing: boolean, animated: boolean): void;
	editButtonItem(): UIBarButtonItem;
	addChildViewController(childController: UIViewController): void;
	removeFromParentViewController(): void;
	transitionFromViewControllerToViewControllerDurationOptionsAnimationsCompletion(fromViewController: UIViewController, toViewController: UIViewController, duration: number, options: number, animations: () => void, completion: (arg1: boolean) => void): void;
	beginAppearanceTransitionAnimated(isAppearing: boolean, animated: boolean): void;
	endAppearanceTransition(): void;
	childViewControllerForStatusBarStyle(): UIViewController;
	childViewControllerForStatusBarHidden(): UIViewController;
	setOverrideTraitCollectionForChildViewController(collection: UITraitCollection, childViewController: UIViewController): void;
	overrideTraitCollectionForChildViewController(childViewController: UIViewController): UITraitCollection;
	automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers(): boolean;
	shouldAutomaticallyForwardRotationMethods(): boolean;
	shouldAutomaticallyForwardAppearanceMethods(): boolean;
	willMoveToParentViewController(parent: UIViewController): void;
	didMoveToParentViewController(parent: UIViewController): void;
	encodeRestorableStateWithCoder(coder: NSCoder): void;
	decodeRestorableStateWithCoder(coder: NSCoder): void;
	applicationFinishedRestoringState(): void;
	updateViewConstraints(): void;
	setToolbarItemsAnimated(toolbarItems: NSArray, animated: boolean): void;
	transitionCoordinator(): any;
	collapseSecondaryViewControllerForSplitViewController(secondaryViewController: UIViewController, splitViewController: UISplitViewController): void;
	separateSecondaryViewControllerForSplitViewController(splitViewController: UISplitViewController): UIViewController;
	presentMoviePlayerViewControllerAnimated(moviePlayerViewController: MPMoviePlayerViewController): void;
	dismissMoviePlayerViewControllerAnimated(): void;
	static prepareInterstitialAds(): void;
	requestInterstitialAdPresentation(): boolean;
	init(): UIViewController;
	static new(): UIViewController;
	static allocWithZone(zone: any): UIViewController;
	static alloc(): UIViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	traitCollectionDidChange(previousTraitCollection: UITraitCollection): void;
	preferredContentSizeDidChangeForChildContentContainer(container: any): void;
	systemLayoutFittingSizeDidChangeForChildContentContainer(container: any): void;
	sizeForChildContentContainerWithParentContainerSize(container: any, parentSize: CGSize): CGSize;
	viewWillTransitionToSizeWithTransitionCoordinator(size: CGSize, coordinator: any): void;
	willTransitionToTraitCollectionWithTransitionCoordinator(newCollection: UITraitCollection, coordinator: any): void;
	beginRequestWithExtensionContext(context: NSExtensionContext): void;
}
declare class UIGestureRecognizer extends NSObject {
	state: number;
	delegate: any;
	enabled: boolean;
	view: UIView;
	cancelsTouchesInView: boolean;
	delaysTouchesBegan: boolean;
	delaysTouchesEnded: boolean;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UIGestureRecognizer;
	addTargetAction(target: any, action: any): void;
	removeTargetAction(target: any, action: any): void;
	requireGestureRecognizerToFail(otherGestureRecognizer: UIGestureRecognizer): void;
	locationInView(view: UIView): CGPoint;
	numberOfTouches(): number;
	locationOfTouchInView(touchIndex: number, view: UIView): CGPoint;
	ignoreTouchForEvent(touch: UITouch, event: UIEvent): void;
	reset(): void;
	canPreventGestureRecognizer(preventedGestureRecognizer: UIGestureRecognizer): boolean;
	canBePreventedByGestureRecognizer(preventingGestureRecognizer: UIGestureRecognizer): boolean;
	shouldRequireFailureOfGestureRecognizer(otherGestureRecognizer: UIGestureRecognizer): boolean;
	shouldBeRequiredToFailByGestureRecognizer(otherGestureRecognizer: UIGestureRecognizer): boolean;
	touchesBeganWithEvent(touches: NSSet, event: UIEvent): void;
	touchesMovedWithEvent(touches: NSSet, event: UIEvent): void;
	touchesEndedWithEvent(touches: NSSet, event: UIEvent): void;
	touchesCancelledWithEvent(touches: NSSet, event: UIEvent): void;
	init(): UIGestureRecognizer;
	static new(): UIGestureRecognizer;
	static allocWithZone(zone: any): UIGestureRecognizer;
	static alloc(): UIGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPanGestureRecognizer extends UIGestureRecognizer {
	minimumNumberOfTouches: number;
	maximumNumberOfTouches: number;
	constructor(target: any, action: any);
	constructor();
	translationInView(view: UIView): CGPoint;
	setTranslationInView(translation: CGPoint, view: UIView): void;
	velocityInView(view: UIView): CGPoint;
	initWithTargetAction(target: any, action: any): UIPanGestureRecognizer;
	init(): UIPanGestureRecognizer;
	static new(): UIPanGestureRecognizer;
	static allocWithZone(zone: any): UIPanGestureRecognizer;
	static alloc(): UIPanGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITapGestureRecognizer extends UIGestureRecognizer {
	numberOfTapsRequired: number;
	numberOfTouchesRequired: number;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UITapGestureRecognizer;
	init(): UITapGestureRecognizer;
	static new(): UITapGestureRecognizer;
	static allocWithZone(zone: any): UITapGestureRecognizer;
	static alloc(): UITapGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UINavigationController extends UIViewController {
	topViewController: UIViewController;
	visibleViewController: UIViewController;
	viewControllers: NSArray;
	navigationBarHidden: boolean;
	navigationBar: UINavigationBar;
	toolbarHidden: boolean;
	toolbar: UIToolbar;
	delegate: any;
	interactivePopGestureRecognizer: UIGestureRecognizer;
	hidesBarsWhenKeyboardAppears: boolean;
	hidesBarsOnSwipe: boolean;
	barHideOnSwipeGestureRecognizer: UIPanGestureRecognizer;
	hidesBarsWhenVerticallyCompact: boolean;
	hidesBarsOnTap: boolean;
	barHideOnTapGestureRecognizer: UITapGestureRecognizer;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): UINavigationController;
	initWithRootViewController(rootViewController: UIViewController): UINavigationController;
	pushViewControllerAnimated(viewController: UIViewController, animated: boolean): void;
	popViewControllerAnimated(animated: boolean): UIViewController;
	popToViewControllerAnimated(viewController: UIViewController, animated: boolean): NSArray;
	popToRootViewControllerAnimated(animated: boolean): NSArray;
	setViewControllersAnimated(viewControllers: NSArray, animated: boolean): void;
	setNavigationBarHiddenAnimated(hidden: boolean, animated: boolean): void;
	setToolbarHiddenAnimated(hidden: boolean, animated: boolean): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UINavigationController;
	init(): UINavigationController;
	static new(): UINavigationController;
	static allocWithZone(zone: any): UINavigationController;
	static alloc(): UINavigationController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIAcceleration extends NSObject {
	timestamp: number;
	x: number;
	y: number;
	z: number;
	constructor();
	init(): UIAcceleration;
	static new(): UIAcceleration;
	static allocWithZone(zone: any): UIAcceleration;
	static alloc(): UIAcceleration;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIAccelerometer extends NSObject {
	updateInterval: number;
	delegate: any;
	constructor();
	static sharedAccelerometer(): UIAccelerometer;
	init(): UIAccelerometer;
	static new(): UIAccelerometer;
	static allocWithZone(zone: any): UIAccelerometer;
	static alloc(): UIAccelerometer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIBezierPath extends NSObject implements NSCopying, NSCoding {
	CGPath: any;
	empty: boolean;
	bounds: CGRect;
	currentPoint: CGPoint;
	lineWidth: number;
	lineCapStyle: number;
	lineJoinStyle: number;
	miterLimit: number;
	flatness: number;
	usesEvenOddFillRule: boolean;
	constructor();
	static bezierPath(): UIBezierPath;
	static bezierPathWithRect(rect: CGRect): UIBezierPath;
	static bezierPathWithOvalInRect(rect: CGRect): UIBezierPath;
	static bezierPathWithRoundedRectCornerRadius(rect: CGRect, cornerRadius: number): UIBezierPath;
	static bezierPathWithRoundedRectByRoundingCornersCornerRadii(rect: CGRect, corners: number, cornerRadii: CGSize): UIBezierPath;
	static bezierPathWithArcCenterRadiusStartAngleEndAngleClockwise(center: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): UIBezierPath;
	static bezierPathWithCGPath(CGPath: any): UIBezierPath;
	moveToPoint(point: CGPoint): void;
	addLineToPoint(point: CGPoint): void;
	addCurveToPointControlPoint1ControlPoint2(endPoint: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;
	addQuadCurveToPointControlPoint(endPoint: CGPoint, controlPoint: CGPoint): void;
	addArcWithCenterRadiusStartAngleEndAngleClockwise(center: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
	closePath(): void;
	removeAllPoints(): void;
	appendPath(bezierPath: UIBezierPath): void;
	bezierPathByReversingPath(): UIBezierPath;
	applyTransform(transform: CGAffineTransform): void;
	containsPoint(point: CGPoint): boolean;
	setLineDashCountPhase(pattern: any, count: number, phase: number): void;
	getLineDashCountPhase(pattern: any, count: any, phase: any): void;
	fill(): void;
	stroke(): void;
	fillWithBlendModeAlpha(blendMode: number, alpha: number): void;
	strokeWithBlendModeAlpha(blendMode: number, alpha: number): void;
	addClip(): void;
	init(): UIBezierPath;
	static new(): UIBezierPath;
	static allocWithZone(zone: any): UIBezierPath;
	static alloc(): UIBezierPath;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIScrollView extends UIView implements NSCoding {
	contentOffset: CGPoint;
	contentSize: CGSize;
	contentInset: UIEdgeInsets;
	delegate: any;
	directionalLockEnabled: boolean;
	bounces: boolean;
	alwaysBounceVertical: boolean;
	alwaysBounceHorizontal: boolean;
	pagingEnabled: boolean;
	scrollEnabled: boolean;
	showsHorizontalScrollIndicator: boolean;
	showsVerticalScrollIndicator: boolean;
	scrollIndicatorInsets: UIEdgeInsets;
	indicatorStyle: number;
	decelerationRate: number;
	tracking: boolean;
	dragging: boolean;
	decelerating: boolean;
	delaysContentTouches: boolean;
	canCancelContentTouches: boolean;
	minimumZoomScale: number;
	maximumZoomScale: number;
	zoomScale: number;
	bouncesZoom: boolean;
	zooming: boolean;
	zoomBouncing: boolean;
	scrollsToTop: boolean;
	panGestureRecognizer: UIPanGestureRecognizer;
	pinchGestureRecognizer: UIPinchGestureRecognizer;
	keyboardDismissMode: number;
	constructor(frame: CGRect);
	constructor();
	setContentOffsetAnimated(contentOffset: CGPoint, animated: boolean): void;
	scrollRectToVisibleAnimated(rect: CGRect, animated: boolean): void;
	flashScrollIndicators(): void;
	touchesShouldBeginWithEventInContentView(touches: NSSet, event: UIEvent, view: UIView): boolean;
	touchesShouldCancelInContentView(view: UIView): boolean;
	setZoomScaleAnimated(scale: number, animated: boolean): void;
	zoomToRectAnimated(rect: CGRect, animated: boolean): void;
	initWithFrame(frame: CGRect): UIScrollView;
	init(): UIScrollView;
	static new(): UIScrollView;
	static allocWithZone(zone: any): UIScrollView;
	static alloc(): UIScrollView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UISwipeGestureRecognizer extends UIGestureRecognizer {
	numberOfTouchesRequired: number;
	direction: number;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UISwipeGestureRecognizer;
	init(): UISwipeGestureRecognizer;
	static new(): UISwipeGestureRecognizer;
	static allocWithZone(zone: any): UISwipeGestureRecognizer;
	static alloc(): UISwipeGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITableViewCell extends UIView implements NSCoding, UIGestureRecognizerDelegate {
	imageView: UIImageView;
	textLabel: UILabel;
	detailTextLabel: UILabel;
	contentView: UIView;
	backgroundView: UIView;
	selectedBackgroundView: UIView;
	multipleSelectionBackgroundView: UIView;
	reuseIdentifier: string;
	selectionStyle: number;
	selected: boolean;
	highlighted: boolean;
	editingStyle: number;
	showsReorderControl: boolean;
	shouldIndentWhileEditing: boolean;
	accessoryType: number;
	accessoryView: UIView;
	editingAccessoryType: number;
	editingAccessoryView: UIView;
	indentationLevel: number;
	indentationWidth: number;
	separatorInset: UIEdgeInsets;
	editing: boolean;
	showingDeleteConfirmation: boolean;
	text: string;
	font: UIFont;
	textAlignment: number;
	lineBreakMode: number;
	textColor: UIColor;
	selectedTextColor: UIColor;
	image: UIImage;
	selectedImage: UIImage;
	hidesAccessoryWhenEditing: boolean;
	target: any;
	editAction: any;
	accessoryAction: any;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(style: number, reuseIdentifier: string);
	constructor(frame: CGRect, reuseIdentifier: string);
	constructor(frame: CGRect);
	constructor();
	initWithStyleReuseIdentifier(style: number, reuseIdentifier: string): UITableViewCell;
	prepareForReuse(): void;
	setSelectedAnimated(selected: boolean, animated: boolean): void;
	setHighlightedAnimated(highlighted: boolean, animated: boolean): void;
	setEditingAnimated(editing: boolean, animated: boolean): void;
	willTransitionToState(state: number): void;
	didTransitionToState(state: number): void;
	initWithFrameReuseIdentifier(frame: CGRect, reuseIdentifier: string): UITableViewCell;
	initWithFrame(frame: CGRect): UITableViewCell;
	init(): UITableViewCell;
	static new(): UITableViewCell;
	static allocWithZone(zone: any): UITableViewCell;
	static alloc(): UITableViewCell;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UITableViewRowAction extends NSObject implements NSCopying {
	style: number;
	title: string;
	backgroundColor: UIColor;
	backgroundEffect: UIVisualEffect;
	constructor();
	static rowActionWithStyleTitleHandler(style: number, title: string, handler: (arg1: UITableViewRowAction, arg2: NSIndexPath) => void): UITableViewRowAction;
	init(): UITableViewRowAction;
	static new(): UITableViewRowAction;
	static allocWithZone(zone: any): UITableViewRowAction;
	static alloc(): UITableViewRowAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class UITableView extends UIScrollView implements NSCoding {
	style: number;
	dataSource: any;
	rowHeight: number;
	sectionHeaderHeight: number;
	sectionFooterHeight: number;
	estimatedRowHeight: number;
	estimatedSectionHeaderHeight: number;
	estimatedSectionFooterHeight: number;
	separatorInset: UIEdgeInsets;
	backgroundView: UIView;
	editing: boolean;
	allowsSelection: boolean;
	allowsSelectionDuringEditing: boolean;
	allowsMultipleSelection: boolean;
	allowsMultipleSelectionDuringEditing: boolean;
	sectionIndexMinimumDisplayRowCount: number;
	sectionIndexColor: UIColor;
	sectionIndexBackgroundColor: UIColor;
	sectionIndexTrackingBackgroundColor: UIColor;
	separatorStyle: number;
	separatorColor: UIColor;
	separatorEffect: UIVisualEffect;
	tableHeaderView: UIView;
	tableFooterView: UIView;
	constructor(frame: CGRect, style: number);
	constructor(frame: CGRect);
	constructor();
	initWithFrameStyle(frame: CGRect, style: number): UITableView;
	reloadData(): void;
	reloadSectionIndexTitles(): void;
	numberOfSections(): number;
	numberOfRowsInSection(section: number): number;
	rectForSection(section: number): CGRect;
	rectForHeaderInSection(section: number): CGRect;
	rectForFooterInSection(section: number): CGRect;
	rectForRowAtIndexPath(indexPath: NSIndexPath): CGRect;
	indexPathForRowAtPoint(point: CGPoint): NSIndexPath;
	indexPathForCell(cell: UITableViewCell): NSIndexPath;
	indexPathsForRowsInRect(rect: CGRect): NSArray;
	cellForRowAtIndexPath(indexPath: NSIndexPath): UITableViewCell;
	visibleCells(): NSArray;
	indexPathsForVisibleRows(): NSArray;
	headerViewForSection(section: number): UITableViewHeaderFooterView;
	footerViewForSection(section: number): UITableViewHeaderFooterView;
	scrollToRowAtIndexPathAtScrollPositionAnimated(indexPath: NSIndexPath, scrollPosition: number, animated: boolean): void;
	scrollToNearestSelectedRowAtScrollPositionAnimated(scrollPosition: number, animated: boolean): void;
	beginUpdates(): void;
	endUpdates(): void;
	insertSectionsWithRowAnimation(sections: NSIndexSet, animation: number): void;
	deleteSectionsWithRowAnimation(sections: NSIndexSet, animation: number): void;
	reloadSectionsWithRowAnimation(sections: NSIndexSet, animation: number): void;
	moveSectionToSection(section: number, newSection: number): void;
	insertRowsAtIndexPathsWithRowAnimation(indexPaths: NSArray, animation: number): void;
	deleteRowsAtIndexPathsWithRowAnimation(indexPaths: NSArray, animation: number): void;
	reloadRowsAtIndexPathsWithRowAnimation(indexPaths: NSArray, animation: number): void;
	moveRowAtIndexPathToIndexPath(indexPath: NSIndexPath, newIndexPath: NSIndexPath): void;
	setEditingAnimated(editing: boolean, animated: boolean): void;
	indexPathForSelectedRow(): NSIndexPath;
	indexPathsForSelectedRows(): NSArray;
	selectRowAtIndexPathAnimatedScrollPosition(indexPath: NSIndexPath, animated: boolean, scrollPosition: number): void;
	deselectRowAtIndexPathAnimated(indexPath: NSIndexPath, animated: boolean): void;
	dequeueReusableCellWithIdentifier(identifier: string): any;
	dequeueReusableCellWithIdentifierForIndexPath(identifier: string, indexPath: NSIndexPath): any;
	dequeueReusableHeaderFooterViewWithIdentifier(identifier: string): any;
	registerNibForCellReuseIdentifier(nib: UINib, identifier: string): void;
	registerClassForCellReuseIdentifier(cellClass: any, identifier: string): void;
	registerNibForHeaderFooterViewReuseIdentifier(nib: UINib, identifier: string): void;
	registerClassForHeaderFooterViewReuseIdentifier(aClass: any, identifier: string): void;
	initWithFrame(frame: CGRect): UITableView;
	init(): UITableView;
	static new(): UITableView;
	static allocWithZone(zone: any): UITableView;
	static alloc(): UITableView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIPickerView extends UIView implements NSCoding, UITableViewDataSource {
	dataSource: any;
	delegate: any;
	showsSelectionIndicator: boolean;
	numberOfComponents: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(frame: CGRect);
	constructor();
	numberOfRowsInComponent(component: number): number;
	rowSizeForComponent(component: number): CGSize;
	viewForRowForComponent(row: number, component: number): UIView;
	reloadAllComponents(): void;
	reloadComponent(component: number): void;
	selectRowInComponentAnimated(row: number, component: number, animated: boolean): void;
	selectedRowInComponent(component: number): number;
	initWithFrame(frame: CGRect): UIPickerView;
	init(): UIPickerView;
	static new(): UIPickerView;
	static allocWithZone(zone: any): UIPickerView;
	static alloc(): UIPickerView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	tableViewNumberOfRowsInSection(tableView: UITableView, section: number): number;
	tableViewCellForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UITableViewCell;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIAccessibilityCustomAction extends NSObject {
	name: string;
	target: any;
	selector: any;
	constructor(name: string, target: any, selector: any);
	constructor();
	initWithNameTargetSelector(name: string, target: any, selector: any): UIAccessibilityCustomAction;
	init(): UIAccessibilityCustomAction;
	static new(): UIAccessibilityCustomAction;
	static allocWithZone(zone: any): UIAccessibilityCustomAction;
	static alloc(): UIAccessibilityCustomAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIImage extends NSObject implements NSSecureCoding, UIAccessibilityIdentification {
	size: CGSize;
	CGImage: any;
	CIImage: CIImage;
	imageOrientation: number;
	scale: number;
	images: NSArray;
	duration: number;
	capInsets: UIEdgeInsets;
	resizingMode: number;
	alignmentRectInsets: UIEdgeInsets;
	renderingMode: number;
	traitCollection: UITraitCollection;
	imageAsset: UIImageAsset;
	leftCapWidth: number;
	topCapHeight: number;
	accessibilityIdentifier: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(path: string);
	constructor(data: NSData);
	constructor(data: NSData, scale: number);
	constructor(cgImage: any);
	constructor(cgImage: any, scale: number, orientation: number);
	constructor(ciImage: CIImage);
	constructor(ciImage: CIImage, scale: number, orientation: number);
	constructor();
	static imageNamed(name: string): UIImage;
	static imageNamedInBundleCompatibleWithTraitCollection(name: string, bundle: NSBundle, traitCollection: UITraitCollection): UIImage;
	static imageWithContentsOfFile(path: string): UIImage;
	static imageWithData(data: NSData): UIImage;
	static imageWithDataScale(data: NSData, scale: number): UIImage;
	static imageWithCGImage(cgImage: any): UIImage;
	static imageWithCGImageScaleOrientation(cgImage: any, scale: number, orientation: number): UIImage;
	static imageWithCIImage(ciImage: CIImage): UIImage;
	static imageWithCIImageScaleOrientation(ciImage: CIImage, scale: number, orientation: number): UIImage;
	initWithContentsOfFile(path: string): UIImage;
	initWithData(data: NSData): UIImage;
	initWithDataScale(data: NSData, scale: number): UIImage;
	initWithCGImage(cgImage: any): UIImage;
	initWithCGImageScaleOrientation(cgImage: any, scale: number, orientation: number): UIImage;
	initWithCIImage(ciImage: CIImage): UIImage;
	initWithCIImageScaleOrientation(ciImage: CIImage, scale: number, orientation: number): UIImage;
	static animatedImageNamedDuration(name: string, duration: number): UIImage;
	static animatedResizableImageNamedCapInsetsDuration(name: string, capInsets: UIEdgeInsets, duration: number): UIImage;
	static animatedResizableImageNamedCapInsetsResizingModeDuration(name: string, capInsets: UIEdgeInsets, resizingMode: number, duration: number): UIImage;
	static animatedImageWithImagesDuration(images: NSArray, duration: number): UIImage;
	drawAtPoint(point: CGPoint): void;
	drawAtPointBlendModeAlpha(point: CGPoint, blendMode: number, alpha: number): void;
	drawInRect(rect: CGRect): void;
	drawInRectBlendModeAlpha(rect: CGRect, blendMode: number, alpha: number): void;
	drawAsPatternInRect(rect: CGRect): void;
	resizableImageWithCapInsets(capInsets: UIEdgeInsets): UIImage;
	resizableImageWithCapInsetsResizingMode(capInsets: UIEdgeInsets, resizingMode: number): UIImage;
	imageWithAlignmentRectInsets(alignmentInsets: UIEdgeInsets): UIImage;
	imageWithRenderingMode(renderingMode: number): UIImage;
	stretchableImageWithLeftCapWidthTopCapHeight(leftCapWidth: number, topCapHeight: number): UIImage;
	init(): UIImage;
	static new(): UIImage;
	static allocWithZone(zone: any): UIImage;
	static alloc(): UIImage;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIBarItem extends NSObject implements UIAppearance, UIAccessibilityIdentification {
	enabled: boolean;
	title: string;
	image: UIImage;
	landscapeImagePhone: UIImage;
	imageInsets: UIEdgeInsets;
	landscapeImagePhoneInsets: UIEdgeInsets;
	tag: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	accessibilityIdentifier: string;
	constructor();
	setTitleTextAttributesForState(attributes: NSDictionary, state: number): void;
	titleTextAttributesForState(state: number): NSDictionary;
	init(): UIBarItem;
	static new(): UIBarItem;
	static allocWithZone(zone: any): UIBarItem;
	static alloc(): UIBarItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static appearance(): any;
	static appearanceWhenContainedIn(ContainerClass: any): any;
	static appearanceForTraitCollection(trait: UITraitCollection): any;
	static appearanceForTraitCollectionWhenContainedIn(trait: UITraitCollection, ContainerClass: any): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIAccessibilityElement extends NSObject implements UIAccessibilityIdentification {
	accessibilityContainer: any;
	accessibilityIdentifier: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(container: any);
	constructor();
	initWithAccessibilityContainer(container: any): UIAccessibilityElement;
	init(): UIAccessibilityElement;
	static new(): UIAccessibilityElement;
	static allocWithZone(zone: any): UIAccessibilityElement;
	static alloc(): UIAccessibilityElement;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIActivityIndicatorView extends UIView implements NSCoding {
	activityIndicatorViewStyle: number;
	hidesWhenStopped: boolean;
	color: UIColor;
	constructor(style: number);
	constructor(frame: CGRect);
	constructor();
	initWithActivityIndicatorStyle(style: number): UIActivityIndicatorView;
	startAnimating(): void;
	stopAnimating(): void;
	isAnimating(): boolean;
	initWithFrame(frame: CGRect): UIActivityIndicatorView;
	init(): UIActivityIndicatorView;
	static new(): UIActivityIndicatorView;
	static allocWithZone(zone: any): UIActivityIndicatorView;
	static alloc(): UIActivityIndicatorView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIActivity extends NSObject {
	constructor();
	static activityCategory(): number;
	activityType(): string;
	activityTitle(): string;
	activityImage(): UIImage;
	canPerformWithActivityItems(activityItems: NSArray): boolean;
	prepareWithActivityItems(activityItems: NSArray): void;
	activityViewController(): UIViewController;
	performActivity(): void;
	activityDidFinish(completed: boolean): void;
	init(): UIActivity;
	static new(): UIActivity;
	static allocWithZone(zone: any): UIActivity;
	static alloc(): UIActivity;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIActivityItemProvider extends NSOperation implements UIActivityItemSource {
	placeholderItem: any;
	activityType: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(placeholderItem: any);
	constructor();
	initWithPlaceholderItem(placeholderItem: any): UIActivityItemProvider;
	item(): any;
	init(): UIActivityItemProvider;
	static new(): UIActivityItemProvider;
	static allocWithZone(zone: any): UIActivityItemProvider;
	static alloc(): UIActivityItemProvider;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	activityViewControllerPlaceholderItem(activityViewController: UIActivityViewController): any;
	activityViewControllerItemForActivityType(activityViewController: UIActivityViewController, activityType: string): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIActivityViewController extends UIViewController {
	completionHandler: (arg1: string, arg2: boolean) => void;
	completionWithItemsHandler: (arg1: string, arg2: boolean, arg3: NSArray, arg4: NSError) => void;
	excludedActivityTypes: NSArray;
	constructor(activityItems: NSArray, applicationActivities: NSArray);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithActivityItemsApplicationActivities(activityItems: NSArray, applicationActivities: NSArray): UIActivityViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIActivityViewController;
	init(): UIActivityViewController;
	static new(): UIActivityViewController;
	static allocWithZone(zone: any): UIActivityViewController;
	static alloc(): UIActivityViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIAlertAction extends NSObject implements NSCopying {
	title: string;
	style: number;
	enabled: boolean;
	constructor();
	static actionWithTitleStyleHandler(title: string, style: number, handler: (arg1: UIAlertAction) => void): UIAlertAction;
	init(): UIAlertAction;
	static new(): UIAlertAction;
	static allocWithZone(zone: any): UIAlertAction;
	static alloc(): UIAlertAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class UIAlertController extends UIViewController {
	actions: NSArray;
	textFields: NSArray;
	message: string;
	preferredStyle: number;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static alertControllerWithTitleMessagePreferredStyle(title: string, message: string, preferredStyle: number): UIAlertController;
	addAction(action: UIAlertAction): void;
	addTextFieldWithConfigurationHandler(configurationHandler: (arg1: UITextField) => void): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIAlertController;
	init(): UIAlertController;
	static new(): UIAlertController;
	static allocWithZone(zone: any): UIAlertController;
	static alloc(): UIAlertController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIBarButtonItem extends UIBarItem implements NSCoding {
	style: number;
	width: number;
	possibleTitles: NSSet;
	customView: UIView;
	action: any;
	target: any;
	tintColor: UIColor;
	constructor(image: UIImage, style: number, target: any, action: any);
	constructor(image: UIImage, landscapeImagePhone: UIImage, style: number, target: any, action: any);
	constructor(title: string, style: number, target: any, action: any);
	constructor(systemItem: number, target: any, action: any);
	constructor(customView: UIView);
	constructor();
	initWithImageStyleTargetAction(image: UIImage, style: number, target: any, action: any): UIBarButtonItem;
	initWithImageLandscapeImagePhoneStyleTargetAction(image: UIImage, landscapeImagePhone: UIImage, style: number, target: any, action: any): UIBarButtonItem;
	initWithTitleStyleTargetAction(title: string, style: number, target: any, action: any): UIBarButtonItem;
	initWithBarButtonSystemItemTargetAction(systemItem: number, target: any, action: any): UIBarButtonItem;
	initWithCustomView(customView: UIView): UIBarButtonItem;
	setBackgroundImageForStateBarMetrics(backgroundImage: UIImage, state: number, barMetrics: number): void;
	backgroundImageForStateBarMetrics(state: number, barMetrics: number): UIImage;
	setBackgroundImageForStateStyleBarMetrics(backgroundImage: UIImage, state: number, style: number, barMetrics: number): void;
	backgroundImageForStateStyleBarMetrics(state: number, style: number, barMetrics: number): UIImage;
	setBackgroundVerticalPositionAdjustmentForBarMetrics(adjustment: number, barMetrics: number): void;
	backgroundVerticalPositionAdjustmentForBarMetrics(barMetrics: number): number;
	setTitlePositionAdjustmentForBarMetrics(adjustment: UIOffset, barMetrics: number): void;
	titlePositionAdjustmentForBarMetrics(barMetrics: number): UIOffset;
	setBackButtonBackgroundImageForStateBarMetrics(backgroundImage: UIImage, state: number, barMetrics: number): void;
	backButtonBackgroundImageForStateBarMetrics(state: number, barMetrics: number): UIImage;
	setBackButtonTitlePositionAdjustmentForBarMetrics(adjustment: UIOffset, barMetrics: number): void;
	backButtonTitlePositionAdjustmentForBarMetrics(barMetrics: number): UIOffset;
	setBackButtonBackgroundVerticalPositionAdjustmentForBarMetrics(adjustment: number, barMetrics: number): void;
	backButtonBackgroundVerticalPositionAdjustmentForBarMetrics(barMetrics: number): number;
	init(): UIBarButtonItem;
	static new(): UIBarButtonItem;
	static allocWithZone(zone: any): UIBarButtonItem;
	static alloc(): UIBarButtonItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIButton extends UIControl implements NSCoding {
	contentEdgeInsets: UIEdgeInsets;
	titleEdgeInsets: UIEdgeInsets;
	reversesTitleShadowWhenHighlighted: boolean;
	imageEdgeInsets: UIEdgeInsets;
	adjustsImageWhenHighlighted: boolean;
	adjustsImageWhenDisabled: boolean;
	showsTouchWhenHighlighted: boolean;
	buttonType: number;
	currentTitle: string;
	currentTitleColor: UIColor;
	currentTitleShadowColor: UIColor;
	currentImage: UIImage;
	currentBackgroundImage: UIImage;
	currentAttributedTitle: NSAttributedString;
	titleLabel: UILabel;
	imageView: UIImageView;
	font: UIFont;
	lineBreakMode: number;
	titleShadowOffset: CGSize;
	constructor(frame: CGRect);
	constructor();
	static buttonWithType(buttonType: number): any;
	setTitleForState(title: string, state: number): void;
	setTitleColorForState(color: UIColor, state: number): void;
	setTitleShadowColorForState(color: UIColor, state: number): void;
	setImageForState(image: UIImage, state: number): void;
	setBackgroundImageForState(image: UIImage, state: number): void;
	setAttributedTitleForState(title: NSAttributedString, state: number): void;
	titleForState(state: number): string;
	titleColorForState(state: number): UIColor;
	titleShadowColorForState(state: number): UIColor;
	imageForState(state: number): UIImage;
	backgroundImageForState(state: number): UIImage;
	attributedTitleForState(state: number): NSAttributedString;
	backgroundRectForBounds(bounds: CGRect): CGRect;
	contentRectForBounds(bounds: CGRect): CGRect;
	titleRectForContentRect(contentRect: CGRect): CGRect;
	imageRectForContentRect(contentRect: CGRect): CGRect;
	initWithFrame(frame: CGRect): UIButton;
	init(): UIButton;
	static new(): UIButton;
	static allocWithZone(zone: any): UIButton;
	static alloc(): UIButton;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UICollectionView extends UIScrollView {
	collectionViewLayout: UICollectionViewLayout;
	dataSource: any;
	backgroundView: UIView;
	allowsSelection: boolean;
	allowsMultipleSelection: boolean;
	constructor(frame: CGRect, layout: UICollectionViewLayout);
	constructor(frame: CGRect);
	constructor();
	initWithFrameCollectionViewLayout(frame: CGRect, layout: UICollectionViewLayout): UICollectionView;
	registerClassForCellWithReuseIdentifier(cellClass: any, identifier: string): void;
	registerNibForCellWithReuseIdentifier(nib: UINib, identifier: string): void;
	registerClassForSupplementaryViewOfKindWithReuseIdentifier(viewClass: any, elementKind: string, identifier: string): void;
	registerNibForSupplementaryViewOfKindWithReuseIdentifier(nib: UINib, kind: string, identifier: string): void;
	dequeueReusableCellWithReuseIdentifierForIndexPath(identifier: string, indexPath: NSIndexPath): any;
	dequeueReusableSupplementaryViewOfKindWithReuseIdentifierForIndexPath(elementKind: string, identifier: string, indexPath: NSIndexPath): any;
	indexPathsForSelectedItems(): NSArray;
	selectItemAtIndexPathAnimatedScrollPosition(indexPath: NSIndexPath, animated: boolean, scrollPosition: number): void;
	deselectItemAtIndexPathAnimated(indexPath: NSIndexPath, animated: boolean): void;
	reloadData(): void;
	setCollectionViewLayoutAnimated(layout: UICollectionViewLayout, animated: boolean): void;
	setCollectionViewLayoutAnimatedCompletion(layout: UICollectionViewLayout, animated: boolean, completion: (arg1: boolean) => void): void;
	startInteractiveTransitionToCollectionViewLayoutCompletion(layout: UICollectionViewLayout, completion: (arg1: boolean, arg2: boolean) => void): UICollectionViewTransitionLayout;
	finishInteractiveTransition(): void;
	cancelInteractiveTransition(): void;
	numberOfSections(): number;
	numberOfItemsInSection(section: number): number;
	layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	layoutAttributesForSupplementaryElementOfKindAtIndexPath(kind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	indexPathForItemAtPoint(point: CGPoint): NSIndexPath;
	indexPathForCell(cell: UICollectionViewCell): NSIndexPath;
	cellForItemAtIndexPath(indexPath: NSIndexPath): UICollectionViewCell;
	visibleCells(): NSArray;
	indexPathsForVisibleItems(): NSArray;
	scrollToItemAtIndexPathAtScrollPositionAnimated(indexPath: NSIndexPath, scrollPosition: number, animated: boolean): void;
	insertSections(sections: NSIndexSet): void;
	deleteSections(sections: NSIndexSet): void;
	reloadSections(sections: NSIndexSet): void;
	moveSectionToSection(section: number, newSection: number): void;
	insertItemsAtIndexPaths(indexPaths: NSArray): void;
	deleteItemsAtIndexPaths(indexPaths: NSArray): void;
	reloadItemsAtIndexPaths(indexPaths: NSArray): void;
	moveItemAtIndexPathToIndexPath(indexPath: NSIndexPath, newIndexPath: NSIndexPath): void;
	performBatchUpdatesCompletion(updates: () => void, completion: (arg1: boolean) => void): void;
	initWithFrame(frame: CGRect): UICollectionView;
	init(): UICollectionView;
	static new(): UICollectionView;
	static allocWithZone(zone: any): UICollectionView;
	static alloc(): UICollectionView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionReusableView extends UIView {
	reuseIdentifier: string;
	constructor(frame: CGRect);
	constructor();
	prepareForReuse(): void;
	applyLayoutAttributes(layoutAttributes: UICollectionViewLayoutAttributes): void;
	willTransitionFromLayoutToLayout(oldLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout): void;
	didTransitionFromLayoutToLayout(oldLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout): void;
	preferredLayoutAttributesFittingAttributes(layoutAttributes: UICollectionViewLayoutAttributes): UICollectionViewLayoutAttributes;
	initWithFrame(frame: CGRect): UICollectionReusableView;
	init(): UICollectionReusableView;
	static new(): UICollectionReusableView;
	static allocWithZone(zone: any): UICollectionReusableView;
	static alloc(): UICollectionReusableView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionViewCell extends UICollectionReusableView {
	contentView: UIView;
	selected: boolean;
	highlighted: boolean;
	backgroundView: UIView;
	selectedBackgroundView: UIView;
	constructor(frame: CGRect);
	constructor();
	initWithFrame(frame: CGRect): UICollectionViewCell;
	init(): UICollectionViewCell;
	static new(): UICollectionViewCell;
	static allocWithZone(zone: any): UICollectionViewCell;
	static alloc(): UICollectionViewCell;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionViewController extends UIViewController implements UICollectionViewDelegate, UICollectionViewDataSource {
	collectionView: UICollectionView;
	clearsSelectionOnViewWillAppear: boolean;
	useLayoutToLayoutNavigationTransitions: boolean;
	collectionViewLayout: UICollectionViewLayout;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(layout: UICollectionViewLayout);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithCollectionViewLayout(layout: UICollectionViewLayout): UICollectionViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UICollectionViewController;
	init(): UICollectionViewController;
	static new(): UICollectionViewController;
	static allocWithZone(zone: any): UICollectionViewController;
	static alloc(): UICollectionViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	collectionViewNumberOfItemsInSection(collectionView: UICollectionView, section: number): number;
	collectionViewCellForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): UICollectionViewCell;
}
declare class UICollectionViewLayoutAttributes extends NSObject implements NSCopying, UIDynamicItem {
	frame: CGRect;
	size: CGSize;
	transform3D: CATransform3D;
	bounds: CGRect;
	alpha: number;
	zIndex: number;
	hidden: boolean;
	indexPath: NSIndexPath;
	representedElementCategory: number;
	representedElementKind: string;
	center: CGPoint;
	transform: CGAffineTransform;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static layoutAttributesForCellWithIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	static layoutAttributesForSupplementaryViewOfKindWithIndexPath(elementKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	static layoutAttributesForDecorationViewOfKindWithIndexPath(decorationViewKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	init(): UICollectionViewLayoutAttributes;
	static new(): UICollectionViewLayoutAttributes;
	static allocWithZone(zone: any): UICollectionViewLayoutAttributes;
	static alloc(): UICollectionViewLayoutAttributes;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UICollectionViewUpdateItem extends NSObject {
	indexPathBeforeUpdate: NSIndexPath;
	indexPathAfterUpdate: NSIndexPath;
	updateAction: number;
	constructor();
	init(): UICollectionViewUpdateItem;
	static new(): UICollectionViewUpdateItem;
	static allocWithZone(zone: any): UICollectionViewUpdateItem;
	static alloc(): UICollectionViewUpdateItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionViewLayoutInvalidationContext extends NSObject {
	invalidateEverything: boolean;
	invalidateDataSourceCounts: boolean;
	invalidatedItemIndexPaths: NSArray;
	invalidatedSupplementaryIndexPaths: NSDictionary;
	invalidatedDecorationIndexPaths: NSDictionary;
	contentOffsetAdjustment: CGPoint;
	contentSizeAdjustment: CGSize;
	constructor();
	invalidateItemsAtIndexPaths(indexPaths: NSArray): void;
	invalidateSupplementaryElementsOfKindAtIndexPaths(elementKind: string, indexPaths: NSArray): void;
	invalidateDecorationElementsOfKindAtIndexPaths(elementKind: string, indexPaths: NSArray): void;
	init(): UICollectionViewLayoutInvalidationContext;
	static new(): UICollectionViewLayoutInvalidationContext;
	static allocWithZone(zone: any): UICollectionViewLayoutInvalidationContext;
	static alloc(): UICollectionViewLayoutInvalidationContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionViewLayout extends NSObject implements NSCoding {
	collectionView: UICollectionView;
	constructor();
	invalidateLayout(): void;
	invalidateLayoutWithContext(context: UICollectionViewLayoutInvalidationContext): void;
	registerClassForDecorationViewOfKind(viewClass: any, elementKind: string): void;
	registerNibForDecorationViewOfKind(nib: UINib, elementKind: string): void;
	static layoutAttributesClass(): any;
	static invalidationContextClass(): any;
	prepareLayout(): void;
	layoutAttributesForElementsInRect(rect: CGRect): NSArray;
	layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	layoutAttributesForSupplementaryViewOfKindAtIndexPath(elementKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	layoutAttributesForDecorationViewOfKindAtIndexPath(elementKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	shouldInvalidateLayoutForBoundsChange(newBounds: CGRect): boolean;
	invalidationContextForBoundsChange(newBounds: CGRect): UICollectionViewLayoutInvalidationContext;
	shouldInvalidateLayoutForPreferredLayoutAttributesWithOriginalAttributes(preferredAttributes: UICollectionViewLayoutAttributes, originalAttributes: UICollectionViewLayoutAttributes): boolean;
	invalidationContextForPreferredLayoutAttributesWithOriginalAttributes(preferredAttributes: UICollectionViewLayoutAttributes, originalAttributes: UICollectionViewLayoutAttributes): UICollectionViewLayoutInvalidationContext;
	targetContentOffsetForProposedContentOffsetWithScrollingVelocity(proposedContentOffset: CGPoint, velocity: CGPoint): CGPoint;
	targetContentOffsetForProposedContentOffset(proposedContentOffset: CGPoint): CGPoint;
	collectionViewContentSize(): CGSize;
	prepareForCollectionViewUpdates(updateItems: NSArray): void;
	finalizeCollectionViewUpdates(): void;
	prepareForAnimatedBoundsChange(oldBounds: CGRect): void;
	finalizeAnimatedBoundsChange(): void;
	prepareForTransitionToLayout(newLayout: UICollectionViewLayout): void;
	prepareForTransitionFromLayout(oldLayout: UICollectionViewLayout): void;
	finalizeLayoutTransition(): void;
	initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	initialLayoutAttributesForAppearingSupplementaryElementOfKindAtIndexPath(elementKind: string, elementIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	finalLayoutAttributesForDisappearingSupplementaryElementOfKindAtIndexPath(elementKind: string, elementIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	initialLayoutAttributesForAppearingDecorationElementOfKindAtIndexPath(elementKind: string, decorationIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	finalLayoutAttributesForDisappearingDecorationElementOfKindAtIndexPath(elementKind: string, decorationIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	indexPathsToDeleteForSupplementaryViewOfKind(elementKind: string): NSArray;
	indexPathsToDeleteForDecorationViewOfKind(elementKind: string): NSArray;
	indexPathsToInsertForSupplementaryViewOfKind(elementKind: string): NSArray;
	indexPathsToInsertForDecorationViewOfKind(elementKind: string): NSArray;
	init(): UICollectionViewLayout;
	static new(): UICollectionViewLayout;
	static allocWithZone(zone: any): UICollectionViewLayout;
	static alloc(): UICollectionViewLayout;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UICollectionViewFlowLayoutInvalidationContext extends UICollectionViewLayoutInvalidationContext {
	invalidateFlowLayoutDelegateMetrics: boolean;
	invalidateFlowLayoutAttributes: boolean;
	constructor();
	init(): UICollectionViewFlowLayoutInvalidationContext;
	static new(): UICollectionViewFlowLayoutInvalidationContext;
	static allocWithZone(zone: any): UICollectionViewFlowLayoutInvalidationContext;
	static alloc(): UICollectionViewFlowLayoutInvalidationContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionViewFlowLayout extends UICollectionViewLayout {
	minimumLineSpacing: number;
	minimumInteritemSpacing: number;
	itemSize: CGSize;
	estimatedItemSize: CGSize;
	scrollDirection: number;
	headerReferenceSize: CGSize;
	footerReferenceSize: CGSize;
	sectionInset: UIEdgeInsets;
	constructor();
	init(): UICollectionViewFlowLayout;
	static new(): UICollectionViewFlowLayout;
	static allocWithZone(zone: any): UICollectionViewFlowLayout;
	static alloc(): UICollectionViewFlowLayout;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollectionViewTransitionLayout extends UICollectionViewLayout {
	transitionProgress: number;
	currentLayout: UICollectionViewLayout;
	nextLayout: UICollectionViewLayout;
	constructor(currentLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout);
	constructor();
	initWithCurrentLayoutNextLayout(currentLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout): UICollectionViewTransitionLayout;
	updateValueForAnimatedKey(value: number, key: string): void;
	valueForAnimatedKey(key: string): number;
	init(): UICollectionViewTransitionLayout;
	static new(): UICollectionViewTransitionLayout;
	static allocWithZone(zone: any): UICollectionViewTransitionLayout;
	static alloc(): UICollectionViewTransitionLayout;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDatePicker extends UIControl implements NSCoding {
	datePickerMode: number;
	locale: NSLocale;
	calendar: NSCalendar;
	timeZone: NSTimeZone;
	date: NSDate;
	minimumDate: NSDate;
	maximumDate: NSDate;
	countDownDuration: number;
	minuteInterval: number;
	constructor(frame: CGRect);
	constructor();
	setDateAnimated(date: NSDate, animated: boolean): void;
	initWithFrame(frame: CGRect): UIDatePicker;
	init(): UIDatePicker;
	static new(): UIDatePicker;
	static allocWithZone(zone: any): UIDatePicker;
	static alloc(): UIDatePicker;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIDocument extends NSObject implements NSFilePresenter {
	fileURL: NSURL;
	localizedName: string;
	fileType: string;
	fileModificationDate: NSDate;
	documentState: number;
	undoManager: NSUndoManager;
	userActivity: NSUserActivity;
	presentedItemURL: NSURL;
	presentedItemOperationQueue: NSOperationQueue;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(url: NSURL);
	constructor();
	initWithFileURL(url: NSURL): UIDocument;
	openWithCompletionHandler(completionHandler: (arg1: boolean) => void): void;
	closeWithCompletionHandler(completionHandler: (arg1: boolean) => void): void;
	loadFromContentsOfTypeError(contents: any, typeName: string, outError: any): boolean;
	contentsForTypeError(typeName: string, outError: any): any;
	disableEditing(): void;
	enableEditing(): void;
	hasUnsavedChanges(): boolean;
	updateChangeCount(change: number): void;
	changeCountTokenForSaveOperation(saveOperation: number): any;
	updateChangeCountWithTokenForSaveOperation(changeCountToken: any, saveOperation: number): void;
	saveToURLForSaveOperationCompletionHandler(url: NSURL, saveOperation: number, completionHandler: (arg1: boolean) => void): void;
	autosaveWithCompletionHandler(completionHandler: (arg1: boolean) => void): void;
	savingFileType(): string;
	fileNameExtensionForTypeSaveOperation(typeName: string, saveOperation: number): string;
	writeContentsAndAttributesSafelyToURLForSaveOperationError(contents: any, additionalFileAttributes: NSDictionary, url: NSURL, saveOperation: number, outError: any): boolean;
	writeContentsToURLForSaveOperationOriginalContentsURLError(contents: any, url: NSURL, saveOperation: number, originalContentsURL: NSURL, outError: any): boolean;
	fileAttributesToWriteToURLForSaveOperationError(url: NSURL, saveOperation: number, outError: any): NSDictionary;
	readFromURLError(url: NSURL, outError: any): boolean;
	performAsynchronousFileAccessUsingBlock(block: () => void): void;
	handleErrorUserInteractionPermitted(error: NSError, userInteractionPermitted: boolean): void;
	finishedHandlingErrorRecovered(error: NSError, recovered: boolean): void;
	userInteractionNoLongerPermittedForError(error: NSError): void;
	revertToContentsOfURLCompletionHandler(url: NSURL, completionHandler: (arg1: boolean) => void): void;
	updateUserActivityState(userActivity: NSUserActivity): void;
	restoreUserActivityState(userActivity: NSUserActivity): void;
	init(): UIDocument;
	static new(): UIDocument;
	static allocWithZone(zone: any): UIDocument;
	static alloc(): UIDocument;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIDocumentInteractionController extends NSObject implements UIActionSheetDelegate {
	delegate: any;
	URL: NSURL;
	UTI: string;
	name: string;
	icons: NSArray;
	annotation: any;
	gestureRecognizers: NSArray;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static interactionControllerWithURL(url: NSURL): UIDocumentInteractionController;
	presentOptionsMenuFromRectInViewAnimated(rect: CGRect, view: UIView, animated: boolean): boolean;
	presentOptionsMenuFromBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): boolean;
	presentPreviewAnimated(animated: boolean): boolean;
	presentOpenInMenuFromRectInViewAnimated(rect: CGRect, view: UIView, animated: boolean): boolean;
	presentOpenInMenuFromBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): boolean;
	dismissPreviewAnimated(animated: boolean): void;
	dismissMenuAnimated(animated: boolean): void;
	init(): UIDocumentInteractionController;
	static new(): UIDocumentInteractionController;
	static allocWithZone(zone: any): UIDocumentInteractionController;
	static alloc(): UIDocumentInteractionController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIDocumentPickerViewController extends UIViewController {
	delegate: any;
	documentPickerMode: number;
	constructor(allowedUTIs: NSArray, mode: number);
	constructor(url: NSURL, mode: number);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithDocumentTypesInMode(allowedUTIs: NSArray, mode: number): UIDocumentPickerViewController;
	initWithURLInMode(url: NSURL, mode: number): UIDocumentPickerViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIDocumentPickerViewController;
	init(): UIDocumentPickerViewController;
	static new(): UIDocumentPickerViewController;
	static allocWithZone(zone: any): UIDocumentPickerViewController;
	static alloc(): UIDocumentPickerViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDocumentMenuViewController extends UIViewController {
	delegate: any;
	constructor(allowedUTIs: NSArray, mode: number);
	constructor(url: NSURL, mode: number);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithDocumentTypesInMode(allowedUTIs: NSArray, mode: number): UIDocumentMenuViewController;
	initWithURLInMode(url: NSURL, mode: number): UIDocumentMenuViewController;
	addOptionWithTitleImageOrderHandler(title: string, image: UIImage, order: number, handler: () => void): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIDocumentMenuViewController;
	init(): UIDocumentMenuViewController;
	static new(): UIDocumentMenuViewController;
	static allocWithZone(zone: any): UIDocumentMenuViewController;
	static alloc(): UIDocumentMenuViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDocumentPickerExtensionViewController extends UIViewController {
	documentPickerMode: number;
	originalURL: NSURL;
	validTypes: NSArray;
	providerIdentifier: string;
	documentStorageURL: NSURL;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	dismissGrantingAccessToURL(url: NSURL): void;
	prepareForPresentationInMode(mode: number): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIDocumentPickerExtensionViewController;
	init(): UIDocumentPickerExtensionViewController;
	static new(): UIDocumentPickerExtensionViewController;
	static allocWithZone(zone: any): UIDocumentPickerExtensionViewController;
	static alloc(): UIDocumentPickerExtensionViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSFileProviderExtension extends NSObject {
	constructor();
	static writePlaceholderAtURLWithMetadataError(placeholderURL: NSURL, metadata: NSDictionary, error: any): boolean;
	static placeholderURLForURL(url: NSURL): NSURL;
	providerIdentifier(): string;
	documentStorageURL(): NSURL;
	URLForItemWithPersistentIdentifier(identifier: string): NSURL;
	persistentIdentifierForItemAtURL(url: NSURL): string;
	providePlaceholderAtURLCompletionHandler(url: NSURL, completionHandler: (arg1: NSError) => void): void;
	startProvidingItemAtURLCompletionHandler(url: NSURL, completionHandler: (arg1: NSError) => void): void;
	itemChangedAtURL(url: NSURL): void;
	stopProvidingItemAtURL(url: NSURL): void;
	init(): NSFileProviderExtension;
	static new(): NSFileProviderExtension;
	static allocWithZone(zone: any): NSFileProviderExtension;
	static alloc(): NSFileProviderExtension;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIVisualEffect extends NSObject implements NSCopying, NSSecureCoding {
	constructor();
	init(): UIVisualEffect;
	static new(): UIVisualEffect;
	static allocWithZone(zone: any): UIVisualEffect;
	static alloc(): UIVisualEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIBlurEffect extends UIVisualEffect {
	constructor();
	static effectWithStyle(style: number): UIBlurEffect;
	init(): UIBlurEffect;
	static new(): UIBlurEffect;
	static allocWithZone(zone: any): UIBlurEffect;
	static alloc(): UIBlurEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIVibrancyEffect extends UIVisualEffect {
	constructor();
	static effectForBlurEffect(blurEffect: UIBlurEffect): UIVibrancyEffect;
	static notificationCenterVibrancyEffect(): UIVibrancyEffect;
	init(): UIVibrancyEffect;
	static new(): UIVibrancyEffect;
	static allocWithZone(zone: any): UIVibrancyEffect;
	static alloc(): UIVibrancyEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIVisualEffectView extends UIView implements NSSecureCoding {
	contentView: UIView;
	effect: UIVisualEffect;
	constructor(effect: UIVisualEffect);
	constructor(frame: CGRect);
	constructor();
	initWithEffect(effect: UIVisualEffect): UIVisualEffectView;
	initWithFrame(frame: CGRect): UIVisualEffectView;
	init(): UIVisualEffectView;
	static new(): UIVisualEffectView;
	static allocWithZone(zone: any): UIVisualEffectView;
	static alloc(): UIVisualEffectView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIImageAsset extends NSObject implements NSSecureCoding {
	constructor();
	imageWithTraitCollection(traitCollection: UITraitCollection): UIImage;
	registerImageWithTraitCollection(image: UIImage, traitCollection: UITraitCollection): void;
	unregisterImageWithTraitCollection(traitCollection: UITraitCollection): void;
	init(): UIImageAsset;
	static new(): UIImageAsset;
	static allocWithZone(zone: any): UIImageAsset;
	static alloc(): UIImageAsset;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIImagePickerController extends UINavigationController implements NSCoding {
	sourceType: number;
	mediaTypes: NSArray;
	allowsEditing: boolean;
	allowsImageEditing: boolean;
	videoMaximumDuration: number;
	videoQuality: number;
	showsCameraControls: boolean;
	cameraOverlayView: UIView;
	cameraViewTransform: CGAffineTransform;
	cameraCaptureMode: number;
	cameraDevice: number;
	cameraFlashMode: number;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static isSourceTypeAvailable(sourceType: number): boolean;
	static availableMediaTypesForSourceType(sourceType: number): NSArray;
	static isCameraDeviceAvailable(cameraDevice: number): boolean;
	static isFlashAvailableForCameraDevice(cameraDevice: number): boolean;
	static availableCaptureModesForCameraDevice(cameraDevice: number): NSArray;
	takePicture(): void;
	startVideoCapture(): boolean;
	stopVideoCapture(): void;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): UIImagePickerController;
	initWithRootViewController(rootViewController: UIViewController): UIImagePickerController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIImagePickerController;
	init(): UIImagePickerController;
	static new(): UIImagePickerController;
	static allocWithZone(zone: any): UIImagePickerController;
	static alloc(): UIImagePickerController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIImageView extends UIView {
	image: UIImage;
	highlightedImage: UIImage;
	highlighted: boolean;
	animationImages: NSArray;
	highlightedAnimationImages: NSArray;
	animationDuration: number;
	animationRepeatCount: number;
	constructor(image: UIImage);
	constructor(image: UIImage, highlightedImage: UIImage);
	constructor(frame: CGRect);
	constructor();
	initWithImage(image: UIImage): UIImageView;
	initWithImageHighlightedImage(image: UIImage, highlightedImage: UIImage): UIImageView;
	startAnimating(): void;
	stopAnimating(): void;
	isAnimating(): boolean;
	initWithFrame(frame: CGRect): UIImageView;
	init(): UIImageView;
	static new(): UIImageView;
	static allocWithZone(zone: any): UIImageView;
	static alloc(): UIImageView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIInputView extends UIView {
	inputViewStyle: number;
	constructor(frame: CGRect, inputViewStyle: number);
	constructor(frame: CGRect);
	constructor();
	initWithFrameInputViewStyle(frame: CGRect, inputViewStyle: number): UIInputView;
	initWithFrame(frame: CGRect): UIInputView;
	init(): UIInputView;
	static new(): UIInputView;
	static allocWithZone(zone: any): UIInputView;
	static alloc(): UIInputView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIInputViewController extends UIViewController implements UITextInputDelegate {
	inputView: UIInputView;
	textDocumentProxy: NSObject;
	primaryLanguage: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	dismissKeyboard(): void;
	advanceToNextInputMode(): void;
	requestSupplementaryLexiconWithCompletion(completionHandler: (arg1: UILexicon) => void): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIInputViewController;
	init(): UIInputViewController;
	static new(): UIInputViewController;
	static allocWithZone(zone: any): UIInputViewController;
	static alloc(): UIInputViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	selectionWillChange(textInput: any): void;
	selectionDidChange(textInput: any): void;
	textWillChange(textInput: any): void;
	textDidChange(textInput: any): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UILabel extends UIView implements NSCoding {
	text: string;
	font: UIFont;
	textColor: UIColor;
	shadowColor: UIColor;
	shadowOffset: CGSize;
	textAlignment: number;
	lineBreakMode: number;
	attributedText: NSAttributedString;
	highlightedTextColor: UIColor;
	highlighted: boolean;
	enabled: boolean;
	numberOfLines: number;
	adjustsFontSizeToFitWidth: boolean;
	adjustsLetterSpacingToFitWidth: boolean;
	minimumFontSize: number;
	baselineAdjustment: number;
	minimumScaleFactor: number;
	preferredMaxLayoutWidth: number;
	constructor(frame: CGRect);
	constructor();
	textRectForBoundsLimitedToNumberOfLines(bounds: CGRect, numberOfLines: number): CGRect;
	drawTextInRect(rect: CGRect): void;
	initWithFrame(frame: CGRect): UILabel;
	init(): UILabel;
	static new(): UILabel;
	static allocWithZone(zone: any): UILabel;
	static alloc(): UILabel;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UILexiconEntry extends NSObject implements NSCopying {
	documentText: string;
	userInput: string;
	constructor();
	init(): UILexiconEntry;
	static new(): UILexiconEntry;
	static allocWithZone(zone: any): UILexiconEntry;
	static alloc(): UILexiconEntry;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class UILexicon extends NSObject implements NSCopying {
	entries: NSArray;
	constructor();
	init(): UILexicon;
	static new(): UILexicon;
	static allocWithZone(zone: any): UILexicon;
	static alloc(): UILexicon;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class UILocalNotification extends NSObject implements NSCopying, NSCoding {
	fireDate: NSDate;
	timeZone: NSTimeZone;
	repeatInterval: number;
	repeatCalendar: NSCalendar;
	region: CLRegion;
	regionTriggersOnce: boolean;
	alertBody: string;
	hasAction: boolean;
	alertAction: string;
	alertLaunchImage: string;
	soundName: string;
	applicationIconBadgeNumber: number;
	userInfo: NSDictionary;
	category: string;
	constructor();
	init(): UILocalNotification;
	static new(): UILocalNotification;
	static allocWithZone(zone: any): UILocalNotification;
	static alloc(): UILocalNotification;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIUserNotificationSettings extends NSObject {
	types: number;
	categories: NSSet;
	constructor();
	static settingsForTypesCategories(types: number, categories: NSSet): UIUserNotificationSettings;
	init(): UIUserNotificationSettings;
	static new(): UIUserNotificationSettings;
	static allocWithZone(zone: any): UIUserNotificationSettings;
	static alloc(): UIUserNotificationSettings;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIUserNotificationCategory extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
	identifier: string;
	constructor();
	actionsForContext(context: number): NSArray;
	init(): UIUserNotificationCategory;
	static new(): UIUserNotificationCategory;
	static allocWithZone(zone: any): UIUserNotificationCategory;
	static alloc(): UIUserNotificationCategory;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIMutableUserNotificationCategory extends UIUserNotificationCategory {
	identifier: string;
	constructor();
	setActionsForContext(actions: NSArray, context: number): void;
	init(): UIMutableUserNotificationCategory;
	static new(): UIMutableUserNotificationCategory;
	static allocWithZone(zone: any): UIMutableUserNotificationCategory;
	static alloc(): UIMutableUserNotificationCategory;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIUserNotificationAction extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
	identifier: string;
	title: string;
	activationMode: number;
	authenticationRequired: boolean;
	destructive: boolean;
	constructor();
	init(): UIUserNotificationAction;
	static new(): UIUserNotificationAction;
	static allocWithZone(zone: any): UIUserNotificationAction;
	static alloc(): UIUserNotificationAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIMutableUserNotificationAction extends UIUserNotificationAction {
	identifier: string;
	title: string;
	activationMode: number;
	authenticationRequired: boolean;
	destructive: boolean;
	constructor();
	init(): UIMutableUserNotificationAction;
	static new(): UIMutableUserNotificationAction;
	static allocWithZone(zone: any): UIMutableUserNotificationAction;
	static alloc(): UIMutableUserNotificationAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UILocalizedIndexedCollation extends NSObject {
	sectionTitles: NSArray;
	sectionIndexTitles: NSArray;
	constructor();
	static currentCollation(): any;
	sectionForSectionIndexTitleAtIndex(indexTitleIndex: number): number;
	sectionForObjectCollationStringSelector(object: any, selector: any): number;
	sortedArrayFromArrayCollationStringSelector(array: NSArray, selector: any): NSArray;
	init(): UILocalizedIndexedCollation;
	static new(): UILocalizedIndexedCollation;
	static allocWithZone(zone: any): UILocalizedIndexedCollation;
	static alloc(): UILocalizedIndexedCollation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UILongPressGestureRecognizer extends UIGestureRecognizer {
	numberOfTapsRequired: number;
	numberOfTouchesRequired: number;
	minimumPressDuration: number;
	allowableMovement: number;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UILongPressGestureRecognizer;
	init(): UILongPressGestureRecognizer;
	static new(): UILongPressGestureRecognizer;
	static allocWithZone(zone: any): UILongPressGestureRecognizer;
	static alloc(): UILongPressGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIManagedDocument extends UIDocument {
	managedObjectContext: NSManagedObjectContext;
	managedObjectModel: NSManagedObjectModel;
	persistentStoreOptions: NSDictionary;
	modelConfiguration: string;
	constructor(url: NSURL);
	constructor();
	static persistentStoreName(): string;
	configurePersistentStoreCoordinatorForURLOfTypeModelConfigurationStoreOptionsError(storeURL: NSURL, fileType: string, configuration: string, storeOptions: NSDictionary, error: any): boolean;
	persistentStoreTypeForFileType(fileType: string): string;
	readAdditionalContentFromURLError(absoluteURL: NSURL, error: any): boolean;
	additionalContentForURLError(absoluteURL: NSURL, error: any): any;
	writeAdditionalContentToURLOriginalContentsURLError(content: any, absoluteURL: NSURL, absoluteOriginalContentsURL: NSURL, error: any): boolean;
	initWithFileURL(url: NSURL): UIManagedDocument;
	init(): UIManagedDocument;
	static new(): UIManagedDocument;
	static allocWithZone(zone: any): UIManagedDocument;
	static alloc(): UIManagedDocument;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIMenuController extends NSObject {
	menuVisible: boolean;
	arrowDirection: number;
	menuItems: NSArray;
	menuFrame: CGRect;
	constructor();
	static sharedMenuController(): UIMenuController;
	setMenuVisibleAnimated(menuVisible: boolean, animated: boolean): void;
	setTargetRectInView(targetRect: CGRect, targetView: UIView): void;
	update(): void;
	init(): UIMenuController;
	static new(): UIMenuController;
	static allocWithZone(zone: any): UIMenuController;
	static alloc(): UIMenuController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIMenuItem extends NSObject {
	title: string;
	action: any;
	constructor(title: string, action: any);
	constructor();
	initWithTitleAction(title: string, action: any): UIMenuItem;
	init(): UIMenuItem;
	static new(): UIMenuItem;
	static allocWithZone(zone: any): UIMenuItem;
	static alloc(): UIMenuItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIMotionEffect extends NSObject implements NSCopying, NSCoding {
	constructor();
	keyPathsAndRelativeValuesForViewerOffset(viewerOffset: UIOffset): NSDictionary;
	init(): UIMotionEffect;
	static new(): UIMotionEffect;
	static allocWithZone(zone: any): UIMotionEffect;
	static alloc(): UIMotionEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIInterpolatingMotionEffect extends UIMotionEffect {
	keyPath: string;
	type: number;
	minimumRelativeValue: any;
	maximumRelativeValue: any;
	constructor(keyPath: string, type: number);
	constructor();
	initWithKeyPathType(keyPath: string, type: number): UIInterpolatingMotionEffect;
	init(): UIInterpolatingMotionEffect;
	static new(): UIInterpolatingMotionEffect;
	static allocWithZone(zone: any): UIInterpolatingMotionEffect;
	static alloc(): UIInterpolatingMotionEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIMotionEffectGroup extends UIMotionEffect {
	motionEffects: NSArray;
	constructor();
	init(): UIMotionEffectGroup;
	static new(): UIMotionEffectGroup;
	static allocWithZone(zone: any): UIMotionEffectGroup;
	static alloc(): UIMotionEffectGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UINavigationBar extends UIView implements NSCoding, UIBarPositioning {
	barStyle: number;
	delegate: any;
	translucent: boolean;
	topItem: UINavigationItem;
	backItem: UINavigationItem;
	items: NSArray;
	barTintColor: UIColor;
	shadowImage: UIImage;
	titleTextAttributes: NSDictionary;
	backIndicatorImage: UIImage;
	backIndicatorTransitionMaskImage: UIImage;
	barPosition: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(frame: CGRect);
	constructor();
	pushNavigationItemAnimated(item: UINavigationItem, animated: boolean): void;
	popNavigationItemAnimated(animated: boolean): UINavigationItem;
	setItemsAnimated(items: NSArray, animated: boolean): void;
	setBackgroundImageForBarPositionBarMetrics(backgroundImage: UIImage, barPosition: number, barMetrics: number): void;
	backgroundImageForBarPositionBarMetrics(barPosition: number, barMetrics: number): UIImage;
	setBackgroundImageForBarMetrics(backgroundImage: UIImage, barMetrics: number): void;
	backgroundImageForBarMetrics(barMetrics: number): UIImage;
	setTitleVerticalPositionAdjustmentForBarMetrics(adjustment: number, barMetrics: number): void;
	titleVerticalPositionAdjustmentForBarMetrics(barMetrics: number): number;
	initWithFrame(frame: CGRect): UINavigationBar;
	init(): UINavigationBar;
	static new(): UINavigationBar;
	static allocWithZone(zone: any): UINavigationBar;
	static alloc(): UINavigationBar;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UINavigationItem extends NSObject implements NSCoding {
	title: string;
	backBarButtonItem: UIBarButtonItem;
	titleView: UIView;
	prompt: string;
	hidesBackButton: boolean;
	leftBarButtonItems: NSArray;
	rightBarButtonItems: NSArray;
	leftItemsSupplementBackButton: boolean;
	leftBarButtonItem: UIBarButtonItem;
	rightBarButtonItem: UIBarButtonItem;
	constructor(title: string);
	constructor();
	initWithTitle(title: string): UINavigationItem;
	setHidesBackButtonAnimated(hidesBackButton: boolean, animated: boolean): void;
	setLeftBarButtonItemsAnimated(items: NSArray, animated: boolean): void;
	setRightBarButtonItemsAnimated(items: NSArray, animated: boolean): void;
	setLeftBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): void;
	setRightBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): void;
	init(): UINavigationItem;
	static new(): UINavigationItem;
	static allocWithZone(zone: any): UINavigationItem;
	static alloc(): UINavigationItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UINib extends NSObject {
	constructor();
	static nibWithNibNameBundle(name: string, bundleOrNil: NSBundle): UINib;
	static nibWithDataBundle(data: NSData, bundleOrNil: NSBundle): UINib;
	instantiateWithOwnerOptions(ownerOrNil: any, optionsOrNil: NSDictionary): NSArray;
	init(): UINib;
	static new(): UINib;
	static allocWithZone(zone: any): UINib;
	static alloc(): UINib;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPageControl extends UIControl {
	numberOfPages: number;
	currentPage: number;
	hidesForSinglePage: boolean;
	defersCurrentPageDisplay: boolean;
	pageIndicatorTintColor: UIColor;
	currentPageIndicatorTintColor: UIColor;
	constructor(frame: CGRect);
	constructor();
	updateCurrentPageDisplay(): void;
	sizeForNumberOfPages(pageCount: number): CGSize;
	initWithFrame(frame: CGRect): UIPageControl;
	init(): UIPageControl;
	static new(): UIPageControl;
	static allocWithZone(zone: any): UIPageControl;
	static alloc(): UIPageControl;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPageViewController extends UIViewController {
	delegate: any;
	dataSource: any;
	transitionStyle: number;
	navigationOrientation: number;
	spineLocation: number;
	doubleSided: boolean;
	gestureRecognizers: NSArray;
	viewControllers: NSArray;
	constructor(style: number, navigationOrientation: number, options: NSDictionary);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithTransitionStyleNavigationOrientationOptions(style: number, navigationOrientation: number, options: NSDictionary): UIPageViewController;
	setViewControllersDirectionAnimatedCompletion(viewControllers: NSArray, direction: number, animated: boolean, completion: (arg1: boolean) => void): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIPageViewController;
	init(): UIPageViewController;
	static new(): UIPageViewController;
	static allocWithZone(zone: any): UIPageViewController;
	static alloc(): UIPageViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPasteboard extends NSObject {
	name: string;
	persistent: boolean;
	changeCount: number;
	numberOfItems: number;
	items: NSArray;
	string: string;
	strings: NSArray;
	URL: NSURL;
	URLs: NSArray;
	image: UIImage;
	images: NSArray;
	color: UIColor;
	colors: NSArray;
	constructor();
	static generalPasteboard(): UIPasteboard;
	static pasteboardWithNameCreate(pasteboardName: string, create: boolean): UIPasteboard;
	static pasteboardWithUniqueName(): UIPasteboard;
	static removePasteboardWithName(pasteboardName: string): void;
	pasteboardTypes(): NSArray;
	containsPasteboardTypes(pasteboardTypes: NSArray): boolean;
	dataForPasteboardType(pasteboardType: string): NSData;
	valueForPasteboardType(pasteboardType: string): any;
	setValueForPasteboardType(value: any, pasteboardType: string): void;
	setDataForPasteboardType(data: NSData, pasteboardType: string): void;
	pasteboardTypesForItemSet(itemSet: NSIndexSet): NSArray;
	containsPasteboardTypesInItemSet(pasteboardTypes: NSArray, itemSet: NSIndexSet): boolean;
	itemSetWithPasteboardTypes(pasteboardTypes: NSArray): NSIndexSet;
	valuesForPasteboardTypeInItemSet(pasteboardType: string, itemSet: NSIndexSet): NSArray;
	dataForPasteboardTypeInItemSet(pasteboardType: string, itemSet: NSIndexSet): NSArray;
	addItems(items: NSArray): void;
	init(): UIPasteboard;
	static new(): UIPasteboard;
	static allocWithZone(zone: any): UIPasteboard;
	static alloc(): UIPasteboard;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPinchGestureRecognizer extends UIGestureRecognizer {
	scale: number;
	velocity: number;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UIPinchGestureRecognizer;
	init(): UIPinchGestureRecognizer;
	static new(): UIPinchGestureRecognizer;
	static allocWithZone(zone: any): UIPinchGestureRecognizer;
	static alloc(): UIPinchGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPopoverController extends NSObject implements UIAppearanceContainer {
	delegate: any;
	contentViewController: UIViewController;
	popoverContentSize: CGSize;
	popoverVisible: boolean;
	popoverArrowDirection: number;
	passthroughViews: NSArray;
	backgroundColor: UIColor;
	popoverLayoutMargins: UIEdgeInsets;
	popoverBackgroundViewClass: any;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(viewController: UIViewController);
	constructor();
	initWithContentViewController(viewController: UIViewController): UIPopoverController;
	setContentViewControllerAnimated(viewController: UIViewController, animated: boolean): void;
	setPopoverContentSizeAnimated(size: CGSize, animated: boolean): void;
	presentPopoverFromRectInViewPermittedArrowDirectionsAnimated(rect: CGRect, view: UIView, arrowDirections: number, animated: boolean): void;
	presentPopoverFromBarButtonItemPermittedArrowDirectionsAnimated(item: UIBarButtonItem, arrowDirections: number, animated: boolean): void;
	dismissPopoverAnimated(animated: boolean): void;
	init(): UIPopoverController;
	static new(): UIPopoverController;
	static allocWithZone(zone: any): UIPopoverController;
	static alloc(): UIPopoverController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIPopoverBackgroundView extends UIView implements UIPopoverBackgroundViewMethods {
	arrowOffset: number;
	arrowDirection: number;
	constructor(frame: CGRect);
	constructor();
	static wantsDefaultContentAppearance(): boolean;
	initWithFrame(frame: CGRect): UIPopoverBackgroundView;
	init(): UIPopoverBackgroundView;
	static new(): UIPopoverBackgroundView;
	static allocWithZone(zone: any): UIPopoverBackgroundView;
	static alloc(): UIPopoverBackgroundView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static arrowBase(): number;
	static contentViewInsets(): UIEdgeInsets;
	static arrowHeight(): number;
}
declare class UIPrinter extends NSObject {
	URL: NSURL;
	displayName: string;
	displayLocation: string;
	supportedJobTypes: number;
	makeAndModel: string;
	supportsColor: boolean;
	supportsDuplex: boolean;
	constructor();
	static printerWithURL(url: NSURL): UIPrinter;
	contactPrinter(completionHandler: (arg1: boolean) => void): void;
	init(): UIPrinter;
	static new(): UIPrinter;
	static allocWithZone(zone: any): UIPrinter;
	static alloc(): UIPrinter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPrinterPickerController extends NSObject {
	selectedPrinter: UIPrinter;
	delegate: any;
	constructor();
	static printerPickerControllerWithInitiallySelectedPrinter(printer: UIPrinter): UIPrinterPickerController;
	presentAnimatedCompletionHandler(animated: boolean, completion: (arg1: UIPrinterPickerController, arg2: boolean, arg3: NSError) => void): boolean;
	presentFromRectInViewAnimatedCompletionHandler(rect: CGRect, view: UIView, animated: boolean, completion: (arg1: UIPrinterPickerController, arg2: boolean, arg3: NSError) => void): boolean;
	presentFromBarButtonItemAnimatedCompletionHandler(item: UIBarButtonItem, animated: boolean, completion: (arg1: UIPrinterPickerController, arg2: boolean, arg3: NSError) => void): boolean;
	dismissAnimated(animated: boolean): void;
	init(): UIPrinterPickerController;
	static new(): UIPrinterPickerController;
	static allocWithZone(zone: any): UIPrinterPickerController;
	static alloc(): UIPrinterPickerController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPrintFormatter extends NSObject implements NSCopying {
	printPageRenderer: UIPrintPageRenderer;
	maximumContentHeight: number;
	maximumContentWidth: number;
	contentInsets: UIEdgeInsets;
	perPageContentInsets: UIEdgeInsets;
	startPage: number;
	pageCount: number;
	constructor();
	removeFromPrintPageRenderer(): void;
	rectForPageAtIndex(pageIndex: number): CGRect;
	drawInRectForPageAtIndex(rect: CGRect, pageIndex: number): void;
	init(): UIPrintFormatter;
	static new(): UIPrintFormatter;
	static allocWithZone(zone: any): UIPrintFormatter;
	static alloc(): UIPrintFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class UISimpleTextPrintFormatter extends UIPrintFormatter {
	text: string;
	attributedText: NSAttributedString;
	font: UIFont;
	color: UIColor;
	textAlignment: number;
	constructor(text: string);
	constructor(attributedText: NSAttributedString);
	constructor();
	initWithText(text: string): UISimpleTextPrintFormatter;
	initWithAttributedText(attributedText: NSAttributedString): UISimpleTextPrintFormatter;
	init(): UISimpleTextPrintFormatter;
	static new(): UISimpleTextPrintFormatter;
	static allocWithZone(zone: any): UISimpleTextPrintFormatter;
	static alloc(): UISimpleTextPrintFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIMarkupTextPrintFormatter extends UIPrintFormatter {
	markupText: string;
	constructor(markupText: string);
	constructor();
	initWithMarkupText(markupText: string): UIMarkupTextPrintFormatter;
	init(): UIMarkupTextPrintFormatter;
	static new(): UIMarkupTextPrintFormatter;
	static allocWithZone(zone: any): UIMarkupTextPrintFormatter;
	static alloc(): UIMarkupTextPrintFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIViewPrintFormatter extends UIPrintFormatter {
	view: UIView;
	constructor();
	init(): UIViewPrintFormatter;
	static new(): UIViewPrintFormatter;
	static allocWithZone(zone: any): UIViewPrintFormatter;
	static alloc(): UIViewPrintFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPrintInfo extends NSObject implements NSCopying, NSCoding {
	printerID: string;
	jobName: string;
	outputType: number;
	orientation: number;
	duplex: number;
	constructor();
	static printInfo(): UIPrintInfo;
	static printInfoWithDictionary(dictionary: NSDictionary): UIPrintInfo;
	dictionaryRepresentation(): NSDictionary;
	init(): UIPrintInfo;
	static new(): UIPrintInfo;
	static allocWithZone(zone: any): UIPrintInfo;
	static alloc(): UIPrintInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIPrintInteractionController extends NSObject {
	printInfo: UIPrintInfo;
	delegate: any;
	showsPageRange: boolean;
	showsNumberOfCopies: boolean;
	showsPaperSelectionForLoadedPapers: boolean;
	printPaper: UIPrintPaper;
	printPageRenderer: UIPrintPageRenderer;
	printFormatter: UIPrintFormatter;
	printingItem: any;
	printingItems: NSArray;
	constructor();
	static isPrintingAvailable(): boolean;
	static printableUTIs(): NSSet;
	static canPrintURL(url: NSURL): boolean;
	static canPrintData(data: NSData): boolean;
	static sharedPrintController(): UIPrintInteractionController;
	presentAnimatedCompletionHandler(animated: boolean, completion: (arg1: UIPrintInteractionController, arg2: boolean, arg3: NSError) => void): boolean;
	presentFromRectInViewAnimatedCompletionHandler(rect: CGRect, view: UIView, animated: boolean, completion: (arg1: UIPrintInteractionController, arg2: boolean, arg3: NSError) => void): boolean;
	presentFromBarButtonItemAnimatedCompletionHandler(item: UIBarButtonItem, animated: boolean, completion: (arg1: UIPrintInteractionController, arg2: boolean, arg3: NSError) => void): boolean;
	printToPrinterCompletionHandler(printer: UIPrinter, completion: (arg1: UIPrintInteractionController, arg2: boolean, arg3: NSError) => void): boolean;
	dismissAnimated(animated: boolean): void;
	init(): UIPrintInteractionController;
	static new(): UIPrintInteractionController;
	static allocWithZone(zone: any): UIPrintInteractionController;
	static alloc(): UIPrintInteractionController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPrintPageRenderer extends NSObject {
	headerHeight: number;
	footerHeight: number;
	paperRect: CGRect;
	printableRect: CGRect;
	printFormatters: NSArray;
	constructor();
	printFormattersForPageAtIndex(pageIndex: number): NSArray;
	addPrintFormatterStartingAtPageAtIndex(formatter: UIPrintFormatter, pageIndex: number): void;
	numberOfPages(): number;
	prepareForDrawingPages(range: NSRange): void;
	drawPageAtIndexInRect(pageIndex: number, printableRect: CGRect): void;
	drawPrintFormatterForPageAtIndex(printFormatter: UIPrintFormatter, pageIndex: number): void;
	drawHeaderForPageAtIndexInRect(pageIndex: number, headerRect: CGRect): void;
	drawContentForPageAtIndexInRect(pageIndex: number, contentRect: CGRect): void;
	drawFooterForPageAtIndexInRect(pageIndex: number, footerRect: CGRect): void;
	init(): UIPrintPageRenderer;
	static new(): UIPrintPageRenderer;
	static allocWithZone(zone: any): UIPrintPageRenderer;
	static alloc(): UIPrintPageRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPrintPaper extends NSObject {
	paperSize: CGSize;
	printableRect: CGRect;
	constructor();
	static bestPaperForPageSizeWithPapersFromArray(contentSize: CGSize, paperList: NSArray): UIPrintPaper;
	printRect(): CGRect;
	init(): UIPrintPaper;
	static new(): UIPrintPaper;
	static allocWithZone(zone: any): UIPrintPaper;
	static alloc(): UIPrintPaper;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIProgressView extends UIView implements NSCoding {
	progressViewStyle: number;
	progress: number;
	progressTintColor: UIColor;
	trackTintColor: UIColor;
	progressImage: UIImage;
	trackImage: UIImage;
	constructor(style: number);
	constructor(frame: CGRect);
	constructor();
	initWithProgressViewStyle(style: number): UIProgressView;
	setProgressAnimated(progress: number, animated: boolean): void;
	initWithFrame(frame: CGRect): UIProgressView;
	init(): UIProgressView;
	static new(): UIProgressView;
	static allocWithZone(zone: any): UIProgressView;
	static alloc(): UIProgressView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIReferenceLibraryViewController extends UIViewController {
	constructor(term: string);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static dictionaryHasDefinitionForTerm(term: string): boolean;
	initWithTerm(term: string): UIReferenceLibraryViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIReferenceLibraryViewController;
	init(): UIReferenceLibraryViewController;
	static new(): UIReferenceLibraryViewController;
	static allocWithZone(zone: any): UIReferenceLibraryViewController;
	static alloc(): UIReferenceLibraryViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIRefreshControl extends UIControl {
	refreshing: boolean;
	attributedTitle: NSAttributedString;
	constructor(frame: CGRect);
	constructor();
	beginRefreshing(): void;
	endRefreshing(): void;
	initWithFrame(frame: CGRect): UIRefreshControl;
	init(): UIRefreshControl;
	static new(): UIRefreshControl;
	static allocWithZone(zone: any): UIRefreshControl;
	static alloc(): UIRefreshControl;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIRotationGestureRecognizer extends UIGestureRecognizer {
	rotation: number;
	velocity: number;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UIRotationGestureRecognizer;
	init(): UIRotationGestureRecognizer;
	static new(): UIRotationGestureRecognizer;
	static allocWithZone(zone: any): UIRotationGestureRecognizer;
	static alloc(): UIRotationGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIScreen extends NSObject implements UITraitEnvironment {
	bounds: CGRect;
	applicationFrame: CGRect;
	scale: number;
	availableModes: NSArray;
	preferredMode: UIScreenMode;
	currentMode: UIScreenMode;
	overscanCompensation: number;
	mirroredScreen: UIScreen;
	brightness: number;
	wantsSoftwareDimming: boolean;
	coordinateSpace: any;
	fixedCoordinateSpace: any;
	nativeBounds: CGRect;
	nativeScale: number;
	traitCollection: UITraitCollection;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static screens(): NSArray;
	static mainScreen(): UIScreen;
	displayLinkWithTargetSelector(target: any, sel: any): CADisplayLink;
	snapshotViewAfterScreenUpdates(afterUpdates: boolean): UIView;
	init(): UIScreen;
	static new(): UIScreen;
	static allocWithZone(zone: any): UIScreen;
	static alloc(): UIScreen;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	traitCollectionDidChange(previousTraitCollection: UITraitCollection): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIScreenEdgePanGestureRecognizer extends UIPanGestureRecognizer {
	edges: number;
	constructor(target: any, action: any);
	constructor();
	initWithTargetAction(target: any, action: any): UIScreenEdgePanGestureRecognizer;
	init(): UIScreenEdgePanGestureRecognizer;
	static new(): UIScreenEdgePanGestureRecognizer;
	static allocWithZone(zone: any): UIScreenEdgePanGestureRecognizer;
	static alloc(): UIScreenEdgePanGestureRecognizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIScreenMode extends NSObject {
	size: CGSize;
	pixelAspectRatio: number;
	constructor();
	init(): UIScreenMode;
	static new(): UIScreenMode;
	static allocWithZone(zone: any): UIScreenMode;
	static alloc(): UIScreenMode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UISearchBar extends UIView implements UIBarPositioning, UITextInputTraits {
	barStyle: number;
	delegate: any;
	text: string;
	prompt: string;
	placeholder: string;
	showsBookmarkButton: boolean;
	showsCancelButton: boolean;
	showsSearchResultsButton: boolean;
	searchResultsButtonSelected: boolean;
	barTintColor: UIColor;
	searchBarStyle: number;
	translucent: boolean;
	scopeButtonTitles: NSArray;
	selectedScopeButtonIndex: number;
	showsScopeBar: boolean;
	inputAccessoryView: UIView;
	backgroundImage: UIImage;
	scopeBarBackgroundImage: UIImage;
	searchFieldBackgroundPositionAdjustment: UIOffset;
	searchTextPositionAdjustment: UIOffset;
	barPosition: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	autocapitalizationType: number;
	autocorrectionType: number;
	spellCheckingType: number;
	keyboardType: number;
	keyboardAppearance: number;
	returnKeyType: number;
	enablesReturnKeyAutomatically: boolean;
	secureTextEntry: boolean;
	constructor(frame: CGRect);
	constructor();
	setShowsCancelButtonAnimated(showsCancelButton: boolean, animated: boolean): void;
	setBackgroundImageForBarPositionBarMetrics(backgroundImage: UIImage, barPosition: number, barMetrics: number): void;
	backgroundImageForBarPositionBarMetrics(barPosition: number, barMetrics: number): UIImage;
	setSearchFieldBackgroundImageForState(backgroundImage: UIImage, state: number): void;
	searchFieldBackgroundImageForState(state: number): UIImage;
	setImageForSearchBarIconState(iconImage: UIImage, icon: number, state: number): void;
	imageForSearchBarIconState(icon: number, state: number): UIImage;
	setScopeBarButtonBackgroundImageForState(backgroundImage: UIImage, state: number): void;
	scopeBarButtonBackgroundImageForState(state: number): UIImage;
	setScopeBarButtonDividerImageForLeftSegmentStateRightSegmentState(dividerImage: UIImage, leftState: number, rightState: number): void;
	scopeBarButtonDividerImageForLeftSegmentStateRightSegmentState(leftState: number, rightState: number): UIImage;
	setScopeBarButtonTitleTextAttributesForState(attributes: NSDictionary, state: number): void;
	scopeBarButtonTitleTextAttributesForState(state: number): NSDictionary;
	setPositionAdjustmentForSearchBarIcon(adjustment: UIOffset, icon: number): void;
	positionAdjustmentForSearchBarIcon(icon: number): UIOffset;
	initWithFrame(frame: CGRect): UISearchBar;
	init(): UISearchBar;
	static new(): UISearchBar;
	static allocWithZone(zone: any): UISearchBar;
	static alloc(): UISearchBar;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIPresentationController extends NSObject implements UIAppearanceContainer, UITraitEnvironment, UIContentContainer {
	presentingViewController: UIViewController;
	presentedViewController: UIViewController;
	presentationStyle: number;
	containerView: UIView;
	delegate: any;
	overrideTraitCollection: UITraitCollection;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	traitCollection: UITraitCollection;
	preferredContentSize: CGSize;
	constructor(presentedViewController: UIViewController, presentingViewController: UIViewController);
	constructor();
	initWithPresentedViewControllerPresentingViewController(presentedViewController: UIViewController, presentingViewController: UIViewController): UIPresentationController;
	adaptivePresentationStyle(): number;
	containerViewWillLayoutSubviews(): void;
	containerViewDidLayoutSubviews(): void;
	presentedView(): UIView;
	frameOfPresentedViewInContainerView(): CGRect;
	shouldPresentInFullscreen(): boolean;
	shouldRemovePresentersView(): boolean;
	presentationTransitionWillBegin(): void;
	presentationTransitionDidEnd(completed: boolean): void;
	dismissalTransitionWillBegin(): void;
	dismissalTransitionDidEnd(completed: boolean): void;
	init(): UIPresentationController;
	static new(): UIPresentationController;
	static allocWithZone(zone: any): UIPresentationController;
	static alloc(): UIPresentationController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	traitCollectionDidChange(previousTraitCollection: UITraitCollection): void;
	preferredContentSizeDidChangeForChildContentContainer(container: any): void;
	systemLayoutFittingSizeDidChangeForChildContentContainer(container: any): void;
	sizeForChildContentContainerWithParentContainerSize(container: any, parentSize: CGSize): CGSize;
	viewWillTransitionToSizeWithTransitionCoordinator(size: CGSize, coordinator: any): void;
	willTransitionToTraitCollectionWithTransitionCoordinator(newCollection: UITraitCollection, coordinator: any): void;
}
declare class UIPercentDrivenInteractiveTransition extends NSObject implements UIViewControllerInteractiveTransitioning {
	duration: number;
	percentComplete: number;
	completionSpeedProperty: number;
	completionCurveProperty: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	updateInteractiveTransition(percentComplete: number): void;
	cancelInteractiveTransition(): void;
	finishInteractiveTransition(): void;
	init(): UIPercentDrivenInteractiveTransition;
	static new(): UIPercentDrivenInteractiveTransition;
	static allocWithZone(zone: any): UIPercentDrivenInteractiveTransition;
	static alloc(): UIPercentDrivenInteractiveTransition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	startInteractiveTransition(transitionContext: any): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UISearchController extends UIViewController implements UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning {
	searchResultsUpdater: any;
	active: boolean;
	delegate: any;
	dimsBackgroundDuringPresentation: boolean;
	hidesNavigationBarDuringPresentation: boolean;
	searchResultsController: UIViewController;
	searchBar: UISearchBar;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(searchResultsController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithSearchResultsController(searchResultsController: UIViewController): UISearchController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UISearchController;
	init(): UISearchController;
	static new(): UISearchController;
	static allocWithZone(zone: any): UISearchController;
	static alloc(): UISearchController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	transitionDuration(transitionContext: any): number;
	animateTransition(transitionContext: any): void;
}
declare class UISearchDisplayController extends NSObject {
	delegate: any;
	active: boolean;
	searchBar: UISearchBar;
	searchContentsController: UIViewController;
	searchResultsTableView: UITableView;
	searchResultsDataSource: any;
	searchResultsDelegate: any;
	searchResultsTitle: string;
	displaysSearchBarInNavigationBar: boolean;
	navigationItem: UINavigationItem;
	constructor(searchBar: UISearchBar, viewController: UIViewController);
	constructor();
	initWithSearchBarContentsController(searchBar: UISearchBar, viewController: UIViewController): UISearchDisplayController;
	setActiveAnimated(visible: boolean, animated: boolean): void;
	init(): UISearchDisplayController;
	static new(): UISearchDisplayController;
	static allocWithZone(zone: any): UISearchDisplayController;
	static alloc(): UISearchDisplayController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UISegmentedControl extends UIControl implements NSCoding {
	segmentedControlStyle: number;
	momentary: boolean;
	numberOfSegments: number;
	apportionsSegmentWidthsByContent: boolean;
	selectedSegmentIndex: number;
	constructor(items: NSArray);
	constructor(frame: CGRect);
	constructor();
	initWithItems(items: NSArray): UISegmentedControl;
	insertSegmentWithTitleAtIndexAnimated(title: string, segment: number, animated: boolean): void;
	insertSegmentWithImageAtIndexAnimated(image: UIImage, segment: number, animated: boolean): void;
	removeSegmentAtIndexAnimated(segment: number, animated: boolean): void;
	removeAllSegments(): void;
	setTitleForSegmentAtIndex(title: string, segment: number): void;
	titleForSegmentAtIndex(segment: number): string;
	setImageForSegmentAtIndex(image: UIImage, segment: number): void;
	imageForSegmentAtIndex(segment: number): UIImage;
	setWidthForSegmentAtIndex(width: number, segment: number): void;
	widthForSegmentAtIndex(segment: number): number;
	setContentOffsetForSegmentAtIndex(offset: CGSize, segment: number): void;
	contentOffsetForSegmentAtIndex(segment: number): CGSize;
	setEnabledForSegmentAtIndex(enabled: boolean, segment: number): void;
	isEnabledForSegmentAtIndex(segment: number): boolean;
	setBackgroundImageForStateBarMetrics(backgroundImage: UIImage, state: number, barMetrics: number): void;
	backgroundImageForStateBarMetrics(state: number, barMetrics: number): UIImage;
	setDividerImageForLeftSegmentStateRightSegmentStateBarMetrics(dividerImage: UIImage, leftState: number, rightState: number, barMetrics: number): void;
	dividerImageForLeftSegmentStateRightSegmentStateBarMetrics(leftState: number, rightState: number, barMetrics: number): UIImage;
	setTitleTextAttributesForState(attributes: NSDictionary, state: number): void;
	titleTextAttributesForState(state: number): NSDictionary;
	setContentPositionAdjustmentForSegmentTypeBarMetrics(adjustment: UIOffset, leftCenterRightOrAlone: number, barMetrics: number): void;
	contentPositionAdjustmentForSegmentTypeBarMetrics(leftCenterRightOrAlone: number, barMetrics: number): UIOffset;
	initWithFrame(frame: CGRect): UISegmentedControl;
	init(): UISegmentedControl;
	static new(): UISegmentedControl;
	static allocWithZone(zone: any): UISegmentedControl;
	static alloc(): UISegmentedControl;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UISlider extends UIControl implements NSCoding {
	value: number;
	minimumValue: number;
	maximumValue: number;
	minimumValueImage: UIImage;
	maximumValueImage: UIImage;
	continuous: boolean;
	minimumTrackTintColor: UIColor;
	maximumTrackTintColor: UIColor;
	thumbTintColor: UIColor;
	currentThumbImage: UIImage;
	currentMinimumTrackImage: UIImage;
	currentMaximumTrackImage: UIImage;
	constructor(frame: CGRect);
	constructor();
	setValueAnimated(value: number, animated: boolean): void;
	setThumbImageForState(image: UIImage, state: number): void;
	setMinimumTrackImageForState(image: UIImage, state: number): void;
	setMaximumTrackImageForState(image: UIImage, state: number): void;
	thumbImageForState(state: number): UIImage;
	minimumTrackImageForState(state: number): UIImage;
	maximumTrackImageForState(state: number): UIImage;
	minimumValueImageRectForBounds(bounds: CGRect): CGRect;
	maximumValueImageRectForBounds(bounds: CGRect): CGRect;
	trackRectForBounds(bounds: CGRect): CGRect;
	thumbRectForBoundsTrackRectValue(bounds: CGRect, rect: CGRect, value: number): CGRect;
	initWithFrame(frame: CGRect): UISlider;
	init(): UISlider;
	static new(): UISlider;
	static allocWithZone(zone: any): UISlider;
	static alloc(): UISlider;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UISplitViewController extends UIViewController {
	viewControllers: NSArray;
	delegate: any;
	presentsWithGesture: boolean;
	collapsed: boolean;
	preferredDisplayMode: number;
	displayMode: number;
	preferredPrimaryColumnWidthFraction: number;
	minimumPrimaryColumnWidth: number;
	maximumPrimaryColumnWidth: number;
	primaryColumnWidth: number;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	displayModeButtonItem(): UIBarButtonItem;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UISplitViewController;
	init(): UISplitViewController;
	static new(): UISplitViewController;
	static allocWithZone(zone: any): UISplitViewController;
	static alloc(): UISplitViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIStepper extends UIControl {
	continuous: boolean;
	autorepeat: boolean;
	wraps: boolean;
	value: number;
	minimumValue: number;
	maximumValue: number;
	stepValue: number;
	constructor(frame: CGRect);
	constructor();
	setBackgroundImageForState(image: UIImage, state: number): void;
	backgroundImageForState(state: number): UIImage;
	setDividerImageForLeftSegmentStateRightSegmentState(image: UIImage, leftState: number, rightState: number): void;
	dividerImageForLeftSegmentStateRightSegmentState(state: number, state1: number): UIImage;
	setIncrementImageForState(image: UIImage, state: number): void;
	incrementImageForState(state: number): UIImage;
	setDecrementImageForState(image: UIImage, state: number): void;
	decrementImageForState(state: number): UIImage;
	initWithFrame(frame: CGRect): UIStepper;
	init(): UIStepper;
	static new(): UIStepper;
	static allocWithZone(zone: any): UIStepper;
	static alloc(): UIStepper;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIStoryboard extends NSObject {
	constructor();
	static storyboardWithNameBundle(name: string, storyboardBundleOrNil: NSBundle): UIStoryboard;
	instantiateInitialViewController(): any;
	instantiateViewControllerWithIdentifier(identifier: string): any;
	init(): UIStoryboard;
	static new(): UIStoryboard;
	static allocWithZone(zone: any): UIStoryboard;
	static alloc(): UIStoryboard;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIStoryboardSegue extends NSObject {
	identifier: string;
	sourceViewController: any;
	destinationViewController: any;
	constructor(identifier: string, source: UIViewController, destination: UIViewController);
	constructor();
	static segueWithIdentifierSourceDestinationPerformHandler(identifier: string, source: UIViewController, destination: UIViewController, performHandler: () => void): UIStoryboardSegue;
	initWithIdentifierSourceDestination(identifier: string, source: UIViewController, destination: UIViewController): UIStoryboardSegue;
	perform(): void;
	init(): UIStoryboardSegue;
	static new(): UIStoryboardSegue;
	static allocWithZone(zone: any): UIStoryboardSegue;
	static alloc(): UIStoryboardSegue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIStoryboardPopoverSegue extends UIStoryboardSegue {
	popoverController: UIPopoverController;
	constructor(identifier: string, source: UIViewController, destination: UIViewController);
	constructor();
	static segueWithIdentifierSourceDestinationPerformHandler(identifier: string, source: UIViewController, destination: UIViewController, performHandler: () => void): UIStoryboardPopoverSegue;
	initWithIdentifierSourceDestination(identifier: string, source: UIViewController, destination: UIViewController): UIStoryboardPopoverSegue;
	init(): UIStoryboardPopoverSegue;
	static new(): UIStoryboardPopoverSegue;
	static allocWithZone(zone: any): UIStoryboardPopoverSegue;
	static alloc(): UIStoryboardPopoverSegue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UISwitch extends UIControl implements NSCoding {
	onTintColor: UIColor;
	thumbTintColor: UIColor;
	onImage: UIImage;
	offImage: UIImage;
	on: boolean;
	constructor(frame: CGRect);
	constructor();
	setOnAnimated(on: boolean, animated: boolean): void;
	initWithFrame(frame: CGRect): UISwitch;
	init(): UISwitch;
	static new(): UISwitch;
	static allocWithZone(zone: any): UISwitch;
	static alloc(): UISwitch;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UITabBar extends UIView {
	delegate: any;
	items: NSArray;
	selectedItem: UITabBarItem;
	barTintColor: UIColor;
	selectedImageTintColor: UIColor;
	backgroundImage: UIImage;
	selectionIndicatorImage: UIImage;
	shadowImage: UIImage;
	itemPositioning: number;
	itemWidth: number;
	itemSpacing: number;
	barStyle: number;
	translucent: boolean;
	constructor(frame: CGRect);
	constructor();
	setItemsAnimated(items: NSArray, animated: boolean): void;
	beginCustomizingItems(items: NSArray): void;
	endCustomizingAnimated(animated: boolean): boolean;
	isCustomizing(): boolean;
	initWithFrame(frame: CGRect): UITabBar;
	init(): UITabBar;
	static new(): UITabBar;
	static allocWithZone(zone: any): UITabBar;
	static alloc(): UITabBar;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITabBarController extends UIViewController implements UITabBarDelegate, NSCoding {
	viewControllers: NSArray;
	selectedViewController: UIViewController;
	selectedIndex: number;
	moreNavigationController: UINavigationController;
	customizableViewControllers: NSArray;
	tabBar: UITabBar;
	delegate: any;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	setViewControllersAnimated(viewControllers: NSArray, animated: boolean): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UITabBarController;
	init(): UITabBarController;
	static new(): UITabBarController;
	static allocWithZone(zone: any): UITabBarController;
	static alloc(): UITabBarController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UITabBarItem extends UIBarItem {
	selectedImage: UIImage;
	badgeValue: string;
	constructor(title: string, image: UIImage, tag: number);
	constructor(title: string, image: UIImage, selectedImage: UIImage);
	constructor(systemItem: number, tag: number);
	constructor();
	initWithTitleImageTag(title: string, image: UIImage, tag: number): UITabBarItem;
	initWithTitleImageSelectedImage(title: string, image: UIImage, selectedImage: UIImage): UITabBarItem;
	initWithTabBarSystemItemTag(systemItem: number, tag: number): UITabBarItem;
	setFinishedSelectedImageWithFinishedUnselectedImage(selectedImage: UIImage, unselectedImage: UIImage): void;
	finishedSelectedImage(): UIImage;
	finishedUnselectedImage(): UIImage;
	setTitlePositionAdjustment(adjustment: UIOffset): void;
	titlePositionAdjustment(): UIOffset;
	init(): UITabBarItem;
	static new(): UITabBarItem;
	static allocWithZone(zone: any): UITabBarItem;
	static alloc(): UITabBarItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITableViewHeaderFooterView extends UIView {
	textLabel: UILabel;
	detailTextLabel: UILabel;
	contentView: UIView;
	backgroundView: UIView;
	reuseIdentifier: string;
	constructor(reuseIdentifier: string);
	constructor(frame: CGRect);
	constructor();
	initWithReuseIdentifier(reuseIdentifier: string): UITableViewHeaderFooterView;
	prepareForReuse(): void;
	initWithFrame(frame: CGRect): UITableViewHeaderFooterView;
	init(): UITableViewHeaderFooterView;
	static new(): UITableViewHeaderFooterView;
	static allocWithZone(zone: any): UITableViewHeaderFooterView;
	static alloc(): UITableViewHeaderFooterView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITableViewController extends UIViewController implements UITableViewDelegate, UITableViewDataSource {
	tableView: UITableView;
	clearsSelectionOnViewWillAppear: boolean;
	refreshControl: UIRefreshControl;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(style: number);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithStyle(style: number): UITableViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UITableViewController;
	init(): UITableViewController;
	static new(): UITableViewController;
	static allocWithZone(zone: any): UITableViewController;
	static alloc(): UITableViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	tableViewNumberOfRowsInSection(tableView: UITableView, section: number): number;
	tableViewCellForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UITableViewCell;
}
declare class UITextChecker extends NSObject {
	constructor();
	rangeOfMisspelledWordInStringRangeStartingAtWrapLanguage(stringToCheck: string, range: NSRange, startingOffset: number, wrapFlag: boolean, language: string): NSRange;
	guessesForWordRangeInStringLanguage(range: NSRange, string: string, language: string): NSArray;
	completionsForPartialWordRangeInStringLanguage(range: NSRange, string: string, language: string): NSArray;
	ignoreWord(wordToIgnore: string): void;
	ignoredWords(): NSArray;
	setIgnoredWords(words: NSArray): void;
	static learnWord(word: string): void;
	static hasLearnedWord(word: string): boolean;
	static unlearnWord(word: string): void;
	static availableLanguages(): NSArray;
	init(): UITextChecker;
	static new(): UITextChecker;
	static allocWithZone(zone: any): UITextChecker;
	static alloc(): UITextChecker;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UITextView extends UIScrollView implements UITextInput {
	text: string;
	font: UIFont;
	textColor: UIColor;
	textAlignment: number;
	selectedRange: NSRange;
	editable: boolean;
	selectable: boolean;
	dataDetectorTypes: number;
	allowsEditingTextAttributes: boolean;
	attributedText: NSAttributedString;
	typingAttributes: NSDictionary;
	inputView: UIView;
	inputAccessoryView: UIView;
	clearsOnInsertion: boolean;
	textContainer: NSTextContainer;
	textContainerInset: UIEdgeInsets;
	layoutManager: NSLayoutManager;
	textStorage: NSTextStorage;
	linkTextAttributes: NSDictionary;
	selectedTextRange: UITextRange;
	markedTextRange: UITextRange;
	markedTextStyle: NSDictionary;
	beginningOfDocument: UITextPosition;
	endOfDocument: UITextPosition;
	inputDelegate: any;
	tokenizer: any;
	textInputView: UIView;
	selectionAffinity: number;
	autocapitalizationType: number;
	autocorrectionType: number;
	spellCheckingType: number;
	keyboardType: number;
	keyboardAppearance: number;
	returnKeyType: number;
	enablesReturnKeyAutomatically: boolean;
	secureTextEntry: boolean;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(frame: CGRect, textContainer: NSTextContainer);
	constructor(frame: CGRect);
	constructor();
	scrollRangeToVisible(range: NSRange): void;
	initWithFrameTextContainer(frame: CGRect, textContainer: NSTextContainer): UITextView;
	initWithFrame(frame: CGRect): UITextView;
	init(): UITextView;
	static new(): UITextView;
	static allocWithZone(zone: any): UITextView;
	static alloc(): UITextView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	textInRange(range: UITextRange): string;
	replaceRangeWithText(range: UITextRange, text: string): void;
	setMarkedTextSelectedRange(markedText: string, selectedRange: NSRange): void;
	unmarkText(): void;
	textRangeFromPositionToPosition(fromPosition: UITextPosition, toPosition: UITextPosition): UITextRange;
	positionFromPositionOffset(position: UITextPosition, offset: number): UITextPosition;
	positionFromPositionInDirectionOffset(position: UITextPosition, direction: number, offset: number): UITextPosition;
	comparePositionToPosition(position: UITextPosition, other: UITextPosition): number;
	offsetFromPositionToPosition(from: UITextPosition, toPosition: UITextPosition): number;
	positionWithinRangeFarthestInDirection(range: UITextRange, direction: number): UITextPosition;
	characterRangeByExtendingPositionInDirection(position: UITextPosition, direction: number): UITextRange;
	baseWritingDirectionForPositionInDirection(position: UITextPosition, direction: number): number;
	setBaseWritingDirectionForRange(writingDirection: number, range: UITextRange): void;
	firstRectForRange(range: UITextRange): CGRect;
	caretRectForPosition(position: UITextPosition): CGRect;
	selectionRectsForRange(range: UITextRange): NSArray;
	closestPositionToPoint(point: CGPoint): UITextPosition;
	closestPositionToPointWithinRange(point: CGPoint, range: UITextRange): UITextPosition;
	characterRangeAtPoint(point: CGPoint): UITextRange;
	hasText(): boolean;
	insertText(text: string): void;
	deleteBackward(): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIToolbar extends UIView implements UIBarPositioning {
	barStyle: number;
	items: NSArray;
	translucent: boolean;
	barTintColor: UIColor;
	delegate: any;
	barPosition: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(frame: CGRect);
	constructor();
	setItemsAnimated(items: NSArray, animated: boolean): void;
	setBackgroundImageForToolbarPositionBarMetrics(backgroundImage: UIImage, topOrBottom: number, barMetrics: number): void;
	backgroundImageForToolbarPositionBarMetrics(topOrBottom: number, barMetrics: number): UIImage;
	setShadowImageForToolbarPosition(shadowImage: UIImage, topOrBottom: number): void;
	shadowImageForToolbarPosition(topOrBottom: number): UIImage;
	initWithFrame(frame: CGRect): UIToolbar;
	init(): UIToolbar;
	static new(): UIToolbar;
	static allocWithZone(zone: any): UIToolbar;
	static alloc(): UIToolbar;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UITouch extends NSObject {
	timestamp: number;
	phase: number;
	tapCount: number;
	majorRadius: number;
	majorRadiusTolerance: number;
	window: UIWindow;
	view: UIView;
	gestureRecognizers: NSArray;
	constructor();
	locationInView(view: UIView): CGPoint;
	previousLocationInView(view: UIView): CGPoint;
	locationInNode(node: SKNode): CGPoint;
	previousLocationInNode(node: SKNode): CGPoint;
	init(): UITouch;
	static new(): UITouch;
	static allocWithZone(zone: any): UITouch;
	static alloc(): UITouch;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIVideoEditorController extends UINavigationController {
	videoPath: string;
	videoMaximumDuration: number;
	videoQuality: number;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static canEditVideoAtPath(videoPath: string): boolean;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): UIVideoEditorController;
	initWithRootViewController(rootViewController: UIViewController): UIVideoEditorController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): UIVideoEditorController;
	init(): UIVideoEditorController;
	static new(): UIVideoEditorController;
	static allocWithZone(zone: any): UIVideoEditorController;
	static alloc(): UIVideoEditorController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIWebView extends UIView implements NSCoding, UIScrollViewDelegate {
	delegate: any;
	scrollView: UIScrollView;
	request: NSURLRequest;
	canGoBack: boolean;
	canGoForward: boolean;
	loading: boolean;
	scalesPageToFit: boolean;
	detectsPhoneNumbers: boolean;
	dataDetectorTypes: number;
	allowsInlineMediaPlayback: boolean;
	mediaPlaybackRequiresUserAction: boolean;
	mediaPlaybackAllowsAirPlay: boolean;
	suppressesIncrementalRendering: boolean;
	keyboardDisplayRequiresUserAction: boolean;
	paginationMode: number;
	paginationBreakingMode: number;
	pageLength: number;
	gapBetweenPages: number;
	pageCount: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(frame: CGRect);
	constructor();
	loadRequest(request: NSURLRequest): void;
	loadHTMLStringBaseURL(string: string, baseURL: NSURL): void;
	loadDataMIMETypeTextEncodingNameBaseURL(data: NSData, MIMEType: string, textEncodingName: string, baseURL: NSURL): void;
	reload(): void;
	stopLoading(): void;
	goBack(): void;
	goForward(): void;
	stringByEvaluatingJavaScriptFromString(script: string): string;
	initWithFrame(frame: CGRect): UIWebView;
	init(): UIWebView;
	static new(): UIWebView;
	static allocWithZone(zone: any): UIWebView;
	static alloc(): UIWebView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class UIWindow extends UIView {
	screen: UIScreen;
	windowLevel: number;
	keyWindow: boolean;
	rootViewController: UIViewController;
	constructor(frame: CGRect);
	constructor();
	becomeKeyWindow(): void;
	resignKeyWindow(): void;
	makeKeyWindow(): void;
	makeKeyAndVisible(): void;
	sendEvent(event: UIEvent): void;
	convertPointToWindow(point: CGPoint, window: UIWindow): CGPoint;
	convertPointFromWindow(point: CGPoint, window: UIWindow): CGPoint;
	convertRectToWindow(rect: CGRect, window: UIWindow): CGRect;
	convertRectFromWindow(rect: CGRect, window: UIWindow): CGRect;
	initWithFrame(frame: CGRect): UIWindow;
	init(): UIWindow;
	static new(): UIWindow;
	static allocWithZone(zone: any): UIWindow;
	static alloc(): UIWindow;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSTextStorage extends NSMutableAttributedString {
	layoutManagers: NSArray;
	editedMask: number;
	editedRange: NSRange;
	changeInLength: number;
	delegate: any;
	fixesAttributesLazily: boolean;
	constructor(str: string);
	constructor(str: string, attrs: NSDictionary);
	constructor(attrStr: NSAttributedString);
	constructor(url: NSURL, options: NSDictionary, dict: any, error: any);
	constructor(data: NSData, options: NSDictionary, dict: any, error: any);
	constructor();
	addLayoutManager(aLayoutManager: NSLayoutManager): void;
	removeLayoutManager(aLayoutManager: NSLayoutManager): void;
	editedRangeChangeInLength(editedMask: number, editedRange: NSRange, delta: number): void;
	processEditing(): void;
	invalidateAttributesInRange(range: NSRange): void;
	ensureAttributesAreFixedInRange(range: NSRange): void;
	initWithString(str: string): NSTextStorage;
	initWithStringAttributes(str: string, attrs: NSDictionary): NSTextStorage;
	initWithAttributedString(attrStr: NSAttributedString): NSTextStorage;
	initWithFileURLOptionsDocumentAttributesError(url: NSURL, options: NSDictionary, dict: any, error: any): NSTextStorage;
	initWithDataOptionsDocumentAttributesError(data: NSData, options: NSDictionary, dict: any, error: any): NSTextStorage;
	init(): NSTextStorage;
	static new(): NSTextStorage;
	static allocWithZone(zone: any): NSTextStorage;
	static alloc(): NSTextStorage;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSLayoutManager extends NSObject implements NSCoding {
	textStorage: NSTextStorage;
	textContainers: NSArray;
	delegate: any;
	showsInvisibleCharacters: boolean;
	showsControlCharacters: boolean;
	hyphenationFactor: number;
	usesFontLeading: boolean;
	allowsNonContiguousLayout: boolean;
	hasNonContiguousLayout: boolean;
	numberOfGlyphs: number;
	extraLineFragmentRect: CGRect;
	extraLineFragmentUsedRect: CGRect;
	extraLineFragmentTextContainer: NSTextContainer;
	constructor();
	addTextContainer(container: NSTextContainer): void;
	insertTextContainerAtIndex(container: NSTextContainer, index: number): void;
	removeTextContainerAtIndex(index: number): void;
	textContainerChangedGeometry(container: NSTextContainer): void;
	invalidateGlyphsForCharacterRangeChangeInLengthActualCharacterRange(charRange: NSRange, delta: number, actualCharRange: any): void;
	invalidateLayoutForCharacterRangeActualCharacterRange(charRange: NSRange, actualCharRange: any): void;
	invalidateDisplayForCharacterRange(charRange: NSRange): void;
	invalidateDisplayForGlyphRange(glyphRange: NSRange): void;
	processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(textStorage: NSTextStorage, editMask: number, newCharRange: NSRange, delta: number, invalidatedCharRange: NSRange): void;
	ensureGlyphsForCharacterRange(charRange: NSRange): void;
	ensureGlyphsForGlyphRange(glyphRange: NSRange): void;
	ensureLayoutForCharacterRange(charRange: NSRange): void;
	ensureLayoutForGlyphRange(glyphRange: NSRange): void;
	ensureLayoutForTextContainer(container: NSTextContainer): void;
	ensureLayoutForBoundingRectInTextContainer(bounds: CGRect, container: NSTextContainer): void;
	setGlyphsPropertiesCharacterIndexesFontForGlyphRange(glyphs: any, props: any, charIndexes: any, aFont: UIFont, glyphRange: NSRange): void;
	glyphAtIndexIsValidIndex(glyphIndex: number, isValidIndex: any): number;
	glyphAtIndex(glyphIndex: number): number;
	isValidGlyphIndex(glyphIndex: number): boolean;
	propertyForGlyphAtIndex(glyphIndex: number): number;
	characterIndexForGlyphAtIndex(glyphIndex: number): number;
	glyphIndexForCharacterAtIndex(charIndex: number): number;
	getGlyphsInRangeGlyphsPropertiesCharacterIndexesBidiLevels(glyphRange: NSRange, glyphBuffer: any, props: any, charIndexBuffer: any, bidiLevelBuffer: string): number;
	setTextContainerForGlyphRange(container: NSTextContainer, glyphRange: NSRange): void;
	setLineFragmentRectForGlyphRangeUsedRect(fragmentRect: CGRect, glyphRange: NSRange, usedRect: CGRect): void;
	setExtraLineFragmentRectUsedRectTextContainer(fragmentRect: CGRect, usedRect: CGRect, container: NSTextContainer): void;
	setLocationForStartOfGlyphRange(location: CGPoint, glyphRange: NSRange): void;
	setNotShownAttributeForGlyphAtIndex(flag: boolean, glyphIndex: number): void;
	setDrawsOutsideLineFragmentForGlyphAtIndex(flag: boolean, glyphIndex: number): void;
	setAttachmentSizeForGlyphRange(attachmentSize: CGSize, glyphRange: NSRange): void;
	getFirstUnlaidCharacterIndexGlyphIndex(charIndex: any, glyphIndex: any): void;
	firstUnlaidCharacterIndex(): number;
	firstUnlaidGlyphIndex(): number;
	textContainerForGlyphAtIndexEffectiveRange(glyphIndex: number, effectiveGlyphRange: any): NSTextContainer;
	usedRectForTextContainer(container: NSTextContainer): CGRect;
	lineFragmentRectForGlyphAtIndexEffectiveRange(glyphIndex: number, effectiveGlyphRange: any): CGRect;
	lineFragmentUsedRectForGlyphAtIndexEffectiveRange(glyphIndex: number, effectiveGlyphRange: any): CGRect;
	locationForGlyphAtIndex(glyphIndex: number): CGPoint;
	notShownAttributeForGlyphAtIndex(glyphIndex: number): boolean;
	drawsOutsideLineFragmentForGlyphAtIndex(glyphIndex: number): boolean;
	attachmentSizeForGlyphAtIndex(glyphIndex: number): CGSize;
	truncatedGlyphRangeInLineFragmentForGlyphAtIndex(glyphIndex: number): NSRange;
	glyphRangeForCharacterRangeActualCharacterRange(charRange: NSRange, actualCharRange: any): NSRange;
	characterRangeForGlyphRangeActualGlyphRange(glyphRange: NSRange, actualGlyphRange: any): NSRange;
	glyphRangeForTextContainer(container: NSTextContainer): NSRange;
	rangeOfNominallySpacedGlyphsContainingIndex(glyphIndex: number): NSRange;
	boundingRectForGlyphRangeInTextContainer(glyphRange: NSRange, container: NSTextContainer): CGRect;
	glyphRangeForBoundingRectInTextContainer(bounds: CGRect, container: NSTextContainer): NSRange;
	glyphRangeForBoundingRectWithoutAdditionalLayoutInTextContainer(bounds: CGRect, container: NSTextContainer): NSRange;
	glyphIndexForPointInTextContainerFractionOfDistanceThroughGlyph(point: CGPoint, container: NSTextContainer, partialFraction: any): number;
	glyphIndexForPointInTextContainer(point: CGPoint, container: NSTextContainer): number;
	fractionOfDistanceThroughGlyphForPointInTextContainer(point: CGPoint, container: NSTextContainer): number;
	characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(point: CGPoint, container: NSTextContainer, partialFraction: any): number;
	getLineFragmentInsertionPointsForCharacterAtIndexAlternatePositionsInDisplayOrderPositionsCharacterIndexes(charIndex: number, aFlag: boolean, dFlag: boolean, positions: any, charIndexes: any): number;
	enumerateLineFragmentsForGlyphRangeUsingBlock(glyphRange: NSRange, block: (arg1: CGRect, arg2: CGRect, arg3: NSTextContainer, arg4: NSRange, arg5: any) => void): void;
	enumerateEnclosingRectsForGlyphRangeWithinSelectedGlyphRangeInTextContainerUsingBlock(glyphRange: NSRange, selectedRange: NSRange, textContainer: NSTextContainer, block: (arg1: CGRect, arg2: any) => void): void;
	drawBackgroundForGlyphRangeAtPoint(glyphsToShow: NSRange, origin: CGPoint): void;
	drawGlyphsForGlyphRangeAtPoint(glyphsToShow: NSRange, origin: CGPoint): void;
	showCGGlyphsPositionsCountFontMatrixAttributesInContext(glyphs: any, positions: any, glyphCount: number, font: UIFont, textMatrix: CGAffineTransform, attributes: NSDictionary, graphicsContext: any): void;
	fillBackgroundRectArrayCountForCharacterRangeColor(rectArray: any, rectCount: number, charRange: NSRange, color: UIColor): void;
	drawUnderlineForGlyphRangeUnderlineTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: NSRange, underlineVal: number, baselineOffset: number, lineRect: CGRect, lineGlyphRange: NSRange, containerOrigin: CGPoint): void;
	underlineGlyphRangeUnderlineTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: NSRange, underlineVal: number, lineRect: CGRect, lineGlyphRange: NSRange, containerOrigin: CGPoint): void;
	drawStrikethroughForGlyphRangeStrikethroughTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: NSRange, strikethroughVal: number, baselineOffset: number, lineRect: CGRect, lineGlyphRange: NSRange, containerOrigin: CGPoint): void;
	strikethroughGlyphRangeStrikethroughTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: NSRange, strikethroughVal: number, lineRect: CGRect, lineGlyphRange: NSRange, containerOrigin: CGPoint): void;
	init(): NSLayoutManager;
	static new(): NSLayoutManager;
	static allocWithZone(zone: any): NSLayoutManager;
	static alloc(): NSLayoutManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSShadow extends NSObject implements NSCopying, NSCoding {
	shadowOffset: CGSize;
	shadowBlurRadius: number;
	shadowColor: any;
	constructor();
	init(): NSShadow;
	static new(): NSShadow;
	static allocWithZone(zone: any): NSShadow;
	static alloc(): NSShadow;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSStringDrawingContext extends NSObject {
	minimumScaleFactor: number;
	minimumTrackingAdjustment: number;
	actualScaleFactor: number;
	actualTrackingAdjustment: number;
	totalBounds: CGRect;
	constructor();
	init(): NSStringDrawingContext;
	static new(): NSStringDrawingContext;
	static allocWithZone(zone: any): NSStringDrawingContext;
	static alloc(): NSStringDrawingContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NSTextAttachment extends NSObject implements NSTextAttachmentContainer, NSCoding {
	contents: NSData;
	fileType: string;
	fileWrapper: NSFileWrapper;
	image: UIImage;
	bounds: CGRect;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(contentData: NSData, uti: string);
	constructor();
	initWithDataOfType(contentData: NSData, uti: string): NSTextAttachment;
	init(): NSTextAttachment;
	static new(): NSTextAttachment;
	static allocWithZone(zone: any): NSTextAttachment;
	static alloc(): NSTextAttachment;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	imageForBoundsTextContainerCharacterIndex(imageBounds: CGRect, textContainer: NSTextContainer, charIndex: number): UIImage;
	attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(textContainer: NSTextContainer, lineFrag: CGRect, position: CGPoint, charIndex: number): CGRect;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NSTextContainer extends NSObject implements NSCoding, NSTextLayoutOrientationProvider {
	layoutManager: NSLayoutManager;
	size: CGSize;
	exclusionPaths: NSArray;
	lineBreakMode: number;
	lineFragmentPadding: number;
	maximumNumberOfLines: number;
	widthTracksTextView: boolean;
	heightTracksTextView: boolean;
	layoutOrientation: number;
	constructor(size: CGSize);
	constructor();
	initWithSize(size: CGSize): NSTextContainer;
	lineFragmentRectForProposedRectAtIndexWritingDirectionRemainingRect(proposedRect: CGRect, characterIndex: number, baseWritingDirection: number, remainingRect: any): CGRect;
	init(): NSTextContainer;
	static new(): NSTextContainer;
	static allocWithZone(zone: any): NSTextContainer;
	static alloc(): NSTextContainer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class UIPopoverPresentationController extends UIPresentationController {
	permittedArrowDirections: number;
	sourceView: UIView;
	sourceRect: CGRect;
	barButtonItem: UIBarButtonItem;
	arrowDirection: number;
	passthroughViews: NSArray;
	backgroundColor: UIColor;
	popoverLayoutMargins: UIEdgeInsets;
	popoverBackgroundViewClass: any;
	constructor(presentedViewController: UIViewController, presentingViewController: UIViewController);
	constructor();
	initWithPresentedViewControllerPresentingViewController(presentedViewController: UIViewController, presentingViewController: UIViewController): UIPopoverPresentationController;
	init(): UIPopoverPresentationController;
	static new(): UIPopoverPresentationController;
	static allocWithZone(zone: any): UIPopoverPresentationController;
	static alloc(): UIPopoverPresentationController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDynamicAnimator extends NSObject {
	referenceView: UIView;
	behaviors: NSArray;
	running: boolean;
	delegate: any;
	constructor(view: UIView);
	constructor(layout: UICollectionViewLayout);
	constructor();
	initWithReferenceView(view: UIView): UIDynamicAnimator;
	addBehavior(behavior: UIDynamicBehavior): void;
	removeBehavior(behavior: UIDynamicBehavior): void;
	removeAllBehaviors(): void;
	itemsInRect(rect: CGRect): NSArray;
	updateItemUsingCurrentState(item: any): void;
	elapsedTime(): number;
	initWithCollectionViewLayout(layout: UICollectionViewLayout): UIDynamicAnimator;
	layoutAttributesForCellAtIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	layoutAttributesForSupplementaryViewOfKindAtIndexPath(kind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	layoutAttributesForDecorationViewOfKindAtIndexPath(decorationViewKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
	init(): UIDynamicAnimator;
	static new(): UIDynamicAnimator;
	static allocWithZone(zone: any): UIDynamicAnimator;
	static alloc(): UIDynamicAnimator;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIPushBehavior extends UIDynamicBehavior {
	items: NSArray;
	mode: number;
	active: boolean;
	angle: number;
	magnitude: number;
	pushDirection: CGVector;
	constructor(items: NSArray, mode: number);
	constructor();
	initWithItemsMode(items: NSArray, mode: number): UIPushBehavior;
	addItem(item: any): void;
	removeItem(item: any): void;
	targetOffsetFromCenterForItem(item: any): UIOffset;
	setTargetOffsetFromCenterForItem(o: UIOffset, item: any): void;
	setAngleMagnitude(angle: number, magnitude: number): void;
	init(): UIPushBehavior;
	static new(): UIPushBehavior;
	static allocWithZone(zone: any): UIPushBehavior;
	static alloc(): UIPushBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UISnapBehavior extends UIDynamicBehavior {
	damping: number;
	constructor(item: any, point: CGPoint);
	constructor();
	initWithItemSnapToPoint(item: any, point: CGPoint): UISnapBehavior;
	init(): UISnapBehavior;
	static new(): UISnapBehavior;
	static allocWithZone(zone: any): UISnapBehavior;
	static alloc(): UISnapBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIDynamicItemBehavior extends UIDynamicBehavior {
	items: NSArray;
	elasticity: number;
	friction: number;
	density: number;
	resistance: number;
	angularResistance: number;
	allowsRotation: boolean;
	constructor(items: NSArray);
	constructor();
	initWithItems(items: NSArray): UIDynamicItemBehavior;
	addItem(item: any): void;
	removeItem(item: any): void;
	addLinearVelocityForItem(velocity: CGPoint, item: any): void;
	linearVelocityForItem(item: any): CGPoint;
	addAngularVelocityForItem(velocity: number, item: any): void;
	angularVelocityForItem(item: any): number;
	init(): UIDynamicItemBehavior;
	static new(): UIDynamicItemBehavior;
	static allocWithZone(zone: any): UIDynamicItemBehavior;
	static alloc(): UIDynamicItemBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIGravityBehavior extends UIDynamicBehavior {
	items: NSArray;
	gravityDirection: CGVector;
	angle: number;
	magnitude: number;
	constructor(items: NSArray);
	constructor();
	initWithItems(items: NSArray): UIGravityBehavior;
	addItem(item: any): void;
	removeItem(item: any): void;
	setAngleMagnitude(angle: number, magnitude: number): void;
	init(): UIGravityBehavior;
	static new(): UIGravityBehavior;
	static allocWithZone(zone: any): UIGravityBehavior;
	static alloc(): UIGravityBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UIAttachmentBehavior extends UIDynamicBehavior {
	items: NSArray;
	attachedBehaviorType: number;
	anchorPoint: CGPoint;
	length: number;
	damping: number;
	frequency: number;
	constructor(item: any, point: CGPoint);
	constructor(item: any, offset: UIOffset, point: CGPoint);
	constructor(item1: any, item2: any);
	constructor(item1: any, offset1: UIOffset, item2: any, offset2: UIOffset);
	constructor();
	initWithItemAttachedToAnchor(item: any, point: CGPoint): UIAttachmentBehavior;
	initWithItemOffsetFromCenterAttachedToAnchor(item: any, offset: UIOffset, point: CGPoint): UIAttachmentBehavior;
	initWithItemAttachedToItem(item1: any, item2: any): UIAttachmentBehavior;
	initWithItemOffsetFromCenterAttachedToItemOffsetFromCenter(item1: any, offset1: UIOffset, item2: any, offset2: UIOffset): UIAttachmentBehavior;
	init(): UIAttachmentBehavior;
	static new(): UIAttachmentBehavior;
	static allocWithZone(zone: any): UIAttachmentBehavior;
	static alloc(): UIAttachmentBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class UICollisionBehavior extends UIDynamicBehavior {
	items: NSArray;
	collisionMode: number;
	translatesReferenceBoundsIntoBoundary: boolean;
	boundaryIdentifiers: NSArray;
	collisionDelegate: any;
	constructor(items: NSArray);
	constructor();
	initWithItems(items: NSArray): UICollisionBehavior;
	addItem(item: any): void;
	removeItem(item: any): void;
	setTranslatesReferenceBoundsIntoBoundaryWithInsets(insets: UIEdgeInsets): void;
	addBoundaryWithIdentifierForPath(identifier: any, bezierPath: UIBezierPath): void;
	addBoundaryWithIdentifierFromPointToPoint(identifier: any, p1: CGPoint, p2: CGPoint): void;
	boundaryWithIdentifier(identifier: any): UIBezierPath;
	removeBoundaryWithIdentifier(identifier: any): void;
	removeAllBoundaries(): void;
	init(): UICollisionBehavior;
	static new(): UICollisionBehavior;
	static allocWithZone(zone: any): UICollisionBehavior;
	static alloc(): UICollisionBehavior;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIColor extends NSObject implements NSCoding, NSCopying {
	constructor(c: any);
	constructor(color: UIColor);
	constructor();
	static colorWithCGColor(c: any): CIColor;
	static colorWithRedGreenBlueAlpha(r: number, g: number, b: number, a: number): CIColor;
	static colorWithRedGreenBlue(r: number, g: number, b: number): CIColor;
	static colorWithString(representation: string): CIColor;
	initWithCGColor(c: any): CIColor;
	numberOfComponents(): number;
	components(): any;
	alpha(): number;
	colorSpace(): any;
	red(): number;
	green(): number;
	blue(): number;
	stringRepresentation(): string;
	initWithColor(color: UIColor): CIColor;
	init(): CIColor;
	static new(): CIColor;
	static allocWithZone(zone: any): CIColor;
	static alloc(): CIColor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CIImage extends NSObject implements NSCoding, NSCopying {
	constructor(data: NSData);
	constructor(data: NSData, d: NSDictionary);
	constructor(d: NSData, bpr: number, size: CGSize, f: number, c: any);
	constructor(name: number, size: CGSize, flag: boolean, cs: any);
	constructor(url: NSURL);
	constructor(url: NSURL, d: NSDictionary);
	constructor(color: CIColor);
	constructor(image: UIImage);
	constructor(image: UIImage, options: NSDictionary);
	constructor();
	static imageWithCGImage(image: any): CIImage;
	static imageWithCGImageOptions(image: any, d: NSDictionary): CIImage;
	static imageWithBitmapDataBytesPerRowSizeFormatColorSpace(d: NSData, bpr: number, size: CGSize, f: number, cs: any): CIImage;
	static imageWithTextureSizeFlippedColorSpace(name: number, size: CGSize, flag: boolean, cs: any): CIImage;
	static imageWithContentsOfURL(url: NSURL): CIImage;
	static imageWithContentsOfURLOptions(url: NSURL, d: NSDictionary): CIImage;
	static imageWithData(data: NSData): CIImage;
	static imageWithDataOptions(data: NSData, d: NSDictionary): CIImage;
	static imageWithCVPixelBuffer(buffer: any): CIImage;
	static imageWithCVPixelBufferOptions(buffer: any, dict: NSDictionary): CIImage;
	static imageWithColor(color: CIColor): CIImage;
	static emptyImage(): CIImage;
	initWithCGImage(image: any): CIImage;
	initWithCGImageOptions(image: any, d: NSDictionary): CIImage;
	initWithData(data: NSData): CIImage;
	initWithDataOptions(data: NSData, d: NSDictionary): CIImage;
	initWithBitmapDataBytesPerRowSizeFormatColorSpace(d: NSData, bpr: number, size: CGSize, f: number, c: any): CIImage;
	initWithTextureSizeFlippedColorSpace(name: number, size: CGSize, flag: boolean, cs: any): CIImage;
	initWithContentsOfURL(url: NSURL): CIImage;
	initWithContentsOfURLOptions(url: NSURL, d: NSDictionary): CIImage;
	initWithCVPixelBuffer(buffer: any): CIImage;
	initWithCVPixelBufferOptions(buffer: any, dict: NSDictionary): CIImage;
	initWithColor(color: CIColor): CIImage;
	imageByApplyingTransform(matrix: CGAffineTransform): CIImage;
	imageByApplyingOrientation(orientation: number): CIImage;
	imageTransformForOrientation(orientation: number): CGAffineTransform;
	imageByCompositingOverImage(dest: CIImage): CIImage;
	imageByCroppingToRect(r: CGRect): CIImage;
	imageByClampingToExtent(): CIImage;
	extent(): CGRect;
	imageByApplyingFilterWithInputParameters(filterName: string, params: NSDictionary): CIImage;
	properties(): NSDictionary;
	regionOfInterestForImageInRect(im: CIImage, r: CGRect): CGRect;
	autoAdjustmentFilters(): NSArray;
	autoAdjustmentFiltersWithOptions(dict: NSDictionary): NSArray;
	initWithImage(image: UIImage): CIImage;
	initWithImageOptions(image: UIImage, options: NSDictionary): CIImage;
	init(): CIImage;
	static new(): CIImage;
	static allocWithZone(zone: any): CIImage;
	static alloc(): CIImage;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CIContext extends NSObject {
	constructor();
	static contextWithOptions(dict: NSDictionary): CIContext;
	static contextWithEAGLContext(eaglContext: EAGLContext): CIContext;
	static contextWithEAGLContextOptions(eaglContext: EAGLContext, dict: NSDictionary): CIContext;
	drawImageAtPointFromRect(im: CIImage, p: CGPoint, src: CGRect): void;
	drawImageInRectFromRect(im: CIImage, dest: CGRect, src: CGRect): void;
	createCGImageFromRect(im: CIImage, r: CGRect): any;
	createCGImageFromRectFormatColorSpace(im: CIImage, r: CGRect, f: number, cs: any): any;
	renderToBitmapRowBytesBoundsFormatColorSpace(im: CIImage, data: any, rb: number, r: CGRect, f: number, cs: any): void;
	renderToCVPixelBuffer(image: CIImage, buffer: any): void;
	renderToCVPixelBufferBoundsColorSpace(image: CIImage, buffer: any, r: CGRect, cs: any): void;
	inputImageMaximumSize(): CGSize;
	outputImageMaximumSize(): CGSize;
	init(): CIContext;
	static new(): CIContext;
	static allocWithZone(zone: any): CIContext;
	static alloc(): CIContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIFilter extends NSObject implements NSCoding, NSCopying {
	outputImage: CIImage;
	constructor();
	name(): string;
	inputKeys(): NSArray;
	outputKeys(): NSArray;
	setDefaults(): void;
	attributes(): NSDictionary;
	static filterWithName(name: string): CIFilter;
	static filterWithNameKeysAndValues(name: string, key0: any): CIFilter;
	static filterWithNameWithInputParameters(name: string, params: NSDictionary): CIFilter;
	static filterNamesInCategory(category: string): NSArray;
	static filterNamesInCategories(categories: NSArray): NSArray;
	static serializedXMPFromFiltersInputImageExtent(filters: NSArray, extent: CGRect): NSData;
	static filterArrayFromSerializedXMPInputImageExtentError(xmpData: NSData, extent: CGRect, outError: any): NSArray;
	init(): CIFilter;
	static new(): CIFilter;
	static allocWithZone(zone: any): CIFilter;
	static alloc(): CIFilter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CIVector extends NSObject implements NSCopying, NSCoding {
	constructor(values: any, count: number);
	constructor(x: number);
	constructor(x: number, y: number);
	constructor(x: number, y: number, z: number);
	constructor(x: number, y: number, z: number, w: number);
	constructor(p: CGPoint);
	constructor(r: CGRect);
	constructor(r: CGAffineTransform);
	constructor(representation: string);
	constructor();
	static vectorWithValuesCount(values: any, count: number): CIVector;
	static vectorWithX(x: number): CIVector;
	static vectorWithXY(x: number, y: number): CIVector;
	static vectorWithXYZ(x: number, y: number, z: number): CIVector;
	static vectorWithXYZW(x: number, y: number, z: number, w: number): CIVector;
	static vectorWithCGPoint(p: CGPoint): CIVector;
	static vectorWithCGRect(r: CGRect): CIVector;
	static vectorWithCGAffineTransform(t: CGAffineTransform): CIVector;
	static vectorWithString(representation: string): CIVector;
	initWithValuesCount(values: any, count: number): CIVector;
	initWithX(x: number): CIVector;
	initWithXY(x: number, y: number): CIVector;
	initWithXYZ(x: number, y: number, z: number): CIVector;
	initWithXYZW(x: number, y: number, z: number, w: number): CIVector;
	initWithCGPoint(p: CGPoint): CIVector;
	initWithCGRect(r: CGRect): CIVector;
	initWithCGAffineTransform(r: CGAffineTransform): CIVector;
	initWithString(representation: string): CIVector;
	valueAtIndex(index: number): number;
	count(): number;
	X(): number;
	Y(): number;
	Z(): number;
	W(): number;
	CGPointValue(): CGPoint;
	CGRectValue(): CGRect;
	CGAffineTransformValue(): CGAffineTransform;
	stringRepresentation(): string;
	init(): CIVector;
	static new(): CIVector;
	static allocWithZone(zone: any): CIVector;
	static alloc(): CIVector;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CIDetector extends NSObject {
	constructor();
	static detectorOfTypeContextOptions(type: string, context: CIContext, options: NSDictionary): CIDetector;
	featuresInImage(image: CIImage): NSArray;
	featuresInImageOptions(image: CIImage, options: NSDictionary): NSArray;
	init(): CIDetector;
	static new(): CIDetector;
	static allocWithZone(zone: any): CIDetector;
	static alloc(): CIDetector;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIFeature extends NSObject {
	type: string;
	bounds: CGRect;
	constructor();
	init(): CIFeature;
	static new(): CIFeature;
	static allocWithZone(zone: any): CIFeature;
	static alloc(): CIFeature;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIFaceFeature extends CIFeature {
	hasLeftEyePosition: boolean;
	leftEyePosition: CGPoint;
	hasRightEyePosition: boolean;
	rightEyePosition: CGPoint;
	hasMouthPosition: boolean;
	mouthPosition: CGPoint;
	hasTrackingID: boolean;
	trackingID: number;
	hasTrackingFrameCount: boolean;
	trackingFrameCount: number;
	hasFaceAngle: boolean;
	faceAngle: number;
	hasSmile: boolean;
	leftEyeClosed: boolean;
	rightEyeClosed: boolean;
	constructor();
	init(): CIFaceFeature;
	static new(): CIFaceFeature;
	static allocWithZone(zone: any): CIFaceFeature;
	static alloc(): CIFaceFeature;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIRectangleFeature extends CIFeature {
	topLeft: CGPoint;
	topRight: CGPoint;
	bottomLeft: CGPoint;
	bottomRight: CGPoint;
	constructor();
	init(): CIRectangleFeature;
	static new(): CIRectangleFeature;
	static allocWithZone(zone: any): CIRectangleFeature;
	static alloc(): CIRectangleFeature;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIQRCodeFeature extends CIFeature {
	topLeft: CGPoint;
	topRight: CGPoint;
	bottomLeft: CGPoint;
	bottomRight: CGPoint;
	messageString: string;
	constructor();
	init(): CIQRCodeFeature;
	static new(): CIQRCodeFeature;
	static allocWithZone(zone: any): CIQRCodeFeature;
	static alloc(): CIQRCodeFeature;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIKernel extends NSObject {
	constructor();
	static kernelsWithString(s: string): NSArray;
	static kernelWithString(string: string): CIKernel;
	name(): string;
	applyWithExtentRoiCallbackArguments(extent: CGRect, callback: (arg1: number, arg2: CGRect) => CGRect, args: NSArray): CIImage;
	init(): CIKernel;
	static new(): CIKernel;
	static allocWithZone(zone: any): CIKernel;
	static alloc(): CIKernel;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIColorKernel extends CIKernel {
	constructor();
	applyWithExtentArguments(extent: CGRect, args: NSArray): CIImage;
	static kernelWithString(string: string): CIColorKernel;
	init(): CIColorKernel;
	static new(): CIColorKernel;
	static allocWithZone(zone: any): CIColorKernel;
	static alloc(): CIColorKernel;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CIWarpKernel extends CIKernel {
	constructor();
	applyWithExtentRoiCallbackInputImageArguments(extent: CGRect, callback: (arg1: number, arg2: CGRect) => CGRect, image: CIImage, args: NSArray): CIImage;
	static kernelWithString(string: string): CIWarpKernel;
	init(): CIWarpKernel;
	static new(): CIWarpKernel;
	static allocWithZone(zone: any): CIWarpKernel;
	static alloc(): CIWarpKernel;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EAGLSharegroup extends NSObject {
	debugLabel: string;
	constructor();
	init(): EAGLSharegroup;
	static new(): EAGLSharegroup;
	static allocWithZone(zone: any): EAGLSharegroup;
	static alloc(): EAGLSharegroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EAGLContext extends NSObject {
	API: number;
	sharegroup: EAGLSharegroup;
	debugLabel: string;
	multiThreaded: boolean;
	constructor(api: number);
	constructor(api: number, sharegroup: EAGLSharegroup);
	constructor();
	initWithAPI(api: number): EAGLContext;
	initWithAPISharegroup(api: number, sharegroup: EAGLSharegroup): EAGLContext;
	static setCurrentContext(context: EAGLContext): boolean;
	static currentContext(): EAGLContext;
	renderbufferStorageFromDrawable(target: number, drawable: any): boolean;
	presentRenderbuffer(target: number): boolean;
	init(): EAGLContext;
	static new(): EAGLContext;
	static allocWithZone(zone: any): EAGLContext;
	static alloc(): EAGLContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLVertexAttribute extends NSObject {
	name: string;
	attributeIndex: number;
	active: boolean;
	constructor();
	init(): MTLVertexAttribute;
	static new(): MTLVertexAttribute;
	static allocWithZone(zone: any): MTLVertexAttribute;
	static alloc(): MTLVertexAttribute;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLCompileOptions extends NSObject implements NSCopying {
	preprocessorMacros: NSDictionary;
	fastMathEnabled: boolean;
	constructor();
	init(): MTLCompileOptions;
	static new(): MTLCompileOptions;
	static allocWithZone(zone: any): MTLCompileOptions;
	static alloc(): MTLCompileOptions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLTextureDescriptor extends NSObject implements NSCopying {
	textureType: number;
	pixelFormat: number;
	width: number;
	height: number;
	depth: number;
	mipmapLevelCount: number;
	sampleCount: number;
	arrayLength: number;
	resourceOptions: number;
	constructor();
	static texture2DDescriptorWithPixelFormatWidthHeightMipmapped(pixelFormat: number, width: number, height: number, mipmapped: boolean): MTLTextureDescriptor;
	static textureCubeDescriptorWithPixelFormatSizeMipmapped(pixelFormat: number, size: number, mipmapped: boolean): MTLTextureDescriptor;
	init(): MTLTextureDescriptor;
	static new(): MTLTextureDescriptor;
	static allocWithZone(zone: any): MTLTextureDescriptor;
	static alloc(): MTLTextureDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLStencilDescriptor extends NSObject implements NSCopying {
	stencilCompareFunction: number;
	stencilFailureOperation: number;
	depthFailureOperation: number;
	depthStencilPassOperation: number;
	readMask: number;
	writeMask: number;
	constructor();
	init(): MTLStencilDescriptor;
	static new(): MTLStencilDescriptor;
	static allocWithZone(zone: any): MTLStencilDescriptor;
	static alloc(): MTLStencilDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLDepthStencilDescriptor extends NSObject implements NSCopying {
	depthCompareFunction: number;
	depthWriteEnabled: boolean;
	frontFaceStencil: MTLStencilDescriptor;
	backFaceStencil: MTLStencilDescriptor;
	label: string;
	constructor();
	init(): MTLDepthStencilDescriptor;
	static new(): MTLDepthStencilDescriptor;
	static allocWithZone(zone: any): MTLDepthStencilDescriptor;
	static alloc(): MTLDepthStencilDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLRenderPassAttachmentDescriptor extends NSObject implements NSCopying {
	texture: any;
	level: number;
	slice: number;
	depthPlane: number;
	resolveTexture: any;
	resolveLevel: number;
	resolveSlice: number;
	resolveDepthPlane: number;
	loadAction: number;
	storeAction: number;
	constructor();
	init(): MTLRenderPassAttachmentDescriptor;
	static new(): MTLRenderPassAttachmentDescriptor;
	static allocWithZone(zone: any): MTLRenderPassAttachmentDescriptor;
	static alloc(): MTLRenderPassAttachmentDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLRenderPassColorAttachmentDescriptor extends MTLRenderPassAttachmentDescriptor {
	clearColor: MTLClearColor;
	constructor();
	init(): MTLRenderPassColorAttachmentDescriptor;
	static new(): MTLRenderPassColorAttachmentDescriptor;
	static allocWithZone(zone: any): MTLRenderPassColorAttachmentDescriptor;
	static alloc(): MTLRenderPassColorAttachmentDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLRenderPassDepthAttachmentDescriptor extends MTLRenderPassAttachmentDescriptor {
	clearDepth: number;
	constructor();
	init(): MTLRenderPassDepthAttachmentDescriptor;
	static new(): MTLRenderPassDepthAttachmentDescriptor;
	static allocWithZone(zone: any): MTLRenderPassDepthAttachmentDescriptor;
	static alloc(): MTLRenderPassDepthAttachmentDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLRenderPassStencilAttachmentDescriptor extends MTLRenderPassAttachmentDescriptor {
	clearStencil: number;
	constructor();
	init(): MTLRenderPassStencilAttachmentDescriptor;
	static new(): MTLRenderPassStencilAttachmentDescriptor;
	static allocWithZone(zone: any): MTLRenderPassStencilAttachmentDescriptor;
	static alloc(): MTLRenderPassStencilAttachmentDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLRenderPassColorAttachmentDescriptorArray extends NSObject {
	constructor();
	objectAtIndexedSubscript(attachmentIndex: number): MTLRenderPassColorAttachmentDescriptor;
	setObjectAtIndexedSubscript(attachment: MTLRenderPassColorAttachmentDescriptor, attachmentIndex: number): void;
	init(): MTLRenderPassColorAttachmentDescriptorArray;
	static new(): MTLRenderPassColorAttachmentDescriptorArray;
	static allocWithZone(zone: any): MTLRenderPassColorAttachmentDescriptorArray;
	static alloc(): MTLRenderPassColorAttachmentDescriptorArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLRenderPassDescriptor extends NSObject implements NSCopying {
	colorAttachments: MTLRenderPassColorAttachmentDescriptorArray;
	depthAttachment: MTLRenderPassDepthAttachmentDescriptor;
	stencilAttachment: MTLRenderPassStencilAttachmentDescriptor;
	visibilityResultBuffer: any;
	constructor();
	static renderPassDescriptor(): MTLRenderPassDescriptor;
	init(): MTLRenderPassDescriptor;
	static new(): MTLRenderPassDescriptor;
	static allocWithZone(zone: any): MTLRenderPassDescriptor;
	static alloc(): MTLRenderPassDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLStructMember extends NSObject {
	name: string;
	offset: number;
	dataType: number;
	constructor();
	structType(): MTLStructType;
	arrayType(): MTLArrayType;
	init(): MTLStructMember;
	static new(): MTLStructMember;
	static allocWithZone(zone: any): MTLStructMember;
	static alloc(): MTLStructMember;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLStructType extends NSObject {
	members: NSArray;
	constructor();
	memberByName(name: string): MTLStructMember;
	init(): MTLStructType;
	static new(): MTLStructType;
	static allocWithZone(zone: any): MTLStructType;
	static alloc(): MTLStructType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLArrayType extends NSObject {
	arrayLength: number;
	elementType: number;
	stride: number;
	constructor();
	elementStructType(): MTLStructType;
	elementArrayType(): MTLArrayType;
	init(): MTLArrayType;
	static new(): MTLArrayType;
	static allocWithZone(zone: any): MTLArrayType;
	static alloc(): MTLArrayType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLArgument extends NSObject {
	name: string;
	type: number;
	access: number;
	index: number;
	active: boolean;
	bufferAlignment: number;
	bufferDataSize: number;
	bufferDataType: number;
	bufferStructType: MTLStructType;
	threadgroupMemoryAlignment: number;
	threadgroupMemoryDataSize: number;
	textureType: number;
	textureDataType: number;
	constructor();
	init(): MTLArgument;
	static new(): MTLArgument;
	static allocWithZone(zone: any): MTLArgument;
	static alloc(): MTLArgument;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLComputePipelineReflection extends NSObject {
	arguments: NSArray;
	constructor();
	init(): MTLComputePipelineReflection;
	static new(): MTLComputePipelineReflection;
	static allocWithZone(zone: any): MTLComputePipelineReflection;
	static alloc(): MTLComputePipelineReflection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLRenderPipelineColorAttachmentDescriptor extends NSObject implements NSCopying {
	pixelFormat: number;
	blendingEnabled: boolean;
	sourceRGBBlendFactor: number;
	destinationRGBBlendFactor: number;
	rgbBlendOperation: number;
	sourceAlphaBlendFactor: number;
	destinationAlphaBlendFactor: number;
	alphaBlendOperation: number;
	writeMask: number;
	constructor();
	init(): MTLRenderPipelineColorAttachmentDescriptor;
	static new(): MTLRenderPipelineColorAttachmentDescriptor;
	static allocWithZone(zone: any): MTLRenderPipelineColorAttachmentDescriptor;
	static alloc(): MTLRenderPipelineColorAttachmentDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLRenderPipelineReflection extends NSObject {
	vertexArguments: NSArray;
	fragmentArguments: NSArray;
	constructor();
	init(): MTLRenderPipelineReflection;
	static new(): MTLRenderPipelineReflection;
	static allocWithZone(zone: any): MTLRenderPipelineReflection;
	static alloc(): MTLRenderPipelineReflection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLRenderPipelineDescriptor extends NSObject implements NSCopying {
	label: string;
	vertexFunction: any;
	fragmentFunction: any;
	vertexDescriptor: MTLVertexDescriptor;
	sampleCount: number;
	alphaToCoverageEnabled: boolean;
	alphaToOneEnabled: boolean;
	rasterizationEnabled: boolean;
	colorAttachments: MTLRenderPipelineColorAttachmentDescriptorArray;
	depthAttachmentPixelFormat: number;
	stencilAttachmentPixelFormat: number;
	constructor();
	reset(): void;
	init(): MTLRenderPipelineDescriptor;
	static new(): MTLRenderPipelineDescriptor;
	static allocWithZone(zone: any): MTLRenderPipelineDescriptor;
	static alloc(): MTLRenderPipelineDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLRenderPipelineColorAttachmentDescriptorArray extends NSObject {
	constructor();
	objectAtIndexedSubscript(attachmentIndex: number): MTLRenderPipelineColorAttachmentDescriptor;
	setObjectAtIndexedSubscript(attachment: MTLRenderPipelineColorAttachmentDescriptor, attachmentIndex: number): void;
	init(): MTLRenderPipelineColorAttachmentDescriptorArray;
	static new(): MTLRenderPipelineColorAttachmentDescriptorArray;
	static allocWithZone(zone: any): MTLRenderPipelineColorAttachmentDescriptorArray;
	static alloc(): MTLRenderPipelineColorAttachmentDescriptorArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLVertexBufferLayoutDescriptor extends NSObject implements NSCopying {
	stride: number;
	stepFunction: number;
	stepRate: number;
	constructor();
	init(): MTLVertexBufferLayoutDescriptor;
	static new(): MTLVertexBufferLayoutDescriptor;
	static allocWithZone(zone: any): MTLVertexBufferLayoutDescriptor;
	static alloc(): MTLVertexBufferLayoutDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLVertexBufferLayoutDescriptorArray extends NSObject {
	constructor();
	objectAtIndexedSubscript(index: number): MTLVertexBufferLayoutDescriptor;
	setObjectAtIndexedSubscript(bufferDesc: MTLVertexBufferLayoutDescriptor, index: number): void;
	init(): MTLVertexBufferLayoutDescriptorArray;
	static new(): MTLVertexBufferLayoutDescriptorArray;
	static allocWithZone(zone: any): MTLVertexBufferLayoutDescriptorArray;
	static alloc(): MTLVertexBufferLayoutDescriptorArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLVertexAttributeDescriptor extends NSObject implements NSCopying {
	format: number;
	offset: number;
	bufferIndex: number;
	constructor();
	init(): MTLVertexAttributeDescriptor;
	static new(): MTLVertexAttributeDescriptor;
	static allocWithZone(zone: any): MTLVertexAttributeDescriptor;
	static alloc(): MTLVertexAttributeDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLVertexAttributeDescriptorArray extends NSObject {
	constructor();
	objectAtIndexedSubscript(index: number): MTLVertexAttributeDescriptor;
	setObjectAtIndexedSubscript(attributeDesc: MTLVertexAttributeDescriptor, index: number): void;
	init(): MTLVertexAttributeDescriptorArray;
	static new(): MTLVertexAttributeDescriptorArray;
	static allocWithZone(zone: any): MTLVertexAttributeDescriptorArray;
	static alloc(): MTLVertexAttributeDescriptorArray;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MTLVertexDescriptor extends NSObject implements NSCopying {
	layouts: MTLVertexBufferLayoutDescriptorArray;
	attributes: MTLVertexAttributeDescriptorArray;
	constructor();
	static vertexDescriptor(): MTLVertexDescriptor;
	reset(): void;
	init(): MTLVertexDescriptor;
	static new(): MTLVertexDescriptor;
	static allocWithZone(zone: any): MTLVertexDescriptor;
	static alloc(): MTLVertexDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MTLSamplerDescriptor extends NSObject implements NSCopying {
	minFilter: number;
	magFilter: number;
	mipFilter: number;
	maxAnisotropy: number;
	sAddressMode: number;
	tAddressMode: number;
	rAddressMode: number;
	normalizedCoordinates: boolean;
	lodMinClamp: number;
	lodMaxClamp: number;
	label: string;
	constructor();
	init(): MTLSamplerDescriptor;
	static new(): MTLSamplerDescriptor;
	static allocWithZone(zone: any): MTLSamplerDescriptor;
	static alloc(): MTLSamplerDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class ABPeoplePickerNavigationController extends UINavigationController {
	peoplePickerDelegate: any;
	displayedProperties: NSArray;
	addressBook: any;
	predicateForEnablingPerson: NSPredicate;
	predicateForSelectionOfPerson: NSPredicate;
	predicateForSelectionOfProperty: NSPredicate;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): ABPeoplePickerNavigationController;
	initWithRootViewController(rootViewController: UIViewController): ABPeoplePickerNavigationController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): ABPeoplePickerNavigationController;
	init(): ABPeoplePickerNavigationController;
	static new(): ABPeoplePickerNavigationController;
	static allocWithZone(zone: any): ABPeoplePickerNavigationController;
	static alloc(): ABPeoplePickerNavigationController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ABPersonViewController extends UIViewController implements UIViewControllerRestoration {
	personViewDelegate: any;
	addressBook: any;
	displayedPerson: any;
	displayedProperties: NSArray;
	allowsEditing: boolean;
	allowsActions: boolean;
	shouldShowLinkedPeople: boolean;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	setHighlightedItemForPropertyWithIdentifier(property: number, identifier: number): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): ABPersonViewController;
	init(): ABPersonViewController;
	static new(): ABPersonViewController;
	static allocWithZone(zone: any): ABPersonViewController;
	static alloc(): ABPersonViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static viewControllerWithRestorationIdentifierPathCoder(identifierComponents: NSArray, coder: NSCoder): UIViewController;
}
declare class ABNewPersonViewController extends UIViewController {
	newPersonViewDelegate: any;
	addressBook: any;
	displayedPerson: any;
	parentGroup: any;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): ABNewPersonViewController;
	init(): ABNewPersonViewController;
	static new(): ABNewPersonViewController;
	static allocWithZone(zone: any): ABNewPersonViewController;
	static alloc(): ABNewPersonViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ABUnknownPersonViewController extends UIViewController {
	unknownPersonViewDelegate: any;
	addressBook: any;
	displayedPerson: any;
	alternateName: string;
	message: string;
	allowsActions: boolean;
	allowsAddingToAddressBook: boolean;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): ABUnknownPersonViewController;
	init(): ABUnknownPersonViewController;
	static new(): ABUnknownPersonViewController;
	static allocWithZone(zone: any): ABUnknownPersonViewController;
	static alloc(): ABUnknownPersonViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CALayer extends NSObject implements NSCoding, CAMediaTiming {
	bounds: CGRect;
	position: CGPoint;
	zPosition: number;
	anchorPoint: CGPoint;
	anchorPointZ: number;
	transform: CATransform3D;
	frame: CGRect;
	hidden: boolean;
	doubleSided: boolean;
	geometryFlipped: boolean;
	superlayer: CALayer;
	sublayers: NSArray;
	sublayerTransform: CATransform3D;
	mask: CALayer;
	masksToBounds: boolean;
	contents: any;
	contentsRect: CGRect;
	contentsGravity: string;
	contentsScale: number;
	contentsCenter: CGRect;
	minificationFilter: string;
	magnificationFilter: string;
	minificationFilterBias: number;
	opaque: boolean;
	needsDisplayOnBoundsChange: boolean;
	drawsAsynchronously: boolean;
	edgeAntialiasingMask: number;
	allowsEdgeAntialiasing: boolean;
	backgroundColor: any;
	cornerRadius: number;
	borderWidth: number;
	borderColor: any;
	opacity: number;
	allowsGroupOpacity: boolean;
	compositingFilter: any;
	filters: NSArray;
	backgroundFilters: NSArray;
	shouldRasterize: boolean;
	rasterizationScale: number;
	shadowColor: any;
	shadowOpacity: number;
	shadowOffset: CGSize;
	shadowRadius: number;
	shadowPath: any;
	actions: NSDictionary;
	name: string;
	delegate: any;
	style: NSDictionary;
	visibleRect: CGRect;
	beginTime: number;
	duration: number;
	speed: number;
	timeOffset: number;
	repeatCount: number;
	repeatDuration: number;
	autoreverses: boolean;
	fillMode: string;
	constructor(layer: any);
	constructor();
	static layer(): CALayer;
	initWithLayer(layer: any): CALayer;
	presentationLayer(): any;
	modelLayer(): any;
	static defaultValueForKey(key: string): any;
	static needsDisplayForKey(key: string): boolean;
	shouldArchiveValueForKey(key: string): boolean;
	affineTransform(): CGAffineTransform;
	setAffineTransform(m: CGAffineTransform): void;
	contentsAreFlipped(): boolean;
	removeFromSuperlayer(): void;
	addSublayer(layer: CALayer): void;
	insertSublayerAtIndex(layer: CALayer, idx: number): void;
	insertSublayerBelow(layer: CALayer, sibling: CALayer): void;
	insertSublayerAbove(layer: CALayer, sibling: CALayer): void;
	replaceSublayerWith(layer: CALayer, layer2: CALayer): void;
	convertPointFromLayer(p: CGPoint, l: CALayer): CGPoint;
	convertPointToLayer(p: CGPoint, l: CALayer): CGPoint;
	convertRectFromLayer(r: CGRect, l: CALayer): CGRect;
	convertRectToLayer(r: CGRect, l: CALayer): CGRect;
	convertTimeFromLayer(t: number, l: CALayer): number;
	convertTimeToLayer(t: number, l: CALayer): number;
	hitTest(p: CGPoint): CALayer;
	containsPoint(p: CGPoint): boolean;
	display(): void;
	setNeedsDisplay(): void;
	setNeedsDisplayInRect(r: CGRect): void;
	needsDisplay(): boolean;
	displayIfNeeded(): void;
	drawInContext(ctx: any): void;
	renderInContext(ctx: any): void;
	preferredFrameSize(): CGSize;
	setNeedsLayout(): void;
	needsLayout(): boolean;
	layoutIfNeeded(): void;
	layoutSublayers(): void;
	static defaultActionForKey(event: string): any;
	actionForKey(event: string): any;
	addAnimationForKey(anim: CAAnimation, key: string): void;
	removeAllAnimations(): void;
	removeAnimationForKey(key: string): void;
	animationKeys(): NSArray;
	animationForKey(key: string): CAAnimation;
	scrollPoint(p: CGPoint): void;
	scrollRectToVisible(r: CGRect): void;
	init(): CALayer;
	static new(): CALayer;
	static allocWithZone(zone: any): CALayer;
	static alloc(): CALayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CAAnimation extends NSObject implements NSCoding, NSCopying, CAMediaTiming, CAAction {
	timingFunction: CAMediaTimingFunction;
	delegate: any;
	removedOnCompletion: boolean;
	beginTime: number;
	duration: number;
	speed: number;
	timeOffset: number;
	repeatCount: number;
	repeatDuration: number;
	autoreverses: boolean;
	fillMode: string;
	constructor();
	static animation(): CAAnimation;
	static defaultValueForKey(key: string): any;
	shouldArchiveValueForKey(key: string): boolean;
	init(): CAAnimation;
	static new(): CAAnimation;
	static allocWithZone(zone: any): CAAnimation;
	static alloc(): CAAnimation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	runActionForKeyObjectArguments(event: string, anObject: any, dict: NSDictionary): void;
}
declare class CAPropertyAnimation extends CAAnimation {
	keyPath: string;
	additive: boolean;
	cumulative: boolean;
	valueFunction: CAValueFunction;
	constructor();
	static animationWithKeyPath(path: string): CAPropertyAnimation;
	static animation(): CAPropertyAnimation;
	init(): CAPropertyAnimation;
	static new(): CAPropertyAnimation;
	static allocWithZone(zone: any): CAPropertyAnimation;
	static alloc(): CAPropertyAnimation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CABasicAnimation extends CAPropertyAnimation {
	fromValue: any;
	toValue: any;
	byValue: any;
	constructor();
	static animationWithKeyPath(path: string): CABasicAnimation;
	static animation(): CABasicAnimation;
	init(): CABasicAnimation;
	static new(): CABasicAnimation;
	static allocWithZone(zone: any): CABasicAnimation;
	static alloc(): CABasicAnimation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAKeyframeAnimation extends CAPropertyAnimation {
	values: NSArray;
	path: any;
	keyTimes: NSArray;
	timingFunctions: NSArray;
	calculationMode: string;
	tensionValues: NSArray;
	continuityValues: NSArray;
	biasValues: NSArray;
	rotationMode: string;
	constructor();
	static animationWithKeyPath(path: string): CAKeyframeAnimation;
	static animation(): CAKeyframeAnimation;
	init(): CAKeyframeAnimation;
	static new(): CAKeyframeAnimation;
	static allocWithZone(zone: any): CAKeyframeAnimation;
	static alloc(): CAKeyframeAnimation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CATransition extends CAAnimation {
	type: string;
	subtype: string;
	startProgress: number;
	endProgress: number;
	filter: any;
	constructor();
	static animation(): CATransition;
	init(): CATransition;
	static new(): CATransition;
	static allocWithZone(zone: any): CATransition;
	static alloc(): CATransition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAAnimationGroup extends CAAnimation {
	animations: NSArray;
	constructor();
	static animation(): CAAnimationGroup;
	init(): CAAnimationGroup;
	static new(): CAAnimationGroup;
	static allocWithZone(zone: any): CAAnimationGroup;
	static alloc(): CAAnimationGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CADisplayLink extends NSObject {
	timestamp: number;
	duration: number;
	paused: boolean;
	frameInterval: number;
	constructor();
	static displayLinkWithTargetSelector(target: any, sel: any): CADisplayLink;
	addToRunLoopForMode(runloop: NSRunLoop, mode: string): void;
	removeFromRunLoopForMode(runloop: NSRunLoop, mode: string): void;
	invalidate(): void;
	init(): CADisplayLink;
	static new(): CADisplayLink;
	static allocWithZone(zone: any): CADisplayLink;
	static alloc(): CADisplayLink;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAEAGLLayer extends CALayer implements EAGLDrawable {
	drawableProperties: NSDictionary;
	constructor(layer: any);
	constructor();
	static layer(): CAEAGLLayer;
	initWithLayer(layer: any): CAEAGLLayer;
	init(): CAEAGLLayer;
	static new(): CAEAGLLayer;
	static allocWithZone(zone: any): CAEAGLLayer;
	static alloc(): CAEAGLLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAEmitterCell extends NSObject implements NSCoding, CAMediaTiming {
	name: string;
	enabled: boolean;
	birthRate: number;
	lifetime: number;
	lifetimeRange: number;
	emissionLatitude: number;
	emissionLongitude: number;
	emissionRange: number;
	velocity: number;
	velocityRange: number;
	xAcceleration: number;
	yAcceleration: number;
	zAcceleration: number;
	scale: number;
	scaleRange: number;
	scaleSpeed: number;
	spin: number;
	spinRange: number;
	color: any;
	redRange: number;
	greenRange: number;
	blueRange: number;
	alphaRange: number;
	redSpeed: number;
	greenSpeed: number;
	blueSpeed: number;
	alphaSpeed: number;
	contents: any;
	contentsRect: CGRect;
	minificationFilter: string;
	magnificationFilter: string;
	minificationFilterBias: number;
	emitterCells: NSArray;
	style: NSDictionary;
	beginTime: number;
	duration: number;
	speed: number;
	timeOffset: number;
	repeatCount: number;
	repeatDuration: number;
	autoreverses: boolean;
	fillMode: string;
	constructor();
	static emitterCell(): CAEmitterCell;
	static defaultValueForKey(key: string): any;
	shouldArchiveValueForKey(key: string): boolean;
	init(): CAEmitterCell;
	static new(): CAEmitterCell;
	static allocWithZone(zone: any): CAEmitterCell;
	static alloc(): CAEmitterCell;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CAEmitterLayer extends CALayer {
	emitterCells: NSArray;
	birthRate: number;
	lifetime: number;
	emitterPosition: CGPoint;
	emitterZPosition: number;
	emitterSize: CGSize;
	emitterDepth: number;
	emitterShape: string;
	emitterMode: string;
	renderMode: string;
	preservesDepth: boolean;
	velocity: number;
	scale: number;
	spin: number;
	seed: number;
	constructor(layer: any);
	constructor();
	static layer(): CAEmitterLayer;
	initWithLayer(layer: any): CAEmitterLayer;
	init(): CAEmitterLayer;
	static new(): CAEmitterLayer;
	static allocWithZone(zone: any): CAEmitterLayer;
	static alloc(): CAEmitterLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAGradientLayer extends CALayer {
	colors: NSArray;
	locations: NSArray;
	startPoint: CGPoint;
	endPoint: CGPoint;
	type: string;
	constructor(layer: any);
	constructor();
	static layer(): CAGradientLayer;
	initWithLayer(layer: any): CAGradientLayer;
	init(): CAGradientLayer;
	static new(): CAGradientLayer;
	static allocWithZone(zone: any): CAGradientLayer;
	static alloc(): CAGradientLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAMediaTimingFunction extends NSObject implements NSCoding {
	constructor(c1x: number, c1y: number, c2x: number, c2y: number);
	constructor();
	static functionWithName(name: string): CAMediaTimingFunction;
	static functionWithControlPoints(c1x: number, c1y: number, c2x: number, c2y: number): CAMediaTimingFunction;
	initWithControlPoints(c1x: number, c1y: number, c2x: number, c2y: number): CAMediaTimingFunction;
	getControlPointAtIndexValues(idx: number, ptr: number[]): void;
	init(): CAMediaTimingFunction;
	static new(): CAMediaTimingFunction;
	static allocWithZone(zone: any): CAMediaTimingFunction;
	static alloc(): CAMediaTimingFunction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CAReplicatorLayer extends CALayer {
	instanceCount: number;
	preservesDepth: boolean;
	instanceDelay: number;
	instanceTransform: CATransform3D;
	instanceColor: any;
	instanceRedOffset: number;
	instanceGreenOffset: number;
	instanceBlueOffset: number;
	instanceAlphaOffset: number;
	constructor(layer: any);
	constructor();
	static layer(): CAReplicatorLayer;
	initWithLayer(layer: any): CAReplicatorLayer;
	init(): CAReplicatorLayer;
	static new(): CAReplicatorLayer;
	static allocWithZone(zone: any): CAReplicatorLayer;
	static alloc(): CAReplicatorLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAScrollLayer extends CALayer {
	scrollMode: string;
	constructor(layer: any);
	constructor();
	scrollToPoint(p: CGPoint): void;
	scrollToRect(r: CGRect): void;
	static layer(): CAScrollLayer;
	initWithLayer(layer: any): CAScrollLayer;
	init(): CAScrollLayer;
	static new(): CAScrollLayer;
	static allocWithZone(zone: any): CAScrollLayer;
	static alloc(): CAScrollLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAShapeLayer extends CALayer {
	path: any;
	fillColor: any;
	fillRule: string;
	strokeColor: any;
	strokeStart: number;
	strokeEnd: number;
	lineWidth: number;
	miterLimit: number;
	lineCap: string;
	lineJoin: string;
	lineDashPhase: number;
	lineDashPattern: NSArray;
	constructor(layer: any);
	constructor();
	static layer(): CAShapeLayer;
	initWithLayer(layer: any): CAShapeLayer;
	init(): CAShapeLayer;
	static new(): CAShapeLayer;
	static allocWithZone(zone: any): CAShapeLayer;
	static alloc(): CAShapeLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CATextLayer extends CALayer {
	string: any;
	font: any;
	fontSize: number;
	foregroundColor: any;
	wrapped: boolean;
	truncationMode: string;
	alignmentMode: string;
	constructor(layer: any);
	constructor();
	static layer(): CATextLayer;
	initWithLayer(layer: any): CATextLayer;
	init(): CATextLayer;
	static new(): CATextLayer;
	static allocWithZone(zone: any): CATextLayer;
	static alloc(): CATextLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CATiledLayer extends CALayer {
	levelsOfDetail: number;
	levelsOfDetailBias: number;
	tileSize: CGSize;
	constructor(layer: any);
	constructor();
	static fadeDuration(): number;
	static layer(): CATiledLayer;
	initWithLayer(layer: any): CATiledLayer;
	init(): CATiledLayer;
	static new(): CATiledLayer;
	static allocWithZone(zone: any): CATiledLayer;
	static alloc(): CATiledLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CATransaction extends NSObject {
	constructor();
	static begin(): void;
	static commit(): void;
	static flush(): void;
	static lock(): void;
	static unlock(): void;
	static animationDuration(): number;
	static setAnimationDuration(dur: number): void;
	static animationTimingFunction(): CAMediaTimingFunction;
	static setAnimationTimingFunction(funcArg: CAMediaTimingFunction): void;
	static disableActions(): boolean;
	static setDisableActions(flag: boolean): void;
	static completionBlock(): () => void;
	static setCompletionBlock(block: () => void): void;
	static valueForKey(key: string): any;
	static setValueForKey(anObject: any, key: string): void;
	init(): CATransaction;
	static new(): CATransaction;
	static allocWithZone(zone: any): CATransaction;
	static alloc(): CATransaction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CATransformLayer extends CALayer {
	constructor(layer: any);
	constructor();
	static layer(): CATransformLayer;
	initWithLayer(layer: any): CATransformLayer;
	init(): CATransformLayer;
	static new(): CATransformLayer;
	static allocWithZone(zone: any): CATransformLayer;
	static alloc(): CATransformLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAValueFunction extends NSObject implements NSCoding {
	name: string;
	constructor();
	static functionWithName(name: string): CAValueFunction;
	init(): CAValueFunction;
	static new(): CAValueFunction;
	static allocWithZone(zone: any): CAValueFunction;
	static alloc(): CAValueFunction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class ASIdentifierManager extends NSObject {
	advertisingIdentifier: NSUUID;
	advertisingTrackingEnabled: boolean;
	constructor();
	static sharedManager(): ASIdentifierManager;
	init(): ASIdentifierManager;
	static new(): ASIdentifierManager;
	static allocWithZone(zone: any): ASIdentifierManager;
	static alloc(): ASIdentifierManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ALAssetsLibrary extends NSObject {
	constructor();
	enumerateGroupsWithTypesUsingBlockFailureBlock(types: number, enumerationBlock: (arg1: ALAssetsGroup, arg2: any) => void, failureBlock: (arg1: NSError) => void): void;
	assetForURLResultBlockFailureBlock(assetURL: NSURL, resultBlock: (arg1: ALAsset) => void, failureBlock: (arg1: NSError) => void): void;
	groupForURLResultBlockFailureBlock(groupURL: NSURL, resultBlock: (arg1: ALAssetsGroup) => void, failureBlock: (arg1: NSError) => void): void;
	addAssetsGroupAlbumWithNameResultBlockFailureBlock(name: string, resultBlock: (arg1: ALAssetsGroup) => void, failureBlock: (arg1: NSError) => void): void;
	writeImageToSavedPhotosAlbumOrientationCompletionBlock(imageRef: any, orientation: number, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	writeImageToSavedPhotosAlbumMetadataCompletionBlock(imageRef: any, metadata: NSDictionary, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	writeImageDataToSavedPhotosAlbumMetadataCompletionBlock(imageData: NSData, metadata: NSDictionary, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	writeVideoAtPathToSavedPhotosAlbumCompletionBlock(videoPathURL: NSURL, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	videoAtPathIsCompatibleWithSavedPhotosAlbum(videoPathURL: NSURL): boolean;
	static authorizationStatus(): number;
	static disableSharedPhotoStreamsSupport(): void;
	init(): ALAssetsLibrary;
	static new(): ALAssetsLibrary;
	static allocWithZone(zone: any): ALAssetsLibrary;
	static alloc(): ALAssetsLibrary;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ALAsset extends NSObject {
	originalAsset: ALAsset;
	editable: boolean;
	constructor();
	valueForProperty(property: string): any;
	defaultRepresentation(): ALAssetRepresentation;
	representationForUTI(representationUTI: string): ALAssetRepresentation;
	thumbnail(): any;
	aspectRatioThumbnail(): any;
	writeModifiedImageDataToSavedPhotosAlbumMetadataCompletionBlock(imageData: NSData, metadata: NSDictionary, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	writeModifiedVideoAtPathToSavedPhotosAlbumCompletionBlock(videoPathURL: NSURL, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	setImageDataMetadataCompletionBlock(imageData: NSData, metadata: NSDictionary, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	setVideoAtPathCompletionBlock(videoPathURL: NSURL, completionBlock: (arg1: NSURL, arg2: NSError) => void): void;
	init(): ALAsset;
	static new(): ALAsset;
	static allocWithZone(zone: any): ALAsset;
	static alloc(): ALAsset;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ALAssetsFilter extends NSObject {
	constructor();
	static allPhotos(): ALAssetsFilter;
	static allVideos(): ALAssetsFilter;
	static allAssets(): ALAssetsFilter;
	init(): ALAssetsFilter;
	static new(): ALAssetsFilter;
	static allocWithZone(zone: any): ALAssetsFilter;
	static alloc(): ALAssetsFilter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ALAssetsGroup extends NSObject {
	editable: boolean;
	constructor();
	valueForProperty(property: string): any;
	posterImage(): any;
	setAssetsFilter(filter: ALAssetsFilter): void;
	numberOfAssets(): number;
	enumerateAssetsUsingBlock(enumerationBlock: (arg1: ALAsset, arg2: number, arg3: any) => void): void;
	enumerateAssetsWithOptionsUsingBlock(options: number, enumerationBlock: (arg1: ALAsset, arg2: number, arg3: any) => void): void;
	enumerateAssetsAtIndexesOptionsUsingBlock(indexSet: NSIndexSet, options: number, enumerationBlock: (arg1: ALAsset, arg2: number, arg3: any) => void): void;
	addAsset(asset: ALAsset): boolean;
	init(): ALAssetsGroup;
	static new(): ALAssetsGroup;
	static allocWithZone(zone: any): ALAssetsGroup;
	static alloc(): ALAssetsGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class ALAssetRepresentation extends NSObject {
	constructor();
	UTI(): string;
	dimensions(): CGSize;
	size(): number;
	getBytesFromOffsetLengthError(buffer: string, offset: number, length: number, error: any): number;
	fullResolutionImage(): any;
	CGImageWithOptions(options: NSDictionary): any;
	fullScreenImage(): any;
	url(): NSURL;
	metadata(): NSDictionary;
	orientation(): number;
	scale(): number;
	filename(): string;
	init(): ALAssetRepresentation;
	static new(): ALAssetRepresentation;
	static allocWithZone(zone: any): ALAssetRepresentation;
	static alloc(): ALAssetRepresentation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioBuffer extends NSObject implements NSCopying, NSMutableCopying {
	format: AVAudioFormat;
	audioBufferList: any;
	mutableAudioBufferList: any;
	constructor();
	init(): AVAudioBuffer;
	static new(): AVAudioBuffer;
	static allocWithZone(zone: any): AVAudioBuffer;
	static alloc(): AVAudioBuffer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVAudioPCMBuffer extends AVAudioBuffer {
	frameCapacity: number;
	frameLength: number;
	stride: number;
	floatChannelData: any;
	int16ChannelData: any;
	int32ChannelData: any;
	constructor(format: AVAudioFormat, frameCapacity: number);
	constructor();
	initWithPCMFormatFrameCapacity(format: AVAudioFormat, frameCapacity: number): AVAudioPCMBuffer;
	init(): AVAudioPCMBuffer;
	static new(): AVAudioPCMBuffer;
	static allocWithZone(zone: any): AVAudioPCMBuffer;
	static alloc(): AVAudioPCMBuffer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioChannelLayout extends NSObject {
	layoutTag: number;
	layout: any;
	channelCount: number;
	constructor(layoutTag: number);
	constructor(layout: any);
	constructor();
	initWithLayoutTag(layoutTag: number): AVAudioChannelLayout;
	initWithLayout(layout: any): AVAudioChannelLayout;
	static layoutWithLayoutTag(layoutTag: number): AVAudioChannelLayout;
	static layoutWithLayout(layout: any): AVAudioChannelLayout;
	init(): AVAudioChannelLayout;
	static new(): AVAudioChannelLayout;
	static allocWithZone(zone: any): AVAudioChannelLayout;
	static alloc(): AVAudioChannelLayout;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioEngine extends NSObject {
	musicSequence: any;
	outputNode: AVAudioOutputNode;
	inputNode: AVAudioInputNode;
	mainMixerNode: AVAudioMixerNode;
	running: boolean;
	constructor();
	attachNode(node: AVAudioNode): void;
	detachNode(node: AVAudioNode): void;
	connectToFromBusToBusFormat(node1: AVAudioNode, node2: AVAudioNode, bus1: number, bus2: number, format: AVAudioFormat): void;
	connectToFormat(node1: AVAudioNode, node2: AVAudioNode, format: AVAudioFormat): void;
	disconnectNodeInputBus(node: AVAudioNode, bus: number): void;
	disconnectNodeInput(node: AVAudioNode): void;
	disconnectNodeOutputBus(node: AVAudioNode, bus: number): void;
	disconnectNodeOutput(node: AVAudioNode): void;
	prepare(): void;
	startAndReturnError(outError: any): boolean;
	pause(): void;
	reset(): void;
	stop(): void;
	init(): AVAudioEngine;
	static new(): AVAudioEngine;
	static allocWithZone(zone: any): AVAudioEngine;
	static alloc(): AVAudioEngine;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioNode extends NSObject {
	engine: AVAudioEngine;
	numberOfInputs: number;
	numberOfOutputs: number;
	lastRenderTime: AVAudioTime;
	constructor();
	reset(): void;
	inputFormatForBus(bus: number): AVAudioFormat;
	outputFormatForBus(bus: number): AVAudioFormat;
	nameForInputBus(bus: number): string;
	nameForOutputBus(bus: number): string;
	installTapOnBusBufferSizeFormatBlock(bus: number, bufferSize: number, format: AVAudioFormat, tapBlock: (arg1: AVAudioPCMBuffer, arg2: AVAudioTime) => void): void;
	removeTapOnBus(bus: number): void;
	init(): AVAudioNode;
	static new(): AVAudioNode;
	static allocWithZone(zone: any): AVAudioNode;
	static alloc(): AVAudioNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnit extends AVAudioNode {
	audioComponentDescription: AudioComponentDescription;
	audioUnit: any;
	name: string;
	manufacturerName: string;
	version: number;
	constructor();
	loadAudioUnitPresetAtURLError(url: NSURL, error: any): boolean;
	init(): AVAudioUnit;
	static new(): AVAudioUnit;
	static allocWithZone(zone: any): AVAudioUnit;
	static alloc(): AVAudioUnit;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitEffect extends AVAudioUnit {
	bypass: boolean;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitEffect;
	init(): AVAudioUnitEffect;
	static new(): AVAudioUnitEffect;
	static allocWithZone(zone: any): AVAudioUnitEffect;
	static alloc(): AVAudioUnitEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitReverb extends AVAudioUnitEffect {
	wetDryMix: number;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	loadFactoryPreset(preset: number): void;
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitReverb;
	init(): AVAudioUnitReverb;
	static new(): AVAudioUnitReverb;
	static allocWithZone(zone: any): AVAudioUnitReverb;
	static alloc(): AVAudioUnitReverb;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitEQFilterParameters extends NSObject {
	filterType: number;
	frequency: number;
	bandwidth: number;
	gain: number;
	bypass: boolean;
	constructor();
	init(): AVAudioUnitEQFilterParameters;
	static new(): AVAudioUnitEQFilterParameters;
	static allocWithZone(zone: any): AVAudioUnitEQFilterParameters;
	static alloc(): AVAudioUnitEQFilterParameters;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitEQ extends AVAudioUnitEffect {
	bands: NSArray;
	globalGain: number;
	constructor(numberOfBands: number);
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithNumberOfBands(numberOfBands: number): AVAudioUnitEQ;
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitEQ;
	init(): AVAudioUnitEQ;
	static new(): AVAudioUnitEQ;
	static allocWithZone(zone: any): AVAudioUnitEQ;
	static alloc(): AVAudioUnitEQ;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioEnvironmentDistanceAttenuationParameters extends NSObject {
	distanceAttenuationModel: number;
	referenceDistance: number;
	maximumDistance: number;
	rolloffFactor: number;
	constructor();
	init(): AVAudioEnvironmentDistanceAttenuationParameters;
	static new(): AVAudioEnvironmentDistanceAttenuationParameters;
	static allocWithZone(zone: any): AVAudioEnvironmentDistanceAttenuationParameters;
	static alloc(): AVAudioEnvironmentDistanceAttenuationParameters;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioEnvironmentReverbParameters extends NSObject {
	enable: boolean;
	level: number;
	filterParameters: AVAudioUnitEQFilterParameters;
	constructor();
	loadFactoryReverbPreset(preset: number): void;
	init(): AVAudioEnvironmentReverbParameters;
	static new(): AVAudioEnvironmentReverbParameters;
	static allocWithZone(zone: any): AVAudioEnvironmentReverbParameters;
	static alloc(): AVAudioEnvironmentReverbParameters;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioEnvironmentNode extends AVAudioNode implements AVAudioMixing {
	outputVolume: number;
	nextAvailableInputBus: number;
	listenerPosition: AVAudio3DPoint;
	listenerVectorOrientation: AVAudio3DVectorOrientation;
	listenerAngularOrientation: AVAudio3DAngularOrientation;
	distanceAttenuationParameters: AVAudioEnvironmentDistanceAttenuationParameters;
	reverbParameters: AVAudioEnvironmentReverbParameters;
	volume: number;
	pan: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	renderingAlgorithm: number;
	rate: number;
	reverbBlend: number;
	obstruction: number;
	occlusion: number;
	position: AVAudio3DPoint;
	constructor();
	applicableRenderingAlgorithms(): NSArray;
	init(): AVAudioEnvironmentNode;
	static new(): AVAudioEnvironmentNode;
	static allocWithZone(zone: any): AVAudioEnvironmentNode;
	static alloc(): AVAudioEnvironmentNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class AVAudioFormat extends NSObject {
	standard: boolean;
	commonFormat: number;
	channelCount: number;
	sampleRate: number;
	interleaved: boolean;
	streamDescription: any;
	channelLayout: AVAudioChannelLayout;
	settings: NSDictionary;
	constructor(asbd: any);
	constructor(asbd: any, layout: AVAudioChannelLayout);
	constructor(sampleRate: number, channels: number);
	constructor(sampleRate: number, layout: AVAudioChannelLayout);
	constructor(format: number, sampleRate: number, channels: number, interleaved: boolean);
	constructor(format: number, sampleRate: number, interleaved: boolean, layout: AVAudioChannelLayout);
	constructor(settings: NSDictionary);
	constructor();
	initWithStreamDescription(asbd: any): AVAudioFormat;
	initWithStreamDescriptionChannelLayout(asbd: any, layout: AVAudioChannelLayout): AVAudioFormat;
	initStandardFormatWithSampleRateChannels(sampleRate: number, channels: number): AVAudioFormat;
	initStandardFormatWithSampleRateChannelLayout(sampleRate: number, layout: AVAudioChannelLayout): AVAudioFormat;
	initWithCommonFormatSampleRateChannelsInterleaved(format: number, sampleRate: number, channels: number, interleaved: boolean): AVAudioFormat;
	initWithCommonFormatSampleRateInterleavedChannelLayout(format: number, sampleRate: number, interleaved: boolean, layout: AVAudioChannelLayout): AVAudioFormat;
	initWithSettings(settings: NSDictionary): AVAudioFormat;
	init(): AVAudioFormat;
	static new(): AVAudioFormat;
	static allocWithZone(zone: any): AVAudioFormat;
	static alloc(): AVAudioFormat;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioFile extends NSObject {
	url: NSURL;
	fileFormat: AVAudioFormat;
	processingFormat: AVAudioFormat;
	length: number;
	framePosition: number;
	constructor(fileURL: NSURL, outError: any);
	constructor(fileURL: NSURL, format: number, interleaved: boolean, outError: any);
	constructor(fileURL: NSURL, settings: NSDictionary, outError: any);
	constructor(fileURL: NSURL, settings: NSDictionary, format: number, interleaved: boolean, outError: any);
	constructor();
	initForReadingError(fileURL: NSURL, outError: any): AVAudioFile;
	initForReadingCommonFormatInterleavedError(fileURL: NSURL, format: number, interleaved: boolean, outError: any): AVAudioFile;
	initForWritingSettingsError(fileURL: NSURL, settings: NSDictionary, outError: any): AVAudioFile;
	initForWritingSettingsCommonFormatInterleavedError(fileURL: NSURL, settings: NSDictionary, format: number, interleaved: boolean, outError: any): AVAudioFile;
	readIntoBufferError(buffer: AVAudioPCMBuffer, outError: any): boolean;
	readIntoBufferFrameCountError(buffer: AVAudioPCMBuffer, frames: number, outError: any): boolean;
	writeFromBufferError(buffer: AVAudioPCMBuffer, outError: any): boolean;
	init(): AVAudioFile;
	static new(): AVAudioFile;
	static allocWithZone(zone: any): AVAudioFile;
	static alloc(): AVAudioFile;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioIONode extends AVAudioNode {
	presentationLatency: number;
	audioUnit: any;
	constructor();
	init(): AVAudioIONode;
	static new(): AVAudioIONode;
	static allocWithZone(zone: any): AVAudioIONode;
	static alloc(): AVAudioIONode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioInputNode extends AVAudioIONode implements AVAudioMixing {
	volume: number;
	pan: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	renderingAlgorithm: number;
	rate: number;
	reverbBlend: number;
	obstruction: number;
	occlusion: number;
	position: AVAudio3DPoint;
	constructor();
	init(): AVAudioInputNode;
	static new(): AVAudioInputNode;
	static allocWithZone(zone: any): AVAudioInputNode;
	static alloc(): AVAudioInputNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class AVAudioOutputNode extends AVAudioIONode {
	constructor();
	init(): AVAudioOutputNode;
	static new(): AVAudioOutputNode;
	static allocWithZone(zone: any): AVAudioOutputNode;
	static alloc(): AVAudioOutputNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioMixerNode extends AVAudioNode implements AVAudioMixing {
	outputVolume: number;
	nextAvailableInputBus: number;
	volume: number;
	pan: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	renderingAlgorithm: number;
	rate: number;
	reverbBlend: number;
	obstruction: number;
	occlusion: number;
	position: AVAudio3DPoint;
	constructor();
	init(): AVAudioMixerNode;
	static new(): AVAudioMixerNode;
	static allocWithZone(zone: any): AVAudioMixerNode;
	static alloc(): AVAudioMixerNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class AVAudioPlayer extends NSObject {
	playing: boolean;
	numberOfChannels: number;
	duration: number;
	delegate: any;
	url: NSURL;
	data: NSData;
	pan: number;
	volume: number;
	enableRate: boolean;
	rate: number;
	currentTime: number;
	deviceCurrentTime: number;
	numberOfLoops: number;
	settings: NSDictionary;
	meteringEnabled: boolean;
	channelAssignments: NSArray;
	constructor(url: NSURL, outError: any);
	constructor(data: NSData, outError: any);
	constructor(url: NSURL, utiString: string, outError: any);
	constructor(data: NSData, utiString: string, outError: any);
	constructor();
	initWithContentsOfURLError(url: NSURL, outError: any): AVAudioPlayer;
	initWithDataError(data: NSData, outError: any): AVAudioPlayer;
	initWithContentsOfURLFileTypeHintError(url: NSURL, utiString: string, outError: any): AVAudioPlayer;
	initWithDataFileTypeHintError(data: NSData, utiString: string, outError: any): AVAudioPlayer;
	prepareToPlay(): boolean;
	play(): boolean;
	playAtTime(time: number): boolean;
	pause(): void;
	stop(): void;
	updateMeters(): void;
	peakPowerForChannel(channelNumber: number): number;
	averagePowerForChannel(channelNumber: number): number;
	init(): AVAudioPlayer;
	static new(): AVAudioPlayer;
	static allocWithZone(zone: any): AVAudioPlayer;
	static alloc(): AVAudioPlayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioPlayerNode extends AVAudioNode implements AVAudioMixing {
	playing: boolean;
	volume: number;
	pan: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	renderingAlgorithm: number;
	rate: number;
	reverbBlend: number;
	obstruction: number;
	occlusion: number;
	position: AVAudio3DPoint;
	constructor();
	scheduleBufferCompletionHandler(buffer: AVAudioPCMBuffer, completionHandler: () => void): void;
	scheduleBufferAtTimeOptionsCompletionHandler(buffer: AVAudioPCMBuffer, when: AVAudioTime, options: number, completionHandler: () => void): void;
	scheduleFileAtTimeCompletionHandler(file: AVAudioFile, when: AVAudioTime, completionHandler: () => void): void;
	scheduleSegmentStartingFrameFrameCountAtTimeCompletionHandler(file: AVAudioFile, startFrame: number, numberFrames: number, when: AVAudioTime, completionHandler: () => void): void;
	stop(): void;
	prepareWithFrameCount(frameCount: number): void;
	play(): void;
	playAtTime(when: AVAudioTime): void;
	pause(): void;
	nodeTimeForPlayerTime(playerTime: AVAudioTime): AVAudioTime;
	playerTimeForNodeTime(nodeTime: AVAudioTime): AVAudioTime;
	init(): AVAudioPlayerNode;
	static new(): AVAudioPlayerNode;
	static allocWithZone(zone: any): AVAudioPlayerNode;
	static alloc(): AVAudioPlayerNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class AVAudioRecorder extends NSObject {
	recording: boolean;
	url: NSURL;
	settings: NSDictionary;
	delegate: any;
	currentTime: number;
	deviceCurrentTime: number;
	meteringEnabled: boolean;
	channelAssignments: NSArray;
	constructor(url: NSURL, settings: NSDictionary, outError: any);
	constructor();
	initWithURLSettingsError(url: NSURL, settings: NSDictionary, outError: any): AVAudioRecorder;
	prepareToRecord(): boolean;
	record(): boolean;
	recordAtTime(time: number): boolean;
	recordForDuration(duration: number): boolean;
	recordAtTimeForDuration(time: number, duration: number): boolean;
	pause(): void;
	stop(): void;
	deleteRecording(): boolean;
	updateMeters(): void;
	peakPowerForChannel(channelNumber: number): number;
	averagePowerForChannel(channelNumber: number): number;
	init(): AVAudioRecorder;
	static new(): AVAudioRecorder;
	static allocWithZone(zone: any): AVAudioRecorder;
	static alloc(): AVAudioRecorder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioSession extends NSObject {
	category: string;
	categoryOptions: number;
	mode: string;
	otherAudioPlaying: boolean;
	secondaryAudioShouldBeSilencedHint: boolean;
	currentRoute: AVAudioSessionRouteDescription;
	preferredInput: AVAudioSessionPortDescription;
	availableInputs: NSArray;
	preferredSampleRate: number;
	preferredIOBufferDuration: number;
	preferredInputNumberOfChannels: number;
	preferredOutputNumberOfChannels: number;
	maximumInputNumberOfChannels: number;
	maximumOutputNumberOfChannels: number;
	inputGain: number;
	inputGainSettable: boolean;
	inputAvailable: boolean;
	inputDataSources: NSArray;
	inputDataSource: AVAudioSessionDataSourceDescription;
	outputDataSources: NSArray;
	outputDataSource: AVAudioSessionDataSourceDescription;
	sampleRate: number;
	inputNumberOfChannels: number;
	outputNumberOfChannels: number;
	outputVolume: number;
	inputLatency: number;
	outputLatency: number;
	IOBufferDuration: number;
	delegate: any;
	inputIsAvailable: boolean;
	currentHardwareSampleRate: number;
	currentHardwareInputNumberOfChannels: number;
	currentHardwareOutputNumberOfChannels: number;
	preferredHardwareSampleRate: number;
	constructor();
	static sharedInstance(): AVAudioSession;
	setActiveError(active: boolean, outError: any): boolean;
	setActiveWithOptionsError(active: boolean, options: number, outError: any): boolean;
	setCategoryError(category: string, outError: any): boolean;
	setCategoryWithOptionsError(category: string, options: number, outError: any): boolean;
	recordPermission(): number;
	requestRecordPermission(response: (arg1: boolean) => void): void;
	setModeError(mode: string, outError: any): boolean;
	overrideOutputAudioPortError(portOverride: number, outError: any): boolean;
	setPreferredInputError(inPort: AVAudioSessionPortDescription, outError: any): boolean;
	setPreferredSampleRateError(sampleRate: number, outError: any): boolean;
	setPreferredIOBufferDurationError(duration: number, outError: any): boolean;
	setPreferredInputNumberOfChannelsError(count: number, outError: any): boolean;
	setPreferredOutputNumberOfChannelsError(count: number, outError: any): boolean;
	setInputGainError(gain: number, outError: any): boolean;
	setInputDataSourceError(dataSource: AVAudioSessionDataSourceDescription, outError: any): boolean;
	setOutputDataSourceError(dataSource: AVAudioSessionDataSourceDescription, outError: any): boolean;
	setActiveWithFlagsError(active: boolean, flags: number, outError: any): boolean;
	setPreferredHardwareSampleRateError(sampleRate: number, outError: any): boolean;
	init(): AVAudioSession;
	static new(): AVAudioSession;
	static allocWithZone(zone: any): AVAudioSession;
	static alloc(): AVAudioSession;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioSessionChannelDescription extends NSObject {
	channelName: string;
	owningPortUID: string;
	channelNumber: number;
	channelLabel: number;
	constructor();
	init(): AVAudioSessionChannelDescription;
	static new(): AVAudioSessionChannelDescription;
	static allocWithZone(zone: any): AVAudioSessionChannelDescription;
	static alloc(): AVAudioSessionChannelDescription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioSessionPortDescription extends NSObject {
	portType: string;
	portName: string;
	UID: string;
	channels: NSArray;
	dataSources: NSArray;
	selectedDataSource: AVAudioSessionDataSourceDescription;
	preferredDataSource: AVAudioSessionDataSourceDescription;
	constructor();
	setPreferredDataSourceError(dataSource: AVAudioSessionDataSourceDescription, outError: any): boolean;
	init(): AVAudioSessionPortDescription;
	static new(): AVAudioSessionPortDescription;
	static allocWithZone(zone: any): AVAudioSessionPortDescription;
	static alloc(): AVAudioSessionPortDescription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioSessionRouteDescription extends NSObject {
	inputs: NSArray;
	outputs: NSArray;
	constructor();
	init(): AVAudioSessionRouteDescription;
	static new(): AVAudioSessionRouteDescription;
	static allocWithZone(zone: any): AVAudioSessionRouteDescription;
	static alloc(): AVAudioSessionRouteDescription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioSessionDataSourceDescription extends NSObject {
	dataSourceID: NSNumber;
	dataSourceName: string;
	location: string;
	orientation: string;
	supportedPolarPatterns: NSArray;
	selectedPolarPattern: string;
	preferredPolarPattern: string;
	constructor();
	setPreferredPolarPatternError(pattern: string, outError: any): boolean;
	init(): AVAudioSessionDataSourceDescription;
	static new(): AVAudioSessionDataSourceDescription;
	static allocWithZone(zone: any): AVAudioSessionDataSourceDescription;
	static alloc(): AVAudioSessionDataSourceDescription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioTime extends NSObject {
	hostTimeValid: boolean;
	hostTime: number;
	sampleTimeValid: boolean;
	sampleTime: number;
	sampleRate: number;
	audioTimeStamp: AudioTimeStamp;
	constructor(ts: any, sampleRate: number);
	constructor(hostTime: number);
	constructor(sampleTime: number, sampleRate: number);
	constructor(hostTime: number, sampleTime: number, sampleRate: number);
	constructor();
	initWithAudioTimeStampSampleRate(ts: any, sampleRate: number): AVAudioTime;
	initWithHostTime(hostTime: number): AVAudioTime;
	initWithSampleTimeAtRate(sampleTime: number, sampleRate: number): AVAudioTime;
	initWithHostTimeSampleTimeAtRate(hostTime: number, sampleTime: number, sampleRate: number): AVAudioTime;
	static timeWithAudioTimeStampSampleRate(ts: any, sampleRate: number): AVAudioTime;
	static timeWithHostTime(hostTime: number): AVAudioTime;
	static timeWithSampleTimeAtRate(sampleTime: number, sampleRate: number): AVAudioTime;
	static timeWithHostTimeSampleTimeAtRate(hostTime: number, sampleTime: number, sampleRate: number): AVAudioTime;
	static hostTimeForSeconds(seconds: number): number;
	static secondsForHostTime(hostTime: number): number;
	extrapolateTimeFromAnchor(anchorTime: AVAudioTime): AVAudioTime;
	init(): AVAudioTime;
	static new(): AVAudioTime;
	static allocWithZone(zone: any): AVAudioTime;
	static alloc(): AVAudioTime;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitDelay extends AVAudioUnitEffect {
	delayTime: number;
	feedback: number;
	lowPassCutoff: number;
	wetDryMix: number;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitDelay;
	init(): AVAudioUnitDelay;
	static new(): AVAudioUnitDelay;
	static allocWithZone(zone: any): AVAudioUnitDelay;
	static alloc(): AVAudioUnitDelay;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitDistortion extends AVAudioUnitEffect {
	preGain: number;
	wetDryMix: number;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	loadFactoryPreset(preset: number): void;
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitDistortion;
	init(): AVAudioUnitDistortion;
	static new(): AVAudioUnitDistortion;
	static allocWithZone(zone: any): AVAudioUnitDistortion;
	static alloc(): AVAudioUnitDistortion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitGenerator extends AVAudioUnit implements AVAudioMixing {
	bypass: boolean;
	volume: number;
	pan: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	renderingAlgorithm: number;
	rate: number;
	reverbBlend: number;
	obstruction: number;
	occlusion: number;
	position: AVAudio3DPoint;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitGenerator;
	init(): AVAudioUnitGenerator;
	static new(): AVAudioUnitGenerator;
	static allocWithZone(zone: any): AVAudioUnitGenerator;
	static alloc(): AVAudioUnitGenerator;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class AVAudioUnitMIDIInstrument extends AVAudioUnit {
	constructor(description: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(description: AudioComponentDescription): AVAudioUnitMIDIInstrument;
	startNoteWithVelocityOnChannel(note: number, velocity: number, channel: number): void;
	stopNoteOnChannel(note: number, channel: number): void;
	sendControllerWithValueOnChannel(controller: number, value: number, channel: number): void;
	sendPitchBendOnChannel(pitchbend: number, channel: number): void;
	sendPressureOnChannel(pressure: number, channel: number): void;
	sendPressureForKeyWithValueOnChannel(key: number, value: number, channel: number): void;
	sendProgramChangeOnChannel(program: number, channel: number): void;
	sendProgramChangeBankMSBBankLSBOnChannel(program: number, bankMSB: number, bankLSB: number, channel: number): void;
	sendMIDIEventData1Data2(midiStatus: number, data1: number, data2: number): void;
	sendMIDIEventData1(midiStatus: number, data1: number): void;
	sendMIDISysExEvent(midiData: NSData): void;
	init(): AVAudioUnitMIDIInstrument;
	static new(): AVAudioUnitMIDIInstrument;
	static allocWithZone(zone: any): AVAudioUnitMIDIInstrument;
	static alloc(): AVAudioUnitMIDIInstrument;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitSampler extends AVAudioUnitMIDIInstrument {
	stereoPan: number;
	masterGain: number;
	globalTuning: number;
	constructor(description: AudioComponentDescription);
	constructor();
	loadSoundBankInstrumentAtURLProgramBankMSBBankLSBError(bankURL: NSURL, program: number, bankMSB: number, bankLSB: number, outError: any): boolean;
	loadInstrumentAtURLError(instrumentURL: NSURL, outError: any): boolean;
	loadAudioFilesAtURLsError(audioFiles: NSArray, outError: any): boolean;
	initWithAudioComponentDescription(description: AudioComponentDescription): AVAudioUnitSampler;
	init(): AVAudioUnitSampler;
	static new(): AVAudioUnitSampler;
	static allocWithZone(zone: any): AVAudioUnitSampler;
	static alloc(): AVAudioUnitSampler;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitTimeEffect extends AVAudioUnit {
	bypass: boolean;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitTimeEffect;
	init(): AVAudioUnitTimeEffect;
	static new(): AVAudioUnitTimeEffect;
	static allocWithZone(zone: any): AVAudioUnitTimeEffect;
	static alloc(): AVAudioUnitTimeEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitTimePitch extends AVAudioUnitTimeEffect {
	rate: number;
	pitch: number;
	overlap: number;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitTimePitch;
	init(): AVAudioUnitTimePitch;
	static new(): AVAudioUnitTimePitch;
	static allocWithZone(zone: any): AVAudioUnitTimePitch;
	static alloc(): AVAudioUnitTimePitch;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioUnitVarispeed extends AVAudioUnitTimeEffect {
	rate: number;
	constructor(audioComponentDescription: AudioComponentDescription);
	constructor();
	initWithAudioComponentDescription(audioComponentDescription: AudioComponentDescription): AVAudioUnitVarispeed;
	init(): AVAudioUnitVarispeed;
	static new(): AVAudioUnitVarispeed;
	static allocWithZone(zone: any): AVAudioUnitVarispeed;
	static alloc(): AVAudioUnitVarispeed;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVMIDIPlayer extends NSObject {
	duration: number;
	playing: boolean;
	rate: number;
	currentPosition: number;
	constructor(inURL: NSURL, bankURL: NSURL, outError: any);
	constructor(data: NSData, bankURL: NSURL, outError: any);
	constructor();
	initWithContentsOfURLSoundBankURLError(inURL: NSURL, bankURL: NSURL, outError: any): AVMIDIPlayer;
	initWithDataSoundBankURLError(data: NSData, bankURL: NSURL, outError: any): AVMIDIPlayer;
	prepareToPlay(): void;
	play(completionHandler: () => void): void;
	stop(): void;
	init(): AVMIDIPlayer;
	static new(): AVMIDIPlayer;
	static allocWithZone(zone: any): AVMIDIPlayer;
	static alloc(): AVMIDIPlayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAsset extends NSObject implements NSCopying, AVAsynchronousKeyValueLoading {
	duration: CMTime;
	preferredRate: number;
	preferredVolume: number;
	preferredTransform: CGAffineTransform;
	naturalSize: CGSize;
	providesPreciseDurationAndTiming: boolean;
	referenceRestrictions: number;
	tracks: NSArray;
	trackGroups: NSArray;
	creationDate: AVMetadataItem;
	lyrics: string;
	commonMetadata: NSArray;
	metadata: NSArray;
	availableMetadataFormats: NSArray;
	availableChapterLocales: NSArray;
	availableMediaCharacteristicsWithMediaSelectionOptions: NSArray;
	hasProtectedContent: boolean;
	playable: boolean;
	exportable: boolean;
	readable: boolean;
	composable: boolean;
	compatibleWithSavedPhotosAlbum: boolean;
	constructor();
	static assetWithURL(URL: NSURL): any;
	cancelLoading(): void;
	trackWithTrackID(trackID: number): AVAssetTrack;
	tracksWithMediaType(mediaType: string): NSArray;
	tracksWithMediaCharacteristic(mediaCharacteristic: string): NSArray;
	metadataForFormat(format: string): NSArray;
	chapterMetadataGroupsWithTitleLocaleContainingItemsWithCommonKeys(locale: NSLocale, commonKeys: NSArray): NSArray;
	chapterMetadataGroupsBestMatchingPreferredLanguages(preferredLanguages: NSArray): NSArray;
	mediaSelectionGroupForMediaCharacteristic(mediaCharacteristic: string): AVMediaSelectionGroup;
	unusedTrackID(): number;
	init(): AVAsset;
	static new(): AVAsset;
	static allocWithZone(zone: any): AVAsset;
	static alloc(): AVAsset;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	statusOfValueForKeyError(key: string, outError: any): number;
	loadValuesAsynchronouslyForKeysCompletionHandler(keys: NSArray, handler: () => void): void;
}
declare class AVURLAsset extends AVAsset {
	URL: NSURL;
	resourceLoader: AVAssetResourceLoader;
	constructor(URL: NSURL, options: NSDictionary);
	constructor();
	static audiovisualTypes(): NSArray;
	static audiovisualMIMETypes(): NSArray;
	static isPlayableExtendedMIMEType(extendedMIMEType: string): boolean;
	static URLAssetWithURLOptions(URL: NSURL, options: NSDictionary): AVURLAsset;
	initWithURLOptions(URL: NSURL, options: NSDictionary): AVURLAsset;
	compatibleTrackForCompositionTrack(compositionTrack: AVCompositionTrack): AVAssetTrack;
	init(): AVURLAsset;
	static new(): AVURLAsset;
	static allocWithZone(zone: any): AVURLAsset;
	static alloc(): AVURLAsset;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetExportSession extends NSObject {
	presetName: string;
	asset: AVAsset;
	supportedFileTypes: NSArray;
	outputFileType: string;
	outputURL: NSURL;
	status: number;
	error: NSError;
	progress: number;
	maxDuration: CMTime;
	estimatedOutputFileLength: number;
	timeRange: CMTimeRange;
	metadata: NSArray;
	metadataItemFilter: AVMetadataItemFilter;
	fileLengthLimit: number;
	audioTimePitchAlgorithm: string;
	audioMix: AVAudioMix;
	videoComposition: AVVideoComposition;
	customVideoCompositor: any;
	shouldOptimizeForNetworkUse: boolean;
	canPerformMultiplePassesOverSourceMediaData: boolean;
	directoryForTemporaryFiles: NSURL;
	constructor(asset: AVAsset, presetName: string);
	constructor();
	static allExportPresets(): NSArray;
	static exportPresetsCompatibleWithAsset(asset: AVAsset): NSArray;
	static determineCompatibilityOfExportPresetWithAssetOutputFileTypeCompletionHandler(presetName: string, asset: AVAsset, outputFileType: string, handler: (arg1: boolean) => void): void;
	static exportSessionWithAssetPresetName(asset: AVAsset, presetName: string): AVAssetExportSession;
	initWithAssetPresetName(asset: AVAsset, presetName: string): AVAssetExportSession;
	determineCompatibleFileTypesWithCompletionHandler(handler: (arg1: NSArray) => void): void;
	exportAsynchronouslyWithCompletionHandler(handler: () => void): void;
	cancelExport(): void;
	init(): AVAssetExportSession;
	static new(): AVAssetExportSession;
	static allocWithZone(zone: any): AVAssetExportSession;
	static alloc(): AVAssetExportSession;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetImageGenerator extends NSObject {
	asset: AVAsset;
	appliesPreferredTrackTransform: boolean;
	maximumSize: CGSize;
	apertureMode: string;
	videoComposition: AVVideoComposition;
	customVideoCompositor: any;
	requestedTimeToleranceBefore: CMTime;
	requestedTimeToleranceAfter: CMTime;
	constructor(asset: AVAsset);
	constructor();
	static assetImageGeneratorWithAsset(asset: AVAsset): AVAssetImageGenerator;
	initWithAsset(asset: AVAsset): AVAssetImageGenerator;
	copyCGImageAtTimeActualTimeError(requestedTime: CMTime, actualTime: any, outError: any): any;
	generateCGImagesAsynchronouslyForTimesCompletionHandler(requestedTimes: NSArray, handler: (arg1: CMTime, arg2: any, arg3: CMTime, arg4: number, arg5: NSError) => void): void;
	cancelAllCGImageGeneration(): void;
	init(): AVAssetImageGenerator;
	static new(): AVAssetImageGenerator;
	static allocWithZone(zone: any): AVAssetImageGenerator;
	static alloc(): AVAssetImageGenerator;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReader extends NSObject {
	asset: AVAsset;
	status: number;
	error: NSError;
	timeRange: CMTimeRange;
	outputs: NSArray;
	constructor(asset: AVAsset, outError: any);
	constructor();
	static assetReaderWithAssetError(asset: AVAsset, outError: any): AVAssetReader;
	initWithAssetError(asset: AVAsset, outError: any): AVAssetReader;
	canAddOutput(output: AVAssetReaderOutput): boolean;
	addOutput(output: AVAssetReaderOutput): void;
	startReading(): boolean;
	cancelReading(): void;
	init(): AVAssetReader;
	static new(): AVAssetReader;
	static allocWithZone(zone: any): AVAssetReader;
	static alloc(): AVAssetReader;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVVideoCompositionRenderContext extends NSObject {
	size: CGSize;
	renderTransform: CGAffineTransform;
	renderScale: number;
	pixelAspectRatio: AVPixelAspectRatio;
	edgeWidths: AVEdgeWidths;
	highQualityRendering: boolean;
	videoComposition: AVVideoComposition;
	constructor();
	newPixelBuffer(): any;
	init(): AVVideoCompositionRenderContext;
	static new(): AVVideoCompositionRenderContext;
	static allocWithZone(zone: any): AVVideoCompositionRenderContext;
	static alloc(): AVVideoCompositionRenderContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAsynchronousVideoCompositionRequest extends NSObject implements NSCopying {
	renderContext: AVVideoCompositionRenderContext;
	compositionTime: CMTime;
	sourceTrackIDs: NSArray;
	videoCompositionInstruction: any;
	constructor();
	sourceFrameByTrackID(trackID: number): any;
	finishWithComposedVideoFrame(composedVideoFrame: any): void;
	finishWithError(error: NSError): void;
	finishCancelledRequest(): void;
	init(): AVAsynchronousVideoCompositionRequest;
	static new(): AVAsynchronousVideoCompositionRequest;
	static allocWithZone(zone: any): AVAsynchronousVideoCompositionRequest;
	static alloc(): AVAsynchronousVideoCompositionRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVVideoComposition extends NSObject implements NSCopying, NSMutableCopying {
	customVideoCompositorClass: any;
	frameDuration: CMTime;
	renderSize: CGSize;
	renderScale: number;
	instructions: NSArray;
	animationTool: AVVideoCompositionCoreAnimationTool;
	constructor();
	static videoCompositionWithPropertiesOfAsset(asset: AVAsset): AVVideoComposition;
	isValidForAssetTimeRangeValidationDelegate(asset: AVAsset, timeRange: CMTimeRange, validationDelegate: any): boolean;
	init(): AVVideoComposition;
	static new(): AVVideoComposition;
	static allocWithZone(zone: any): AVVideoComposition;
	static alloc(): AVVideoComposition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVMutableVideoComposition extends AVVideoComposition {
	customVideoCompositorClass: any;
	frameDuration: CMTime;
	renderSize: CGSize;
	renderScale: number;
	instructions: NSArray;
	animationTool: AVVideoCompositionCoreAnimationTool;
	constructor();
	static videoComposition(): AVMutableVideoComposition;
	static videoCompositionWithPropertiesOfAsset(asset: AVAsset): AVMutableVideoComposition;
	init(): AVMutableVideoComposition;
	static new(): AVMutableVideoComposition;
	static allocWithZone(zone: any): AVMutableVideoComposition;
	static alloc(): AVMutableVideoComposition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVVideoCompositionInstruction extends NSObject implements NSSecureCoding, NSCopying, NSMutableCopying, AVVideoCompositionInstructionProtocol {
	backgroundColor: any;
	layerInstructions: NSArray;
	timeRange: CMTimeRange;
	enablePostProcessing: boolean;
	containsTweening: boolean;
	requiredSourceTrackIDs: NSArray;
	passthroughTrackID: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	init(): AVVideoCompositionInstruction;
	static new(): AVVideoCompositionInstruction;
	static allocWithZone(zone: any): AVVideoCompositionInstruction;
	static alloc(): AVVideoCompositionInstruction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class AVMutableVideoCompositionInstruction extends AVVideoCompositionInstruction {
	timeRange: CMTimeRange;
	layerInstructions: NSArray;
	enablePostProcessing: boolean;
	constructor();
	static videoCompositionInstruction(): AVMutableVideoCompositionInstruction;
	init(): AVMutableVideoCompositionInstruction;
	static new(): AVMutableVideoCompositionInstruction;
	static allocWithZone(zone: any): AVMutableVideoCompositionInstruction;
	static alloc(): AVMutableVideoCompositionInstruction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVVideoCompositionLayerInstruction extends NSObject implements NSSecureCoding, NSCopying, NSMutableCopying {
	trackID: number;
	constructor();
	getTransformRampForTimeStartTransformEndTransformTimeRange(time: CMTime, startTransform: any, endTransform: any, timeRange: any): boolean;
	getOpacityRampForTimeStartOpacityEndOpacityTimeRange(time: CMTime, startOpacity: any, endOpacity: any, timeRange: any): boolean;
	getCropRectangleRampForTimeStartCropRectangleEndCropRectangleTimeRange(time: CMTime, startCropRectangle: any, endCropRectangle: any, timeRange: any): boolean;
	init(): AVVideoCompositionLayerInstruction;
	static new(): AVVideoCompositionLayerInstruction;
	static allocWithZone(zone: any): AVVideoCompositionLayerInstruction;
	static alloc(): AVVideoCompositionLayerInstruction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVMutableVideoCompositionLayerInstruction extends AVVideoCompositionLayerInstruction {
	trackID: number;
	constructor();
	static videoCompositionLayerInstructionWithAssetTrack(track: AVAssetTrack): AVMutableVideoCompositionLayerInstruction;
	static videoCompositionLayerInstruction(): AVMutableVideoCompositionLayerInstruction;
	setTransformRampFromStartTransformToEndTransformTimeRange(startTransform: CGAffineTransform, endTransform: CGAffineTransform, timeRange: CMTimeRange): void;
	setTransformAtTime(transform: CGAffineTransform, time: CMTime): void;
	setOpacityRampFromStartOpacityToEndOpacityTimeRange(startOpacity: number, endOpacity: number, timeRange: CMTimeRange): void;
	setOpacityAtTime(opacity: number, time: CMTime): void;
	setCropRectangleRampFromStartCropRectangleToEndCropRectangleTimeRange(startCropRectangle: CGRect, endCropRectangle: CGRect, timeRange: CMTimeRange): void;
	setCropRectangleAtTime(cropRectangle: CGRect, time: CMTime): void;
	init(): AVMutableVideoCompositionLayerInstruction;
	static new(): AVMutableVideoCompositionLayerInstruction;
	static allocWithZone(zone: any): AVMutableVideoCompositionLayerInstruction;
	static alloc(): AVMutableVideoCompositionLayerInstruction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVVideoCompositionCoreAnimationTool extends NSObject {
	constructor();
	static videoCompositionCoreAnimationToolWithAdditionalLayerAsTrackID(layer: CALayer, trackID: number): AVVideoCompositionCoreAnimationTool;
	static videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayerInLayer(videoLayer: CALayer, animationLayer: CALayer): AVVideoCompositionCoreAnimationTool;
	static videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayersInLayer(videoLayers: NSArray, animationLayer: CALayer): AVVideoCompositionCoreAnimationTool;
	init(): AVVideoCompositionCoreAnimationTool;
	static new(): AVVideoCompositionCoreAnimationTool;
	static allocWithZone(zone: any): AVVideoCompositionCoreAnimationTool;
	static alloc(): AVVideoCompositionCoreAnimationTool;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReaderOutput extends NSObject {
	mediaType: string;
	alwaysCopiesSampleData: boolean;
	supportsRandomAccess: boolean;
	constructor();
	copyNextSampleBuffer(): any;
	resetForReadingTimeRanges(timeRanges: NSArray): void;
	markConfigurationAsFinal(): void;
	init(): AVAssetReaderOutput;
	static new(): AVAssetReaderOutput;
	static allocWithZone(zone: any): AVAssetReaderOutput;
	static alloc(): AVAssetReaderOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReaderTrackOutput extends AVAssetReaderOutput {
	track: AVAssetTrack;
	outputSettings: NSDictionary;
	audioTimePitchAlgorithm: string;
	constructor(track: AVAssetTrack, outputSettings: NSDictionary);
	constructor();
	static assetReaderTrackOutputWithTrackOutputSettings(track: AVAssetTrack, outputSettings: NSDictionary): AVAssetReaderTrackOutput;
	initWithTrackOutputSettings(track: AVAssetTrack, outputSettings: NSDictionary): AVAssetReaderTrackOutput;
	init(): AVAssetReaderTrackOutput;
	static new(): AVAssetReaderTrackOutput;
	static allocWithZone(zone: any): AVAssetReaderTrackOutput;
	static alloc(): AVAssetReaderTrackOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReaderAudioMixOutput extends AVAssetReaderOutput {
	audioTracks: NSArray;
	audioSettings: NSDictionary;
	audioMix: AVAudioMix;
	audioTimePitchAlgorithm: string;
	constructor(audioTracks: NSArray, audioSettings: NSDictionary);
	constructor();
	static assetReaderAudioMixOutputWithAudioTracksAudioSettings(audioTracks: NSArray, audioSettings: NSDictionary): AVAssetReaderAudioMixOutput;
	initWithAudioTracksAudioSettings(audioTracks: NSArray, audioSettings: NSDictionary): AVAssetReaderAudioMixOutput;
	init(): AVAssetReaderAudioMixOutput;
	static new(): AVAssetReaderAudioMixOutput;
	static allocWithZone(zone: any): AVAssetReaderAudioMixOutput;
	static alloc(): AVAssetReaderAudioMixOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReaderVideoCompositionOutput extends AVAssetReaderOutput {
	videoTracks: NSArray;
	videoSettings: NSDictionary;
	videoComposition: AVVideoComposition;
	customVideoCompositor: any;
	constructor(videoTracks: NSArray, videoSettings: NSDictionary);
	constructor();
	static assetReaderVideoCompositionOutputWithVideoTracksVideoSettings(videoTracks: NSArray, videoSettings: NSDictionary): AVAssetReaderVideoCompositionOutput;
	initWithVideoTracksVideoSettings(videoTracks: NSArray, videoSettings: NSDictionary): AVAssetReaderVideoCompositionOutput;
	init(): AVAssetReaderVideoCompositionOutput;
	static new(): AVAssetReaderVideoCompositionOutput;
	static allocWithZone(zone: any): AVAssetReaderVideoCompositionOutput;
	static alloc(): AVAssetReaderVideoCompositionOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReaderOutputMetadataAdaptor extends NSObject {
	assetReaderTrackOutput: AVAssetReaderTrackOutput;
	constructor(trackOutput: AVAssetReaderTrackOutput);
	constructor();
	static assetReaderOutputMetadataAdaptorWithAssetReaderTrackOutput(trackOutput: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
	initWithAssetReaderTrackOutput(trackOutput: AVAssetReaderTrackOutput): AVAssetReaderOutputMetadataAdaptor;
	nextTimedMetadataGroup(): AVTimedMetadataGroup;
	init(): AVAssetReaderOutputMetadataAdaptor;
	static new(): AVAssetReaderOutputMetadataAdaptor;
	static allocWithZone(zone: any): AVAssetReaderOutputMetadataAdaptor;
	static alloc(): AVAssetReaderOutputMetadataAdaptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetReaderSampleReferenceOutput extends AVAssetReaderOutput {
	track: AVAssetTrack;
	constructor(track: AVAssetTrack);
	constructor();
	static assetReaderSampleReferenceOutputWithTrack(track: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
	initWithTrack(track: AVAssetTrack): AVAssetReaderSampleReferenceOutput;
	init(): AVAssetReaderSampleReferenceOutput;
	static new(): AVAssetReaderSampleReferenceOutput;
	static allocWithZone(zone: any): AVAssetReaderSampleReferenceOutput;
	static alloc(): AVAssetReaderSampleReferenceOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetResourceLoader extends NSObject {
	delegate: any;
	delegateQueue: NSObject;
	constructor();
	setDelegateQueue(delegate: any, delegateQueue: NSObject): void;
	init(): AVAssetResourceLoader;
	static new(): AVAssetResourceLoader;
	static allocWithZone(zone: any): AVAssetResourceLoader;
	static alloc(): AVAssetResourceLoader;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetResourceLoadingRequest extends NSObject {
	request: NSURLRequest;
	finished: boolean;
	cancelled: boolean;
	contentInformationRequest: AVAssetResourceLoadingContentInformationRequest;
	dataRequest: AVAssetResourceLoadingDataRequest;
	response: NSURLResponse;
	redirect: NSURLRequest;
	constructor();
	finishLoading(): void;
	finishLoadingWithError(error: NSError): void;
	streamingContentKeyRequestDataForAppContentIdentifierOptionsError(appIdentifier: NSData, contentIdentifier: NSData, options: NSDictionary, outError: any): NSData;
	finishLoadingWithResponseDataRedirect(response: NSURLResponse, data: NSData, redirect: NSURLRequest): void;
	init(): AVAssetResourceLoadingRequest;
	static new(): AVAssetResourceLoadingRequest;
	static allocWithZone(zone: any): AVAssetResourceLoadingRequest;
	static alloc(): AVAssetResourceLoadingRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetResourceRenewalRequest extends AVAssetResourceLoadingRequest {
	constructor();
	init(): AVAssetResourceRenewalRequest;
	static new(): AVAssetResourceRenewalRequest;
	static allocWithZone(zone: any): AVAssetResourceRenewalRequest;
	static alloc(): AVAssetResourceRenewalRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetResourceLoadingContentInformationRequest extends NSObject {
	contentType: string;
	contentLength: number;
	byteRangeAccessSupported: boolean;
	renewalDate: NSDate;
	constructor();
	init(): AVAssetResourceLoadingContentInformationRequest;
	static new(): AVAssetResourceLoadingContentInformationRequest;
	static allocWithZone(zone: any): AVAssetResourceLoadingContentInformationRequest;
	static alloc(): AVAssetResourceLoadingContentInformationRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetResourceLoadingDataRequest extends NSObject {
	requestedOffset: number;
	requestedLength: number;
	currentOffset: number;
	constructor();
	respondWithData(data: NSData): void;
	init(): AVAssetResourceLoadingDataRequest;
	static new(): AVAssetResourceLoadingDataRequest;
	static allocWithZone(zone: any): AVAssetResourceLoadingDataRequest;
	static alloc(): AVAssetResourceLoadingDataRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetTrackSegment extends NSObject {
	timeMapping: CMTimeMapping;
	empty: boolean;
	constructor();
	init(): AVAssetTrackSegment;
	static new(): AVAssetTrackSegment;
	static allocWithZone(zone: any): AVAssetTrackSegment;
	static alloc(): AVAssetTrackSegment;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetTrack extends NSObject implements NSCopying, AVAsynchronousKeyValueLoading {
	asset: AVAsset;
	trackID: number;
	mediaType: string;
	formatDescriptions: NSArray;
	playable: boolean;
	enabled: boolean;
	selfContained: boolean;
	totalSampleDataLength: number;
	timeRange: CMTimeRange;
	naturalTimeScale: number;
	estimatedDataRate: number;
	languageCode: string;
	extendedLanguageTag: string;
	naturalSize: CGSize;
	preferredTransform: CGAffineTransform;
	preferredVolume: number;
	nominalFrameRate: number;
	minFrameDuration: CMTime;
	requiresFrameReordering: boolean;
	segments: NSArray;
	commonMetadata: NSArray;
	metadata: NSArray;
	availableMetadataFormats: NSArray;
	availableTrackAssociationTypes: NSArray;
	constructor();
	hasMediaCharacteristic(mediaCharacteristic: string): boolean;
	segmentForTrackTime(trackTime: CMTime): AVAssetTrackSegment;
	samplePresentationTimeForTrackTime(trackTime: CMTime): CMTime;
	metadataForFormat(format: string): NSArray;
	associatedTracksOfType(trackAssociationType: string): NSArray;
	init(): AVAssetTrack;
	static new(): AVAssetTrack;
	static allocWithZone(zone: any): AVAssetTrack;
	static alloc(): AVAssetTrack;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	statusOfValueForKeyError(key: string, outError: any): number;
	loadValuesAsynchronouslyForKeysCompletionHandler(keys: NSArray, handler: () => void): void;
}
declare class AVAssetTrackGroup extends NSObject implements NSCopying {
	trackIDs: NSArray;
	constructor();
	init(): AVAssetTrackGroup;
	static new(): AVAssetTrackGroup;
	static allocWithZone(zone: any): AVAssetTrackGroup;
	static alloc(): AVAssetTrackGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVMediaSelectionGroup extends NSObject implements NSCopying {
	options: NSArray;
	defaultOption: AVMediaSelectionOption;
	allowsEmptySelection: boolean;
	constructor();
	mediaSelectionOptionWithPropertyList(plist: any): AVMediaSelectionOption;
	static playableMediaSelectionOptionsFromArray(mediaSelectionOptions: NSArray): NSArray;
	static mediaSelectionOptionsFromArrayFilteredAndSortedAccordingToPreferredLanguages(mediaSelectionOptions: NSArray, preferredLanguages: NSArray): NSArray;
	static mediaSelectionOptionsFromArrayWithLocale(mediaSelectionOptions: NSArray, locale: NSLocale): NSArray;
	static mediaSelectionOptionsFromArrayWithMediaCharacteristics(mediaSelectionOptions: NSArray, mediaCharacteristics: NSArray): NSArray;
	static mediaSelectionOptionsFromArrayWithoutMediaCharacteristics(mediaSelectionOptions: NSArray, mediaCharacteristics: NSArray): NSArray;
	init(): AVMediaSelectionGroup;
	static new(): AVMediaSelectionGroup;
	static allocWithZone(zone: any): AVMediaSelectionGroup;
	static alloc(): AVMediaSelectionGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVMediaSelectionOption extends NSObject implements NSCopying {
	mediaType: string;
	mediaSubTypes: NSArray;
	playable: boolean;
	extendedLanguageTag: string;
	locale: NSLocale;
	commonMetadata: NSArray;
	availableMetadataFormats: NSArray;
	displayName: string;
	constructor();
	hasMediaCharacteristic(mediaCharacteristic: string): boolean;
	metadataForFormat(format: string): NSArray;
	associatedMediaSelectionOptionInMediaSelectionGroup(mediaSelectionGroup: AVMediaSelectionGroup): AVMediaSelectionOption;
	propertyList(): any;
	displayNameWithLocale(locale: NSLocale): string;
	init(): AVMediaSelectionOption;
	static new(): AVMediaSelectionOption;
	static allocWithZone(zone: any): AVMediaSelectionOption;
	static alloc(): AVMediaSelectionOption;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVAssetWriter extends NSObject {
	outputURL: NSURL;
	outputFileType: string;
	availableMediaTypes: NSArray;
	status: number;
	error: NSError;
	metadata: NSArray;
	shouldOptimizeForNetworkUse: boolean;
	directoryForTemporaryFiles: NSURL;
	inputs: NSArray;
	movieFragmentInterval: CMTime;
	movieTimeScale: number;
	inputGroups: NSArray;
	constructor(outputURL: NSURL, outputFileType: string, outError: any);
	constructor();
	static assetWriterWithURLFileTypeError(outputURL: NSURL, outputFileType: string, outError: any): AVAssetWriter;
	initWithURLFileTypeError(outputURL: NSURL, outputFileType: string, outError: any): AVAssetWriter;
	canApplyOutputSettingsForMediaType(outputSettings: NSDictionary, mediaType: string): boolean;
	canAddInput(input: AVAssetWriterInput): boolean;
	addInput(input: AVAssetWriterInput): void;
	startWriting(): boolean;
	startSessionAtSourceTime(startTime: CMTime): void;
	endSessionAtSourceTime(endTime: CMTime): void;
	cancelWriting(): void;
	finishWriting(): boolean;
	finishWritingWithCompletionHandler(handler: () => void): void;
	canAddInputGroup(inputGroup: AVAssetWriterInputGroup): boolean;
	addInputGroup(inputGroup: AVAssetWriterInputGroup): void;
	init(): AVAssetWriter;
	static new(): AVAssetWriter;
	static allocWithZone(zone: any): AVAssetWriter;
	static alloc(): AVAssetWriter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetWriterInputGroup extends AVMediaSelectionGroup {
	inputs: NSArray;
	defaultInput: AVAssetWriterInput;
	constructor(inputs: NSArray, defaultInput: AVAssetWriterInput);
	constructor();
	static assetWriterInputGroupWithInputsDefaultInput(inputs: NSArray, defaultInput: AVAssetWriterInput): AVAssetWriterInputGroup;
	initWithInputsDefaultInput(inputs: NSArray, defaultInput: AVAssetWriterInput): AVAssetWriterInputGroup;
	init(): AVAssetWriterInputGroup;
	static new(): AVAssetWriterInputGroup;
	static allocWithZone(zone: any): AVAssetWriterInputGroup;
	static alloc(): AVAssetWriterInputGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetWriterInput extends NSObject {
	mediaType: string;
	outputSettings: NSDictionary;
	sourceFormatHint: any;
	metadata: NSArray;
	readyForMoreMediaData: boolean;
	expectsMediaDataInRealTime: boolean;
	languageCode: string;
	extendedLanguageTag: string;
	naturalSize: CGSize;
	transform: CGAffineTransform;
	preferredVolume: number;
	marksOutputTrackAsEnabled: boolean;
	mediaTimeScale: number;
	preferredMediaChunkDuration: CMTime;
	preferredMediaChunkAlignment: number;
	sampleReferenceBaseURL: NSURL;
	performsMultiPassEncodingIfSupported: boolean;
	canPerformMultiplePasses: boolean;
	currentPassDescription: AVAssetWriterInputPassDescription;
	constructor(mediaType: string, outputSettings: NSDictionary);
	constructor(mediaType: string, outputSettings: NSDictionary, sourceFormatHint: any);
	constructor();
	static assetWriterInputWithMediaTypeOutputSettings(mediaType: string, outputSettings: NSDictionary): AVAssetWriterInput;
	static assetWriterInputWithMediaTypeOutputSettingsSourceFormatHint(mediaType: string, outputSettings: NSDictionary, sourceFormatHint: any): AVAssetWriterInput;
	initWithMediaTypeOutputSettings(mediaType: string, outputSettings: NSDictionary): AVAssetWriterInput;
	initWithMediaTypeOutputSettingsSourceFormatHint(mediaType: string, outputSettings: NSDictionary, sourceFormatHint: any): AVAssetWriterInput;
	requestMediaDataWhenReadyOnQueueUsingBlock(queue: NSObject, block: () => void): void;
	appendSampleBuffer(sampleBuffer: any): boolean;
	markAsFinished(): void;
	canAddTrackAssociationWithTrackOfInputType(input: AVAssetWriterInput, trackAssociationType: string): boolean;
	addTrackAssociationWithTrackOfInputType(input: AVAssetWriterInput, trackAssociationType: string): void;
	respondToEachPassDescriptionOnQueueUsingBlock(queue: NSObject, block: () => void): void;
	markCurrentPassAsFinished(): void;
	init(): AVAssetWriterInput;
	static new(): AVAssetWriterInput;
	static allocWithZone(zone: any): AVAssetWriterInput;
	static alloc(): AVAssetWriterInput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetWriterInputPassDescription extends NSObject {
	sourceTimeRanges: NSArray;
	constructor();
	init(): AVAssetWriterInputPassDescription;
	static new(): AVAssetWriterInputPassDescription;
	static allocWithZone(zone: any): AVAssetWriterInputPassDescription;
	static alloc(): AVAssetWriterInputPassDescription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetWriterInputPixelBufferAdaptor extends NSObject {
	assetWriterInput: AVAssetWriterInput;
	sourcePixelBufferAttributes: NSDictionary;
	pixelBufferPool: any;
	constructor(input: AVAssetWriterInput, sourcePixelBufferAttributes: NSDictionary);
	constructor();
	static assetWriterInputPixelBufferAdaptorWithAssetWriterInputSourcePixelBufferAttributes(input: AVAssetWriterInput, sourcePixelBufferAttributes: NSDictionary): AVAssetWriterInputPixelBufferAdaptor;
	initWithAssetWriterInputSourcePixelBufferAttributes(input: AVAssetWriterInput, sourcePixelBufferAttributes: NSDictionary): AVAssetWriterInputPixelBufferAdaptor;
	appendPixelBufferWithPresentationTime(pixelBuffer: any, presentationTime: CMTime): boolean;
	init(): AVAssetWriterInputPixelBufferAdaptor;
	static new(): AVAssetWriterInputPixelBufferAdaptor;
	static allocWithZone(zone: any): AVAssetWriterInputPixelBufferAdaptor;
	static alloc(): AVAssetWriterInputPixelBufferAdaptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAssetWriterInputMetadataAdaptor extends NSObject {
	assetWriterInput: AVAssetWriterInput;
	constructor(input: AVAssetWriterInput);
	constructor();
	static assetWriterInputMetadataAdaptorWithAssetWriterInput(input: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
	initWithAssetWriterInput(input: AVAssetWriterInput): AVAssetWriterInputMetadataAdaptor;
	appendTimedMetadataGroup(timedMetadataGroup: AVTimedMetadataGroup): boolean;
	init(): AVAssetWriterInputMetadataAdaptor;
	static new(): AVAssetWriterInputMetadataAdaptor;
	static allocWithZone(zone: any): AVAssetWriterInputMetadataAdaptor;
	static alloc(): AVAssetWriterInputMetadataAdaptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioMix extends NSObject implements NSCopying, NSMutableCopying {
	inputParameters: NSArray;
	constructor();
	init(): AVAudioMix;
	static new(): AVAudioMix;
	static allocWithZone(zone: any): AVAudioMix;
	static alloc(): AVAudioMix;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVMutableAudioMix extends AVAudioMix {
	inputParameters: NSArray;
	constructor();
	static audioMix(): AVMutableAudioMix;
	init(): AVMutableAudioMix;
	static new(): AVMutableAudioMix;
	static allocWithZone(zone: any): AVMutableAudioMix;
	static alloc(): AVMutableAudioMix;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVAudioMixInputParameters extends NSObject implements NSCopying, NSMutableCopying {
	trackID: number;
	audioTimePitchAlgorithm: string;
	audioTapProcessor: any;
	constructor();
	getVolumeRampForTimeStartVolumeEndVolumeTimeRange(time: CMTime, startVolume: any, endVolume: any, timeRange: any): boolean;
	init(): AVAudioMixInputParameters;
	static new(): AVAudioMixInputParameters;
	static allocWithZone(zone: any): AVAudioMixInputParameters;
	static alloc(): AVAudioMixInputParameters;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVMutableAudioMixInputParameters extends AVAudioMixInputParameters {
	trackID: number;
	audioTimePitchAlgorithm: string;
	audioTapProcessor: any;
	constructor();
	static audioMixInputParametersWithTrack(track: AVAssetTrack): AVMutableAudioMixInputParameters;
	static audioMixInputParameters(): AVMutableAudioMixInputParameters;
	setVolumeRampFromStartVolumeToEndVolumeTimeRange(startVolume: number, endVolume: number, timeRange: CMTimeRange): void;
	setVolumeAtTime(volume: number, time: CMTime): void;
	init(): AVMutableAudioMixInputParameters;
	static new(): AVMutableAudioMixInputParameters;
	static allocWithZone(zone: any): AVMutableAudioMixInputParameters;
	static alloc(): AVMutableAudioMixInputParameters;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureDevice extends NSObject {
	uniqueID: string;
	modelID: string;
	localizedName: string;
	connected: boolean;
	formats: NSArray;
	activeFormat: AVCaptureDeviceFormat;
	activeVideoMinFrameDuration: CMTime;
	activeVideoMaxFrameDuration: CMTime;
	position: number;
	hasFlash: boolean;
	flashAvailable: boolean;
	flashActive: boolean;
	flashMode: number;
	hasTorch: boolean;
	torchAvailable: boolean;
	torchActive: boolean;
	torchLevel: number;
	torchMode: number;
	focusMode: number;
	focusPointOfInterestSupported: boolean;
	focusPointOfInterest: CGPoint;
	adjustingFocus: boolean;
	autoFocusRangeRestrictionSupported: boolean;
	autoFocusRangeRestriction: number;
	smoothAutoFocusSupported: boolean;
	smoothAutoFocusEnabled: boolean;
	lensPosition: number;
	exposureMode: number;
	exposurePointOfInterestSupported: boolean;
	exposurePointOfInterest: CGPoint;
	adjustingExposure: boolean;
	lensAperture: number;
	exposureDuration: CMTime;
	ISO: number;
	exposureTargetOffset: number;
	exposureTargetBias: number;
	minExposureTargetBias: number;
	maxExposureTargetBias: number;
	whiteBalanceMode: number;
	adjustingWhiteBalance: boolean;
	deviceWhiteBalanceGains: AVCaptureWhiteBalanceGains;
	grayWorldDeviceWhiteBalanceGains: AVCaptureWhiteBalanceGains;
	maxWhiteBalanceGain: number;
	subjectAreaChangeMonitoringEnabled: boolean;
	lowLightBoostSupported: boolean;
	lowLightBoostEnabled: boolean;
	automaticallyEnablesLowLightBoostWhenAvailable: boolean;
	videoZoomFactor: number;
	rampingVideoZoom: boolean;
	automaticallyAdjustsVideoHDREnabled: boolean;
	videoHDREnabled: boolean;
	constructor();
	static devices(): NSArray;
	static devicesWithMediaType(mediaType: string): NSArray;
	static defaultDeviceWithMediaType(mediaType: string): AVCaptureDevice;
	static deviceWithUniqueID(deviceUniqueID: string): AVCaptureDevice;
	hasMediaType(mediaType: string): boolean;
	lockForConfiguration(outError: any): boolean;
	unlockForConfiguration(): void;
	supportsAVCaptureSessionPreset(preset: string): boolean;
	isFlashModeSupported(flashMode: number): boolean;
	isTorchModeSupported(torchMode: number): boolean;
	setTorchModeOnWithLevelError(torchLevel: number, outError: any): boolean;
	isFocusModeSupported(focusMode: number): boolean;
	setFocusModeLockedWithLensPositionCompletionHandler(lensPosition: number, handler: (arg1: CMTime) => void): void;
	isExposureModeSupported(exposureMode: number): boolean;
	setExposureModeCustomWithDurationISOCompletionHandler(duration: CMTime, ISO: number, handler: (arg1: CMTime) => void): void;
	setExposureTargetBiasCompletionHandler(bias: number, handler: (arg1: CMTime) => void): void;
	isWhiteBalanceModeSupported(whiteBalanceMode: number): boolean;
	setWhiteBalanceModeLockedWithDeviceWhiteBalanceGainsCompletionHandler(whiteBalanceGains: AVCaptureWhiteBalanceGains, handler: (arg1: CMTime) => void): void;
	chromaticityValuesForDeviceWhiteBalanceGains(whiteBalanceGains: AVCaptureWhiteBalanceGains): AVCaptureWhiteBalanceChromaticityValues;
	deviceWhiteBalanceGainsForChromaticityValues(chromaticityValues: AVCaptureWhiteBalanceChromaticityValues): AVCaptureWhiteBalanceGains;
	temperatureAndTintValuesForDeviceWhiteBalanceGains(whiteBalanceGains: AVCaptureWhiteBalanceGains): AVCaptureWhiteBalanceTemperatureAndTintValues;
	deviceWhiteBalanceGainsForTemperatureAndTintValues(tempAndTintValues: AVCaptureWhiteBalanceTemperatureAndTintValues): AVCaptureWhiteBalanceGains;
	rampToVideoZoomFactorWithRate(factor: number, rate: number): void;
	cancelVideoZoomRamp(): void;
	static authorizationStatusForMediaType(mediaType: string): number;
	static requestAccessForMediaTypeCompletionHandler(mediaType: string, handler: (arg1: boolean) => void): void;
	init(): AVCaptureDevice;
	static new(): AVCaptureDevice;
	static allocWithZone(zone: any): AVCaptureDevice;
	static alloc(): AVCaptureDevice;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVFrameRateRange extends NSObject {
	minFrameRate: number;
	maxFrameRate: number;
	maxFrameDuration: CMTime;
	minFrameDuration: CMTime;
	constructor();
	init(): AVFrameRateRange;
	static new(): AVFrameRateRange;
	static allocWithZone(zone: any): AVFrameRateRange;
	static alloc(): AVFrameRateRange;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureDeviceFormat extends NSObject {
	mediaType: string;
	formatDescription: any;
	videoSupportedFrameRateRanges: NSArray;
	videoFieldOfView: number;
	videoBinned: boolean;
	videoStabilizationSupported: boolean;
	videoMaxZoomFactor: number;
	videoZoomFactorUpscaleThreshold: number;
	minExposureDuration: CMTime;
	maxExposureDuration: CMTime;
	minISO: number;
	maxISO: number;
	videoHDRSupported: boolean;
	highResolutionStillImageDimensions: CMVideoDimensions;
	autoFocusSystem: number;
	constructor();
	isVideoStabilizationModeSupported(videoStabilizationMode: number): boolean;
	init(): AVCaptureDeviceFormat;
	static new(): AVCaptureDeviceFormat;
	static allocWithZone(zone: any): AVCaptureDeviceFormat;
	static alloc(): AVCaptureDeviceFormat;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureInput extends NSObject {
	ports: NSArray;
	constructor();
	init(): AVCaptureInput;
	static new(): AVCaptureInput;
	static allocWithZone(zone: any): AVCaptureInput;
	static alloc(): AVCaptureInput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureInputPort extends NSObject {
	input: AVCaptureInput;
	mediaType: string;
	formatDescription: any;
	enabled: boolean;
	clock: any;
	constructor();
	init(): AVCaptureInputPort;
	static new(): AVCaptureInputPort;
	static allocWithZone(zone: any): AVCaptureInputPort;
	static alloc(): AVCaptureInputPort;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureDeviceInput extends AVCaptureInput {
	device: AVCaptureDevice;
	constructor(device: AVCaptureDevice, outError: any);
	constructor();
	static deviceInputWithDeviceError(device: AVCaptureDevice, outError: any): any;
	initWithDeviceError(device: AVCaptureDevice, outError: any): AVCaptureDeviceInput;
	init(): AVCaptureDeviceInput;
	static new(): AVCaptureDeviceInput;
	static allocWithZone(zone: any): AVCaptureDeviceInput;
	static alloc(): AVCaptureDeviceInput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureSession extends NSObject {
	sessionPreset: string;
	inputs: NSArray;
	outputs: NSArray;
	running: boolean;
	interrupted: boolean;
	usesApplicationAudioSession: boolean;
	automaticallyConfiguresApplicationAudioSession: boolean;
	masterClock: any;
	constructor();
	canSetSessionPreset(preset: string): boolean;
	canAddInput(input: AVCaptureInput): boolean;
	addInput(input: AVCaptureInput): void;
	removeInput(input: AVCaptureInput): void;
	canAddOutput(output: AVCaptureOutput): boolean;
	addOutput(output: AVCaptureOutput): void;
	removeOutput(output: AVCaptureOutput): void;
	addInputWithNoConnections(input: AVCaptureInput): void;
	addOutputWithNoConnections(output: AVCaptureOutput): void;
	canAddConnection(connection: AVCaptureConnection): boolean;
	addConnection(connection: AVCaptureConnection): void;
	removeConnection(connection: AVCaptureConnection): void;
	beginConfiguration(): void;
	commitConfiguration(): void;
	startRunning(): void;
	stopRunning(): void;
	init(): AVCaptureSession;
	static new(): AVCaptureSession;
	static allocWithZone(zone: any): AVCaptureSession;
	static alloc(): AVCaptureSession;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureConnection extends NSObject {
	inputPorts: NSArray;
	output: AVCaptureOutput;
	videoPreviewLayer: AVCaptureVideoPreviewLayer;
	enabled: boolean;
	active: boolean;
	audioChannels: NSArray;
	supportsVideoMirroring: boolean;
	videoMirrored: boolean;
	automaticallyAdjustsVideoMirroring: boolean;
	supportsVideoOrientation: boolean;
	videoOrientation: number;
	supportsVideoMinFrameDuration: boolean;
	videoMinFrameDuration: CMTime;
	supportsVideoMaxFrameDuration: boolean;
	videoMaxFrameDuration: CMTime;
	videoMaxScaleAndCropFactor: number;
	videoScaleAndCropFactor: number;
	preferredVideoStabilizationMode: number;
	activeVideoStabilizationMode: number;
	supportsVideoStabilization: boolean;
	videoStabilizationEnabled: boolean;
	enablesVideoStabilizationWhenAvailable: boolean;
	constructor(ports: NSArray, output: AVCaptureOutput);
	constructor(port: AVCaptureInputPort, layer: AVCaptureVideoPreviewLayer);
	constructor();
	static connectionWithInputPortsOutput(ports: NSArray, output: AVCaptureOutput): AVCaptureConnection;
	static connectionWithInputPortVideoPreviewLayer(port: AVCaptureInputPort, layer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
	initWithInputPortsOutput(ports: NSArray, output: AVCaptureOutput): AVCaptureConnection;
	initWithInputPortVideoPreviewLayer(port: AVCaptureInputPort, layer: AVCaptureVideoPreviewLayer): AVCaptureConnection;
	init(): AVCaptureConnection;
	static new(): AVCaptureConnection;
	static allocWithZone(zone: any): AVCaptureConnection;
	static alloc(): AVCaptureConnection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureAudioChannel extends NSObject {
	averagePowerLevel: number;
	peakHoldLevel: number;
	constructor();
	init(): AVCaptureAudioChannel;
	static new(): AVCaptureAudioChannel;
	static allocWithZone(zone: any): AVCaptureAudioChannel;
	static alloc(): AVCaptureAudioChannel;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureOutput extends NSObject {
	connections: NSArray;
	constructor();
	connectionWithMediaType(mediaType: string): AVCaptureConnection;
	transformedMetadataObjectForMetadataObjectConnection(metadataObject: AVMetadataObject, connection: AVCaptureConnection): AVMetadataObject;
	metadataOutputRectOfInterestForRect(rectInOutputCoordinates: CGRect): CGRect;
	rectForMetadataOutputRectOfInterest(rectInMetadataOutputCoordinates: CGRect): CGRect;
	init(): AVCaptureOutput;
	static new(): AVCaptureOutput;
	static allocWithZone(zone: any): AVCaptureOutput;
	static alloc(): AVCaptureOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureVideoDataOutput extends AVCaptureOutput {
	sampleBufferDelegate: any;
	sampleBufferCallbackQueue: NSObject;
	videoSettings: NSDictionary;
	availableVideoCVPixelFormatTypes: NSArray;
	availableVideoCodecTypes: NSArray;
	minFrameDuration: CMTime;
	alwaysDiscardsLateVideoFrames: boolean;
	constructor();
	setSampleBufferDelegateQueue(sampleBufferDelegate: any, sampleBufferCallbackQueue: NSObject): void;
	recommendedVideoSettingsForAssetWriterWithOutputFileType(outputFileType: string): NSDictionary;
	init(): AVCaptureVideoDataOutput;
	static new(): AVCaptureVideoDataOutput;
	static allocWithZone(zone: any): AVCaptureVideoDataOutput;
	static alloc(): AVCaptureVideoDataOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureAudioDataOutput extends AVCaptureOutput {
	sampleBufferDelegate: any;
	sampleBufferCallbackQueue: NSObject;
	constructor();
	setSampleBufferDelegateQueue(sampleBufferDelegate: any, sampleBufferCallbackQueue: NSObject): void;
	recommendedAudioSettingsForAssetWriterWithOutputFileType(outputFileType: string): NSDictionary;
	init(): AVCaptureAudioDataOutput;
	static new(): AVCaptureAudioDataOutput;
	static allocWithZone(zone: any): AVCaptureAudioDataOutput;
	static alloc(): AVCaptureAudioDataOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureFileOutput extends AVCaptureOutput {
	outputFileURL: NSURL;
	recording: boolean;
	recordedDuration: CMTime;
	recordedFileSize: number;
	maxRecordedDuration: CMTime;
	maxRecordedFileSize: number;
	minFreeDiskSpaceLimit: number;
	constructor();
	startRecordingToOutputFileURLRecordingDelegate(outputFileURL: NSURL, delegate: any): void;
	stopRecording(): void;
	init(): AVCaptureFileOutput;
	static new(): AVCaptureFileOutput;
	static allocWithZone(zone: any): AVCaptureFileOutput;
	static alloc(): AVCaptureFileOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureMovieFileOutput extends AVCaptureFileOutput {
	movieFragmentInterval: CMTime;
	metadata: NSArray;
	constructor();
	init(): AVCaptureMovieFileOutput;
	static new(): AVCaptureMovieFileOutput;
	static allocWithZone(zone: any): AVCaptureMovieFileOutput;
	static alloc(): AVCaptureMovieFileOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureStillImageOutput extends AVCaptureOutput {
	outputSettings: NSDictionary;
	availableImageDataCVPixelFormatTypes: NSArray;
	availableImageDataCodecTypes: NSArray;
	stillImageStabilizationSupported: boolean;
	automaticallyEnablesStillImageStabilizationWhenAvailable: boolean;
	stillImageStabilizationActive: boolean;
	highResolutionStillImageOutputEnabled: boolean;
	capturingStillImage: boolean;
	maxBracketedCaptureStillImageCount: number;
	constructor();
	captureStillImageAsynchronouslyFromConnectionCompletionHandler(connection: AVCaptureConnection, handler: (arg1: any, arg2: NSError) => void): void;
	static jpegStillImageNSDataRepresentation(jpegSampleBuffer: any): NSData;
	prepareToCaptureStillImageBracketFromConnectionWithSettingsArrayCompletionHandler(connection: AVCaptureConnection, settings: NSArray, handler: (arg1: boolean, arg2: NSError) => void): void;
	captureStillImageBracketAsynchronouslyFromConnectionWithSettingsArrayCompletionHandler(connection: AVCaptureConnection, settings: NSArray, handler: (arg1: any, arg2: AVCaptureBracketedStillImageSettings, arg3: NSError) => void): void;
	init(): AVCaptureStillImageOutput;
	static new(): AVCaptureStillImageOutput;
	static allocWithZone(zone: any): AVCaptureStillImageOutput;
	static alloc(): AVCaptureStillImageOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureBracketedStillImageSettings extends NSObject {
	constructor();
	init(): AVCaptureBracketedStillImageSettings;
	static new(): AVCaptureBracketedStillImageSettings;
	static allocWithZone(zone: any): AVCaptureBracketedStillImageSettings;
	static alloc(): AVCaptureBracketedStillImageSettings;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureManualExposureBracketedStillImageSettings extends AVCaptureBracketedStillImageSettings {
	exposureDuration: CMTime;
	ISO: number;
	constructor();
	static manualExposureSettingsWithExposureDurationISO(duration: CMTime, ISO: number): AVCaptureManualExposureBracketedStillImageSettings;
	init(): AVCaptureManualExposureBracketedStillImageSettings;
	static new(): AVCaptureManualExposureBracketedStillImageSettings;
	static allocWithZone(zone: any): AVCaptureManualExposureBracketedStillImageSettings;
	static alloc(): AVCaptureManualExposureBracketedStillImageSettings;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureAutoExposureBracketedStillImageSettings extends AVCaptureBracketedStillImageSettings {
	exposureTargetBias: number;
	constructor();
	static autoExposureSettingsWithExposureTargetBias(exposureTargetBias: number): AVCaptureAutoExposureBracketedStillImageSettings;
	init(): AVCaptureAutoExposureBracketedStillImageSettings;
	static new(): AVCaptureAutoExposureBracketedStillImageSettings;
	static allocWithZone(zone: any): AVCaptureAutoExposureBracketedStillImageSettings;
	static alloc(): AVCaptureAutoExposureBracketedStillImageSettings;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureMetadataOutput extends AVCaptureOutput {
	metadataObjectsDelegate: any;
	metadataObjectsCallbackQueue: NSObject;
	availableMetadataObjectTypes: NSArray;
	metadataObjectTypes: NSArray;
	rectOfInterest: CGRect;
	constructor();
	setMetadataObjectsDelegateQueue(objectsDelegate: any, objectsCallbackQueue: NSObject): void;
	init(): AVCaptureMetadataOutput;
	static new(): AVCaptureMetadataOutput;
	static allocWithZone(zone: any): AVCaptureMetadataOutput;
	static alloc(): AVCaptureMetadataOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCaptureVideoPreviewLayer extends CALayer {
	session: AVCaptureSession;
	connection: AVCaptureConnection;
	videoGravity: string;
	orientationSupported: boolean;
	orientation: number;
	mirroringSupported: boolean;
	automaticallyAdjustsMirroring: boolean;
	mirrored: boolean;
	constructor(layer: any);
	constructor();
	static layerWithSession(session: AVCaptureSession): any;
	initWithSession(session: AVCaptureSession): AVCaptureVideoPreviewLayer;
	static layerWithSessionWithNoConnection(session: AVCaptureSession): any;
	initWithSessionWithNoConnection(session: AVCaptureSession): AVCaptureVideoPreviewLayer;
	setSessionWithNoConnection(session: AVCaptureSession): void;
	captureDevicePointOfInterestForPoint(pointInLayer: CGPoint): CGPoint;
	pointForCaptureDevicePointOfInterest(captureDevicePointOfInterest: CGPoint): CGPoint;
	metadataOutputRectOfInterestForRect(rectInLayerCoordinates: CGRect): CGRect;
	rectForMetadataOutputRectOfInterest(rectInMetadataOutputCoordinates: CGRect): CGRect;
	transformedMetadataObjectForMetadataObject(metadataObject: AVMetadataObject): AVMetadataObject;
	static layer(): AVCaptureVideoPreviewLayer;
	initWithLayer(layer: any): AVCaptureVideoPreviewLayer;
	init(): AVCaptureVideoPreviewLayer;
	static new(): AVCaptureVideoPreviewLayer;
	static allocWithZone(zone: any): AVCaptureVideoPreviewLayer;
	static alloc(): AVCaptureVideoPreviewLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVComposition extends AVAsset implements NSMutableCopying {
	constructor();
	init(): AVComposition;
	static new(): AVComposition;
	static allocWithZone(zone: any): AVComposition;
	static alloc(): AVComposition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVMutableComposition extends AVComposition {
	naturalSize: CGSize;
	constructor();
	static composition(): AVMutableComposition;
	insertTimeRangeOfAssetAtTimeError(timeRange: CMTimeRange, asset: AVAsset, startTime: CMTime, outError: any): boolean;
	insertEmptyTimeRange(timeRange: CMTimeRange): void;
	removeTimeRange(timeRange: CMTimeRange): void;
	scaleTimeRangeToDuration(timeRange: CMTimeRange, duration: CMTime): void;
	addMutableTrackWithMediaTypePreferredTrackID(mediaType: string, preferredTrackID: number): AVMutableCompositionTrack;
	removeTrack(track: AVCompositionTrack): void;
	mutableTrackCompatibleWithTrack(track: AVAssetTrack): AVMutableCompositionTrack;
	init(): AVMutableComposition;
	static new(): AVMutableComposition;
	static allocWithZone(zone: any): AVMutableComposition;
	static alloc(): AVMutableComposition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCompositionTrack extends AVAssetTrack {
	constructor();
	init(): AVCompositionTrack;
	static new(): AVCompositionTrack;
	static allocWithZone(zone: any): AVCompositionTrack;
	static alloc(): AVCompositionTrack;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVMutableCompositionTrack extends AVCompositionTrack {
	naturalTimeScale: number;
	languageCode: string;
	extendedLanguageTag: string;
	preferredTransform: CGAffineTransform;
	preferredVolume: number;
	segments: NSArray;
	constructor();
	insertTimeRangeOfTrackAtTimeError(timeRange: CMTimeRange, track: AVAssetTrack, startTime: CMTime, error: any): boolean;
	insertTimeRangesOfTracksAtTimeError(timeRanges: NSArray, tracks: NSArray, startTime: CMTime, error: any): boolean;
	insertEmptyTimeRange(timeRange: CMTimeRange): void;
	removeTimeRange(timeRange: CMTimeRange): void;
	scaleTimeRangeToDuration(timeRange: CMTimeRange, duration: CMTime): void;
	validateTrackSegmentsError(trackSegments: NSArray, error: any): boolean;
	init(): AVMutableCompositionTrack;
	static new(): AVMutableCompositionTrack;
	static allocWithZone(zone: any): AVMutableCompositionTrack;
	static alloc(): AVMutableCompositionTrack;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVCompositionTrackSegment extends AVAssetTrackSegment {
	sourceURL: NSURL;
	sourceTrackID: number;
	constructor(URL: NSURL, trackID: number, sourceTimeRange: CMTimeRange, targetTimeRange: CMTimeRange);
	constructor(timeRange: CMTimeRange);
	constructor();
	static compositionTrackSegmentWithURLTrackIDSourceTimeRangeTargetTimeRange(URL: NSURL, trackID: number, sourceTimeRange: CMTimeRange, targetTimeRange: CMTimeRange): AVCompositionTrackSegment;
	static compositionTrackSegmentWithTimeRange(timeRange: CMTimeRange): AVCompositionTrackSegment;
	initWithURLTrackIDSourceTimeRangeTargetTimeRange(URL: NSURL, trackID: number, sourceTimeRange: CMTimeRange, targetTimeRange: CMTimeRange): AVCompositionTrackSegment;
	initWithTimeRange(timeRange: CMTimeRange): AVCompositionTrackSegment;
	init(): AVCompositionTrackSegment;
	static new(): AVCompositionTrackSegment;
	static allocWithZone(zone: any): AVCompositionTrackSegment;
	static alloc(): AVCompositionTrackSegment;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVMetadataItem extends NSObject implements AVAsynchronousKeyValueLoading, NSCopying, NSMutableCopying {
	identifier: string;
	extendedLanguageTag: string;
	locale: NSLocale;
	time: CMTime;
	duration: CMTime;
	dataType: string;
	value: any;
	extraAttributes: NSDictionary;
	stringValue: string;
	numberValue: NSNumber;
	dateValue: NSDate;
	dataValue: NSData;
	key: any;
	commonKey: string;
	keySpace: string;
	constructor();
	static metadataItemsFromArrayFilteredAndSortedAccordingToPreferredLanguages(metadataItems: NSArray, preferredLanguages: NSArray): NSArray;
	static metadataItemsFromArrayFilteredByIdentifier(metadataItems: NSArray, identifier: string): NSArray;
	static metadataItemsFromArrayFilteredByMetadataItemFilter(metadataItems: NSArray, metadataItemFilter: AVMetadataItemFilter): NSArray;
	static identifierForKeyKeySpace(key: any, keySpace: string): string;
	static keySpaceForIdentifier(identifier: string): string;
	static keyForIdentifier(identifier: string): any;
	static metadataItemsFromArrayWithLocale(metadataItems: NSArray, locale: NSLocale): NSArray;
	static metadataItemsFromArrayWithKeyKeySpace(metadataItems: NSArray, key: any, keySpace: string): NSArray;
	init(): AVMetadataItem;
	static new(): AVMetadataItem;
	static allocWithZone(zone: any): AVMetadataItem;
	static alloc(): AVMetadataItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	statusOfValueForKeyError(key: string, outError: any): number;
	loadValuesAsynchronouslyForKeysCompletionHandler(keys: NSArray, handler: () => void): void;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class AVMutableMetadataItem extends AVMetadataItem {
	identifier: string;
	extendedLanguageTag: string;
	locale: NSLocale;
	time: CMTime;
	duration: CMTime;
	dataType: string;
	value: any;
	extraAttributes: NSDictionary;
	keySpace: string;
	key: any;
	constructor();
	static metadataItem(): AVMutableMetadataItem;
	init(): AVMutableMetadataItem;
	static new(): AVMutableMetadataItem;
	static allocWithZone(zone: any): AVMutableMetadataItem;
	static alloc(): AVMutableMetadataItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVMetadataItemFilter extends NSObject {
	constructor();
	static metadataItemFilterForSharing(): AVMetadataItemFilter;
	init(): AVMetadataItemFilter;
	static new(): AVMetadataItemFilter;
	static allocWithZone(zone: any): AVMetadataItemFilter;
	static alloc(): AVMetadataItemFilter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVMetadataObject extends NSObject {
	time: CMTime;
	duration: CMTime;
	bounds: CGRect;
	type: string;
	constructor();
	init(): AVMetadataObject;
	static new(): AVMetadataObject;
	static allocWithZone(zone: any): AVMetadataObject;
	static alloc(): AVMetadataObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVMetadataFaceObject extends AVMetadataObject implements NSCopying {
	faceID: number;
	hasRollAngle: boolean;
	rollAngle: number;
	hasYawAngle: boolean;
	yawAngle: number;
	constructor();
	init(): AVMetadataFaceObject;
	static new(): AVMetadataFaceObject;
	static allocWithZone(zone: any): AVMetadataFaceObject;
	static alloc(): AVMetadataFaceObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVMetadataMachineReadableCodeObject extends AVMetadataObject {
	corners: NSArray;
	stringValue: string;
	constructor();
	init(): AVMetadataMachineReadableCodeObject;
	static new(): AVMetadataMachineReadableCodeObject;
	static allocWithZone(zone: any): AVMetadataMachineReadableCodeObject;
	static alloc(): AVMetadataMachineReadableCodeObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVOutputSettingsAssistant extends NSObject {
	audioSettings: NSDictionary;
	videoSettings: NSDictionary;
	outputFileType: string;
	sourceAudioFormat: any;
	sourceVideoFormat: any;
	sourceVideoAverageFrameDuration: CMTime;
	sourceVideoMinFrameDuration: CMTime;
	constructor();
	static availableOutputSettingsPresets(): NSArray;
	static outputSettingsAssistantWithPreset(presetIdentifier: string): AVOutputSettingsAssistant;
	init(): AVOutputSettingsAssistant;
	static new(): AVOutputSettingsAssistant;
	static allocWithZone(zone: any): AVOutputSettingsAssistant;
	static alloc(): AVOutputSettingsAssistant;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayer extends NSObject {
	status: number;
	error: NSError;
	rate: number;
	currentItem: AVPlayerItem;
	actionAtItemEnd: number;
	masterClock: any;
	volume: number;
	muted: boolean;
	closedCaptionDisplayEnabled: boolean;
	appliesMediaSelectionCriteriaAutomatically: boolean;
	allowsExternalPlayback: boolean;
	externalPlaybackActive: boolean;
	usesExternalPlaybackWhileExternalScreenIsActive: boolean;
	externalPlaybackVideoGravity: string;
	allowsAirPlayVideo: boolean;
	airPlayVideoActive: boolean;
	usesAirPlayVideoWhileAirPlayScreenIsActive: boolean;
	outputObscuredDueToInsufficientExternalProtection: boolean;
	constructor(URL: NSURL);
	constructor(item: AVPlayerItem);
	constructor();
	static playerWithURL(URL: NSURL): any;
	static playerWithPlayerItem(item: AVPlayerItem): any;
	initWithURL(URL: NSURL): AVPlayer;
	initWithPlayerItem(item: AVPlayerItem): AVPlayer;
	play(): void;
	pause(): void;
	replaceCurrentItemWithPlayerItem(item: AVPlayerItem): void;
	currentTime(): CMTime;
	seekToDate(date: NSDate): void;
	seekToDateCompletionHandler(date: NSDate, completionHandler: (arg1: boolean) => void): void;
	seekToTime(time: CMTime): void;
	seekToTimeToleranceBeforeToleranceAfter(time: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime): void;
	seekToTimeCompletionHandler(time: CMTime, completionHandler: (arg1: boolean) => void): void;
	seekToTimeToleranceBeforeToleranceAfterCompletionHandler(time: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler: (arg1: boolean) => void): void;
	setRateTimeAtHostTime(rate: number, itemTime: CMTime, hostClockTime: CMTime): void;
	prerollAtRateCompletionHandler(rate: number, completionHandler: (arg1: boolean) => void): void;
	cancelPendingPrerolls(): void;
	addPeriodicTimeObserverForIntervalQueueUsingBlock(interval: CMTime, queue: NSObject, block: (arg1: CMTime) => void): any;
	addBoundaryTimeObserverForTimesQueueUsingBlock(times: NSArray, queue: NSObject, block: () => void): any;
	removeTimeObserver(observer: any): void;
	setMediaSelectionCriteriaForMediaCharacteristic(criteria: AVPlayerMediaSelectionCriteria, mediaCharacteristic: string): void;
	mediaSelectionCriteriaForMediaCharacteristic(mediaCharacteristic: string): AVPlayerMediaSelectionCriteria;
	init(): AVPlayer;
	static new(): AVPlayer;
	static allocWithZone(zone: any): AVPlayer;
	static alloc(): AVPlayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVQueuePlayer extends AVPlayer {
	constructor(items: NSArray);
	constructor(URL: NSURL);
	constructor(item: AVPlayerItem);
	constructor();
	static queuePlayerWithItems(items: NSArray): any;
	initWithItems(items: NSArray): AVQueuePlayer;
	items(): NSArray;
	advanceToNextItem(): void;
	canInsertItemAfterItem(item: AVPlayerItem, afterItem: AVPlayerItem): boolean;
	insertItemAfterItem(item: AVPlayerItem, afterItem: AVPlayerItem): void;
	removeItem(item: AVPlayerItem): void;
	removeAllItems(): void;
	initWithURL(URL: NSURL): AVQueuePlayer;
	initWithPlayerItem(item: AVPlayerItem): AVQueuePlayer;
	init(): AVQueuePlayer;
	static new(): AVQueuePlayer;
	static allocWithZone(zone: any): AVQueuePlayer;
	static alloc(): AVQueuePlayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerItem extends NSObject implements NSCopying {
	status: number;
	error: NSError;
	asset: AVAsset;
	tracks: NSArray;
	duration: CMTime;
	presentationSize: CGSize;
	timedMetadata: NSArray;
	automaticallyLoadedAssetKeys: NSArray;
	canPlayFastForward: boolean;
	canPlaySlowForward: boolean;
	canPlayReverse: boolean;
	canPlaySlowReverse: boolean;
	canPlayFastReverse: boolean;
	canStepForward: boolean;
	canStepBackward: boolean;
	forwardPlaybackEndTime: CMTime;
	reversePlaybackEndTime: CMTime;
	seekableTimeRanges: NSArray;
	timebase: any;
	videoComposition: AVVideoComposition;
	customVideoCompositor: any;
	seekingWaitsForVideoCompositionRendering: boolean;
	textStyleRules: NSArray;
	audioTimePitchAlgorithm: string;
	audioMix: AVAudioMix;
	loadedTimeRanges: NSArray;
	playbackLikelyToKeepUp: boolean;
	playbackBufferFull: boolean;
	playbackBufferEmpty: boolean;
	preferredPeakBitRate: number;
	outputs: NSArray;
	constructor(URL: NSURL);
	constructor(asset: AVAsset);
	constructor(asset: AVAsset, automaticallyLoadedAssetKeys: NSArray);
	constructor();
	static playerItemWithURL(URL: NSURL): AVPlayerItem;
	static playerItemWithAsset(asset: AVAsset): AVPlayerItem;
	static playerItemWithAssetAutomaticallyLoadedAssetKeys(asset: AVAsset, automaticallyLoadedAssetKeys: NSArray): AVPlayerItem;
	initWithURL(URL: NSURL): AVPlayerItem;
	initWithAsset(asset: AVAsset): AVPlayerItem;
	initWithAssetAutomaticallyLoadedAssetKeys(asset: AVAsset, automaticallyLoadedAssetKeys: NSArray): AVPlayerItem;
	currentTime(): CMTime;
	seekToTime(time: CMTime): void;
	seekToTimeCompletionHandler(time: CMTime, completionHandler: (arg1: boolean) => void): void;
	seekToTimeToleranceBeforeToleranceAfter(time: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime): void;
	seekToTimeToleranceBeforeToleranceAfterCompletionHandler(time: CMTime, toleranceBefore: CMTime, toleranceAfter: CMTime, completionHandler: (arg1: boolean) => void): void;
	cancelPendingSeeks(): void;
	currentDate(): NSDate;
	seekToDate(date: NSDate): boolean;
	seekToDateCompletionHandler(date: NSDate, completionHandler: (arg1: boolean) => void): boolean;
	stepByCount(stepCount: number): void;
	selectMediaOptionInMediaSelectionGroup(mediaSelectionOption: AVMediaSelectionOption, mediaSelectionGroup: AVMediaSelectionGroup): void;
	selectMediaOptionAutomaticallyInMediaSelectionGroup(mediaSelectionGroup: AVMediaSelectionGroup): void;
	selectedMediaOptionInMediaSelectionGroup(mediaSelectionGroup: AVMediaSelectionGroup): AVMediaSelectionOption;
	accessLog(): AVPlayerItemAccessLog;
	errorLog(): AVPlayerItemErrorLog;
	addOutput(output: AVPlayerItemOutput): void;
	removeOutput(output: AVPlayerItemOutput): void;
	init(): AVPlayerItem;
	static new(): AVPlayerItem;
	static allocWithZone(zone: any): AVPlayerItem;
	static alloc(): AVPlayerItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVPlayerItemAccessLog extends NSObject implements NSCopying {
	extendedLogDataStringEncoding: number;
	events: NSArray;
	constructor();
	extendedLogData(): NSData;
	init(): AVPlayerItemAccessLog;
	static new(): AVPlayerItemAccessLog;
	static allocWithZone(zone: any): AVPlayerItemAccessLog;
	static alloc(): AVPlayerItemAccessLog;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVPlayerItemErrorLog extends NSObject implements NSCopying {
	extendedLogDataStringEncoding: number;
	events: NSArray;
	constructor();
	extendedLogData(): NSData;
	init(): AVPlayerItemErrorLog;
	static new(): AVPlayerItemErrorLog;
	static allocWithZone(zone: any): AVPlayerItemErrorLog;
	static alloc(): AVPlayerItemErrorLog;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVPlayerItemAccessLogEvent extends NSObject implements NSCopying {
	numberOfSegmentsDownloaded: number;
	numberOfMediaRequests: number;
	playbackStartDate: NSDate;
	URI: string;
	serverAddress: string;
	numberOfServerAddressChanges: number;
	playbackSessionID: string;
	playbackStartOffset: number;
	segmentsDownloadedDuration: number;
	durationWatched: number;
	numberOfStalls: number;
	numberOfBytesTransferred: number;
	transferDuration: number;
	observedBitrate: number;
	indicatedBitrate: number;
	numberOfDroppedVideoFrames: number;
	startupTime: number;
	downloadOverdue: number;
	observedMaxBitrate: number;
	observedMinBitrate: number;
	observedBitrateStandardDeviation: number;
	playbackType: string;
	mediaRequestsWWAN: number;
	switchBitrate: number;
	constructor();
	init(): AVPlayerItemAccessLogEvent;
	static new(): AVPlayerItemAccessLogEvent;
	static allocWithZone(zone: any): AVPlayerItemAccessLogEvent;
	static alloc(): AVPlayerItemAccessLogEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVPlayerItemErrorLogEvent extends NSObject implements NSCopying {
	date: NSDate;
	URI: string;
	serverAddress: string;
	playbackSessionID: string;
	errorStatusCode: number;
	errorDomain: string;
	errorComment: string;
	constructor();
	init(): AVPlayerItemErrorLogEvent;
	static new(): AVPlayerItemErrorLogEvent;
	static allocWithZone(zone: any): AVPlayerItemErrorLogEvent;
	static alloc(): AVPlayerItemErrorLogEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVPlayerItemOutput extends NSObject {
	suppressesPlayerRendering: boolean;
	constructor();
	itemTimeForHostTime(hostTimeInSeconds: number): CMTime;
	itemTimeForMachAbsoluteTime(machAbsoluteTime: number): CMTime;
	init(): AVPlayerItemOutput;
	static new(): AVPlayerItemOutput;
	static allocWithZone(zone: any): AVPlayerItemOutput;
	static alloc(): AVPlayerItemOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerItemVideoOutput extends AVPlayerItemOutput {
	delegate: any;
	delegateQueue: NSObject;
	constructor(pixelBufferAttributes: NSDictionary);
	constructor();
	initWithPixelBufferAttributes(pixelBufferAttributes: NSDictionary): AVPlayerItemVideoOutput;
	hasNewPixelBufferForItemTime(itemTime: CMTime): boolean;
	copyPixelBufferForItemTimeItemTimeForDisplay(itemTime: CMTime, outItemTimeForDisplay: any): any;
	setDelegateQueue(delegate: any, delegateQueue: NSObject): void;
	requestNotificationOfMediaDataChangeWithAdvanceInterval(interval: number): void;
	init(): AVPlayerItemVideoOutput;
	static new(): AVPlayerItemVideoOutput;
	static allocWithZone(zone: any): AVPlayerItemVideoOutput;
	static alloc(): AVPlayerItemVideoOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerItemLegibleOutput extends AVPlayerItemOutput {
	delegate: any;
	delegateQueue: NSObject;
	advanceIntervalForDelegateInvocation: number;
	textStylingResolution: string;
	constructor(subtypes: NSArray);
	constructor();
	setDelegateQueue(delegate: any, delegateQueue: NSObject): void;
	initWithMediaSubtypesForNativeRepresentation(subtypes: NSArray): AVPlayerItemLegibleOutput;
	init(): AVPlayerItemLegibleOutput;
	static new(): AVPlayerItemLegibleOutput;
	static allocWithZone(zone: any): AVPlayerItemLegibleOutput;
	static alloc(): AVPlayerItemLegibleOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerItemMetadataOutput extends AVPlayerItemOutput {
	delegate: any;
	delegateQueue: NSObject;
	advanceIntervalForDelegateInvocation: number;
	constructor(identifiers: NSArray);
	constructor();
	initWithIdentifiers(identifiers: NSArray): AVPlayerItemMetadataOutput;
	setDelegateQueue(delegate: any, delegateQueue: NSObject): void;
	init(): AVPlayerItemMetadataOutput;
	static new(): AVPlayerItemMetadataOutput;
	static allocWithZone(zone: any): AVPlayerItemMetadataOutput;
	static alloc(): AVPlayerItemMetadataOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerItemTrack extends NSObject {
	assetTrack: AVAssetTrack;
	enabled: boolean;
	currentVideoFrameRate: number;
	constructor();
	init(): AVPlayerItemTrack;
	static new(): AVPlayerItemTrack;
	static allocWithZone(zone: any): AVPlayerItemTrack;
	static alloc(): AVPlayerItemTrack;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerLayer extends CALayer {
	player: AVPlayer;
	videoGravity: string;
	readyForDisplay: boolean;
	videoRect: CGRect;
	constructor(layer: any);
	constructor();
	static playerLayerWithPlayer(player: AVPlayer): AVPlayerLayer;
	static layer(): AVPlayerLayer;
	initWithLayer(layer: any): AVPlayerLayer;
	init(): AVPlayerLayer;
	static new(): AVPlayerLayer;
	static allocWithZone(zone: any): AVPlayerLayer;
	static alloc(): AVPlayerLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerMediaSelectionCriteria extends NSObject {
	preferredLanguages: NSArray;
	preferredMediaCharacteristics: NSArray;
	constructor(preferredLanguages: NSArray, preferredMediaCharacteristics: NSArray);
	constructor();
	initWithPreferredLanguagesPreferredMediaCharacteristics(preferredLanguages: NSArray, preferredMediaCharacteristics: NSArray): AVPlayerMediaSelectionCriteria;
	init(): AVPlayerMediaSelectionCriteria;
	static new(): AVPlayerMediaSelectionCriteria;
	static allocWithZone(zone: any): AVPlayerMediaSelectionCriteria;
	static alloc(): AVPlayerMediaSelectionCriteria;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVSampleBufferDisplayLayer extends CALayer {
	controlTimebase: any;
	videoGravity: string;
	status: number;
	error: NSError;
	readyForMoreMediaData: boolean;
	constructor(layer: any);
	constructor();
	enqueueSampleBuffer(sampleBuffer: any): void;
	flush(): void;
	flushAndRemoveImage(): void;
	requestMediaDataWhenReadyOnQueueUsingBlock(queue: NSObject, block: () => void): void;
	stopRequestingMediaData(): void;
	static layer(): AVSampleBufferDisplayLayer;
	initWithLayer(layer: any): AVSampleBufferDisplayLayer;
	init(): AVSampleBufferDisplayLayer;
	static new(): AVSampleBufferDisplayLayer;
	static allocWithZone(zone: any): AVSampleBufferDisplayLayer;
	static alloc(): AVSampleBufferDisplayLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVSpeechSynthesisVoice extends NSObject implements NSSecureCoding {
	language: string;
	constructor();
	static speechVoices(): NSArray;
	static currentLanguageCode(): string;
	static voiceWithLanguage(language: string): AVSpeechSynthesisVoice;
	init(): AVSpeechSynthesisVoice;
	static new(): AVSpeechSynthesisVoice;
	static allocWithZone(zone: any): AVSpeechSynthesisVoice;
	static alloc(): AVSpeechSynthesisVoice;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class AVSpeechUtterance extends NSObject implements NSCopying, NSSecureCoding {
	voice: AVSpeechSynthesisVoice;
	speechString: string;
	rate: number;
	pitchMultiplier: number;
	volume: number;
	preUtteranceDelay: number;
	postUtteranceDelay: number;
	constructor(string: string);
	constructor();
	static speechUtteranceWithString(string: string): AVSpeechUtterance;
	initWithString(string: string): AVSpeechUtterance;
	init(): AVSpeechUtterance;
	static new(): AVSpeechUtterance;
	static allocWithZone(zone: any): AVSpeechUtterance;
	static alloc(): AVSpeechUtterance;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class AVSpeechSynthesizer extends NSObject {
	delegate: any;
	speaking: boolean;
	paused: boolean;
	constructor();
	speakUtterance(utterance: AVSpeechUtterance): void;
	stopSpeakingAtBoundary(boundary: number): boolean;
	pauseSpeakingAtBoundary(boundary: number): boolean;
	continueSpeaking(): boolean;
	init(): AVSpeechSynthesizer;
	static new(): AVSpeechSynthesizer;
	static allocWithZone(zone: any): AVSpeechSynthesizer;
	static alloc(): AVSpeechSynthesizer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVSynchronizedLayer extends CALayer {
	playerItem: AVPlayerItem;
	constructor(layer: any);
	constructor();
	static synchronizedLayerWithPlayerItem(playerItem: AVPlayerItem): AVSynchronizedLayer;
	static layer(): AVSynchronizedLayer;
	initWithLayer(layer: any): AVSynchronizedLayer;
	init(): AVSynchronizedLayer;
	static new(): AVSynchronizedLayer;
	static allocWithZone(zone: any): AVSynchronizedLayer;
	static alloc(): AVSynchronizedLayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVTextStyleRule extends NSObject implements NSCopying {
	textMarkupAttributes: NSDictionary;
	textSelector: string;
	constructor(textMarkupAttributes: NSDictionary);
	constructor(textMarkupAttributes: NSDictionary, textSelector: string);
	constructor();
	static propertyListForTextStyleRules(textStyleRules: NSArray): any;
	static textStyleRulesFromPropertyList(plist: any): NSArray;
	static textStyleRuleWithTextMarkupAttributes(textMarkupAttributes: NSDictionary): AVTextStyleRule;
	static textStyleRuleWithTextMarkupAttributesTextSelector(textMarkupAttributes: NSDictionary, textSelector: string): AVTextStyleRule;
	initWithTextMarkupAttributes(textMarkupAttributes: NSDictionary): AVTextStyleRule;
	initWithTextMarkupAttributesTextSelector(textMarkupAttributes: NSDictionary, textSelector: string): AVTextStyleRule;
	init(): AVTextStyleRule;
	static new(): AVTextStyleRule;
	static allocWithZone(zone: any): AVTextStyleRule;
	static alloc(): AVTextStyleRule;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVTimedMetadataGroup extends NSObject implements NSCopying {
	timeRange: CMTimeRange;
	items: NSArray;
	constructor(items: NSArray, timeRange: CMTimeRange);
	constructor(sampleBuffer: any);
	constructor();
	initWithItemsTimeRange(items: NSArray, timeRange: CMTimeRange): AVTimedMetadataGroup;
	initWithSampleBuffer(sampleBuffer: any): AVTimedMetadataGroup;
	copyFormatDescription(): any;
	init(): AVTimedMetadataGroup;
	static new(): AVTimedMetadataGroup;
	static allocWithZone(zone: any): AVTimedMetadataGroup;
	static alloc(): AVTimedMetadataGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class AVMutableTimedMetadataGroup extends AVTimedMetadataGroup {
	timeRange: CMTimeRange;
	items: NSArray;
	constructor(items: NSArray, timeRange: CMTimeRange);
	constructor(sampleBuffer: any);
	constructor();
	initWithItemsTimeRange(items: NSArray, timeRange: CMTimeRange): AVMutableTimedMetadataGroup;
	initWithSampleBuffer(sampleBuffer: any): AVMutableTimedMetadataGroup;
	init(): AVMutableTimedMetadataGroup;
	static new(): AVMutableTimedMetadataGroup;
	static allocWithZone(zone: any): AVMutableTimedMetadataGroup;
	static alloc(): AVMutableTimedMetadataGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class AVPlayerViewController extends UIViewController {
	player: AVPlayer;
	showsPlaybackControls: boolean;
	videoGravity: string;
	readyForDisplay: boolean;
	videoBounds: CGRect;
	contentOverlayView: UIView;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static preparePrerollAds(): void;
	playPrerollAdWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	cancelPreroll(): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): AVPlayerViewController;
	init(): AVPlayerViewController;
	static new(): AVPlayerViewController;
	static allocWithZone(zone: any): AVPlayerViewController;
	static alloc(): AVPlayerViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKContainer extends NSObject {
	containerIdentifier: string;
	privateCloudDatabase: CKDatabase;
	publicCloudDatabase: CKDatabase;
	constructor();
	static defaultContainer(): CKContainer;
	static containerWithIdentifier(containerIdentifier: string): CKContainer;
	addOperation(operation: CKOperation): void;
	accountStatusWithCompletionHandler(completionHandler: (arg1: number, arg2: NSError) => void): void;
	statusForApplicationPermissionCompletionHandler(applicationPermission: number, completionHandler: (arg1: number, arg2: NSError) => void): void;
	requestApplicationPermissionCompletionHandler(applicationPermission: number, completionHandler: (arg1: number, arg2: NSError) => void): void;
	fetchUserRecordIDWithCompletionHandler(completionHandler: (arg1: CKRecordID, arg2: NSError) => void): void;
	discoverAllContactUserInfosWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	discoverUserInfoWithEmailAddressCompletionHandler(email: string, completionHandler: (arg1: CKDiscoveredUserInfo, arg2: NSError) => void): void;
	discoverUserInfoWithUserRecordIDCompletionHandler(userRecordID: CKRecordID, completionHandler: (arg1: CKDiscoveredUserInfo, arg2: NSError) => void): void;
	init(): CKContainer;
	static new(): CKContainer;
	static allocWithZone(zone: any): CKContainer;
	static alloc(): CKContainer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKAsset extends NSObject implements CKRecordValue {
	fileURL: NSURL;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(fileURL: NSURL);
	constructor();
	initWithFileURL(fileURL: NSURL): CKAsset;
	init(): CKAsset;
	static new(): CKAsset;
	static allocWithZone(zone: any): CKAsset;
	static alloc(): CKAsset;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class CKDatabase extends NSObject {
	constructor();
	addOperation(operation: CKDatabaseOperation): void;
	fetchRecordWithIDCompletionHandler(recordID: CKRecordID, completionHandler: (arg1: CKRecord, arg2: NSError) => void): void;
	saveRecordCompletionHandler(record: CKRecord, completionHandler: (arg1: CKRecord, arg2: NSError) => void): void;
	deleteRecordWithIDCompletionHandler(recordID: CKRecordID, completionHandler: (arg1: CKRecordID, arg2: NSError) => void): void;
	performQueryInZoneWithIDCompletionHandler(query: CKQuery, zoneID: CKRecordZoneID, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	fetchAllRecordZonesWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	fetchRecordZoneWithIDCompletionHandler(zoneID: CKRecordZoneID, completionHandler: (arg1: CKRecordZone, arg2: NSError) => void): void;
	saveRecordZoneCompletionHandler(zone: CKRecordZone, completionHandler: (arg1: CKRecordZone, arg2: NSError) => void): void;
	deleteRecordZoneWithIDCompletionHandler(zoneID: CKRecordZoneID, completionHandler: (arg1: CKRecordZoneID, arg2: NSError) => void): void;
	fetchSubscriptionWithIDCompletionHandler(subscriptionID: string, completionHandler: (arg1: CKSubscription, arg2: NSError) => void): void;
	fetchAllSubscriptionsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	saveSubscriptionCompletionHandler(subscription: CKSubscription, completionHandler: (arg1: CKSubscription, arg2: NSError) => void): void;
	deleteSubscriptionWithIDCompletionHandler(subscriptionID: string, completionHandler: (arg1: string, arg2: NSError) => void): void;
	init(): CKDatabase;
	static new(): CKDatabase;
	static allocWithZone(zone: any): CKDatabase;
	static alloc(): CKDatabase;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKLocationSortDescriptor extends NSSortDescriptor implements NSSecureCoding {
	relativeLocation: CLLocation;
	constructor(key: string, relativeLocation: CLLocation);
	constructor(key: string, ascending: boolean);
	constructor(key: string, ascending: boolean, selector: any);
	constructor(key: string, ascending: boolean, cmptr: (arg1: any, arg2: any) => number);
	constructor();
	initWithKeyRelativeLocation(key: string, relativeLocation: CLLocation): CKLocationSortDescriptor;
	static sortDescriptorWithKeyAscending(key: string, ascending: boolean): CKLocationSortDescriptor;
	static sortDescriptorWithKeyAscendingSelector(key: string, ascending: boolean, selector: any): CKLocationSortDescriptor;
	initWithKeyAscending(key: string, ascending: boolean): CKLocationSortDescriptor;
	initWithKeyAscendingSelector(key: string, ascending: boolean, selector: any): CKLocationSortDescriptor;
	static sortDescriptorWithKeyAscendingComparator(key: string, ascending: boolean, cmptr: (arg1: any, arg2: any) => number): CKLocationSortDescriptor;
	initWithKeyAscendingComparator(key: string, ascending: boolean, cmptr: (arg1: any, arg2: any) => number): CKLocationSortDescriptor;
	init(): CKLocationSortDescriptor;
	static new(): CKLocationSortDescriptor;
	static allocWithZone(zone: any): CKLocationSortDescriptor;
	static alloc(): CKLocationSortDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CKNotificationID extends NSObject implements NSCopying, NSSecureCoding {
	constructor();
	init(): CKNotificationID;
	static new(): CKNotificationID;
	static allocWithZone(zone: any): CKNotificationID;
	static alloc(): CKNotificationID;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CKNotification extends NSObject {
	notificationType: number;
	notificationID: CKNotificationID;
	containerIdentifier: string;
	isPruned: boolean;
	alertBody: string;
	alertLocalizationKey: string;
	alertLocalizationArgs: NSArray;
	alertActionLocalizationKey: string;
	alertLaunchImage: string;
	badge: NSNumber;
	soundName: string;
	constructor();
	static notificationFromRemoteNotificationDictionary(notificationDictionary: NSDictionary): CKNotification;
	init(): CKNotification;
	static new(): CKNotification;
	static allocWithZone(zone: any): CKNotification;
	static alloc(): CKNotification;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKQueryNotification extends CKNotification {
	queryNotificationReason: number;
	recordFields: NSDictionary;
	recordID: CKRecordID;
	isPublicDatabase: boolean;
	constructor();
	static notificationFromRemoteNotificationDictionary(notificationDictionary: NSDictionary): CKQueryNotification;
	init(): CKQueryNotification;
	static new(): CKQueryNotification;
	static allocWithZone(zone: any): CKQueryNotification;
	static alloc(): CKQueryNotification;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKRecordZoneNotification extends CKNotification {
	recordZoneID: CKRecordZoneID;
	constructor();
	static notificationFromRemoteNotificationDictionary(notificationDictionary: NSDictionary): CKRecordZoneNotification;
	init(): CKRecordZoneNotification;
	static new(): CKRecordZoneNotification;
	static allocWithZone(zone: any): CKRecordZoneNotification;
	static alloc(): CKRecordZoneNotification;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKQuery extends NSObject implements NSSecureCoding, NSCopying {
	recordType: string;
	predicate: NSPredicate;
	sortDescriptors: NSArray;
	constructor(recordType: string, predicate: NSPredicate);
	constructor();
	initWithRecordTypePredicate(recordType: string, predicate: NSPredicate): CKQuery;
	init(): CKQuery;
	static new(): CKQuery;
	static allocWithZone(zone: any): CKQuery;
	static alloc(): CKQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKRecordZone extends NSObject implements NSSecureCoding, NSCopying {
	zoneID: CKRecordZoneID;
	capabilities: number;
	constructor(zoneName: string);
	constructor(zoneID: CKRecordZoneID);
	constructor();
	static defaultRecordZone(): CKRecordZone;
	initWithZoneName(zoneName: string): CKRecordZone;
	initWithZoneID(zoneID: CKRecordZoneID): CKRecordZone;
	init(): CKRecordZone;
	static new(): CKRecordZone;
	static allocWithZone(zone: any): CKRecordZone;
	static alloc(): CKRecordZone;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKReference extends NSObject implements NSSecureCoding, NSCopying, CKRecordValue {
	referenceAction: number;
	recordID: CKRecordID;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(recordID: CKRecordID, action: number);
	constructor(record: CKRecord, action: number);
	constructor();
	initWithRecordIDAction(recordID: CKRecordID, action: number): CKReference;
	initWithRecordAction(record: CKRecord, action: number): CKReference;
	init(): CKReference;
	static new(): CKReference;
	static allocWithZone(zone: any): CKReference;
	static alloc(): CKReference;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class CKRecord extends NSObject implements NSSecureCoding, NSCopying {
	recordType: string;
	recordID: CKRecordID;
	recordChangeTag: string;
	creatorUserRecordID: CKRecordID;
	creationDate: NSDate;
	lastModifiedUserRecordID: CKRecordID;
	modificationDate: NSDate;
	constructor(recordType: string);
	constructor(recordType: string, recordID: CKRecordID);
	constructor(recordType: string, zoneID: CKRecordZoneID);
	constructor();
	initWithRecordType(recordType: string): CKRecord;
	initWithRecordTypeRecordID(recordType: string, recordID: CKRecordID): CKRecord;
	initWithRecordTypeZoneID(recordType: string, zoneID: CKRecordZoneID): CKRecord;
	objectForKey(key: string): any;
	setObjectForKey(object: any, key: string): void;
	allKeys(): NSArray;
	allTokens(): NSArray;
	objectForKeyedSubscript(key: string): any;
	setObjectForKeyedSubscript(object: any, key: string): void;
	changedKeys(): NSArray;
	encodeSystemFieldsWithCoder(coder: NSCoder): void;
	init(): CKRecord;
	static new(): CKRecord;
	static allocWithZone(zone: any): CKRecord;
	static alloc(): CKRecord;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKRecordID extends NSObject implements NSSecureCoding, NSCopying {
	recordName: string;
	zoneID: CKRecordZoneID;
	constructor(recordName: string);
	constructor(recordName: string, zoneID: CKRecordZoneID);
	constructor();
	initWithRecordName(recordName: string): CKRecordID;
	initWithRecordNameZoneID(recordName: string, zoneID: CKRecordZoneID): CKRecordID;
	init(): CKRecordID;
	static new(): CKRecordID;
	static allocWithZone(zone: any): CKRecordID;
	static alloc(): CKRecordID;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKRecordZoneID extends NSObject implements NSSecureCoding, NSCopying {
	zoneName: string;
	ownerName: string;
	constructor(zoneName: string, ownerName: string);
	constructor();
	initWithZoneNameOwnerName(zoneName: string, ownerName: string): CKRecordZoneID;
	init(): CKRecordZoneID;
	static new(): CKRecordZoneID;
	static allocWithZone(zone: any): CKRecordZoneID;
	static alloc(): CKRecordZoneID;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKSubscription extends NSObject implements NSSecureCoding, NSCopying {
	subscriptionID: string;
	subscriptionType: number;
	recordType: string;
	predicate: NSPredicate;
	subscriptionOptions: number;
	notificationInfo: CKNotificationInfo;
	zoneID: CKRecordZoneID;
	constructor(recordType: string, predicate: NSPredicate, subscriptionOptions: number);
	constructor(recordType: string, predicate: NSPredicate, subscriptionID: string, subscriptionOptions: number);
	constructor(zoneID: CKRecordZoneID, subscriptionOptions: number);
	constructor(zoneID: CKRecordZoneID, subscriptionID: string, subscriptionOptions: number);
	constructor();
	initWithRecordTypePredicateOptions(recordType: string, predicate: NSPredicate, subscriptionOptions: number): CKSubscription;
	initWithRecordTypePredicateSubscriptionIDOptions(recordType: string, predicate: NSPredicate, subscriptionID: string, subscriptionOptions: number): CKSubscription;
	initWithZoneIDOptions(zoneID: CKRecordZoneID, subscriptionOptions: number): CKSubscription;
	initWithZoneIDSubscriptionIDOptions(zoneID: CKRecordZoneID, subscriptionID: string, subscriptionOptions: number): CKSubscription;
	init(): CKSubscription;
	static new(): CKSubscription;
	static allocWithZone(zone: any): CKSubscription;
	static alloc(): CKSubscription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKNotificationInfo extends NSObject implements NSSecureCoding, NSCopying {
	alertBody: string;
	alertLocalizationKey: string;
	alertLocalizationArgs: NSArray;
	alertActionLocalizationKey: string;
	alertLaunchImage: string;
	soundName: string;
	desiredKeys: NSArray;
	shouldBadge: boolean;
	shouldSendContentAvailable: boolean;
	constructor();
	init(): CKNotificationInfo;
	static new(): CKNotificationInfo;
	static allocWithZone(zone: any): CKNotificationInfo;
	static alloc(): CKNotificationInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CKDiscoveredUserInfo extends NSObject {
	userRecordID: CKRecordID;
	firstName: string;
	lastName: string;
	constructor();
	init(): CKDiscoveredUserInfo;
	static new(): CKDiscoveredUserInfo;
	static allocWithZone(zone: any): CKDiscoveredUserInfo;
	static alloc(): CKDiscoveredUserInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKOperation extends NSOperation {
	container: CKContainer;
	usesBackgroundSession: boolean;
	allowsCellularAccess: boolean;
	constructor();
	init(): CKOperation;
	static new(): CKOperation;
	static allocWithZone(zone: any): CKOperation;
	static alloc(): CKOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKDatabaseOperation extends CKOperation {
	database: CKDatabase;
	constructor();
	init(): CKDatabaseOperation;
	static new(): CKDatabaseOperation;
	static allocWithZone(zone: any): CKDatabaseOperation;
	static alloc(): CKDatabaseOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKModifyRecordsOperation extends CKDatabaseOperation {
	recordsToSave: NSArray;
	recordIDsToDelete: NSArray;
	savePolicy: number;
	clientChangeTokenData: NSData;
	atomic: boolean;
	perRecordProgressBlock: (arg1: CKRecord, arg2: number) => void;
	perRecordCompletionBlock: (arg1: CKRecord, arg2: NSError) => void;
	modifyRecordsCompletionBlock: (arg1: NSArray, arg2: NSArray, arg3: NSError) => void;
	constructor(records: NSArray, recordIDs: NSArray);
	constructor();
	initWithRecordsToSaveRecordIDsToDelete(records: NSArray, recordIDs: NSArray): CKModifyRecordsOperation;
	init(): CKModifyRecordsOperation;
	static new(): CKModifyRecordsOperation;
	static allocWithZone(zone: any): CKModifyRecordsOperation;
	static alloc(): CKModifyRecordsOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKDiscoverAllContactsOperation extends CKOperation {
	discoverAllContactsCompletionBlock: (arg1: NSArray, arg2: NSError) => void;
	constructor();
	init(): CKDiscoverAllContactsOperation;
	static new(): CKDiscoverAllContactsOperation;
	static allocWithZone(zone: any): CKDiscoverAllContactsOperation;
	static alloc(): CKDiscoverAllContactsOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKDiscoverUserInfosOperation extends CKOperation {
	emailAddresses: NSArray;
	userRecordIDs: NSArray;
	discoverUserInfosCompletionBlock: (arg1: NSDictionary, arg2: NSDictionary, arg3: NSError) => void;
	constructor(emailAddresses: NSArray, userRecordIDs: NSArray);
	constructor();
	initWithEmailAddressesUserRecordIDs(emailAddresses: NSArray, userRecordIDs: NSArray): CKDiscoverUserInfosOperation;
	init(): CKDiscoverUserInfosOperation;
	static new(): CKDiscoverUserInfosOperation;
	static allocWithZone(zone: any): CKDiscoverUserInfosOperation;
	static alloc(): CKDiscoverUserInfosOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKFetchRecordsOperation extends CKDatabaseOperation {
	recordIDs: NSArray;
	desiredKeys: NSArray;
	perRecordProgressBlock: (arg1: CKRecordID, arg2: number) => void;
	perRecordCompletionBlock: (arg1: CKRecord, arg2: CKRecordID, arg3: NSError) => void;
	fetchRecordsCompletionBlock: (arg1: NSDictionary, arg2: NSError) => void;
	constructor(recordIDs: NSArray);
	constructor();
	initWithRecordIDs(recordIDs: NSArray): CKFetchRecordsOperation;
	static fetchCurrentUserRecordOperation(): CKFetchRecordsOperation;
	init(): CKFetchRecordsOperation;
	static new(): CKFetchRecordsOperation;
	static allocWithZone(zone: any): CKFetchRecordsOperation;
	static alloc(): CKFetchRecordsOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKServerChangeToken extends NSObject implements NSCopying, NSSecureCoding {
	constructor();
	init(): CKServerChangeToken;
	static new(): CKServerChangeToken;
	static allocWithZone(zone: any): CKServerChangeToken;
	static alloc(): CKServerChangeToken;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CKFetchRecordChangesOperation extends CKDatabaseOperation {
	recordZoneID: CKRecordZoneID;
	previousServerChangeToken: CKServerChangeToken;
	resultsLimit: number;
	desiredKeys: NSArray;
	recordChangedBlock: (arg1: CKRecord) => void;
	recordWithIDWasDeletedBlock: (arg1: CKRecordID) => void;
	moreComing: boolean;
	fetchRecordChangesCompletionBlock: (arg1: CKServerChangeToken, arg2: NSData, arg3: NSError) => void;
	constructor(recordZoneID: CKRecordZoneID, previousServerChangeToken: CKServerChangeToken);
	constructor();
	initWithRecordZoneIDPreviousServerChangeToken(recordZoneID: CKRecordZoneID, previousServerChangeToken: CKServerChangeToken): CKFetchRecordChangesOperation;
	init(): CKFetchRecordChangesOperation;
	static new(): CKFetchRecordChangesOperation;
	static allocWithZone(zone: any): CKFetchRecordChangesOperation;
	static alloc(): CKFetchRecordChangesOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKQueryCursor extends NSObject implements NSCopying, NSSecureCoding {
	constructor();
	init(): CKQueryCursor;
	static new(): CKQueryCursor;
	static allocWithZone(zone: any): CKQueryCursor;
	static alloc(): CKQueryCursor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CKQueryOperation extends CKDatabaseOperation {
	query: CKQuery;
	cursor: CKQueryCursor;
	zoneID: CKRecordZoneID;
	resultsLimit: number;
	desiredKeys: NSArray;
	recordFetchedBlock: (arg1: CKRecord) => void;
	queryCompletionBlock: (arg1: CKQueryCursor, arg2: NSError) => void;
	constructor(query: CKQuery);
	constructor(cursor: CKQueryCursor);
	constructor();
	initWithQuery(query: CKQuery): CKQueryOperation;
	initWithCursor(cursor: CKQueryCursor): CKQueryOperation;
	init(): CKQueryOperation;
	static new(): CKQueryOperation;
	static allocWithZone(zone: any): CKQueryOperation;
	static alloc(): CKQueryOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKModifyBadgeOperation extends CKOperation {
	badgeValue: number;
	modifyBadgeCompletionBlock: (arg1: NSError) => void;
	constructor(badgeValue: number);
	constructor();
	initWithBadgeValue(badgeValue: number): CKModifyBadgeOperation;
	init(): CKModifyBadgeOperation;
	static new(): CKModifyBadgeOperation;
	static allocWithZone(zone: any): CKModifyBadgeOperation;
	static alloc(): CKModifyBadgeOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKFetchNotificationChangesOperation extends CKOperation {
	previousServerChangeToken: CKServerChangeToken;
	resultsLimit: number;
	moreComing: boolean;
	notificationChangedBlock: (arg1: CKNotification) => void;
	fetchNotificationChangesCompletionBlock: (arg1: CKServerChangeToken, arg2: NSError) => void;
	constructor(previousServerChangeToken: CKServerChangeToken);
	constructor();
	initWithPreviousServerChangeToken(previousServerChangeToken: CKServerChangeToken): CKFetchNotificationChangesOperation;
	init(): CKFetchNotificationChangesOperation;
	static new(): CKFetchNotificationChangesOperation;
	static allocWithZone(zone: any): CKFetchNotificationChangesOperation;
	static alloc(): CKFetchNotificationChangesOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKMarkNotificationsReadOperation extends CKOperation {
	notificationIDs: NSArray;
	markNotificationsReadCompletionBlock: (arg1: NSArray, arg2: NSError) => void;
	constructor(notificationIDs: NSArray);
	constructor();
	initWithNotificationIDsToMarkRead(notificationIDs: NSArray): CKMarkNotificationsReadOperation;
	init(): CKMarkNotificationsReadOperation;
	static new(): CKMarkNotificationsReadOperation;
	static allocWithZone(zone: any): CKMarkNotificationsReadOperation;
	static alloc(): CKMarkNotificationsReadOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKFetchSubscriptionsOperation extends CKDatabaseOperation {
	subscriptionIDs: NSArray;
	fetchSubscriptionCompletionBlock: (arg1: NSDictionary, arg2: NSError) => void;
	constructor(subscriptionIDs: NSArray);
	constructor();
	static fetchAllSubscriptionsOperation(): CKFetchSubscriptionsOperation;
	initWithSubscriptionIDs(subscriptionIDs: NSArray): CKFetchSubscriptionsOperation;
	init(): CKFetchSubscriptionsOperation;
	static new(): CKFetchSubscriptionsOperation;
	static allocWithZone(zone: any): CKFetchSubscriptionsOperation;
	static alloc(): CKFetchSubscriptionsOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKModifySubscriptionsOperation extends CKDatabaseOperation {
	subscriptionsToSave: NSArray;
	subscriptionIDsToDelete: NSArray;
	modifySubscriptionsCompletionBlock: (arg1: NSArray, arg2: NSArray, arg3: NSError) => void;
	constructor(subscriptionsToSave: NSArray, subscriptionIDsToDelete: NSArray);
	constructor();
	initWithSubscriptionsToSaveSubscriptionIDsToDelete(subscriptionsToSave: NSArray, subscriptionIDsToDelete: NSArray): CKModifySubscriptionsOperation;
	init(): CKModifySubscriptionsOperation;
	static new(): CKModifySubscriptionsOperation;
	static allocWithZone(zone: any): CKModifySubscriptionsOperation;
	static alloc(): CKModifySubscriptionsOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKModifyRecordZonesOperation extends CKDatabaseOperation {
	recordZonesToSave: NSArray;
	recordZoneIDsToDelete: NSArray;
	modifyRecordZonesCompletionBlock: (arg1: NSArray, arg2: NSArray, arg3: NSError) => void;
	constructor(recordZonesToSave: NSArray, recordZoneIDsToDelete: NSArray);
	constructor();
	initWithRecordZonesToSaveRecordZoneIDsToDelete(recordZonesToSave: NSArray, recordZoneIDsToDelete: NSArray): CKModifyRecordZonesOperation;
	init(): CKModifyRecordZonesOperation;
	static new(): CKModifyRecordZonesOperation;
	static allocWithZone(zone: any): CKModifyRecordZonesOperation;
	static alloc(): CKModifyRecordZonesOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CKFetchRecordZonesOperation extends CKDatabaseOperation {
	recordZoneIDs: NSArray;
	fetchRecordZonesCompletionBlock: (arg1: NSDictionary, arg2: NSError) => void;
	constructor(zoneIDs: NSArray);
	constructor();
	static fetchAllRecordZonesOperation(): CKFetchRecordZonesOperation;
	initWithRecordZoneIDs(zoneIDs: NSArray): CKFetchRecordZonesOperation;
	init(): CKFetchRecordZonesOperation;
	static new(): CKFetchRecordZonesOperation;
	static allocWithZone(zone: any): CKFetchRecordZonesOperation;
	static alloc(): CKFetchRecordZonesOperation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CLFloor extends NSObject implements NSCopying, NSSecureCoding {
	level: number;
	constructor();
	init(): CLFloor;
	static new(): CLFloor;
	static allocWithZone(zone: any): CLFloor;
	static alloc(): CLFloor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CLLocation extends NSObject implements NSCopying, NSSecureCoding, CKRecordValue {
	coordinate: CLLocationCoordinate2D;
	altitude: number;
	horizontalAccuracy: number;
	verticalAccuracy: number;
	course: number;
	speed: number;
	timestamp: NSDate;
	floor: CLFloor;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(latitude: number, longitude: number);
	constructor(coordinate: CLLocationCoordinate2D, altitude: number, hAccuracy: number, vAccuracy: number, timestamp: NSDate);
	constructor(coordinate: CLLocationCoordinate2D, altitude: number, hAccuracy: number, vAccuracy: number, course: number, speed: number, timestamp: NSDate);
	constructor();
	initWithLatitudeLongitude(latitude: number, longitude: number): CLLocation;
	initWithCoordinateAltitudeHorizontalAccuracyVerticalAccuracyTimestamp(coordinate: CLLocationCoordinate2D, altitude: number, hAccuracy: number, vAccuracy: number, timestamp: NSDate): CLLocation;
	initWithCoordinateAltitudeHorizontalAccuracyVerticalAccuracyCourseSpeedTimestamp(coordinate: CLLocationCoordinate2D, altitude: number, hAccuracy: number, vAccuracy: number, course: number, speed: number, timestamp: NSDate): CLLocation;
	getDistanceFrom(location: CLLocation): number;
	distanceFromLocation(location: CLLocation): number;
	init(): CLLocation;
	static new(): CLLocation;
	static allocWithZone(zone: any): CLLocation;
	static alloc(): CLLocation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class CLRegion extends NSObject implements NSCopying, NSSecureCoding {
	center: CLLocationCoordinate2D;
	radius: number;
	identifier: string;
	notifyOnEntry: boolean;
	notifyOnExit: boolean;
	constructor(center: CLLocationCoordinate2D, radius: number, identifier: string);
	constructor();
	initCircularRegionWithCenterRadiusIdentifier(center: CLLocationCoordinate2D, radius: number, identifier: string): CLRegion;
	containsCoordinate(coordinate: CLLocationCoordinate2D): boolean;
	init(): CLRegion;
	static new(): CLRegion;
	static allocWithZone(zone: any): CLRegion;
	static alloc(): CLRegion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CLCircularRegion extends CLRegion {
	constructor();
	initWithCenterRadiusIdentifier(center: CLLocationCoordinate2D, radius: number, identifier: string): CLCircularRegion;
	initCircularRegionWithCenterRadiusIdentifier(center: CLLocationCoordinate2D, radius: number, identifier: string): CLCircularRegion;
	init(): CLCircularRegion;
	static new(): CLCircularRegion;
	static allocWithZone(zone: any): CLCircularRegion;
	static alloc(): CLCircularRegion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CLBeaconRegion extends CLRegion {
	proximityUUID: NSUUID;
	major: NSNumber;
	minor: NSNumber;
	notifyEntryStateOnDisplay: boolean;
	constructor(proximityUUID: NSUUID, identifier: string);
	constructor(proximityUUID: NSUUID, major: number, identifier: string);
	constructor(proximityUUID: NSUUID, major: number, minor: number, identifier: string);
	constructor(center: CLLocationCoordinate2D, radius: number, identifier: string);
	constructor();
	initWithProximityUUIDIdentifier(proximityUUID: NSUUID, identifier: string): CLBeaconRegion;
	initWithProximityUUIDMajorIdentifier(proximityUUID: NSUUID, major: number, identifier: string): CLBeaconRegion;
	initWithProximityUUIDMajorMinorIdentifier(proximityUUID: NSUUID, major: number, minor: number, identifier: string): CLBeaconRegion;
	peripheralDataWithMeasuredPower(measuredPower: NSNumber): NSMutableDictionary;
	initCircularRegionWithCenterRadiusIdentifier(center: CLLocationCoordinate2D, radius: number, identifier: string): CLBeaconRegion;
	init(): CLBeaconRegion;
	static new(): CLBeaconRegion;
	static allocWithZone(zone: any): CLBeaconRegion;
	static alloc(): CLBeaconRegion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CLBeacon extends NSObject implements NSCopying, NSSecureCoding {
	proximityUUID: NSUUID;
	major: NSNumber;
	minor: NSNumber;
	proximity: number;
	accuracy: number;
	rssi: number;
	constructor();
	init(): CLBeacon;
	static new(): CLBeacon;
	static allocWithZone(zone: any): CLBeacon;
	static alloc(): CLBeacon;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CLHeading extends NSObject implements NSCopying, NSSecureCoding {
	magneticHeading: number;
	trueHeading: number;
	headingAccuracy: number;
	x: number;
	y: number;
	z: number;
	timestamp: NSDate;
	constructor();
	init(): CLHeading;
	static new(): CLHeading;
	static allocWithZone(zone: any): CLHeading;
	static alloc(): CLHeading;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CLLocationManager extends NSObject {
	delegate: any;
	locationServicesEnabled: boolean;
	purpose: string;
	activityType: number;
	distanceFilter: number;
	desiredAccuracy: number;
	pausesLocationUpdatesAutomatically: boolean;
	location: CLLocation;
	headingAvailable: boolean;
	headingFilter: number;
	headingOrientation: number;
	heading: CLHeading;
	maximumRegionMonitoringDistance: number;
	monitoredRegions: NSSet;
	rangedRegions: NSSet;
	constructor();
	static locationServicesEnabled(): boolean;
	static headingAvailable(): boolean;
	static significantLocationChangeMonitoringAvailable(): boolean;
	static isMonitoringAvailableForClass(regionClass: any): boolean;
	static regionMonitoringAvailable(): boolean;
	static regionMonitoringEnabled(): boolean;
	static isRangingAvailable(): boolean;
	static authorizationStatus(): number;
	requestWhenInUseAuthorization(): void;
	requestAlwaysAuthorization(): void;
	startUpdatingLocation(): void;
	stopUpdatingLocation(): void;
	startUpdatingHeading(): void;
	stopUpdatingHeading(): void;
	dismissHeadingCalibrationDisplay(): void;
	startMonitoringSignificantLocationChanges(): void;
	stopMonitoringSignificantLocationChanges(): void;
	startMonitoringForRegionDesiredAccuracy(region: CLRegion, accuracy: number): void;
	stopMonitoringForRegion(region: CLRegion): void;
	startMonitoringForRegion(region: CLRegion): void;
	requestStateForRegion(region: CLRegion): void;
	startRangingBeaconsInRegion(region: CLBeaconRegion): void;
	stopRangingBeaconsInRegion(region: CLBeaconRegion): void;
	allowDeferredLocationUpdatesUntilTraveledTimeout(distance: number, timeout: number): void;
	disallowDeferredLocationUpdates(): void;
	static deferredLocationUpdatesAvailable(): boolean;
	startMonitoringVisits(): void;
	stopMonitoringVisits(): void;
	init(): CLLocationManager;
	static new(): CLLocationManager;
	static allocWithZone(zone: any): CLLocationManager;
	static alloc(): CLLocationManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CLVisit extends NSObject implements NSSecureCoding, NSCopying {
	arrivalDate: NSDate;
	departureDate: NSDate;
	coordinate: CLLocationCoordinate2D;
	horizontalAccuracy: number;
	constructor();
	init(): CLVisit;
	static new(): CLVisit;
	static allocWithZone(zone: any): CLVisit;
	static alloc(): CLVisit;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CLPlacemark extends NSObject implements NSCopying, NSSecureCoding {
	location: CLLocation;
	region: CLRegion;
	addressDictionary: NSDictionary;
	name: string;
	thoroughfare: string;
	subThoroughfare: string;
	locality: string;
	subLocality: string;
	administrativeArea: string;
	subAdministrativeArea: string;
	postalCode: string;
	ISOcountryCode: string;
	country: string;
	inlandWater: string;
	ocean: string;
	areasOfInterest: NSArray;
	constructor(placemark: CLPlacemark);
	constructor();
	initWithPlacemark(placemark: CLPlacemark): CLPlacemark;
	init(): CLPlacemark;
	static new(): CLPlacemark;
	static allocWithZone(zone: any): CLPlacemark;
	static alloc(): CLPlacemark;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CLGeocoder extends NSObject {
	geocoding: boolean;
	constructor();
	reverseGeocodeLocationCompletionHandler(location: CLLocation, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	geocodeAddressDictionaryCompletionHandler(addressDictionary: NSDictionary, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	geocodeAddressStringCompletionHandler(addressString: string, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	geocodeAddressStringInRegionCompletionHandler(addressString: string, region: CLRegion, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	cancelGeocode(): void;
	init(): CLGeocoder;
	static new(): CLGeocoder;
	static allocWithZone(zone: any): CLGeocoder;
	static alloc(): CLGeocoder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAInterAppAudioSwitcherView extends UIView {
	showingAppNames: boolean;
	constructor(frame: CGRect);
	constructor();
	setOutputAudioUnit(au: any): void;
	contentWidth(): number;
	initWithFrame(frame: CGRect): CAInterAppAudioSwitcherView;
	init(): CAInterAppAudioSwitcherView;
	static new(): CAInterAppAudioSwitcherView;
	static allocWithZone(zone: any): CAInterAppAudioSwitcherView;
	static alloc(): CAInterAppAudioSwitcherView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CAInterAppAudioTransportView extends UIView {
	enabled: boolean;
	playing: boolean;
	recording: boolean;
	connected: boolean;
	labelColor: UIColor;
	currentTimeLabelFont: UIFont;
	rewindButtonColor: UIColor;
	playButtonColor: UIColor;
	pauseButtonColor: UIColor;
	recordButtonColor: UIColor;
	constructor(frame: CGRect);
	constructor();
	setOutputAudioUnit(au: any): void;
	initWithFrame(frame: CGRect): CAInterAppAudioTransportView;
	init(): CAInterAppAudioTransportView;
	static new(): CAInterAppAudioTransportView;
	static allocWithZone(zone: any): CAInterAppAudioTransportView;
	static alloc(): CAInterAppAudioTransportView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CABTMIDILocalPeripheralViewController extends UIViewController {
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): CABTMIDILocalPeripheralViewController;
	init(): CABTMIDILocalPeripheralViewController;
	static new(): CABTMIDILocalPeripheralViewController;
	static allocWithZone(zone: any): CABTMIDILocalPeripheralViewController;
	static alloc(): CABTMIDILocalPeripheralViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CABTMIDICentralViewController extends UIViewController {
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): CABTMIDICentralViewController;
	init(): CABTMIDICentralViewController;
	static new(): CABTMIDICentralViewController;
	static allocWithZone(zone: any): CABTMIDICentralViewController;
	static alloc(): CABTMIDICentralViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBCentralManager extends NSObject {
	delegate: any;
	state: number;
	constructor(delegate: any, queue: NSObject);
	constructor(delegate: any, queue: NSObject, options: NSDictionary);
	constructor();
	initWithDelegateQueue(delegate: any, queue: NSObject): CBCentralManager;
	initWithDelegateQueueOptions(delegate: any, queue: NSObject, options: NSDictionary): CBCentralManager;
	retrievePeripherals(peripheralUUIDs: NSArray): void;
	retrievePeripheralsWithIdentifiers(identifiers: NSArray): NSArray;
	retrieveConnectedPeripherals(): void;
	retrieveConnectedPeripheralsWithServices(serviceUUIDs: NSArray): NSArray;
	scanForPeripheralsWithServicesOptions(serviceUUIDs: NSArray, options: NSDictionary): void;
	stopScan(): void;
	connectPeripheralOptions(peripheral: CBPeripheral, options: NSDictionary): void;
	cancelPeripheralConnection(peripheral: CBPeripheral): void;
	init(): CBCentralManager;
	static new(): CBCentralManager;
	static allocWithZone(zone: any): CBCentralManager;
	static alloc(): CBCentralManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBPeripheralManager extends NSObject {
	delegate: any;
	state: number;
	isAdvertising: boolean;
	constructor(delegate: any, queue: NSObject);
	constructor(delegate: any, queue: NSObject, options: NSDictionary);
	constructor();
	static authorizationStatus(): number;
	initWithDelegateQueue(delegate: any, queue: NSObject): CBPeripheralManager;
	initWithDelegateQueueOptions(delegate: any, queue: NSObject, options: NSDictionary): CBPeripheralManager;
	startAdvertising(advertisementData: NSDictionary): void;
	stopAdvertising(): void;
	setDesiredConnectionLatencyForCentral(latency: number, central: CBCentral): void;
	addService(service: CBMutableService): void;
	removeService(service: CBMutableService): void;
	removeAllServices(): void;
	respondToRequestWithResult(request: CBATTRequest, result: number): void;
	updateValueForCharacteristicOnSubscribedCentrals(value: NSData, characteristic: CBMutableCharacteristic, centrals: NSArray): boolean;
	init(): CBPeripheralManager;
	static new(): CBPeripheralManager;
	static allocWithZone(zone: any): CBPeripheralManager;
	static alloc(): CBPeripheralManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBPeer extends NSObject implements NSCopying {
	UUID: any;
	identifier: NSUUID;
	constructor();
	init(): CBPeer;
	static new(): CBPeer;
	static allocWithZone(zone: any): CBPeer;
	static alloc(): CBPeer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class CBPeripheral extends CBPeer {
	delegate: any;
	name: string;
	RSSI: NSNumber;
	isConnected: boolean;
	state: number;
	services: NSArray;
	constructor();
	readRSSI(): void;
	discoverServices(serviceUUIDs: NSArray): void;
	discoverIncludedServicesForService(includedServiceUUIDs: NSArray, service: CBService): void;
	discoverCharacteristicsForService(characteristicUUIDs: NSArray, service: CBService): void;
	readValueForCharacteristic(characteristic: CBCharacteristic): void;
	writeValueForCharacteristicType(data: NSData, characteristic: CBCharacteristic, type: number): void;
	setNotifyValueForCharacteristic(enabled: boolean, characteristic: CBCharacteristic): void;
	discoverDescriptorsForCharacteristic(characteristic: CBCharacteristic): void;
	readValueForDescriptor(descriptor: CBDescriptor): void;
	writeValueForDescriptor(data: NSData, descriptor: CBDescriptor): void;
	init(): CBPeripheral;
	static new(): CBPeripheral;
	static allocWithZone(zone: any): CBPeripheral;
	static alloc(): CBPeripheral;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBCentral extends CBPeer {
	maximumUpdateValueLength: number;
	constructor();
	init(): CBCentral;
	static new(): CBCentral;
	static allocWithZone(zone: any): CBCentral;
	static alloc(): CBCentral;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBAttribute extends NSObject {
	UUID: CBUUID;
	constructor();
	init(): CBAttribute;
	static new(): CBAttribute;
	static allocWithZone(zone: any): CBAttribute;
	static alloc(): CBAttribute;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBService extends CBAttribute {
	peripheral: CBPeripheral;
	isPrimary: boolean;
	includedServices: NSArray;
	characteristics: NSArray;
	constructor();
	init(): CBService;
	static new(): CBService;
	static allocWithZone(zone: any): CBService;
	static alloc(): CBService;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBMutableService extends CBService {
	UUID: CBUUID;
	isPrimary: boolean;
	includedServices: NSArray;
	characteristics: NSArray;
	constructor(UUID: CBUUID, isPrimary: boolean);
	constructor();
	initWithTypePrimary(UUID: CBUUID, isPrimary: boolean): CBMutableService;
	init(): CBMutableService;
	static new(): CBMutableService;
	static allocWithZone(zone: any): CBMutableService;
	static alloc(): CBMutableService;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBCharacteristic extends CBAttribute {
	service: CBService;
	properties: number;
	value: NSData;
	descriptors: NSArray;
	isBroadcasted: boolean;
	isNotifying: boolean;
	constructor();
	init(): CBCharacteristic;
	static new(): CBCharacteristic;
	static allocWithZone(zone: any): CBCharacteristic;
	static alloc(): CBCharacteristic;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBMutableCharacteristic extends CBCharacteristic {
	permissions: number;
	subscribedCentrals: NSArray;
	UUID: CBUUID;
	properties: number;
	value: NSData;
	descriptors: NSArray;
	constructor(UUID: CBUUID, properties: number, value: NSData, permissions: number);
	constructor();
	initWithTypePropertiesValuePermissions(UUID: CBUUID, properties: number, value: NSData, permissions: number): CBMutableCharacteristic;
	init(): CBMutableCharacteristic;
	static new(): CBMutableCharacteristic;
	static allocWithZone(zone: any): CBMutableCharacteristic;
	static alloc(): CBMutableCharacteristic;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBDescriptor extends CBAttribute {
	characteristic: CBCharacteristic;
	value: any;
	constructor();
	init(): CBDescriptor;
	static new(): CBDescriptor;
	static allocWithZone(zone: any): CBDescriptor;
	static alloc(): CBDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBMutableDescriptor extends CBDescriptor {
	constructor(UUID: CBUUID, value: any);
	constructor();
	initWithTypeValue(UUID: CBUUID, value: any): CBMutableDescriptor;
	init(): CBMutableDescriptor;
	static new(): CBMutableDescriptor;
	static allocWithZone(zone: any): CBMutableDescriptor;
	static alloc(): CBMutableDescriptor;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CBUUID extends NSObject implements NSCopying {
	data: NSData;
	UUIDString: string;
	constructor();
	static UUIDWithString(theString: string): CBUUID;
	static UUIDWithData(theData: NSData): CBUUID;
	static UUIDWithCFUUID(theUUID: any): CBUUID;
	static UUIDWithNSUUID(theUUID: NSUUID): CBUUID;
	init(): CBUUID;
	static new(): CBUUID;
	static allocWithZone(zone: any): CBUUID;
	static alloc(): CBUUID;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class CBATTRequest extends NSObject {
	central: CBCentral;
	characteristic: CBCharacteristic;
	offset: number;
	value: NSData;
	constructor();
	init(): CBATTRequest;
	static new(): CBATTRequest;
	static allocWithZone(zone: any): CBATTRequest;
	static alloc(): CBATTRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMLogItem extends NSObject implements NSSecureCoding, NSCopying {
	timestamp: number;
	constructor();
	init(): CMLogItem;
	static new(): CMLogItem;
	static allocWithZone(zone: any): CMLogItem;
	static alloc(): CMLogItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CMAccelerometerData extends CMLogItem {
	acceleration: CMAcceleration;
	constructor();
	init(): CMAccelerometerData;
	static new(): CMAccelerometerData;
	static allocWithZone(zone: any): CMAccelerometerData;
	static alloc(): CMAccelerometerData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMAltitudeData extends CMLogItem {
	relativeAltitude: NSNumber;
	pressure: NSNumber;
	constructor();
	init(): CMAltitudeData;
	static new(): CMAltitudeData;
	static allocWithZone(zone: any): CMAltitudeData;
	static alloc(): CMAltitudeData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMAltimeter extends NSObject {
	constructor();
	static isRelativeAltitudeAvailable(): boolean;
	startRelativeAltitudeUpdatesToQueueWithHandler(queue: NSOperationQueue, handler: (arg1: CMAltitudeData, arg2: NSError) => void): void;
	stopRelativeAltitudeUpdates(): void;
	init(): CMAltimeter;
	static new(): CMAltimeter;
	static allocWithZone(zone: any): CMAltimeter;
	static alloc(): CMAltimeter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMAttitude extends NSObject implements NSCopying, NSSecureCoding {
	roll: number;
	pitch: number;
	yaw: number;
	rotationMatrix: CMRotationMatrix;
	quaternion: CMQuaternion;
	constructor();
	multiplyByInverseOfAttitude(attitude: CMAttitude): void;
	init(): CMAttitude;
	static new(): CMAttitude;
	static allocWithZone(zone: any): CMAttitude;
	static alloc(): CMAttitude;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class CMGyroData extends CMLogItem {
	rotationRate: CMRotationRate;
	constructor();
	init(): CMGyroData;
	static new(): CMGyroData;
	static allocWithZone(zone: any): CMGyroData;
	static alloc(): CMGyroData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMMagnetometerData extends CMLogItem {
	magneticField: CMMagneticField;
	constructor();
	init(): CMMagnetometerData;
	static new(): CMMagnetometerData;
	static allocWithZone(zone: any): CMMagnetometerData;
	static alloc(): CMMagnetometerData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMDeviceMotion extends CMLogItem {
	attitude: CMAttitude;
	rotationRate: CMRotationRate;
	gravity: CMAcceleration;
	userAcceleration: CMAcceleration;
	magneticField: CMCalibratedMagneticField;
	constructor();
	init(): CMDeviceMotion;
	static new(): CMDeviceMotion;
	static allocWithZone(zone: any): CMDeviceMotion;
	static alloc(): CMDeviceMotion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMMotionActivity extends CMLogItem {
	confidence: number;
	startDate: NSDate;
	unknown: boolean;
	stationary: boolean;
	walking: boolean;
	running: boolean;
	automotive: boolean;
	cycling: boolean;
	constructor();
	init(): CMMotionActivity;
	static new(): CMMotionActivity;
	static allocWithZone(zone: any): CMMotionActivity;
	static alloc(): CMMotionActivity;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMMotionActivityManager extends NSObject {
	constructor();
	static isActivityAvailable(): boolean;
	queryActivityStartingFromDateToDateToQueueWithHandler(start: NSDate, end: NSDate, queue: NSOperationQueue, handler: (arg1: NSArray, arg2: NSError) => void): void;
	startActivityUpdatesToQueueWithHandler(queue: NSOperationQueue, handler: (arg1: CMMotionActivity) => void): void;
	stopActivityUpdates(): void;
	init(): CMMotionActivityManager;
	static new(): CMMotionActivityManager;
	static allocWithZone(zone: any): CMMotionActivityManager;
	static alloc(): CMMotionActivityManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMMotionManager extends NSObject {
	accelerometerUpdateInterval: number;
	accelerometerAvailable: boolean;
	accelerometerActive: boolean;
	accelerometerData: CMAccelerometerData;
	gyroUpdateInterval: number;
	gyroAvailable: boolean;
	gyroActive: boolean;
	gyroData: CMGyroData;
	magnetometerUpdateInterval: number;
	magnetometerAvailable: boolean;
	magnetometerActive: boolean;
	magnetometerData: CMMagnetometerData;
	deviceMotionUpdateInterval: number;
	attitudeReferenceFrame: number;
	deviceMotionAvailable: boolean;
	deviceMotionActive: boolean;
	deviceMotion: CMDeviceMotion;
	showsDeviceMovementDisplay: boolean;
	constructor();
	startAccelerometerUpdates(): void;
	startAccelerometerUpdatesToQueueWithHandler(queue: NSOperationQueue, handler: (arg1: CMAccelerometerData, arg2: NSError) => void): void;
	stopAccelerometerUpdates(): void;
	startGyroUpdates(): void;
	startGyroUpdatesToQueueWithHandler(queue: NSOperationQueue, handler: (arg1: CMGyroData, arg2: NSError) => void): void;
	stopGyroUpdates(): void;
	startMagnetometerUpdates(): void;
	startMagnetometerUpdatesToQueueWithHandler(queue: NSOperationQueue, handler: (arg1: CMMagnetometerData, arg2: NSError) => void): void;
	stopMagnetometerUpdates(): void;
	static availableAttitudeReferenceFrames(): number;
	startDeviceMotionUpdates(): void;
	startDeviceMotionUpdatesToQueueWithHandler(queue: NSOperationQueue, handler: (arg1: CMDeviceMotion, arg2: NSError) => void): void;
	startDeviceMotionUpdatesUsingReferenceFrame(referenceFrame: number): void;
	startDeviceMotionUpdatesUsingReferenceFrameToQueueWithHandler(referenceFrame: number, queue: NSOperationQueue, handler: (arg1: CMDeviceMotion, arg2: NSError) => void): void;
	stopDeviceMotionUpdates(): void;
	init(): CMMotionManager;
	static new(): CMMotionManager;
	static allocWithZone(zone: any): CMMotionManager;
	static alloc(): CMMotionManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMPedometerData extends NSObject implements NSSecureCoding, NSCopying {
	startDate: NSDate;
	endDate: NSDate;
	numberOfSteps: NSNumber;
	distance: NSNumber;
	floorsAscended: NSNumber;
	floorsDescended: NSNumber;
	constructor();
	init(): CMPedometerData;
	static new(): CMPedometerData;
	static allocWithZone(zone: any): CMPedometerData;
	static alloc(): CMPedometerData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class CMPedometer extends NSObject {
	constructor();
	static isStepCountingAvailable(): boolean;
	static isDistanceAvailable(): boolean;
	static isFloorCountingAvailable(): boolean;
	queryPedometerDataFromDateToDateWithHandler(start: NSDate, end: NSDate, handler: (arg1: CMPedometerData, arg2: NSError) => void): void;
	startPedometerUpdatesFromDateWithHandler(start: NSDate, handler: (arg1: CMPedometerData, arg2: NSError) => void): void;
	stopPedometerUpdates(): void;
	init(): CMPedometer;
	static new(): CMPedometer;
	static allocWithZone(zone: any): CMPedometer;
	static alloc(): CMPedometer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CMStepCounter extends NSObject {
	constructor();
	static isStepCountingAvailable(): boolean;
	queryStepCountStartingFromToToQueueWithHandler(start: NSDate, end: NSDate, queue: NSOperationQueue, handler: (arg1: number, arg2: NSError) => void): void;
	startStepCountingUpdatesToQueueUpdateOnWithHandler(queue: NSOperationQueue, stepCounts: number, handler: (arg1: number, arg2: NSDate, arg3: NSError) => void): void;
	stopStepCountingUpdates(): void;
	init(): CMStepCounter;
	static new(): CMStepCounter;
	static allocWithZone(zone: any): CMStepCounter;
	static alloc(): CMStepCounter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CTCall extends NSObject {
	callState: string;
	callID: string;
	constructor();
	init(): CTCall;
	static new(): CTCall;
	static allocWithZone(zone: any): CTCall;
	static alloc(): CTCall;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CTCallCenter extends NSObject {
	currentCalls: NSSet;
	callEventHandler: (arg1: CTCall) => void;
	constructor();
	init(): CTCallCenter;
	static new(): CTCallCenter;
	static allocWithZone(zone: any): CTCallCenter;
	static alloc(): CTCallCenter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CTCarrier extends NSObject {
	carrierName: string;
	mobileCountryCode: string;
	mobileNetworkCode: string;
	isoCountryCode: string;
	allowsVOIP: boolean;
	constructor();
	init(): CTCarrier;
	static new(): CTCarrier;
	static allocWithZone(zone: any): CTCarrier;
	static alloc(): CTCarrier;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CTSubscriber extends NSObject {
	carrierToken: NSData;
	constructor();
	init(): CTSubscriber;
	static new(): CTSubscriber;
	static allocWithZone(zone: any): CTSubscriber;
	static alloc(): CTSubscriber;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CTSubscriberInfo extends NSObject {
	constructor();
	static subscriber(): CTSubscriber;
	init(): CTSubscriberInfo;
	static new(): CTSubscriberInfo;
	static allocWithZone(zone: any): CTSubscriberInfo;
	static alloc(): CTSubscriberInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class CTTelephonyNetworkInfo extends NSObject {
	subscriberCellularProvider: CTCarrier;
	subscriberCellularProviderDidUpdateNotifier: (arg1: CTCarrier) => void;
	currentRadioAccessTechnology: string;
	constructor();
	init(): CTTelephonyNetworkInfo;
	static new(): CTTelephonyNetworkInfo;
	static allocWithZone(zone: any): CTTelephonyNetworkInfo;
	static alloc(): CTTelephonyNetworkInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKObject extends NSObject {
	constructor();
	hasChanges(): boolean;
	isNew(): boolean;
	reset(): void;
	rollback(): void;
	refresh(): boolean;
	init(): EKObject;
	static new(): EKObject;
	static allocWithZone(zone: any): EKObject;
	static alloc(): EKObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKAlarm extends EKObject implements NSCopying {
	relativeOffset: number;
	absoluteDate: NSDate;
	structuredLocation: EKStructuredLocation;
	proximity: number;
	constructor();
	static alarmWithAbsoluteDate(date: NSDate): EKAlarm;
	static alarmWithRelativeOffset(offset: number): EKAlarm;
	init(): EKAlarm;
	static new(): EKAlarm;
	static allocWithZone(zone: any): EKAlarm;
	static alloc(): EKAlarm;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class EKEventStore extends NSObject {
	eventStoreIdentifier: string;
	calendars: NSArray;
	defaultCalendarForNewEvents: EKCalendar;
	constructor();
	static authorizationStatusForEntityType(entityType: number): number;
	requestAccessToEntityTypeCompletion(entityType: number, completion: (arg1: boolean, arg2: NSError) => void): void;
	sources(): NSArray;
	sourceWithIdentifier(identifier: string): EKSource;
	calendarsForEntityType(entityType: number): NSArray;
	defaultCalendarForNewReminders(): EKCalendar;
	calendarWithIdentifier(identifier: string): EKCalendar;
	saveCalendarCommitError(calendar: EKCalendar, commit: boolean, error: any): boolean;
	removeCalendarCommitError(calendar: EKCalendar, commit: boolean, error: any): boolean;
	calendarItemWithIdentifier(identifier: string): EKCalendarItem;
	calendarItemsWithExternalIdentifier(externalIdentifier: string): NSArray;
	saveEventSpanError(event: EKEvent, span: number, error: any): boolean;
	removeEventSpanError(event: EKEvent, span: number, error: any): boolean;
	saveEventSpanCommitError(event: EKEvent, span: number, commit: boolean, error: any): boolean;
	removeEventSpanCommitError(event: EKEvent, span: number, commit: boolean, error: any): boolean;
	eventWithIdentifier(identifier: string): EKEvent;
	eventsMatchingPredicate(predicate: NSPredicate): NSArray;
	enumerateEventsMatchingPredicateUsingBlock(predicate: NSPredicate, block: (arg1: EKEvent, arg2: any) => void): void;
	predicateForEventsWithStartDateEndDateCalendars(startDate: NSDate, endDate: NSDate, calendars: NSArray): NSPredicate;
	saveReminderCommitError(reminder: EKReminder, commit: boolean, error: any): boolean;
	removeReminderCommitError(reminder: EKReminder, commit: boolean, error: any): boolean;
	fetchRemindersMatchingPredicateCompletion(predicate: NSPredicate, completion: (arg1: NSArray) => void): any;
	cancelFetchRequest(fetchIdentifier: any): void;
	predicateForRemindersInCalendars(calendars: NSArray): NSPredicate;
	predicateForIncompleteRemindersWithDueDateStartingEndingCalendars(startDate: NSDate, endDate: NSDate, calendars: NSArray): NSPredicate;
	predicateForCompletedRemindersWithCompletionDateStartingEndingCalendars(startDate: NSDate, endDate: NSDate, calendars: NSArray): NSPredicate;
	commit(error: any): boolean;
	reset(): void;
	refreshSourcesIfNecessary(): void;
	init(): EKEventStore;
	static new(): EKEventStore;
	static allocWithZone(zone: any): EKEventStore;
	static alloc(): EKEventStore;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKCalendar extends EKObject {
	source: EKSource;
	calendarIdentifier: string;
	title: string;
	type: number;
	allowsContentModifications: boolean;
	subscribed: boolean;
	immutable: boolean;
	CGColor: any;
	supportedEventAvailabilities: number;
	allowedEntityTypes: number;
	constructor();
	static calendarWithEventStore(eventStore: EKEventStore): EKCalendar;
	static calendarForEntityTypeEventStore(entityType: number, eventStore: EKEventStore): EKCalendar;
	init(): EKCalendar;
	static new(): EKCalendar;
	static allocWithZone(zone: any): EKCalendar;
	static alloc(): EKCalendar;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKParticipant extends EKObject implements NSCopying {
	URL: NSURL;
	name: string;
	participantStatus: number;
	participantRole: number;
	participantType: number;
	isCurrentUser: boolean;
	constructor();
	ABRecordWithAddressBook(addressBook: any): any;
	init(): EKParticipant;
	static new(): EKParticipant;
	static allocWithZone(zone: any): EKParticipant;
	static alloc(): EKParticipant;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class EKCalendarItem extends EKObject {
	UUID: string;
	calendar: EKCalendar;
	calendarItemIdentifier: string;
	calendarItemExternalIdentifier: string;
	title: string;
	location: string;
	notes: string;
	URL: NSURL;
	lastModifiedDate: NSDate;
	creationDate: NSDate;
	timeZone: NSTimeZone;
	hasAlarms: boolean;
	hasRecurrenceRules: boolean;
	hasAttendees: boolean;
	hasNotes: boolean;
	attendees: NSArray;
	alarms: NSArray;
	recurrenceRules: NSArray;
	constructor();
	addAlarm(alarm: EKAlarm): void;
	removeAlarm(alarm: EKAlarm): void;
	addRecurrenceRule(rule: EKRecurrenceRule): void;
	removeRecurrenceRule(rule: EKRecurrenceRule): void;
	init(): EKCalendarItem;
	static new(): EKCalendarItem;
	static allocWithZone(zone: any): EKCalendarItem;
	static alloc(): EKCalendarItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKEvent extends EKCalendarItem {
	eventIdentifier: string;
	allDay: boolean;
	startDate: NSDate;
	endDate: NSDate;
	organizer: EKParticipant;
	availability: number;
	status: number;
	isDetached: boolean;
	birthdayPersonID: number;
	constructor();
	static eventWithEventStore(eventStore: EKEventStore): EKEvent;
	compareStartDateWithEvent(other: EKEvent): number;
	init(): EKEvent;
	static new(): EKEvent;
	static allocWithZone(zone: any): EKEvent;
	static alloc(): EKEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKRecurrenceEnd extends NSObject implements NSCopying {
	endDate: NSDate;
	occurrenceCount: number;
	constructor();
	static recurrenceEndWithEndDate(endDate: NSDate): any;
	static recurrenceEndWithOccurrenceCount(occurrenceCount: number): any;
	init(): EKRecurrenceEnd;
	static new(): EKRecurrenceEnd;
	static allocWithZone(zone: any): EKRecurrenceEnd;
	static alloc(): EKRecurrenceEnd;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class EKRecurrenceDayOfWeek extends NSObject implements NSCopying {
	dayOfTheWeek: number;
	weekNumber: number;
	constructor(dayOfTheWeek: number, weekNumber: number);
	constructor();
	static dayOfWeek(dayOfTheWeek: number): EKRecurrenceDayOfWeek;
	static dayOfWeekWeekNumber(dayOfTheWeek: number, weekNumber: number): EKRecurrenceDayOfWeek;
	initWithDayOfTheWeekWeekNumber(dayOfTheWeek: number, weekNumber: number): EKRecurrenceDayOfWeek;
	init(): EKRecurrenceDayOfWeek;
	static new(): EKRecurrenceDayOfWeek;
	static allocWithZone(zone: any): EKRecurrenceDayOfWeek;
	static alloc(): EKRecurrenceDayOfWeek;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class EKRecurrenceRule extends EKObject implements NSCopying {
	calendarIdentifier: string;
	recurrenceEnd: EKRecurrenceEnd;
	frequency: number;
	interval: number;
	firstDayOfTheWeek: number;
	daysOfTheWeek: NSArray;
	daysOfTheMonth: NSArray;
	daysOfTheYear: NSArray;
	weeksOfTheYear: NSArray;
	monthsOfTheYear: NSArray;
	setPositions: NSArray;
	constructor(type: number, interval: number, end: EKRecurrenceEnd);
	constructor(type: number, interval: number, days: NSArray, monthDays: NSArray, months: NSArray, weeksOfTheYear: NSArray, daysOfTheYear: NSArray, setPositions: NSArray, end: EKRecurrenceEnd);
	constructor();
	initRecurrenceWithFrequencyIntervalEnd(type: number, interval: number, end: EKRecurrenceEnd): EKRecurrenceRule;
	initRecurrenceWithFrequencyIntervalDaysOfTheWeekDaysOfTheMonthMonthsOfTheYearWeeksOfTheYearDaysOfTheYearSetPositionsEnd(type: number, interval: number, days: NSArray, monthDays: NSArray, months: NSArray, weeksOfTheYear: NSArray, daysOfTheYear: NSArray, setPositions: NSArray, end: EKRecurrenceEnd): EKRecurrenceRule;
	init(): EKRecurrenceRule;
	static new(): EKRecurrenceRule;
	static allocWithZone(zone: any): EKRecurrenceRule;
	static alloc(): EKRecurrenceRule;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class EKReminder extends EKCalendarItem {
	startDateComponents: NSDateComponents;
	dueDateComponents: NSDateComponents;
	completed: boolean;
	completionDate: NSDate;
	priority: number;
	constructor();
	static reminderWithEventStore(eventStore: EKEventStore): EKReminder;
	init(): EKReminder;
	static new(): EKReminder;
	static allocWithZone(zone: any): EKReminder;
	static alloc(): EKReminder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKSource extends EKObject {
	sourceIdentifier: string;
	sourceType: number;
	title: string;
	calendars: NSSet;
	constructor();
	calendarsForEntityType(entityType: number): NSSet;
	init(): EKSource;
	static new(): EKSource;
	static allocWithZone(zone: any): EKSource;
	static alloc(): EKSource;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKStructuredLocation extends EKObject implements NSCopying {
	title: string;
	geoLocation: CLLocation;
	radius: number;
	constructor();
	static locationWithTitle(title: string): EKStructuredLocation;
	init(): EKStructuredLocation;
	static new(): EKStructuredLocation;
	static allocWithZone(zone: any): EKStructuredLocation;
	static alloc(): EKStructuredLocation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class EKEventEditViewController extends UINavigationController {
	editViewDelegate: any;
	eventStore: EKEventStore;
	event: EKEvent;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	cancelEditing(): void;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): EKEventEditViewController;
	initWithRootViewController(rootViewController: UIViewController): EKEventEditViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): EKEventEditViewController;
	init(): EKEventEditViewController;
	static new(): EKEventEditViewController;
	static allocWithZone(zone: any): EKEventEditViewController;
	static alloc(): EKEventEditViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKEventViewController extends UIViewController {
	delegate: any;
	event: EKEvent;
	allowsEditing: boolean;
	allowsCalendarPreview: boolean;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): EKEventViewController;
	init(): EKEventViewController;
	static new(): EKEventViewController;
	static allocWithZone(zone: any): EKEventViewController;
	static alloc(): EKEventViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class EKCalendarChooser extends UIViewController {
	selectionStyle: number;
	delegate: any;
	showsDoneButton: boolean;
	showsCancelButton: boolean;
	selectedCalendars: NSSet;
	constructor(selectionStyle: number, displayStyle: number, eventStore: EKEventStore);
	constructor(style: number, displayStyle: number, entityType: number, eventStore: EKEventStore);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithSelectionStyleDisplayStyleEventStore(selectionStyle: number, displayStyle: number, eventStore: EKEventStore): EKCalendarChooser;
	initWithSelectionStyleDisplayStyleEntityTypeEventStore(style: number, displayStyle: number, entityType: number, eventStore: EKEventStore): EKCalendarChooser;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): EKCalendarChooser;
	init(): EKCalendarChooser;
	static new(): EKCalendarChooser;
	static allocWithZone(zone: any): EKCalendarChooser;
	static alloc(): EKCalendarChooser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKAchievement extends NSObject implements NSCoding, NSSecureCoding {
	identifier: string;
	percentComplete: number;
	completed: boolean;
	lastReportedDate: NSDate;
	showsCompletionBanner: boolean;
	player: GKPlayer;
	hidden: boolean;
	playerID: string;
	constructor(identifier: string);
	constructor(identifier: string, player: GKPlayer);
	constructor(identifier: string, playerID: string);
	constructor();
	static loadAchievementsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	static resetAchievementsWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	initWithIdentifier(identifier: string): GKAchievement;
	initWithIdentifierPlayer(identifier: string, player: GKPlayer): GKAchievement;
	static reportAchievementsWithCompletionHandler(achievements: NSArray, completionHandler: (arg1: NSError) => void): void;
	reportAchievementWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	initWithIdentifierForPlayer(identifier: string, playerID: string): GKAchievement;
	challengeComposeControllerWithMessagePlayersCompletionHandler(message: string, players: NSArray, completionHandler: (arg1: UIViewController, arg2: boolean, arg3: NSArray) => void): UIViewController;
	selectChallengeablePlayersWithCompletionHandler(players: NSArray, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	static reportAchievementsWithEligibleChallengesWithCompletionHandler(achievements: NSArray, challenges: NSArray, completionHandler: (arg1: NSError) => void): void;
	selectChallengeablePlayerIDsWithCompletionHandler(playerIDs: NSArray, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	issueChallengeToPlayersMessage(playerIDs: NSArray, message: string): void;
	challengeComposeControllerWithPlayersMessageCompletionHandler(playerIDs: NSArray, message: string, completionHandler: (arg1: UIViewController, arg2: boolean, arg3: NSArray) => void): UIViewController;
	init(): GKAchievement;
	static new(): GKAchievement;
	static allocWithZone(zone: any): GKAchievement;
	static alloc(): GKAchievement;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	static supportsSecureCoding(): boolean;
}
declare class GKAchievementDescription extends NSObject implements NSCoding, NSSecureCoding {
	identifier: string;
	groupIdentifier: string;
	title: string;
	achievedDescription: string;
	unachievedDescription: string;
	maximumPoints: number;
	hidden: boolean;
	replayable: boolean;
	image: UIImage;
	constructor();
	static loadAchievementDescriptionsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	loadImageWithCompletionHandler(completionHandler: (arg1: UIImage, arg2: NSError) => void): void;
	static incompleteAchievementImage(): UIImage;
	static placeholderCompletedAchievementImage(): UIImage;
	init(): GKAchievementDescription;
	static new(): GKAchievementDescription;
	static allocWithZone(zone: any): GKAchievementDescription;
	static alloc(): GKAchievementDescription;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	static supportsSecureCoding(): boolean;
}
declare class GKLeaderboard extends NSObject {
	timeScope: number;
	playerScope: number;
	identifier: string;
	title: string;
	range: NSRange;
	scores: NSArray;
	maxRange: number;
	localPlayerScore: GKScore;
	loading: boolean;
	groupIdentifier: string;
	category: string;
	constructor();
	initWithPlayers(players: NSArray): GKLeaderboard;
	loadScoresWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	static loadLeaderboardsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	initWithPlayerIDs(playerIDs: NSArray): GKLeaderboard;
	static loadCategoriesWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSArray, arg3: NSError) => void): void;
	static setDefaultLeaderboardWithCompletionHandler(leaderboardIdentifier: string, completionHandler: (arg1: NSError) => void): void;
	loadImageWithCompletionHandler(completionHandler: (arg1: UIImage, arg2: NSError) => void): void;
	init(): GKLeaderboard;
	static new(): GKLeaderboard;
	static allocWithZone(zone: any): GKLeaderboard;
	static alloc(): GKLeaderboard;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKGameCenterViewController extends UINavigationController {
	gameCenterDelegate: any;
	viewState: number;
	leaderboardTimeScope: number;
	leaderboardIdentifier: string;
	leaderboardCategory: string;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): GKGameCenterViewController;
	initWithRootViewController(rootViewController: UIViewController): GKGameCenterViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GKGameCenterViewController;
	init(): GKGameCenterViewController;
	static new(): GKGameCenterViewController;
	static allocWithZone(zone: any): GKGameCenterViewController;
	static alloc(): GKGameCenterViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKAchievementViewController extends GKGameCenterViewController {
	achievementDelegate: any;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): GKAchievementViewController;
	initWithRootViewController(rootViewController: UIViewController): GKAchievementViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GKAchievementViewController;
	init(): GKAchievementViewController;
	static new(): GKAchievementViewController;
	static allocWithZone(zone: any): GKAchievementViewController;
	static alloc(): GKAchievementViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKScore extends NSObject implements NSCoding, NSSecureCoding {
	value: number;
	formattedValue: string;
	leaderboardIdentifier: string;
	context: number;
	date: NSDate;
	player: GKPlayer;
	rank: number;
	shouldSetDefaultLeaderboard: boolean;
	playerID: string;
	category: string;
	constructor(identifier: string, player: GKPlayer);
	constructor(identifier: string, playerID: string);
	constructor();
	initWithLeaderboardIdentifier(identifier: string): GKScore;
	initWithLeaderboardIdentifierPlayer(identifier: string, player: GKPlayer): GKScore;
	static reportScoresWithCompletionHandler(scores: NSArray, completionHandler: (arg1: NSError) => void): void;
	initWithLeaderboardIdentifierForPlayer(identifier: string, playerID: string): GKScore;
	reportScoreWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	initWithCategory(category: string): GKScore;
	challengeComposeControllerWithMessagePlayersCompletionHandler(message: string, players: NSArray, completionHandler: (arg1: UIViewController, arg2: boolean, arg3: NSArray) => void): UIViewController;
	static reportScoresWithEligibleChallengesWithCompletionHandler(scores: NSArray, challenges: NSArray, completionHandler: (arg1: NSError) => void): void;
	challengeComposeControllerWithPlayersMessageCompletionHandler(playerIDs: NSArray, message: string, completionHandler: (arg1: UIViewController, arg2: boolean, arg3: NSArray) => void): UIViewController;
	issueChallengeToPlayersMessage(playerIDs: NSArray, message: string): void;
	init(): GKScore;
	static new(): GKScore;
	static allocWithZone(zone: any): GKScore;
	static alloc(): GKScore;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	static supportsSecureCoding(): boolean;
}
declare class GKChallenge extends NSObject implements NSCoding, NSSecureCoding {
	issuingPlayerID: string;
	receivingPlayerID: string;
	issuingPlayer: GKPlayer;
	receivingPlayer: GKPlayer;
	state: number;
	issueDate: NSDate;
	completionDate: NSDate;
	message: string;
	constructor();
	static loadReceivedChallengesWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	decline(): void;
	init(): GKChallenge;
	static new(): GKChallenge;
	static allocWithZone(zone: any): GKChallenge;
	static alloc(): GKChallenge;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	static supportsSecureCoding(): boolean;
}
declare class GKScoreChallenge extends GKChallenge {
	score: GKScore;
	constructor();
	init(): GKScoreChallenge;
	static new(): GKScoreChallenge;
	static allocWithZone(zone: any): GKScoreChallenge;
	static alloc(): GKScoreChallenge;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKAchievementChallenge extends GKChallenge {
	achievement: GKAchievement;
	constructor();
	init(): GKAchievementChallenge;
	static new(): GKAchievementChallenge;
	static allocWithZone(zone: any): GKAchievementChallenge;
	static alloc(): GKAchievementChallenge;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKChallengeEventHandler extends NSObject {
	delegate: any;
	constructor();
	static challengeEventHandler(): GKChallengeEventHandler;
	init(): GKChallengeEventHandler;
	static new(): GKChallengeEventHandler;
	static allocWithZone(zone: any): GKChallengeEventHandler;
	static alloc(): GKChallengeEventHandler;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKFriendRequestComposeViewController extends UINavigationController {
	composeViewDelegate: any;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static maxNumberOfRecipients(): number;
	setMessage(message: string): void;
	addRecipientPlayers(players: NSArray): void;
	addRecipientsWithPlayerIDs(playerIDs: NSArray): void;
	addRecipientsWithEmailAddresses(emailAddresses: NSArray): void;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): GKFriendRequestComposeViewController;
	initWithRootViewController(rootViewController: UIViewController): GKFriendRequestComposeViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GKFriendRequestComposeViewController;
	init(): GKFriendRequestComposeViewController;
	static new(): GKFriendRequestComposeViewController;
	static allocWithZone(zone: any): GKFriendRequestComposeViewController;
	static alloc(): GKFriendRequestComposeViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKLeaderboardSet extends NSObject implements NSCoding, NSSecureCoding {
	title: string;
	groupIdentifier: string;
	identifier: string;
	constructor();
	static loadLeaderboardSetsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	loadLeaderboardsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	loadImageWithCompletionHandler(completionHandler: (arg1: UIImage, arg2: NSError) => void): void;
	init(): GKLeaderboardSet;
	static new(): GKLeaderboardSet;
	static allocWithZone(zone: any): GKLeaderboardSet;
	static alloc(): GKLeaderboardSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	static supportsSecureCoding(): boolean;
}
declare class GKLeaderboardViewController extends GKGameCenterViewController {
	timeScope: number;
	category: string;
	leaderboardDelegate: any;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): GKLeaderboardViewController;
	initWithRootViewController(rootViewController: UIViewController): GKLeaderboardViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GKLeaderboardViewController;
	init(): GKLeaderboardViewController;
	static new(): GKLeaderboardViewController;
	static allocWithZone(zone: any): GKLeaderboardViewController;
	static alloc(): GKLeaderboardViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKPlayer extends NSObject {
	playerID: string;
	displayName: string;
	alias: string;
	isFriend: boolean;
	constructor();
	static loadPlayersForIdentifiersWithCompletionHandler(identifiers: NSArray, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	loadPhotoForSizeWithCompletionHandler(size: number, completionHandler: (arg1: UIImage, arg2: NSError) => void): void;
	init(): GKPlayer;
	static new(): GKPlayer;
	static allocWithZone(zone: any): GKPlayer;
	static alloc(): GKPlayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKTurnBasedParticipant extends NSObject {
	player: GKPlayer;
	lastTurnDate: NSDate;
	status: number;
	matchOutcome: number;
	timeoutDate: NSDate;
	playerID: string;
	constructor();
	init(): GKTurnBasedParticipant;
	static new(): GKTurnBasedParticipant;
	static allocWithZone(zone: any): GKTurnBasedParticipant;
	static alloc(): GKTurnBasedParticipant;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKTurnBasedMatch extends NSObject {
	matchID: string;
	creationDate: NSDate;
	participants: NSArray;
	status: number;
	currentParticipant: GKTurnBasedParticipant;
	matchData: NSData;
	message: string;
	matchDataMaximumSize: number;
	exchanges: NSArray;
	activeExchanges: NSArray;
	completedExchanges: NSArray;
	exchangeDataMaximumSize: number;
	exchangeMaxInitiatedExchangesPerPlayer: number;
	constructor();
	setLocalizableMessageWithKeyArguments(key: string, args: NSArray): void;
	static findMatchForRequestWithCompletionHandler(request: GKMatchRequest, completionHandler: (arg1: GKTurnBasedMatch, arg2: NSError) => void): void;
	static loadMatchesWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	static loadMatchWithIDWithCompletionHandler(matchID: string, completionHandler: (arg1: GKTurnBasedMatch, arg2: NSError) => void): void;
	rematchWithCompletionHandler(completionHandler: (arg1: GKTurnBasedMatch, arg2: NSError) => void): void;
	acceptInviteWithCompletionHandler(completionHandler: (arg1: GKTurnBasedMatch, arg2: NSError) => void): void;
	declineInviteWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	removeWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	loadMatchDataWithCompletionHandler(completionHandler: (arg1: NSData, arg2: NSError) => void): void;
	endTurnWithNextParticipantsTurnTimeoutMatchDataCompletionHandler(nextParticipants: NSArray, timeout: number, matchData: NSData, completionHandler: (arg1: NSError) => void): void;
	participantQuitInTurnWithOutcomeNextParticipantsTurnTimeoutMatchDataCompletionHandler(matchOutcome: number, nextParticipants: NSArray, timeout: number, matchData: NSData, completionHandler: (arg1: NSError) => void): void;
	participantQuitOutOfTurnWithOutcomeWithCompletionHandler(matchOutcome: number, completionHandler: (arg1: NSError) => void): void;
	endMatchInTurnWithMatchDataCompletionHandler(matchData: NSData, completionHandler: (arg1: NSError) => void): void;
	endMatchInTurnWithMatchDataScoresAchievementsCompletionHandler(matchData: NSData, scores: NSArray, achievements: NSArray, completionHandler: (arg1: NSError) => void): void;
	saveCurrentTurnWithMatchDataCompletionHandler(matchData: NSData, completionHandler: (arg1: NSError) => void): void;
	saveMergedMatchDataWithResolvedExchangesCompletionHandler(matchData: NSData, exchanges: NSArray, completionHandler: (arg1: NSError) => void): void;
	sendExchangeToParticipantsDataLocalizableMessageKeyArgumentsTimeoutCompletionHandler(participants: NSArray, data: NSData, key: string, args: NSArray, timeout: number, completionHandler: (arg1: GKTurnBasedExchange, arg2: NSError) => void): void;
	sendReminderToParticipantsLocalizableMessageKeyArgumentsCompletionHandler(participants: NSArray, key: string, args: NSArray, completionHandler: (arg1: NSError) => void): void;
	endTurnWithNextParticipantMatchDataCompletionHandler(nextParticipant: GKTurnBasedParticipant, matchData: NSData, completionHandler: (arg1: NSError) => void): void;
	participantQuitInTurnWithOutcomeNextParticipantMatchDataCompletionHandler(matchOutcome: number, nextParticipant: GKTurnBasedParticipant, matchData: NSData, completionHandler: (arg1: NSError) => void): void;
	init(): GKTurnBasedMatch;
	static new(): GKTurnBasedMatch;
	static allocWithZone(zone: any): GKTurnBasedMatch;
	static alloc(): GKTurnBasedMatch;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKTurnBasedExchange extends NSObject {
	exchangeID: string;
	sender: GKTurnBasedParticipant;
	recipients: NSArray;
	status: string;
	message: string;
	data: NSData;
	sendDate: NSDate;
	timeoutDate: NSDate;
	completionDate: NSDate;
	replies: NSArray;
	constructor();
	cancelWithLocalizableMessageKeyArgumentsCompletionHandler(key: string, args: NSArray, completionHandler: (arg1: NSError) => void): void;
	replyWithLocalizableMessageKeyArgumentsDataCompletionHandler(key: string, args: NSArray, data: NSData, completionHandler: (arg1: NSError) => void): void;
	init(): GKTurnBasedExchange;
	static new(): GKTurnBasedExchange;
	static allocWithZone(zone: any): GKTurnBasedExchange;
	static alloc(): GKTurnBasedExchange;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKTurnBasedExchangeReply extends NSObject {
	recipient: GKTurnBasedParticipant;
	message: string;
	data: NSData;
	replyDate: NSDate;
	constructor();
	init(): GKTurnBasedExchangeReply;
	static new(): GKTurnBasedExchangeReply;
	static allocWithZone(zone: any): GKTurnBasedExchangeReply;
	static alloc(): GKTurnBasedExchangeReply;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKTurnBasedEventHandler extends NSObject {
	delegate: NSObject;
	constructor();
	static sharedTurnBasedEventHandler(): GKTurnBasedEventHandler;
	init(): GKTurnBasedEventHandler;
	static new(): GKTurnBasedEventHandler;
	static allocWithZone(zone: any): GKTurnBasedEventHandler;
	static alloc(): GKTurnBasedEventHandler;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKMatchRequest extends NSObject {
	minPlayers: number;
	maxPlayers: number;
	playerGroup: number;
	playerAttributes: number;
	recipients: NSArray;
	playersToInvite: NSArray;
	inviteMessage: string;
	defaultNumberOfPlayers: number;
	recipientResponseHandler: (arg1: GKPlayer, arg2: number) => void;
	inviteeResponseHandler: (arg1: string, arg2: number) => void;
	constructor();
	static maxPlayersAllowedForMatchOfType(matchType: number): number;
	init(): GKMatchRequest;
	static new(): GKMatchRequest;
	static allocWithZone(zone: any): GKMatchRequest;
	static alloc(): GKMatchRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKInvite extends NSObject {
	sender: GKPlayer;
	inviter: string;
	hosted: boolean;
	playerGroup: number;
	playerAttributes: number;
	constructor();
	init(): GKInvite;
	static new(): GKInvite;
	static allocWithZone(zone: any): GKInvite;
	static alloc(): GKInvite;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKMatchmaker extends NSObject {
	inviteHandler: (arg1: GKInvite, arg2: NSArray) => void;
	constructor();
	static sharedMatchmaker(): GKMatchmaker;
	matchForInviteCompletionHandler(invite: GKInvite, completionHandler: (arg1: GKMatch, arg2: NSError) => void): void;
	findMatchForRequestWithCompletionHandler(request: GKMatchRequest, completionHandler: (arg1: GKMatch, arg2: NSError) => void): void;
	findPlayersForHostedRequestWithCompletionHandler(request: GKMatchRequest, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	addPlayersToMatchMatchRequestCompletionHandler(match: GKMatch, matchRequest: GKMatchRequest, completionHandler: (arg1: NSError) => void): void;
	cancel(): void;
	cancelPendingInviteToPlayer(player: GKPlayer): void;
	finishMatchmakingForMatch(match: GKMatch): void;
	queryPlayerGroupActivityWithCompletionHandler(playerGroup: number, completionHandler: (arg1: number, arg2: NSError) => void): void;
	queryActivityWithCompletionHandler(completionHandler: (arg1: number, arg2: NSError) => void): void;
	startBrowsingForNearbyPlayersWithHandler(reachableHandler: (arg1: GKPlayer, arg2: boolean) => void): void;
	stopBrowsingForNearbyPlayers(): void;
	startBrowsingForNearbyPlayersWithReachableHandler(reachableHandler: (arg1: string, arg2: boolean) => void): void;
	cancelInviteToPlayer(playerID: string): void;
	findPlayersForHostedMatchRequestWithCompletionHandler(request: GKMatchRequest, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	init(): GKMatchmaker;
	static new(): GKMatchmaker;
	static allocWithZone(zone: any): GKMatchmaker;
	static alloc(): GKMatchmaker;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKLocalPlayer extends GKPlayer implements GKSavedGameListener {
	authenticated: boolean;
	underage: boolean;
	authenticateHandler: (arg1: UIViewController, arg2: NSError) => void;
	friends: NSArray;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static localPlayer(): GKLocalPlayer;
	loadFriendPlayersWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	setDefaultLeaderboardIdentifierCompletionHandler(leaderboardIdentifier: string, completionHandler: (arg1: NSError) => void): void;
	loadDefaultLeaderboardIdentifierWithCompletionHandler(completionHandler: (arg1: string, arg2: NSError) => void): void;
	generateIdentityVerificationSignatureWithCompletionHandler(completionHandler: (arg1: NSURL, arg2: NSData, arg3: NSData, arg4: number, arg5: NSError) => void): void;
	registerListener(listener: any): void;
	unregisterListener(listener: any): void;
	unregisterAllListeners(): void;
	setDefaultLeaderboardCategoryIDCompletionHandler(categoryID: string, completionHandler: (arg1: NSError) => void): void;
	loadDefaultLeaderboardCategoryIDWithCompletionHandler(completionHandler: (arg1: string, arg2: NSError) => void): void;
	loadFriendsWithCompletionHandler(completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
	authenticateWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	fetchSavedGamesWithCompletionHandler(handler: (arg1: NSArray, arg2: NSError) => void): void;
	saveGameDataWithNameCompletionHandler(data: NSData, name: string, handler: (arg1: GKSavedGame, arg2: NSError) => void): void;
	deleteSavedGamesWithNameCompletionHandler(name: string, handler: (arg1: NSError) => void): void;
	resolveConflictingSavedGamesWithDataCompletionHandler(conflictingSavedGames: NSArray, data: NSData, handler: (arg1: NSArray, arg2: NSError) => void): void;
	init(): GKLocalPlayer;
	static new(): GKLocalPlayer;
	static allocWithZone(zone: any): GKLocalPlayer;
	static alloc(): GKLocalPlayer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class GKMatch extends NSObject {
	players: NSArray;
	delegate: any;
	expectedPlayerCount: number;
	playerIDs: NSArray;
	constructor();
	sendDataToPlayersDataModeError(data: NSData, players: NSArray, mode: number, error: any): boolean;
	sendDataToAllPlayersWithDataModeError(data: NSData, mode: number, error: any): boolean;
	disconnect(): void;
	voiceChatWithName(name: string): GKVoiceChat;
	chooseBestHostingPlayerWithCompletionHandler(completionHandler: (arg1: GKPlayer) => void): void;
	rematchWithCompletionHandler(completionHandler: (arg1: GKMatch, arg2: NSError) => void): void;
	chooseBestHostPlayerWithCompletionHandler(completionHandler: (arg1: string) => void): void;
	sendDataToPlayersWithDataModeError(data: NSData, playerIDs: NSArray, mode: number, error: any): boolean;
	init(): GKMatch;
	static new(): GKMatch;
	static allocWithZone(zone: any): GKMatch;
	static alloc(): GKMatch;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKMatchmakerViewController extends UINavigationController {
	matchmakerDelegate: any;
	matchRequest: GKMatchRequest;
	hosted: boolean;
	defaultInvitationMessage: string;
	constructor(request: GKMatchRequest);
	constructor(invite: GKInvite);
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithMatchRequest(request: GKMatchRequest): GKMatchmakerViewController;
	initWithInvite(invite: GKInvite): GKMatchmakerViewController;
	addPlayersToMatch(match: GKMatch): void;
	setHostedPlayerConnected(playerID: string, connected: boolean): void;
	setHostedPlayerDidConnect(player: GKPlayer, connected: boolean): void;
	setHostedPlayerReady(playerID: string): void;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): GKMatchmakerViewController;
	initWithRootViewController(rootViewController: UIViewController): GKMatchmakerViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GKMatchmakerViewController;
	init(): GKMatchmakerViewController;
	static new(): GKMatchmakerViewController;
	static allocWithZone(zone: any): GKMatchmakerViewController;
	static alloc(): GKMatchmakerViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKNotificationBanner extends NSObject {
	constructor();
	static showBannerWithTitleMessageCompletionHandler(title: string, message: string, completionHandler: () => void): void;
	static showBannerWithTitleMessageDurationCompletionHandler(title: string, message: string, duration: number, completionHandler: () => void): void;
	init(): GKNotificationBanner;
	static new(): GKNotificationBanner;
	static allocWithZone(zone: any): GKNotificationBanner;
	static alloc(): GKNotificationBanner;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKSession extends NSObject {
	delegate: any;
	sessionID: string;
	displayName: string;
	sessionMode: number;
	peerID: string;
	available: boolean;
	disconnectTimeout: number;
	constructor(sessionID: string, name: string, mode: number);
	constructor();
	initWithSessionIDDisplayNameSessionMode(sessionID: string, name: string, mode: number): GKSession;
	displayNameForPeer(peerID: string): string;
	sendDataToPeersWithDataModeError(data: NSData, peers: NSArray, mode: number, error: any): boolean;
	sendDataToAllPeersWithDataModeError(data: NSData, mode: number, error: any): boolean;
	setDataReceiveHandlerWithContext(handler: any, context: any): void;
	connectToPeerWithTimeout(peerID: string, timeout: number): void;
	cancelConnectToPeer(peerID: string): void;
	acceptConnectionFromPeerError(peerID: string, error: any): boolean;
	denyConnectionFromPeer(peerID: string): void;
	disconnectPeerFromAllPeers(peerID: string): void;
	disconnectFromAllPeers(): void;
	peersWithConnectionState(state: number): NSArray;
	init(): GKSession;
	static new(): GKSession;
	static allocWithZone(zone: any): GKSession;
	static alloc(): GKSession;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKPeerPickerController extends NSObject {
	connectionTypesMask: number;
	delegate: any;
	visible: boolean;
	constructor();
	show(): void;
	dismiss(): void;
	init(): GKPeerPickerController;
	static new(): GKPeerPickerController;
	static allocWithZone(zone: any): GKPeerPickerController;
	static alloc(): GKPeerPickerController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKSavedGame extends NSObject implements NSCopying {
	name: string;
	deviceName: string;
	modificationDate: NSDate;
	constructor();
	loadDataWithCompletionHandler(handler: (arg1: NSData, arg2: NSError) => void): void;
	init(): GKSavedGame;
	static new(): GKSavedGame;
	static allocWithZone(zone: any): GKSavedGame;
	static alloc(): GKSavedGame;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class GKTurnBasedMatchmakerViewController extends UINavigationController {
	turnBasedMatchmakerDelegate: any;
	showExistingMatches: boolean;
	constructor(request: GKMatchRequest);
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithMatchRequest(request: GKMatchRequest): GKTurnBasedMatchmakerViewController;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): GKTurnBasedMatchmakerViewController;
	initWithRootViewController(rootViewController: UIViewController): GKTurnBasedMatchmakerViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GKTurnBasedMatchmakerViewController;
	init(): GKTurnBasedMatchmakerViewController;
	static new(): GKTurnBasedMatchmakerViewController;
	static allocWithZone(zone: any): GKTurnBasedMatchmakerViewController;
	static alloc(): GKTurnBasedMatchmakerViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKVoiceChat extends NSObject {
	playerVoiceChatStateDidChangeHandler: (arg1: GKPlayer, arg2: number) => void;
	name: string;
	active: boolean;
	volume: number;
	players: NSArray;
	playerIDs: NSArray;
	playerStateUpdateHandler: (arg1: string, arg2: number) => void;
	constructor();
	start(): void;
	stop(): void;
	setPlayerMuted(player: GKPlayer, isMuted: boolean): void;
	static isVoIPAllowed(): boolean;
	setMuteForPlayer(isMuted: boolean, playerID: string): void;
	init(): GKVoiceChat;
	static new(): GKVoiceChat;
	static allocWithZone(zone: any): GKVoiceChat;
	static alloc(): GKVoiceChat;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GKVoiceChatService extends NSObject {
	client: any;
	microphoneMuted: boolean;
	remoteParticipantVolume: number;
	outputMeteringEnabled: boolean;
	inputMeteringEnabled: boolean;
	outputMeterLevel: number;
	inputMeterLevel: number;
	constructor();
	static defaultVoiceChatService(): GKVoiceChatService;
	static isVoIPAllowed(): boolean;
	startVoiceChatWithParticipantIDError(participantID: string, error: any): boolean;
	stopVoiceChatWithParticipantID(participantID: string): void;
	acceptCallIDError(callID: number, error: any): boolean;
	denyCallID(callID: number): void;
	receivedRealTimeDataFromParticipantID(audio: NSData, participantID: string): void;
	receivedDataFromParticipantID(arbitraryData: NSData, participantID: string): void;
	init(): GKVoiceChatService;
	static new(): GKVoiceChatService;
	static allocWithZone(zone: any): GKVoiceChatService;
	static alloc(): GKVoiceChatService;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKView extends UIView implements NSCoding {
	delegate: any;
	context: EAGLContext;
	drawableWidth: number;
	drawableHeight: number;
	drawableColorFormat: number;
	drawableDepthFormat: number;
	drawableStencilFormat: number;
	drawableMultisample: number;
	snapshot: UIImage;
	enableSetNeedsDisplay: boolean;
	constructor(frame: CGRect, context: EAGLContext);
	constructor(frame: CGRect);
	constructor();
	initWithFrameContext(frame: CGRect, context: EAGLContext): GLKView;
	bindDrawable(): void;
	deleteDrawable(): void;
	display(): void;
	initWithFrame(frame: CGRect): GLKView;
	init(): GLKView;
	static new(): GLKView;
	static allocWithZone(zone: any): GLKView;
	static alloc(): GLKView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class GLKViewController extends UIViewController implements NSCoding, GLKViewDelegate {
	delegate: any;
	preferredFramesPerSecond: number;
	framesPerSecond: number;
	paused: boolean;
	framesDisplayed: number;
	timeSinceFirstResume: number;
	timeSinceLastResume: number;
	timeSinceLastUpdate: number;
	timeSinceLastDraw: number;
	pauseOnWillResignActive: boolean;
	resumeOnDidBecomeActive: boolean;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): GLKViewController;
	init(): GLKViewController;
	static new(): GLKViewController;
	static allocWithZone(zone: any): GLKViewController;
	static alloc(): GLKViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	glkViewDrawInRect(view: GLKView, rect: CGRect): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class GLKEffectProperty extends NSObject {
	constructor();
	init(): GLKEffectProperty;
	static new(): GLKEffectProperty;
	static allocWithZone(zone: any): GLKEffectProperty;
	static alloc(): GLKEffectProperty;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKEffectPropertyTransform extends GLKEffectProperty {
	constructor();
	init(): GLKEffectPropertyTransform;
	static new(): GLKEffectPropertyTransform;
	static allocWithZone(zone: any): GLKEffectPropertyTransform;
	static alloc(): GLKEffectPropertyTransform;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKEffectPropertyLight extends GLKEffectProperty {
	enabled: number;
	spotExponent: number;
	spotCutoff: number;
	constantAttenuation: number;
	linearAttenuation: number;
	quadraticAttenuation: number;
	transform: GLKEffectPropertyTransform;
	constructor();
	init(): GLKEffectPropertyLight;
	static new(): GLKEffectPropertyLight;
	static allocWithZone(zone: any): GLKEffectPropertyLight;
	static alloc(): GLKEffectPropertyLight;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKEffectPropertyMaterial extends GLKEffectProperty {
	shininess: number;
	constructor();
	init(): GLKEffectPropertyMaterial;
	static new(): GLKEffectPropertyMaterial;
	static allocWithZone(zone: any): GLKEffectPropertyMaterial;
	static alloc(): GLKEffectPropertyMaterial;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKEffectPropertyTexture extends GLKEffectProperty {
	enabled: number;
	name: number;
	target: number;
	envMode: number;
	constructor();
	init(): GLKEffectPropertyTexture;
	static new(): GLKEffectPropertyTexture;
	static allocWithZone(zone: any): GLKEffectPropertyTexture;
	static alloc(): GLKEffectPropertyTexture;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKEffectPropertyFog extends GLKEffectProperty {
	enabled: number;
	mode: number;
	density: number;
	start: number;
	end: number;
	constructor();
	init(): GLKEffectPropertyFog;
	static new(): GLKEffectPropertyFog;
	static allocWithZone(zone: any): GLKEffectPropertyFog;
	static alloc(): GLKEffectPropertyFog;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class GLKBaseEffect extends NSObject implements GLKNamedEffect {
	colorMaterialEnabled: number;
	lightModelTwoSided: number;
	useConstantColor: number;
	transform: GLKEffectPropertyTransform;
	light0: GLKEffectPropertyLight;
	light1: GLKEffectPropertyLight;
	light2: GLKEffectPropertyLight;
	lightingType: number;
	material: GLKEffectPropertyMaterial;
	texture2d0: GLKEffectPropertyTexture;
	texture2d1: GLKEffectPropertyTexture;
	textureOrder: NSArray;
	fog: GLKEffectPropertyFog;
	label: string;
	constructor();
	init(): GLKBaseEffect;
	static new(): GLKBaseEffect;
	static allocWithZone(zone: any): GLKBaseEffect;
	static alloc(): GLKBaseEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	prepareToDraw(): void;
}
declare class GLKReflectionMapEffect extends GLKBaseEffect implements GLKNamedEffect {
	textureCubeMap: GLKEffectPropertyTexture;
	constructor();
	init(): GLKReflectionMapEffect;
	static new(): GLKReflectionMapEffect;
	static allocWithZone(zone: any): GLKReflectionMapEffect;
	static alloc(): GLKReflectionMapEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	prepareToDraw(): void;
}
declare class GLKSkyboxEffect extends NSObject implements GLKNamedEffect {
	xSize: number;
	ySize: number;
	zSize: number;
	textureCubeMap: GLKEffectPropertyTexture;
	transform: GLKEffectPropertyTransform;
	label: string;
	constructor();
	draw(): void;
	init(): GLKSkyboxEffect;
	static new(): GLKSkyboxEffect;
	static allocWithZone(zone: any): GLKSkyboxEffect;
	static alloc(): GLKSkyboxEffect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	prepareToDraw(): void;
}
declare class GLKTextureInfo extends NSObject implements NSCopying {
	name: number;
	target: number;
	width: number;
	height: number;
	alphaState: number;
	textureOrigin: number;
	containsMipmaps: boolean;
	constructor();
	init(): GLKTextureInfo;
	static new(): GLKTextureInfo;
	static allocWithZone(zone: any): GLKTextureInfo;
	static alloc(): GLKTextureInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class GLKTextureLoader extends NSObject {
	constructor(sharegroup: EAGLSharegroup);
	constructor();
	static textureWithContentsOfFileOptionsError(path: string, options: NSDictionary, outError: any): GLKTextureInfo;
	static textureWithContentsOfURLOptionsError(url: NSURL, options: NSDictionary, outError: any): GLKTextureInfo;
	static textureWithContentsOfDataOptionsError(data: NSData, options: NSDictionary, outError: any): GLKTextureInfo;
	static textureWithCGImageOptionsError(cgImage: any, options: NSDictionary, outError: any): GLKTextureInfo;
	static cubeMapWithContentsOfFilesOptionsError(paths: NSArray, options: NSDictionary, outError: any): GLKTextureInfo;
	static cubeMapWithContentsOfFileOptionsError(path: string, options: NSDictionary, outError: any): GLKTextureInfo;
	static cubeMapWithContentsOfURLOptionsError(url: NSURL, options: NSDictionary, outError: any): GLKTextureInfo;
	initWithSharegroup(sharegroup: EAGLSharegroup): GLKTextureLoader;
	textureWithContentsOfFileOptionsQueueCompletionHandler(path: string, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	textureWithContentsOfURLOptionsQueueCompletionHandler(url: NSURL, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	textureWithContentsOfDataOptionsQueueCompletionHandler(data: NSData, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	textureWithCGImageOptionsQueueCompletionHandler(cgImage: any, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	cubeMapWithContentsOfFilesOptionsQueueCompletionHandler(paths: NSArray, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	cubeMapWithContentsOfFileOptionsQueueCompletionHandler(path: string, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	cubeMapWithContentsOfURLOptionsQueueCompletionHandler(url: NSURL, options: NSDictionary, queue: NSObject, block: (arg1: GLKTextureInfo, arg2: NSError) => void): void;
	init(): GLKTextureLoader;
	static new(): GLKTextureLoader;
	static allocWithZone(zone: any): GLKTextureLoader;
	static alloc(): GLKTextureLoader;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKObject extends NSObject implements NSSecureCoding {
	UUID: NSUUID;
	source: HKSource;
	metadata: NSDictionary;
	constructor();
	init(): HKObject;
	static new(): HKObject;
	static allocWithZone(zone: any): HKObject;
	static alloc(): HKObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class HKSample extends HKObject {
	sampleType: HKSampleType;
	startDate: NSDate;
	endDate: NSDate;
	constructor();
	init(): HKSample;
	static new(): HKSample;
	static allocWithZone(zone: any): HKSample;
	static alloc(): HKSample;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKWorkoutEvent extends NSObject implements NSSecureCoding {
	type: number;
	date: NSDate;
	constructor();
	static workoutEventWithTypeDate(type: number, date: NSDate): HKWorkoutEvent;
	init(): HKWorkoutEvent;
	static new(): HKWorkoutEvent;
	static allocWithZone(zone: any): HKWorkoutEvent;
	static alloc(): HKWorkoutEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class HKWorkout extends HKSample {
	workoutActivityType: number;
	workoutEvents: NSArray;
	duration: number;
	totalEnergyBurned: HKQuantity;
	totalDistance: HKQuantity;
	constructor();
	static workoutWithActivityTypeStartDateEndDate(workoutActivityType: number, startDate: NSDate, endDate: NSDate): HKWorkout;
	static workoutWithActivityTypeStartDateEndDateWorkoutEventsTotalEnergyBurnedTotalDistanceMetadata(workoutActivityType: number, startDate: NSDate, endDate: NSDate, workoutEvents: NSArray, totalEnergyBurned: HKQuantity, totalDistance: HKQuantity, metadata: NSDictionary): HKWorkout;
	static workoutWithActivityTypeStartDateEndDateDurationTotalEnergyBurnedTotalDistanceMetadata(workoutActivityType: number, startDate: NSDate, endDate: NSDate, duration: number, totalEnergyBurned: HKQuantity, totalDistance: HKQuantity, metadata: NSDictionary): HKWorkout;
	init(): HKWorkout;
	static new(): HKWorkout;
	static allocWithZone(zone: any): HKWorkout;
	static alloc(): HKWorkout;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKQuery extends NSObject {
	sampleType: HKSampleType;
	predicate: NSPredicate;
	constructor();
	static predicateForObjectsWithMetadataKey(key: string): NSPredicate;
	static predicateForObjectsWithMetadataKeyAllowedValues(key: string, allowedValues: NSArray): NSPredicate;
	static predicateForObjectsWithMetadataKeyOperatorTypeValue(key: string, operatorType: number, value: any): NSPredicate;
	static predicateForObjectsFromSource(source: HKSource): NSPredicate;
	static predicateForObjectsFromSources(sources: NSSet): NSPredicate;
	static predicateForObjectWithUUID(UUID: NSUUID): NSPredicate;
	static predicateForObjectsWithUUIDs(UUIDs: NSSet): NSPredicate;
	static predicateForObjectsWithNoCorrelation(): NSPredicate;
	static predicateForObjectsFromWorkout(workout: HKWorkout): NSPredicate;
	static predicateForSamplesWithStartDateEndDateOptions(startDate: NSDate, endDate: NSDate, options: number): NSPredicate;
	static predicateForQuantitySamplesWithOperatorTypeQuantity(operatorType: number, quantity: HKQuantity): NSPredicate;
	static predicateForCategorySamplesWithOperatorTypeValue(operatorType: number, value: number): NSPredicate;
	static predicateForWorkoutsWithWorkoutActivityType(workoutActivityType: number): NSPredicate;
	static predicateForWorkoutsWithOperatorTypeDuration(operatorType: number, duration: number): NSPredicate;
	static predicateForWorkoutsWithOperatorTypeTotalEnergyBurned(operatorType: number, totalEnergyBurned: HKQuantity): NSPredicate;
	static predicateForWorkoutsWithOperatorTypeTotalDistance(operatorType: number, totalDistance: HKQuantity): NSPredicate;
	init(): HKQuery;
	static new(): HKQuery;
	static allocWithZone(zone: any): HKQuery;
	static alloc(): HKQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKAnchoredObjectQuery extends HKQuery {
	constructor(type: HKSampleType, predicate: NSPredicate, anchor: number, limit: number, handler: (arg1: HKAnchoredObjectQuery, arg2: NSArray, arg3: number, arg4: NSError) => void);
	constructor();
	initWithTypePredicateAnchorLimitCompletionHandler(type: HKSampleType, predicate: NSPredicate, anchor: number, limit: number, handler: (arg1: HKAnchoredObjectQuery, arg2: NSArray, arg3: number, arg4: NSError) => void): HKAnchoredObjectQuery;
	init(): HKAnchoredObjectQuery;
	static new(): HKAnchoredObjectQuery;
	static allocWithZone(zone: any): HKAnchoredObjectQuery;
	static alloc(): HKAnchoredObjectQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKCategorySample extends HKSample {
	categoryType: HKCategoryType;
	value: number;
	constructor();
	static categorySampleWithTypeValueStartDateEndDateMetadata(type: HKCategoryType, value: number, startDate: NSDate, endDate: NSDate, metadata: NSDictionary): HKCategorySample;
	static categorySampleWithTypeValueStartDateEndDate(type: HKCategoryType, value: number, startDate: NSDate, endDate: NSDate): HKCategorySample;
	init(): HKCategorySample;
	static new(): HKCategorySample;
	static allocWithZone(zone: any): HKCategorySample;
	static alloc(): HKCategorySample;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKCorrelation extends HKSample implements NSSecureCoding {
	correlationType: HKCorrelationType;
	objects: NSSet;
	constructor();
	static correlationWithTypeStartDateEndDateObjects(correlationType: HKCorrelationType, startDate: NSDate, endDate: NSDate, objects: NSSet): HKCorrelation;
	static correlationWithTypeStartDateEndDateObjectsMetadata(correlationType: HKCorrelationType, startDate: NSDate, endDate: NSDate, objects: NSSet, metadata: NSDictionary): HKCorrelation;
	objectsForType(objectType: HKObjectType): NSSet;
	init(): HKCorrelation;
	static new(): HKCorrelation;
	static allocWithZone(zone: any): HKCorrelation;
	static alloc(): HKCorrelation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class HKCorrelationQuery extends HKQuery {
	correlationType: HKCorrelationType;
	samplePredicates: NSDictionary;
	constructor(correlationType: HKCorrelationType, predicate: NSPredicate, samplePredicates: NSDictionary, completion: (arg1: HKCorrelationQuery, arg2: NSArray, arg3: NSError) => void);
	constructor();
	initWithTypePredicateSamplePredicatesCompletion(correlationType: HKCorrelationType, predicate: NSPredicate, samplePredicates: NSDictionary, completion: (arg1: HKCorrelationQuery, arg2: NSArray, arg3: NSError) => void): HKCorrelationQuery;
	init(): HKCorrelationQuery;
	static new(): HKCorrelationQuery;
	static allocWithZone(zone: any): HKCorrelationQuery;
	static alloc(): HKCorrelationQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKHealthStore extends NSObject {
	constructor();
	static isHealthDataAvailable(): boolean;
	authorizationStatusForType(type: HKObjectType): number;
	requestAuthorizationToShareTypesReadTypesCompletion(typesToShare: NSSet, typesToRead: NSSet, completion: (arg1: boolean, arg2: NSError) => void): void;
	saveObjectWithCompletion(object: HKObject, completion: (arg1: boolean, arg2: NSError) => void): void;
	saveObjectsWithCompletion(objects: NSArray, completion: (arg1: boolean, arg2: NSError) => void): void;
	deleteObjectWithCompletion(object: HKObject, completion: (arg1: boolean, arg2: NSError) => void): void;
	executeQuery(query: HKQuery): void;
	stopQuery(query: HKQuery): void;
	dateOfBirthWithError(error: any): NSDate;
	biologicalSexWithError(error: any): HKBiologicalSexObject;
	bloodTypeWithError(error: any): HKBloodTypeObject;
	addSamplesToWorkoutCompletion(samples: NSArray, workout: HKWorkout, completion: (arg1: boolean, arg2: NSError) => void): void;
	enableBackgroundDeliveryForTypeFrequencyWithCompletion(type: HKObjectType, frequency: number, completion: (arg1: boolean, arg2: NSError) => void): void;
	disableBackgroundDeliveryForTypeWithCompletion(type: HKObjectType, completion: (arg1: boolean, arg2: NSError) => void): void;
	disableAllBackgroundDeliveryWithCompletion(completion: (arg1: boolean, arg2: NSError) => void): void;
	init(): HKHealthStore;
	static new(): HKHealthStore;
	static allocWithZone(zone: any): HKHealthStore;
	static alloc(): HKHealthStore;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKBiologicalSexObject extends NSObject {
	biologicalSex: number;
	constructor();
	init(): HKBiologicalSexObject;
	static new(): HKBiologicalSexObject;
	static allocWithZone(zone: any): HKBiologicalSexObject;
	static alloc(): HKBiologicalSexObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKBloodTypeObject extends NSObject {
	bloodType: number;
	constructor();
	init(): HKBloodTypeObject;
	static new(): HKBloodTypeObject;
	static allocWithZone(zone: any): HKBloodTypeObject;
	static alloc(): HKBloodTypeObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKObjectType extends NSObject implements NSSecureCoding, NSCopying {
	identifier: string;
	constructor();
	static quantityTypeForIdentifier(identifier: string): HKQuantityType;
	static categoryTypeForIdentifier(identifier: string): HKCategoryType;
	static characteristicTypeForIdentifier(identifier: string): HKCharacteristicType;
	static correlationTypeForIdentifier(identifier: string): HKCorrelationType;
	static workoutType(): HKWorkoutType;
	init(): HKObjectType;
	static new(): HKObjectType;
	static allocWithZone(zone: any): HKObjectType;
	static alloc(): HKObjectType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class HKCharacteristicType extends HKObjectType {
	constructor();
	init(): HKCharacteristicType;
	static new(): HKCharacteristicType;
	static allocWithZone(zone: any): HKCharacteristicType;
	static alloc(): HKCharacteristicType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKSampleType extends HKObjectType {
	constructor();
	init(): HKSampleType;
	static new(): HKSampleType;
	static allocWithZone(zone: any): HKSampleType;
	static alloc(): HKSampleType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKCategoryType extends HKSampleType {
	constructor();
	init(): HKCategoryType;
	static new(): HKCategoryType;
	static allocWithZone(zone: any): HKCategoryType;
	static alloc(): HKCategoryType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKCorrelationType extends HKSampleType {
	constructor();
	init(): HKCorrelationType;
	static new(): HKCorrelationType;
	static allocWithZone(zone: any): HKCorrelationType;
	static alloc(): HKCorrelationType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKQuantityType extends HKSampleType {
	aggregationStyle: number;
	constructor();
	isCompatibleWithUnit(unit: HKUnit): boolean;
	init(): HKQuantityType;
	static new(): HKQuantityType;
	static allocWithZone(zone: any): HKQuantityType;
	static alloc(): HKQuantityType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKWorkoutType extends HKSampleType {
	constructor();
	init(): HKWorkoutType;
	static new(): HKWorkoutType;
	static allocWithZone(zone: any): HKWorkoutType;
	static alloc(): HKWorkoutType;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKObserverQuery extends HKQuery {
	constructor(sampleType: HKSampleType, predicate: NSPredicate, updateHandler: (arg1: HKObserverQuery, arg2: () => void, arg3: NSError) => void);
	constructor();
	initWithSampleTypePredicateUpdateHandler(sampleType: HKSampleType, predicate: NSPredicate, updateHandler: (arg1: HKObserverQuery, arg2: () => void, arg3: NSError) => void): HKObserverQuery;
	init(): HKObserverQuery;
	static new(): HKObserverQuery;
	static allocWithZone(zone: any): HKObserverQuery;
	static alloc(): HKObserverQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKQuantity extends NSObject implements NSSecureCoding, NSCopying {
	constructor();
	static quantityWithUnitDoubleValue(unit: HKUnit, value: number): HKQuantity;
	isCompatibleWithUnit(unit: HKUnit): boolean;
	doubleValueForUnit(unit: HKUnit): number;
	compare(quantity: HKQuantity): number;
	init(): HKQuantity;
	static new(): HKQuantity;
	static allocWithZone(zone: any): HKQuantity;
	static alloc(): HKQuantity;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class HKQuantitySample extends HKSample {
	quantityType: HKQuantityType;
	quantity: HKQuantity;
	constructor();
	static quantitySampleWithTypeQuantityStartDateEndDate(quantityType: HKQuantityType, quantity: HKQuantity, startDate: NSDate, endDate: NSDate): HKQuantitySample;
	static quantitySampleWithTypeQuantityStartDateEndDateMetadata(quantityType: HKQuantityType, quantity: HKQuantity, startDate: NSDate, endDate: NSDate, metadata: NSDictionary): HKQuantitySample;
	init(): HKQuantitySample;
	static new(): HKQuantitySample;
	static allocWithZone(zone: any): HKQuantitySample;
	static alloc(): HKQuantitySample;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKSampleQuery extends HKQuery {
	limit: number;
	sortDescriptors: NSArray;
	constructor(sampleType: HKSampleType, predicate: NSPredicate, limit: number, sortDescriptors: NSArray, resultsHandler: (arg1: HKSampleQuery, arg2: NSArray, arg3: NSError) => void);
	constructor();
	initWithSampleTypePredicateLimitSortDescriptorsResultsHandler(sampleType: HKSampleType, predicate: NSPredicate, limit: number, sortDescriptors: NSArray, resultsHandler: (arg1: HKSampleQuery, arg2: NSArray, arg3: NSError) => void): HKSampleQuery;
	init(): HKSampleQuery;
	static new(): HKSampleQuery;
	static allocWithZone(zone: any): HKSampleQuery;
	static alloc(): HKSampleQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKSource extends NSObject implements NSSecureCoding, NSCopying {
	name: string;
	bundleIdentifier: string;
	constructor();
	static defaultSource(): HKSource;
	init(): HKSource;
	static new(): HKSource;
	static allocWithZone(zone: any): HKSource;
	static alloc(): HKSource;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class HKSourceQuery extends HKQuery {
	constructor(sampleType: HKSampleType, objectPredicate: NSPredicate, completionHandler: (arg1: HKSourceQuery, arg2: NSSet, arg3: NSError) => void);
	constructor();
	initWithSampleTypeSamplePredicateCompletionHandler(sampleType: HKSampleType, objectPredicate: NSPredicate, completionHandler: (arg1: HKSourceQuery, arg2: NSSet, arg3: NSError) => void): HKSourceQuery;
	init(): HKSourceQuery;
	static new(): HKSourceQuery;
	static allocWithZone(zone: any): HKSourceQuery;
	static alloc(): HKSourceQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKStatistics extends NSObject implements NSSecureCoding, NSCopying {
	quantityType: HKQuantityType;
	startDate: NSDate;
	endDate: NSDate;
	sources: NSArray;
	constructor();
	averageQuantityForSource(source: HKSource): HKQuantity;
	averageQuantity(): HKQuantity;
	minimumQuantityForSource(source: HKSource): HKQuantity;
	minimumQuantity(): HKQuantity;
	maximumQuantityForSource(source: HKSource): HKQuantity;
	maximumQuantity(): HKQuantity;
	sumQuantityForSource(source: HKSource): HKQuantity;
	sumQuantity(): HKQuantity;
	init(): HKStatistics;
	static new(): HKStatistics;
	static allocWithZone(zone: any): HKStatistics;
	static alloc(): HKStatistics;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class HKStatisticsCollection extends NSObject {
	constructor();
	statisticsForDate(date: NSDate): HKStatistics;
	enumerateStatisticsFromDateToDateWithBlock(startDate: NSDate, endDate: NSDate, block: (arg1: HKStatistics, arg2: any) => void): void;
	statistics(): NSArray;
	sources(): NSSet;
	init(): HKStatisticsCollection;
	static new(): HKStatisticsCollection;
	static allocWithZone(zone: any): HKStatisticsCollection;
	static alloc(): HKStatisticsCollection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKStatisticsCollectionQuery extends HKQuery {
	anchorDate: NSDate;
	options: number;
	intervalComponents: NSDateComponents;
	initialResultsHandler: (arg1: HKStatisticsCollectionQuery, arg2: HKStatisticsCollection, arg3: NSError) => void;
	statisticsUpdateHandler: (arg1: HKStatisticsCollectionQuery, arg2: HKStatistics, arg3: HKStatisticsCollection, arg4: NSError) => void;
	constructor(quantityType: HKQuantityType, quantitySamplePredicate: NSPredicate, options: number, anchorDate: NSDate, intervalComponents: NSDateComponents);
	constructor();
	initWithQuantityTypeQuantitySamplePredicateOptionsAnchorDateIntervalComponents(quantityType: HKQuantityType, quantitySamplePredicate: NSPredicate, options: number, anchorDate: NSDate, intervalComponents: NSDateComponents): HKStatisticsCollectionQuery;
	init(): HKStatisticsCollectionQuery;
	static new(): HKStatisticsCollectionQuery;
	static allocWithZone(zone: any): HKStatisticsCollectionQuery;
	static alloc(): HKStatisticsCollectionQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKStatisticsQuery extends HKQuery {
	constructor(quantityType: HKQuantityType, quantitySamplePredicate: NSPredicate, options: number, handler: (arg1: HKStatisticsQuery, arg2: HKStatistics, arg3: NSError) => void);
	constructor();
	initWithQuantityTypeQuantitySamplePredicateOptionsCompletionHandler(quantityType: HKQuantityType, quantitySamplePredicate: NSPredicate, options: number, handler: (arg1: HKStatisticsQuery, arg2: HKStatistics, arg3: NSError) => void): HKStatisticsQuery;
	init(): HKStatisticsQuery;
	static new(): HKStatisticsQuery;
	static allocWithZone(zone: any): HKStatisticsQuery;
	static alloc(): HKStatisticsQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HKUnit extends NSObject implements NSSecureCoding {
	unitString: string;
	constructor();
	static unitFromString(string: string): HKUnit;
	static unitFromMassFormatterUnit(massFormatterUnit: number): HKUnit;
	static massFormatterUnitFromUnit(unit: HKUnit): number;
	static unitFromLengthFormatterUnit(lengthFormatterUnit: number): HKUnit;
	static lengthFormatterUnitFromUnit(unit: HKUnit): number;
	static unitFromEnergyFormatterUnit(energyFormatterUnit: number): HKUnit;
	static energyFormatterUnitFromUnit(unit: HKUnit): number;
	isNull(): boolean;
	static gramUnitWithMetricPrefix(prefix: number): HKUnit;
	static gramUnit(): HKUnit;
	static ounceUnit(): HKUnit;
	static poundUnit(): HKUnit;
	static stoneUnit(): HKUnit;
	static moleUnitWithMetricPrefixMolarMass(prefix: number, gramsPerMole: number): HKUnit;
	static moleUnitWithMolarMass(gramsPerMole: number): HKUnit;
	static meterUnitWithMetricPrefix(prefix: number): HKUnit;
	static meterUnit(): HKUnit;
	static inchUnit(): HKUnit;
	static footUnit(): HKUnit;
	static mileUnit(): HKUnit;
	static literUnitWithMetricPrefix(prefix: number): HKUnit;
	static literUnit(): HKUnit;
	static fluidOunceUSUnit(): HKUnit;
	static fluidOunceImperialUnit(): HKUnit;
	static pintUSUnit(): HKUnit;
	static pintImperialUnit(): HKUnit;
	static pascalUnitWithMetricPrefix(prefix: number): HKUnit;
	static pascalUnit(): HKUnit;
	static millimeterOfMercuryUnit(): HKUnit;
	static centimeterOfWaterUnit(): HKUnit;
	static atmosphereUnit(): HKUnit;
	static secondUnitWithMetricPrefix(prefix: number): HKUnit;
	static secondUnit(): HKUnit;
	static minuteUnit(): HKUnit;
	static hourUnit(): HKUnit;
	static dayUnit(): HKUnit;
	static jouleUnitWithMetricPrefix(prefix: number): HKUnit;
	static jouleUnit(): HKUnit;
	static calorieUnit(): HKUnit;
	static kilocalorieUnit(): HKUnit;
	static degreeCelsiusUnit(): HKUnit;
	static degreeFahrenheitUnit(): HKUnit;
	static kelvinUnit(): HKUnit;
	static siemenUnitWithMetricPrefix(prefix: number): HKUnit;
	static siemenUnit(): HKUnit;
	static countUnit(): HKUnit;
	static percentUnit(): HKUnit;
	unitMultipliedByUnit(unit: HKUnit): HKUnit;
	unitDividedByUnit(unit: HKUnit): HKUnit;
	unitRaisedToPower(power: number): HKUnit;
	reciprocalUnit(): HKUnit;
	init(): HKUnit;
	static new(): HKUnit;
	static allocWithZone(zone: any): HKUnit;
	static alloc(): HKUnit;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class HMHomeManager extends NSObject {
	delegate: any;
	primaryHome: HMHome;
	homes: NSArray;
	constructor();
	updatePrimaryHomeCompletionHandler(home: HMHome, completion: (arg1: NSError) => void): void;
	addHomeWithNameCompletionHandler(homeName: string, completion: (arg1: HMHome, arg2: NSError) => void): void;
	removeHomeCompletionHandler(home: HMHome, completion: (arg1: NSError) => void): void;
	init(): HMHomeManager;
	static new(): HMHomeManager;
	static allocWithZone(zone: any): HMHomeManager;
	static alloc(): HMHomeManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMAccessoryBrowser extends NSObject {
	delegate: any;
	discoveredAccessories: NSArray;
	constructor();
	startSearchingForNewAccessories(): void;
	stopSearchingForNewAccessories(): void;
	init(): HMAccessoryBrowser;
	static new(): HMAccessoryBrowser;
	static allocWithZone(zone: any): HMAccessoryBrowser;
	static alloc(): HMAccessoryBrowser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMHome extends NSObject {
	delegate: any;
	name: string;
	primary: boolean;
	accessories: NSArray;
	users: NSArray;
	rooms: NSArray;
	zones: NSArray;
	serviceGroups: NSArray;
	actionSets: NSArray;
	triggers: NSArray;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	addAccessoryCompletionHandler(accessory: HMAccessory, completion: (arg1: NSError) => void): void;
	removeAccessoryCompletionHandler(accessory: HMAccessory, completion: (arg1: NSError) => void): void;
	assignAccessoryToRoomCompletionHandler(accessory: HMAccessory, room: HMRoom, completion: (arg1: NSError) => void): void;
	servicesWithTypes(serviceTypes: NSArray): NSArray;
	unblockAccessoryCompletionHandler(accessory: HMAccessory, completion: (arg1: NSError) => void): void;
	addUserWithCompletionHandler(completion: (arg1: HMUser, arg2: NSError) => void): void;
	removeUserCompletionHandler(user: HMUser, completion: (arg1: NSError) => void): void;
	addRoomWithNameCompletionHandler(roomName: string, completion: (arg1: HMRoom, arg2: NSError) => void): void;
	removeRoomCompletionHandler(room: HMRoom, completion: (arg1: NSError) => void): void;
	roomForEntireHome(): HMRoom;
	addZoneWithNameCompletionHandler(zoneName: string, completion: (arg1: HMZone, arg2: NSError) => void): void;
	removeZoneCompletionHandler(zone: HMZone, completion: (arg1: NSError) => void): void;
	addServiceGroupWithNameCompletionHandler(serviceGroupName: string, completion: (arg1: HMServiceGroup, arg2: NSError) => void): void;
	removeServiceGroupCompletionHandler(group: HMServiceGroup, completion: (arg1: NSError) => void): void;
	addActionSetWithNameCompletionHandler(actionSetName: string, completion: (arg1: HMActionSet, arg2: NSError) => void): void;
	removeActionSetCompletionHandler(actionSet: HMActionSet, completion: (arg1: NSError) => void): void;
	executeActionSetCompletionHandler(actionSet: HMActionSet, completion: (arg1: NSError) => void): void;
	addTriggerCompletionHandler(trigger: HMTrigger, completion: (arg1: NSError) => void): void;
	removeTriggerCompletionHandler(trigger: HMTrigger, completion: (arg1: NSError) => void): void;
	init(): HMHome;
	static new(): HMHome;
	static allocWithZone(zone: any): HMHome;
	static alloc(): HMHome;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMRoom extends NSObject {
	name: string;
	accessories: NSArray;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	init(): HMRoom;
	static new(): HMRoom;
	static allocWithZone(zone: any): HMRoom;
	static alloc(): HMRoom;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMZone extends NSObject {
	name: string;
	rooms: NSArray;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	addRoomCompletionHandler(room: HMRoom, completion: (arg1: NSError) => void): void;
	removeRoomCompletionHandler(room: HMRoom, completion: (arg1: NSError) => void): void;
	init(): HMZone;
	static new(): HMZone;
	static allocWithZone(zone: any): HMZone;
	static alloc(): HMZone;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMServiceGroup extends NSObject {
	name: string;
	services: NSArray;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	addServiceCompletionHandler(service: HMService, completion: (arg1: NSError) => void): void;
	removeServiceCompletionHandler(service: HMService, completion: (arg1: NSError) => void): void;
	init(): HMServiceGroup;
	static new(): HMServiceGroup;
	static allocWithZone(zone: any): HMServiceGroup;
	static alloc(): HMServiceGroup;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMAccessory extends NSObject {
	name: string;
	identifier: NSUUID;
	delegate: any;
	reachable: boolean;
	bridged: boolean;
	identifiersForBridgedAccessories: NSArray;
	room: HMRoom;
	services: NSArray;
	blocked: boolean;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	identifyWithCompletionHandler(completion: (arg1: NSError) => void): void;
	init(): HMAccessory;
	static new(): HMAccessory;
	static allocWithZone(zone: any): HMAccessory;
	static alloc(): HMAccessory;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMService extends NSObject {
	accessory: HMAccessory;
	serviceType: string;
	name: string;
	associatedServiceType: string;
	characteristics: NSArray;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	updateAssociatedServiceTypeCompletionHandler(serviceType: string, completion: (arg1: NSError) => void): void;
	init(): HMService;
	static new(): HMService;
	static allocWithZone(zone: any): HMService;
	static alloc(): HMService;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMCharacteristic extends NSObject {
	characteristicType: string;
	service: HMService;
	properties: NSArray;
	metadata: HMCharacteristicMetadata;
	value: any;
	notificationEnabled: boolean;
	constructor();
	writeValueCompletionHandler(value: any, completion: (arg1: NSError) => void): void;
	readValueWithCompletionHandler(completion: (arg1: NSError) => void): void;
	enableNotificationCompletionHandler(enable: boolean, completion: (arg1: NSError) => void): void;
	updateAuthorizationDataCompletionHandler(data: NSData, completion: (arg1: NSError) => void): void;
	init(): HMCharacteristic;
	static new(): HMCharacteristic;
	static allocWithZone(zone: any): HMCharacteristic;
	static alloc(): HMCharacteristic;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMCharacteristicMetadata extends NSObject {
	minimumValue: NSNumber;
	maximumValue: NSNumber;
	stepValue: NSNumber;
	maxLength: NSNumber;
	format: string;
	units: string;
	manufacturerDescription: string;
	constructor();
	init(): HMCharacteristicMetadata;
	static new(): HMCharacteristicMetadata;
	static allocWithZone(zone: any): HMCharacteristicMetadata;
	static alloc(): HMCharacteristicMetadata;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMAction extends NSObject {
	constructor();
	init(): HMAction;
	static new(): HMAction;
	static allocWithZone(zone: any): HMAction;
	static alloc(): HMAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMCharacteristicWriteAction extends HMAction {
	characteristic: HMCharacteristic;
	targetValue: any;
	constructor(characteristic: HMCharacteristic, targetValue: any);
	constructor();
	initWithCharacteristicTargetValue(characteristic: HMCharacteristic, targetValue: any): HMCharacteristicWriteAction;
	updateTargetValueCompletionHandler(targetValue: any, completion: (arg1: NSError) => void): void;
	init(): HMCharacteristicWriteAction;
	static new(): HMCharacteristicWriteAction;
	static allocWithZone(zone: any): HMCharacteristicWriteAction;
	static alloc(): HMCharacteristicWriteAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMActionSet extends NSObject {
	name: string;
	actions: NSSet;
	executing: boolean;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	addActionCompletionHandler(action: HMAction, completion: (arg1: NSError) => void): void;
	removeActionCompletionHandler(action: HMAction, completion: (arg1: NSError) => void): void;
	init(): HMActionSet;
	static new(): HMActionSet;
	static allocWithZone(zone: any): HMActionSet;
	static alloc(): HMActionSet;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMTrigger extends NSObject {
	name: string;
	enabled: boolean;
	actionSets: NSArray;
	lastFireDate: NSDate;
	constructor();
	updateNameCompletionHandler(name: string, completion: (arg1: NSError) => void): void;
	addActionSetCompletionHandler(actionSet: HMActionSet, completion: (arg1: NSError) => void): void;
	removeActionSetCompletionHandler(actionSet: HMActionSet, completion: (arg1: NSError) => void): void;
	enableCompletionHandler(enable: boolean, completion: (arg1: NSError) => void): void;
	init(): HMTrigger;
	static new(): HMTrigger;
	static allocWithZone(zone: any): HMTrigger;
	static alloc(): HMTrigger;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMTimerTrigger extends HMTrigger {
	fireDate: NSDate;
	timeZone: NSTimeZone;
	recurrence: NSDateComponents;
	recurrenceCalendar: NSCalendar;
	constructor(name: string, fireDate: NSDate, timeZone: NSTimeZone, recurrence: NSDateComponents, recurrenceCalendar: NSCalendar);
	constructor();
	initWithNameFireDateTimeZoneRecurrenceRecurrenceCalendar(name: string, fireDate: NSDate, timeZone: NSTimeZone, recurrence: NSDateComponents, recurrenceCalendar: NSCalendar): HMTimerTrigger;
	updateFireDateCompletionHandler(fireDate: NSDate, completion: (arg1: NSError) => void): void;
	updateTimeZoneCompletionHandler(timeZone: NSTimeZone, completion: (arg1: NSError) => void): void;
	updateRecurrenceCompletionHandler(recurrence: NSDateComponents, completion: (arg1: NSError) => void): void;
	init(): HMTimerTrigger;
	static new(): HMTimerTrigger;
	static allocWithZone(zone: any): HMTimerTrigger;
	static alloc(): HMTimerTrigger;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class HMUser extends NSObject {
	name: string;
	constructor();
	init(): HMUser;
	static new(): HMUser;
	static allocWithZone(zone: any): HMUser;
	static alloc(): HMUser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPContentItem extends NSObject {
	identifier: string;
	title: string;
	subtitle: string;
	artwork: MPMediaItemArtwork;
	container: boolean;
	playable: boolean;
	playbackProgress: number;
	constructor(identifier: string);
	constructor();
	initWithIdentifier(identifier: string): MPContentItem;
	init(): MPContentItem;
	static new(): MPContentItem;
	static allocWithZone(zone: any): MPContentItem;
	static alloc(): MPContentItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaEntity extends NSObject implements NSSecureCoding {
	persistentID: number;
	constructor();
	static canFilterByProperty(property: string): boolean;
	enumerateValuesForPropertiesUsingBlock(properties: NSSet, block: (arg1: string, arg2: any, arg3: any) => void): void;
	objectForKeyedSubscript(key: any): any;
	valueForProperty(property: string): any;
	init(): MPMediaEntity;
	static new(): MPMediaEntity;
	static allocWithZone(zone: any): MPMediaEntity;
	static alloc(): MPMediaEntity;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class MPMediaItem extends MPMediaEntity {
	mediaType: number;
	title: string;
	albumTitle: string;
	albumPersistentID: number;
	artist: string;
	artistPersistentID: number;
	albumArtist: string;
	albumArtistPersistentID: number;
	genre: string;
	genrePersistentID: number;
	composer: string;
	composerPersistentID: number;
	playbackDuration: number;
	albumTrackNumber: number;
	albumTrackCount: number;
	discNumber: number;
	discCount: number;
	artwork: MPMediaItemArtwork;
	lyrics: string;
	compilation: boolean;
	releaseDate: NSDate;
	beatsPerMinute: number;
	comments: string;
	assetURL: NSURL;
	cloudItem: boolean;
	podcastTitle: string;
	podcastPersistentID: number;
	playCount: number;
	skipCount: number;
	rating: number;
	lastPlayedDate: NSDate;
	userGrouping: string;
	bookmarkTime: number;
	constructor();
	static persistentIDPropertyForGroupingType(groupingType: number): string;
	static titlePropertyForGroupingType(groupingType: number): string;
	init(): MPMediaItem;
	static new(): MPMediaItem;
	static allocWithZone(zone: any): MPMediaItem;
	static alloc(): MPMediaItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaItemArtwork extends NSObject {
	bounds: CGRect;
	imageCropRect: CGRect;
	constructor(image: UIImage);
	constructor();
	initWithImage(image: UIImage): MPMediaItemArtwork;
	imageWithSize(size: CGSize): UIImage;
	init(): MPMediaItemArtwork;
	static new(): MPMediaItemArtwork;
	static allocWithZone(zone: any): MPMediaItemArtwork;
	static alloc(): MPMediaItemArtwork;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaItemCollection extends MPMediaEntity {
	items: NSArray;
	representativeItem: MPMediaItem;
	count: number;
	mediaTypes: number;
	constructor(items: NSArray);
	constructor();
	static collectionWithItems(items: NSArray): MPMediaItemCollection;
	initWithItems(items: NSArray): MPMediaItemCollection;
	init(): MPMediaItemCollection;
	static new(): MPMediaItemCollection;
	static allocWithZone(zone: any): MPMediaItemCollection;
	static alloc(): MPMediaItemCollection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaLibrary extends NSObject implements NSSecureCoding {
	lastModifiedDate: NSDate;
	constructor();
	static defaultMediaLibrary(): MPMediaLibrary;
	beginGeneratingLibraryChangeNotifications(): void;
	endGeneratingLibraryChangeNotifications(): void;
	init(): MPMediaLibrary;
	static new(): MPMediaLibrary;
	static allocWithZone(zone: any): MPMediaLibrary;
	static alloc(): MPMediaLibrary;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class MPMediaPickerController extends UIViewController {
	mediaTypes: number;
	delegate: any;
	allowsPickingMultipleItems: boolean;
	showsCloudItems: boolean;
	prompt: string;
	constructor(mediaTypes: number);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithMediaTypes(mediaTypes: number): MPMediaPickerController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): MPMediaPickerController;
	init(): MPMediaPickerController;
	static new(): MPMediaPickerController;
	static allocWithZone(zone: any): MPMediaPickerController;
	static alloc(): MPMediaPickerController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaPlaylist extends MPMediaItemCollection {
	name: string;
	playlistAttributes: number;
	seedItems: NSArray;
	constructor(items: NSArray);
	constructor();
	initWithItems(items: NSArray): MPMediaPlaylist;
	init(): MPMediaPlaylist;
	static new(): MPMediaPlaylist;
	static allocWithZone(zone: any): MPMediaPlaylist;
	static alloc(): MPMediaPlaylist;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaQuery extends NSObject implements NSSecureCoding, NSCopying {
	filterPredicates: NSSet;
	items: NSArray;
	collections: NSArray;
	groupingType: number;
	itemSections: NSArray;
	collectionSections: NSArray;
	constructor(filterPredicates: NSSet);
	constructor();
	initWithFilterPredicates(filterPredicates: NSSet): MPMediaQuery;
	addFilterPredicate(predicate: MPMediaPredicate): void;
	removeFilterPredicate(predicate: MPMediaPredicate): void;
	static albumsQuery(): MPMediaQuery;
	static artistsQuery(): MPMediaQuery;
	static songsQuery(): MPMediaQuery;
	static playlistsQuery(): MPMediaQuery;
	static podcastsQuery(): MPMediaQuery;
	static audiobooksQuery(): MPMediaQuery;
	static compilationsQuery(): MPMediaQuery;
	static composersQuery(): MPMediaQuery;
	static genresQuery(): MPMediaQuery;
	init(): MPMediaQuery;
	static new(): MPMediaQuery;
	static allocWithZone(zone: any): MPMediaQuery;
	static alloc(): MPMediaQuery;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class MPMediaPredicate extends NSObject implements NSSecureCoding {
	constructor();
	init(): MPMediaPredicate;
	static new(): MPMediaPredicate;
	static allocWithZone(zone: any): MPMediaPredicate;
	static alloc(): MPMediaPredicate;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class MPMediaPropertyPredicate extends MPMediaPredicate {
	property: string;
	value: any;
	comparisonType: number;
	constructor();
	static predicateWithValueForProperty(value: any, property: string): MPMediaPropertyPredicate;
	static predicateWithValueForPropertyComparisonType(value: any, property: string, comparisonType: number): MPMediaPropertyPredicate;
	init(): MPMediaPropertyPredicate;
	static new(): MPMediaPropertyPredicate;
	static allocWithZone(zone: any): MPMediaPropertyPredicate;
	static alloc(): MPMediaPropertyPredicate;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMediaQuerySection extends NSObject implements NSSecureCoding, NSCopying {
	title: string;
	range: NSRange;
	constructor();
	init(): MPMediaQuerySection;
	static new(): MPMediaQuerySection;
	static allocWithZone(zone: any): MPMediaQuerySection;
	static alloc(): MPMediaQuerySection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class MPMoviePlayerController extends NSObject implements MPMediaPlayback {
	contentURL: NSURL;
	view: UIView;
	backgroundView: UIView;
	playbackState: number;
	loadState: number;
	controlStyle: number;
	repeatMode: number;
	shouldAutoplay: boolean;
	fullscreen: boolean;
	scalingMode: number;
	readyForDisplay: boolean;
	movieMediaTypes: number;
	movieSourceType: number;
	duration: number;
	playableDuration: number;
	naturalSize: CGSize;
	initialPlaybackTime: number;
	endPlaybackTime: number;
	allowsAirPlay: boolean;
	airPlayVideoActive: boolean;
	timedMetadata: NSArray;
	accessLog: MPMovieAccessLog;
	errorLog: MPMovieErrorLog;
	useApplicationAudioSession: boolean;
	isPreparedToPlay: boolean;
	currentPlaybackTime: number;
	currentPlaybackRate: number;
	constructor(url: NSURL);
	constructor();
	initWithContentURL(url: NSURL): MPMoviePlayerController;
	setFullscreenAnimated(fullscreen: boolean, animated: boolean): void;
	thumbnailImageAtTimeTimeOption(playbackTime: number, option: number): UIImage;
	requestThumbnailImagesAtTimesTimeOption(playbackTimes: NSArray, option: number): void;
	cancelAllThumbnailImageRequests(): void;
	static preparePrerollAds(): void;
	playPrerollAdWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	cancelPreroll(): void;
	init(): MPMoviePlayerController;
	static new(): MPMoviePlayerController;
	static allocWithZone(zone: any): MPMoviePlayerController;
	static alloc(): MPMoviePlayerController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	prepareToPlay(): void;
	play(): void;
	pause(): void;
	stop(): void;
	beginSeekingForward(): void;
	beginSeekingBackward(): void;
	endSeeking(): void;
}
declare class MPTimedMetadata extends NSObject {
	key: string;
	keyspace: string;
	value: any;
	timestamp: number;
	allMetadata: NSDictionary;
	constructor();
	init(): MPTimedMetadata;
	static new(): MPTimedMetadata;
	static allocWithZone(zone: any): MPTimedMetadata;
	static alloc(): MPTimedMetadata;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMovieAccessLog extends NSObject implements NSCopying {
	extendedLogData: NSData;
	extendedLogDataStringEncoding: number;
	events: NSArray;
	constructor();
	init(): MPMovieAccessLog;
	static new(): MPMovieAccessLog;
	static allocWithZone(zone: any): MPMovieAccessLog;
	static alloc(): MPMovieAccessLog;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MPMovieErrorLog extends NSObject implements NSCopying {
	extendedLogData: NSData;
	extendedLogDataStringEncoding: number;
	events: NSArray;
	constructor();
	init(): MPMovieErrorLog;
	static new(): MPMovieErrorLog;
	static allocWithZone(zone: any): MPMovieErrorLog;
	static alloc(): MPMovieErrorLog;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MPMovieAccessLogEvent extends NSObject implements NSCopying {
	numberOfSegmentsDownloaded: number;
	playbackStartDate: NSDate;
	URI: string;
	serverAddress: string;
	numberOfServerAddressChanges: number;
	playbackSessionID: string;
	playbackStartOffset: number;
	segmentsDownloadedDuration: number;
	durationWatched: number;
	numberOfStalls: number;
	numberOfBytesTransferred: number;
	observedBitrate: number;
	indicatedBitrate: number;
	numberOfDroppedVideoFrames: number;
	constructor();
	init(): MPMovieAccessLogEvent;
	static new(): MPMovieAccessLogEvent;
	static allocWithZone(zone: any): MPMovieAccessLogEvent;
	static alloc(): MPMovieAccessLogEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MPMovieErrorLogEvent extends NSObject implements NSCopying {
	date: NSDate;
	URI: string;
	serverAddress: string;
	playbackSessionID: string;
	errorStatusCode: number;
	errorDomain: string;
	errorComment: string;
	constructor();
	init(): MPMovieErrorLogEvent;
	static new(): MPMovieErrorLogEvent;
	static allocWithZone(zone: any): MPMovieErrorLogEvent;
	static alloc(): MPMovieErrorLogEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MPMoviePlayerViewController extends UIViewController {
	moviePlayer: MPMoviePlayerController;
	constructor(contentURL: NSURL);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithContentURL(contentURL: NSURL): MPMoviePlayerViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): MPMoviePlayerViewController;
	init(): MPMoviePlayerViewController;
	static new(): MPMoviePlayerViewController;
	static allocWithZone(zone: any): MPMoviePlayerViewController;
	static alloc(): MPMoviePlayerViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPMusicPlayerController extends NSObject implements MPMediaPlayback {
	playbackState: number;
	repeatMode: number;
	shuffleMode: number;
	volume: number;
	nowPlayingItem: MPMediaItem;
	indexOfNowPlayingItem: number;
	isPreparedToPlay: boolean;
	currentPlaybackTime: number;
	currentPlaybackRate: number;
	constructor();
	static applicationMusicPlayer(): MPMusicPlayerController;
	static systemMusicPlayer(): MPMusicPlayerController;
	static iPodMusicPlayer(): MPMusicPlayerController;
	setQueueWithQuery(query: MPMediaQuery): void;
	setQueueWithItemCollection(itemCollection: MPMediaItemCollection): void;
	skipToNextItem(): void;
	skipToBeginning(): void;
	skipToPreviousItem(): void;
	beginGeneratingPlaybackNotifications(): void;
	endGeneratingPlaybackNotifications(): void;
	init(): MPMusicPlayerController;
	static new(): MPMusicPlayerController;
	static allocWithZone(zone: any): MPMusicPlayerController;
	static alloc(): MPMusicPlayerController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	prepareToPlay(): void;
	play(): void;
	pause(): void;
	stop(): void;
	beginSeekingForward(): void;
	beginSeekingBackward(): void;
	endSeeking(): void;
}
declare class MPNowPlayingInfoCenter extends NSObject {
	nowPlayingInfo: NSDictionary;
	constructor();
	static defaultCenter(): MPNowPlayingInfoCenter;
	init(): MPNowPlayingInfoCenter;
	static new(): MPNowPlayingInfoCenter;
	static allocWithZone(zone: any): MPNowPlayingInfoCenter;
	static alloc(): MPNowPlayingInfoCenter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPPlayableContentManager extends NSObject {
	dataSource: any;
	delegate: any;
	constructor();
	static sharedContentManager(): MPPlayableContentManager;
	reloadData(): void;
	beginUpdates(): void;
	endUpdates(): void;
	init(): MPPlayableContentManager;
	static new(): MPPlayableContentManager;
	static allocWithZone(zone: any): MPPlayableContentManager;
	static alloc(): MPPlayableContentManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPRemoteCommand extends NSObject {
	enabled: boolean;
	constructor();
	addTargetAction(target: any, action: any): void;
	removeTargetAction(target: any, action: any): void;
	removeTarget(target: any): void;
	addTargetWithHandler(handler: (arg1: MPRemoteCommandEvent) => number): any;
	init(): MPRemoteCommand;
	static new(): MPRemoteCommand;
	static allocWithZone(zone: any): MPRemoteCommand;
	static alloc(): MPRemoteCommand;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPSkipIntervalCommand extends MPRemoteCommand {
	preferredIntervals: NSArray;
	constructor();
	init(): MPSkipIntervalCommand;
	static new(): MPSkipIntervalCommand;
	static allocWithZone(zone: any): MPSkipIntervalCommand;
	static alloc(): MPSkipIntervalCommand;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPFeedbackCommand extends MPRemoteCommand {
	active: boolean;
	localizedTitle: string;
	constructor();
	init(): MPFeedbackCommand;
	static new(): MPFeedbackCommand;
	static allocWithZone(zone: any): MPFeedbackCommand;
	static alloc(): MPFeedbackCommand;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPRatingCommand extends MPRemoteCommand {
	minimumRating: number;
	maximumRating: number;
	constructor();
	init(): MPRatingCommand;
	static new(): MPRatingCommand;
	static allocWithZone(zone: any): MPRatingCommand;
	static alloc(): MPRatingCommand;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPChangePlaybackRateCommand extends MPRemoteCommand {
	supportedPlaybackRates: NSArray;
	constructor();
	init(): MPChangePlaybackRateCommand;
	static new(): MPChangePlaybackRateCommand;
	static allocWithZone(zone: any): MPChangePlaybackRateCommand;
	static alloc(): MPChangePlaybackRateCommand;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPRemoteCommandCenter extends NSObject {
	pauseCommand: MPRemoteCommand;
	playCommand: MPRemoteCommand;
	stopCommand: MPRemoteCommand;
	togglePlayPauseCommand: MPRemoteCommand;
	nextTrackCommand: MPRemoteCommand;
	previousTrackCommand: MPRemoteCommand;
	skipForwardCommand: MPSkipIntervalCommand;
	skipBackwardCommand: MPSkipIntervalCommand;
	seekForwardCommand: MPRemoteCommand;
	seekBackwardCommand: MPRemoteCommand;
	ratingCommand: MPRatingCommand;
	changePlaybackRateCommand: MPChangePlaybackRateCommand;
	likeCommand: MPFeedbackCommand;
	dislikeCommand: MPFeedbackCommand;
	bookmarkCommand: MPFeedbackCommand;
	constructor();
	static sharedCommandCenter(): MPRemoteCommandCenter;
	init(): MPRemoteCommandCenter;
	static new(): MPRemoteCommandCenter;
	static allocWithZone(zone: any): MPRemoteCommandCenter;
	static alloc(): MPRemoteCommandCenter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPRemoteCommandEvent extends NSObject {
	command: MPRemoteCommand;
	timestamp: number;
	constructor();
	init(): MPRemoteCommandEvent;
	static new(): MPRemoteCommandEvent;
	static allocWithZone(zone: any): MPRemoteCommandEvent;
	static alloc(): MPRemoteCommandEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPSkipIntervalCommandEvent extends MPRemoteCommandEvent {
	interval: number;
	constructor();
	init(): MPSkipIntervalCommandEvent;
	static new(): MPSkipIntervalCommandEvent;
	static allocWithZone(zone: any): MPSkipIntervalCommandEvent;
	static alloc(): MPSkipIntervalCommandEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPSeekCommandEvent extends MPRemoteCommandEvent {
	type: number;
	constructor();
	init(): MPSeekCommandEvent;
	static new(): MPSeekCommandEvent;
	static allocWithZone(zone: any): MPSeekCommandEvent;
	static alloc(): MPSeekCommandEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPRatingCommandEvent extends MPRemoteCommandEvent {
	rating: number;
	constructor();
	init(): MPRatingCommandEvent;
	static new(): MPRatingCommandEvent;
	static allocWithZone(zone: any): MPRatingCommandEvent;
	static alloc(): MPRatingCommandEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPChangePlaybackRateCommandEvent extends MPRemoteCommandEvent {
	playbackRate: number;
	constructor();
	init(): MPChangePlaybackRateCommandEvent;
	static new(): MPChangePlaybackRateCommandEvent;
	static allocWithZone(zone: any): MPChangePlaybackRateCommandEvent;
	static alloc(): MPChangePlaybackRateCommandEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPFeedbackCommandEvent extends MPRemoteCommandEvent {
	negative: boolean;
	constructor();
	init(): MPFeedbackCommandEvent;
	static new(): MPFeedbackCommandEvent;
	static allocWithZone(zone: any): MPFeedbackCommandEvent;
	static alloc(): MPFeedbackCommandEvent;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MPVolumeView extends UIView implements NSCoding {
	showsVolumeSlider: boolean;
	showsRouteButton: boolean;
	wirelessRoutesAvailable: boolean;
	wirelessRouteActive: boolean;
	volumeWarningSliderImage: UIImage;
	constructor(frame: CGRect);
	constructor();
	setMinimumVolumeSliderImageForState(image: UIImage, state: number): void;
	setMaximumVolumeSliderImageForState(image: UIImage, state: number): void;
	setVolumeThumbImageForState(image: UIImage, state: number): void;
	minimumVolumeSliderImageForState(state: number): UIImage;
	maximumVolumeSliderImageForState(state: number): UIImage;
	volumeThumbImageForState(state: number): UIImage;
	volumeSliderRectForBounds(bounds: CGRect): CGRect;
	volumeThumbRectForBoundsVolumeSliderRectValue(bounds: CGRect, rect: CGRect, value: number): CGRect;
	setRouteButtonImageForState(image: UIImage, state: number): void;
	routeButtonImageForState(state: number): UIImage;
	routeButtonRectForBounds(bounds: CGRect): CGRect;
	initWithFrame(frame: CGRect): MPVolumeView;
	init(): MPVolumeView;
	static new(): MPVolumeView;
	static allocWithZone(zone: any): MPVolumeView;
	static alloc(): MPVolumeView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class JSContext extends NSObject {
	globalObject: JSValue;
	exception: JSValue;
	exceptionHandler: (arg1: JSContext, arg2: JSValue) => void;
	virtualMachine: JSVirtualMachine;
	name: string;
	JSGlobalContextRef: any;
	constructor(virtualMachine: JSVirtualMachine);
	constructor();
	initWithVirtualMachine(virtualMachine: JSVirtualMachine): JSContext;
	evaluateScript(script: string): JSValue;
	evaluateScriptWithSourceURL(script: string, sourceURL: NSURL): JSValue;
	static currentContext(): JSContext;
	static currentCallee(): JSValue;
	static currentThis(): JSValue;
	static currentArguments(): NSArray;
	objectForKeyedSubscript(key: any): JSValue;
	setObjectForKeyedSubscript(object: any, key: NSObject): void;
	static contextWithJSGlobalContextRef(jsGlobalContextRef: any): JSContext;
	init(): JSContext;
	static new(): JSContext;
	static allocWithZone(zone: any): JSContext;
	static alloc(): JSContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class JSValue extends NSObject {
	context: JSContext;
	JSValueRef: any;
	constructor();
	static valueWithObjectInContext(value: any, context: JSContext): JSValue;
	static valueWithBoolInContext(value: boolean, context: JSContext): JSValue;
	static valueWithDoubleInContext(value: number, context: JSContext): JSValue;
	static valueWithInt32InContext(value: number, context: JSContext): JSValue;
	static valueWithUInt32InContext(value: number, context: JSContext): JSValue;
	static valueWithNewObjectInContext(context: JSContext): JSValue;
	static valueWithNewArrayInContext(context: JSContext): JSValue;
	static valueWithNewRegularExpressionFromPatternFlagsInContext(pattern: string, flags: string, context: JSContext): JSValue;
	static valueWithNewErrorFromMessageInContext(message: string, context: JSContext): JSValue;
	static valueWithNullInContext(context: JSContext): JSValue;
	static valueWithUndefinedInContext(context: JSContext): JSValue;
	toObject(): any;
	toObjectOfClass(expectedClass: any): any;
	toBool(): boolean;
	toDouble(): number;
	toInt32(): number;
	toUInt32(): number;
	toNumber(): NSNumber;
	toString(): string;
	toDate(): NSDate;
	toArray(): NSArray;
	toDictionary(): NSDictionary;
	valueForProperty(property: string): JSValue;
	setValueForProperty(value: any, property: string): void;
	deleteProperty(property: string): boolean;
	hasProperty(property: string): boolean;
	definePropertyDescriptor(property: string, descriptor: any): void;
	valueAtIndex(index: number): JSValue;
	setValueAtIndex(value: any, index: number): void;
	isUndefined(): boolean;
	isNull(): boolean;
	isBoolean(): boolean;
	isNumber(): boolean;
	isString(): boolean;
	isObject(): boolean;
	isEqualToObject(value: any): boolean;
	isEqualWithTypeCoercionToObject(value: any): boolean;
	isInstanceOf(value: any): boolean;
	callWithArguments(args: NSArray): JSValue;
	constructWithArguments(args: NSArray): JSValue;
	invokeMethodWithArguments(method: string, args: NSArray): JSValue;
	static valueWithPointInContext(point: CGPoint, context: JSContext): JSValue;
	static valueWithRangeInContext(range: NSRange, context: JSContext): JSValue;
	static valueWithRectInContext(rect: CGRect, context: JSContext): JSValue;
	static valueWithSizeInContext(size: CGSize, context: JSContext): JSValue;
	toPoint(): CGPoint;
	toRange(): NSRange;
	toRect(): CGRect;
	toSize(): CGSize;
	objectForKeyedSubscript(key: any): JSValue;
	objectAtIndexedSubscript(index: number): JSValue;
	setObjectForKeyedSubscript(object: any, key: NSObject): void;
	setObjectAtIndexedSubscript(object: any, index: number): void;
	static valueWithJSValueRefInContext(value: any, context: JSContext): JSValue;
	init(): JSValue;
	static new(): JSValue;
	static allocWithZone(zone: any): JSValue;
	static alloc(): JSValue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class JSManagedValue extends NSObject {
	value: JSValue;
	constructor(value: JSValue);
	constructor();
	static managedValueWithValue(value: JSValue): JSManagedValue;
	static managedValueWithValueAndOwner(value: JSValue, owner: any): JSManagedValue;
	initWithValue(value: JSValue): JSManagedValue;
	init(): JSManagedValue;
	static new(): JSManagedValue;
	static allocWithZone(zone: any): JSManagedValue;
	static alloc(): JSManagedValue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class JSVirtualMachine extends NSObject {
	constructor();
	addManagedReferenceWithOwner(object: any, owner: any): void;
	removeManagedReferenceWithOwner(object: any, owner: any): void;
	init(): JSVirtualMachine;
	static new(): JSVirtualMachine;
	static allocWithZone(zone: any): JSVirtualMachine;
	static alloc(): JSVirtualMachine;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class LAContext extends NSObject {
	localizedFallbackTitle: string;
	constructor();
	canEvaluatePolicyError(policy: number, error: any): boolean;
	evaluatePolicyLocalizedReasonReply(policy: number, localizedReason: string, reply: (arg1: boolean, arg2: NSError) => void): void;
	init(): LAContext;
	static new(): LAContext;
	static allocWithZone(zone: any): LAContext;
	static alloc(): LAContext;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKAnnotationView extends UIView {
	reuseIdentifier: string;
	annotation: any;
	image: UIImage;
	centerOffset: CGPoint;
	calloutOffset: CGPoint;
	enabled: boolean;
	highlighted: boolean;
	selected: boolean;
	canShowCallout: boolean;
	leftCalloutAccessoryView: UIView;
	rightCalloutAccessoryView: UIView;
	draggable: boolean;
	dragState: number;
	constructor(annotation: any, reuseIdentifier: string);
	constructor(frame: CGRect);
	constructor();
	initWithAnnotationReuseIdentifier(annotation: any, reuseIdentifier: string): MKAnnotationView;
	prepareForReuse(): void;
	setSelectedAnimated(selected: boolean, animated: boolean): void;
	setDragStateAnimated(newDragState: number, animated: boolean): void;
	initWithFrame(frame: CGRect): MKAnnotationView;
	init(): MKAnnotationView;
	static new(): MKAnnotationView;
	static allocWithZone(zone: any): MKAnnotationView;
	static alloc(): MKAnnotationView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKDistanceFormatter extends NSFormatter {
	locale: NSLocale;
	units: number;
	unitStyle: number;
	constructor();
	stringFromDistance(distance: number): string;
	distanceFromString(distance: string): number;
	init(): MKDistanceFormatter;
	static new(): MKDistanceFormatter;
	static allocWithZone(zone: any): MKDistanceFormatter;
	static alloc(): MKDistanceFormatter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKPlacemark extends CLPlacemark implements MKAnnotation {
	countryCode: string;
	coordinate: CLLocationCoordinate2D;
	title: string;
	subtitle: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(coordinate: CLLocationCoordinate2D, addressDictionary: NSDictionary);
	constructor(placemark: CLPlacemark);
	constructor();
	initWithCoordinateAddressDictionary(coordinate: CLLocationCoordinate2D, addressDictionary: NSDictionary): MKPlacemark;
	initWithPlacemark(placemark: CLPlacemark): MKPlacemark;
	init(): MKPlacemark;
	static new(): MKPlacemark;
	static allocWithZone(zone: any): MKPlacemark;
	static alloc(): MKPlacemark;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKMapItem extends NSObject {
	placemark: MKPlacemark;
	isCurrentLocation: boolean;
	name: string;
	phoneNumber: string;
	url: NSURL;
	constructor(placemark: MKPlacemark);
	constructor();
	static mapItemForCurrentLocation(): MKMapItem;
	initWithPlacemark(placemark: MKPlacemark): MKMapItem;
	openInMapsWithLaunchOptions(launchOptions: NSDictionary): boolean;
	static openMapsWithItemsLaunchOptions(mapItems: NSArray, launchOptions: NSDictionary): boolean;
	init(): MKMapItem;
	static new(): MKMapItem;
	static allocWithZone(zone: any): MKMapItem;
	static alloc(): MKMapItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKOverlayRenderer extends NSObject {
	overlay: any;
	alpha: number;
	contentScaleFactor: number;
	constructor(overlay: any);
	constructor();
	initWithOverlay(overlay: any): MKOverlayRenderer;
	pointForMapPoint(mapPoint: MKMapPoint): CGPoint;
	mapPointForPoint(point: CGPoint): MKMapPoint;
	rectForMapRect(mapRect: MKMapRect): CGRect;
	mapRectForRect(rect: CGRect): MKMapRect;
	canDrawMapRectZoomScale(mapRect: MKMapRect, zoomScale: number): boolean;
	drawMapRectZoomScaleInContext(mapRect: MKMapRect, zoomScale: number, context: any): void;
	setNeedsDisplay(): void;
	setNeedsDisplayInMapRect(mapRect: MKMapRect): void;
	setNeedsDisplayInMapRectZoomScale(mapRect: MKMapRect, zoomScale: number): void;
	init(): MKOverlayRenderer;
	static new(): MKOverlayRenderer;
	static allocWithZone(zone: any): MKOverlayRenderer;
	static alloc(): MKOverlayRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKOverlayView extends UIView {
	overlay: any;
	constructor(overlay: any);
	constructor(frame: CGRect);
	constructor();
	initWithOverlay(overlay: any): MKOverlayView;
	pointForMapPoint(mapPoint: MKMapPoint): CGPoint;
	mapPointForPoint(point: CGPoint): MKMapPoint;
	rectForMapRect(mapRect: MKMapRect): CGRect;
	mapRectForRect(rect: CGRect): MKMapRect;
	canDrawMapRectZoomScale(mapRect: MKMapRect, zoomScale: number): boolean;
	drawMapRectZoomScaleInContext(mapRect: MKMapRect, zoomScale: number, context: any): void;
	setNeedsDisplayInMapRect(mapRect: MKMapRect): void;
	setNeedsDisplayInMapRectZoomScale(mapRect: MKMapRect, zoomScale: number): void;
	initWithFrame(frame: CGRect): MKOverlayView;
	init(): MKOverlayView;
	static new(): MKOverlayView;
	static allocWithZone(zone: any): MKOverlayView;
	static alloc(): MKOverlayView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKMapView extends UIView implements NSCoding {
	delegate: any;
	mapType: number;
	region: MKCoordinateRegion;
	centerCoordinate: CLLocationCoordinate2D;
	visibleMapRect: MKMapRect;
	camera: MKMapCamera;
	zoomEnabled: boolean;
	scrollEnabled: boolean;
	rotateEnabled: boolean;
	pitchEnabled: boolean;
	showsPointsOfInterest: boolean;
	showsBuildings: boolean;
	showsUserLocation: boolean;
	userLocation: MKUserLocation;
	userTrackingMode: number;
	userLocationVisible: boolean;
	annotations: NSArray;
	selectedAnnotations: NSArray;
	annotationVisibleRect: CGRect;
	overlays: NSArray;
	constructor(frame: CGRect);
	constructor();
	setRegionAnimated(region: MKCoordinateRegion, animated: boolean): void;
	setCenterCoordinateAnimated(coordinate: CLLocationCoordinate2D, animated: boolean): void;
	regionThatFits(region: MKCoordinateRegion): MKCoordinateRegion;
	setVisibleMapRectAnimated(mapRect: MKMapRect, animate: boolean): void;
	mapRectThatFits(mapRect: MKMapRect): MKMapRect;
	setVisibleMapRectEdgePaddingAnimated(mapRect: MKMapRect, insets: UIEdgeInsets, animate: boolean): void;
	mapRectThatFitsEdgePadding(mapRect: MKMapRect, insets: UIEdgeInsets): MKMapRect;
	setCameraAnimated(camera: MKMapCamera, animated: boolean): void;
	convertCoordinateToPointToView(coordinate: CLLocationCoordinate2D, view: UIView): CGPoint;
	convertPointToCoordinateFromView(point: CGPoint, view: UIView): CLLocationCoordinate2D;
	convertRegionToRectToView(region: MKCoordinateRegion, view: UIView): CGRect;
	convertRectToRegionFromView(rect: CGRect, view: UIView): MKCoordinateRegion;
	setUserTrackingModeAnimated(mode: number, animated: boolean): void;
	addAnnotation(annotation: any): void;
	addAnnotations(annotations: NSArray): void;
	removeAnnotation(annotation: any): void;
	removeAnnotations(annotations: NSArray): void;
	annotationsInMapRect(mapRect: MKMapRect): NSSet;
	viewForAnnotation(annotation: any): MKAnnotationView;
	dequeueReusableAnnotationViewWithIdentifier(identifier: string): MKAnnotationView;
	selectAnnotationAnimated(annotation: any, animated: boolean): void;
	deselectAnnotationAnimated(annotation: any, animated: boolean): void;
	showAnnotationsAnimated(annotations: NSArray, animated: boolean): void;
	addOverlayLevel(overlay: any, level: number): void;
	addOverlaysLevel(overlays: NSArray, level: number): void;
	removeOverlay(overlay: any): void;
	removeOverlays(overlays: NSArray): void;
	insertOverlayAtIndexLevel(overlay: any, index: number, level: number): void;
	insertOverlayAboveOverlay(overlay: any, sibling: any): void;
	insertOverlayBelowOverlay(overlay: any, sibling: any): void;
	exchangeOverlayWithOverlay(overlay1: any, overlay2: any): void;
	overlaysInLevel(level: number): NSArray;
	rendererForOverlay(overlay: any): MKOverlayRenderer;
	viewForOverlay(overlay: any): MKOverlayView;
	addOverlay(overlay: any): void;
	addOverlays(overlays: NSArray): void;
	insertOverlayAtIndex(overlay: any, index: number): void;
	exchangeOverlayAtIndexWithOverlayAtIndex(index1: number, index2: number): void;
	initWithFrame(frame: CGRect): MKMapView;
	init(): MKMapView;
	static new(): MKMapView;
	static allocWithZone(zone: any): MKMapView;
	static alloc(): MKMapView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class MKPinAnnotationView extends MKAnnotationView {
	pinColor: number;
	animatesDrop: boolean;
	constructor(annotation: any, reuseIdentifier: string);
	constructor(frame: CGRect);
	constructor();
	initWithAnnotationReuseIdentifier(annotation: any, reuseIdentifier: string): MKPinAnnotationView;
	initWithFrame(frame: CGRect): MKPinAnnotationView;
	init(): MKPinAnnotationView;
	static new(): MKPinAnnotationView;
	static allocWithZone(zone: any): MKPinAnnotationView;
	static alloc(): MKPinAnnotationView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKUserLocation extends NSObject implements MKAnnotation {
	updating: boolean;
	location: CLLocation;
	heading: CLHeading;
	title: string;
	subtitle: string;
	coordinate: CLLocationCoordinate2D;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	init(): MKUserLocation;
	static new(): MKUserLocation;
	static allocWithZone(zone: any): MKUserLocation;
	static alloc(): MKUserLocation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKShape extends NSObject implements MKAnnotation {
	title: string;
	subtitle: string;
	coordinate: CLLocationCoordinate2D;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	init(): MKShape;
	static new(): MKShape;
	static allocWithZone(zone: any): MKShape;
	static alloc(): MKShape;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKPointAnnotation extends MKShape {
	coordinate: CLLocationCoordinate2D;
	constructor();
	init(): MKPointAnnotation;
	static new(): MKPointAnnotation;
	static allocWithZone(zone: any): MKPointAnnotation;
	static alloc(): MKPointAnnotation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKMultiPoint extends MKShape {
	pointCount: number;
	constructor();
	points(): any;
	getCoordinatesRange(coords: any, range: NSRange): void;
	init(): MKMultiPoint;
	static new(): MKMultiPoint;
	static allocWithZone(zone: any): MKMultiPoint;
	static alloc(): MKMultiPoint;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKPolyline extends MKMultiPoint implements MKOverlay {
	boundingMapRect: MKMapRect;
	coordinate: CLLocationCoordinate2D;
	title: string;
	subtitle: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static polylineWithPointsCount(points: any, count: number): MKPolyline;
	static polylineWithCoordinatesCount(coords: any, count: number): MKPolyline;
	init(): MKPolyline;
	static new(): MKPolyline;
	static allocWithZone(zone: any): MKPolyline;
	static alloc(): MKPolyline;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKPolygon extends MKMultiPoint implements MKOverlay {
	interiorPolygons: NSArray;
	boundingMapRect: MKMapRect;
	coordinate: CLLocationCoordinate2D;
	title: string;
	subtitle: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static polygonWithPointsCount(points: any, count: number): MKPolygon;
	static polygonWithPointsCountInteriorPolygons(points: any, count: number, interiorPolygons: NSArray): MKPolygon;
	static polygonWithCoordinatesCount(coords: any, count: number): MKPolygon;
	static polygonWithCoordinatesCountInteriorPolygons(coords: any, count: number, interiorPolygons: NSArray): MKPolygon;
	init(): MKPolygon;
	static new(): MKPolygon;
	static allocWithZone(zone: any): MKPolygon;
	static alloc(): MKPolygon;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKCircle extends MKShape implements MKOverlay {
	radius: number;
	boundingMapRect: MKMapRect;
	coordinate: CLLocationCoordinate2D;
	title: string;
	subtitle: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor();
	static circleWithCenterCoordinateRadius(coord: CLLocationCoordinate2D, radius: number): MKCircle;
	static circleWithMapRect(mapRect: MKMapRect): MKCircle;
	init(): MKCircle;
	static new(): MKCircle;
	static allocWithZone(zone: any): MKCircle;
	static alloc(): MKCircle;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKGeodesicPolyline extends MKPolyline {
	constructor();
	static polylineWithPointsCount(points: any, count: number): MKGeodesicPolyline;
	static polylineWithCoordinatesCount(coords: any, count: number): MKGeodesicPolyline;
	init(): MKGeodesicPolyline;
	static new(): MKGeodesicPolyline;
	static allocWithZone(zone: any): MKGeodesicPolyline;
	static alloc(): MKGeodesicPolyline;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKOverlayPathRenderer extends MKOverlayRenderer {
	fillColor: UIColor;
	strokeColor: UIColor;
	lineWidth: number;
	lineJoin: number;
	lineCap: number;
	miterLimit: number;
	lineDashPhase: number;
	lineDashPattern: NSArray;
	path: any;
	constructor(overlay: any);
	constructor();
	createPath(): void;
	invalidatePath(): void;
	applyStrokePropertiesToContextAtZoomScale(context: any, zoomScale: number): void;
	applyFillPropertiesToContextAtZoomScale(context: any, zoomScale: number): void;
	strokePathInContext(path: any, context: any): void;
	fillPathInContext(path: any, context: any): void;
	initWithOverlay(overlay: any): MKOverlayPathRenderer;
	init(): MKOverlayPathRenderer;
	static new(): MKOverlayPathRenderer;
	static allocWithZone(zone: any): MKOverlayPathRenderer;
	static alloc(): MKOverlayPathRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKPolygonRenderer extends MKOverlayPathRenderer {
	polygon: MKPolygon;
	constructor(polygon: MKPolygon);
	constructor(overlay: any);
	constructor();
	initWithPolygon(polygon: MKPolygon): MKPolygonRenderer;
	initWithOverlay(overlay: any): MKPolygonRenderer;
	init(): MKPolygonRenderer;
	static new(): MKPolygonRenderer;
	static allocWithZone(zone: any): MKPolygonRenderer;
	static alloc(): MKPolygonRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKPolylineRenderer extends MKOverlayPathRenderer {
	polyline: MKPolyline;
	constructor(polyline: MKPolyline);
	constructor(overlay: any);
	constructor();
	initWithPolyline(polyline: MKPolyline): MKPolylineRenderer;
	initWithOverlay(overlay: any): MKPolylineRenderer;
	init(): MKPolylineRenderer;
	static new(): MKPolylineRenderer;
	static allocWithZone(zone: any): MKPolylineRenderer;
	static alloc(): MKPolylineRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKCircleRenderer extends MKOverlayPathRenderer {
	circle: MKCircle;
	constructor(circle: MKCircle);
	constructor(overlay: any);
	constructor();
	initWithCircle(circle: MKCircle): MKCircleRenderer;
	initWithOverlay(overlay: any): MKCircleRenderer;
	init(): MKCircleRenderer;
	static new(): MKCircleRenderer;
	static allocWithZone(zone: any): MKCircleRenderer;
	static alloc(): MKCircleRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKLocalSearch extends NSObject {
	searching: boolean;
	constructor(request: MKLocalSearchRequest);
	constructor();
	initWithRequest(request: MKLocalSearchRequest): MKLocalSearch;
	startWithCompletionHandler(completionHandler: (arg1: MKLocalSearchResponse, arg2: NSError) => void): void;
	cancel(): void;
	init(): MKLocalSearch;
	static new(): MKLocalSearch;
	static allocWithZone(zone: any): MKLocalSearch;
	static alloc(): MKLocalSearch;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKLocalSearchRequest extends NSObject implements NSCopying {
	naturalLanguageQuery: string;
	region: MKCoordinateRegion;
	constructor();
	init(): MKLocalSearchRequest;
	static new(): MKLocalSearchRequest;
	static allocWithZone(zone: any): MKLocalSearchRequest;
	static alloc(): MKLocalSearchRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MKLocalSearchResponse extends NSObject {
	mapItems: NSArray;
	boundingRegion: MKCoordinateRegion;
	constructor();
	init(): MKLocalSearchResponse;
	static new(): MKLocalSearchResponse;
	static allocWithZone(zone: any): MKLocalSearchResponse;
	static alloc(): MKLocalSearchResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKDirectionsRequest extends NSObject {
	transportType: number;
	requestsAlternateRoutes: boolean;
	departureDate: NSDate;
	arrivalDate: NSDate;
	constructor(url: NSURL);
	constructor();
	source(): MKMapItem;
	setSource(source: MKMapItem): void;
	destination(): MKMapItem;
	setDestination(destination: MKMapItem): void;
	initWithContentsOfURL(url: NSURL): MKDirectionsRequest;
	static isDirectionsRequestURL(url: NSURL): boolean;
	init(): MKDirectionsRequest;
	static new(): MKDirectionsRequest;
	static allocWithZone(zone: any): MKDirectionsRequest;
	static alloc(): MKDirectionsRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKDirections extends NSObject {
	calculating: boolean;
	constructor(request: MKDirectionsRequest);
	constructor();
	initWithRequest(request: MKDirectionsRequest): MKDirections;
	calculateDirectionsWithCompletionHandler(completionHandler: (arg1: MKDirectionsResponse, arg2: NSError) => void): void;
	calculateETAWithCompletionHandler(completionHandler: (arg1: MKETAResponse, arg2: NSError) => void): void;
	cancel(): void;
	init(): MKDirections;
	static new(): MKDirections;
	static allocWithZone(zone: any): MKDirections;
	static alloc(): MKDirections;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKDirectionsResponse extends NSObject {
	source: MKMapItem;
	destination: MKMapItem;
	routes: NSArray;
	constructor();
	init(): MKDirectionsResponse;
	static new(): MKDirectionsResponse;
	static allocWithZone(zone: any): MKDirectionsResponse;
	static alloc(): MKDirectionsResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKRoute extends NSObject {
	name: string;
	advisoryNotices: NSArray;
	distance: number;
	expectedTravelTime: number;
	transportType: number;
	polyline: MKPolyline;
	steps: NSArray;
	constructor();
	init(): MKRoute;
	static new(): MKRoute;
	static allocWithZone(zone: any): MKRoute;
	static alloc(): MKRoute;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKRouteStep extends NSObject {
	instructions: string;
	notice: string;
	polyline: MKPolyline;
	distance: number;
	transportType: number;
	constructor();
	init(): MKRouteStep;
	static new(): MKRouteStep;
	static allocWithZone(zone: any): MKRouteStep;
	static alloc(): MKRouteStep;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKETAResponse extends NSObject {
	source: MKMapItem;
	destination: MKMapItem;
	expectedTravelTime: number;
	constructor();
	init(): MKETAResponse;
	static new(): MKETAResponse;
	static allocWithZone(zone: any): MKETAResponse;
	static alloc(): MKETAResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKMapSnapshotOptions extends NSObject implements NSCopying {
	camera: MKMapCamera;
	mapRect: MKMapRect;
	region: MKCoordinateRegion;
	mapType: number;
	showsPointsOfInterest: boolean;
	showsBuildings: boolean;
	size: CGSize;
	scale: number;
	constructor();
	init(): MKMapSnapshotOptions;
	static new(): MKMapSnapshotOptions;
	static allocWithZone(zone: any): MKMapSnapshotOptions;
	static alloc(): MKMapSnapshotOptions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class MKMapSnapshotter extends NSObject {
	loading: boolean;
	constructor(options: MKMapSnapshotOptions);
	constructor();
	initWithOptions(options: MKMapSnapshotOptions): MKMapSnapshotter;
	startWithCompletionHandler(completionHandler: (arg1: MKMapSnapshot, arg2: NSError) => void): void;
	startWithQueueCompletionHandler(queue: NSObject, completionHandler: (arg1: MKMapSnapshot, arg2: NSError) => void): void;
	cancel(): void;
	init(): MKMapSnapshotter;
	static new(): MKMapSnapshotter;
	static allocWithZone(zone: any): MKMapSnapshotter;
	static alloc(): MKMapSnapshotter;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKMapSnapshot extends NSObject {
	image: UIImage;
	constructor();
	pointForCoordinate(coordinate: CLLocationCoordinate2D): CGPoint;
	init(): MKMapSnapshot;
	static new(): MKMapSnapshot;
	static allocWithZone(zone: any): MKMapSnapshot;
	static alloc(): MKMapSnapshot;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKTileOverlay extends NSObject implements MKOverlay {
	tileSize: CGSize;
	geometryFlipped: boolean;
	minimumZ: number;
	maximumZ: number;
	URLTemplate: string;
	canReplaceMapContentProperty: boolean;
	boundingMapRect: MKMapRect;
	coordinate: CLLocationCoordinate2D;
	title: string;
	subtitle: string;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(URLTemplate: string);
	constructor();
	initWithURLTemplate(URLTemplate: string): MKTileOverlay;
	URLForTilePath(path: MKTileOverlayPath): NSURL;
	loadTileAtPathResult(path: MKTileOverlayPath, result: (arg1: NSData, arg2: NSError) => void): void;
	init(): MKTileOverlay;
	static new(): MKTileOverlay;
	static allocWithZone(zone: any): MKTileOverlay;
	static alloc(): MKTileOverlay;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MKTileOverlayRenderer extends MKOverlayRenderer {
	constructor(overlay: MKTileOverlay);
	constructor(overlay: any);
	constructor();
	initWithTileOverlay(overlay: MKTileOverlay): MKTileOverlayRenderer;
	reloadData(): void;
	initWithOverlay(overlay: any): MKTileOverlayRenderer;
	init(): MKTileOverlayRenderer;
	static new(): MKTileOverlayRenderer;
	static allocWithZone(zone: any): MKTileOverlayRenderer;
	static alloc(): MKTileOverlayRenderer;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKMapCamera extends NSObject implements NSSecureCoding, NSCopying {
	centerCoordinate: CLLocationCoordinate2D;
	heading: number;
	pitch: number;
	altitude: number;
	constructor();
	static camera(): MKMapCamera;
	static cameraLookingAtCenterCoordinateFromEyeCoordinateEyeAltitude(centerCoordinate: CLLocationCoordinate2D, eyeCoordinate: CLLocationCoordinate2D, eyeAltitude: number): MKMapCamera;
	init(): MKMapCamera;
	static new(): MKMapCamera;
	static allocWithZone(zone: any): MKMapCamera;
	static alloc(): MKMapCamera;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class MKReverseGeocoder extends NSObject {
	delegate: any;
	coordinate: CLLocationCoordinate2D;
	placemark: MKPlacemark;
	querying: boolean;
	constructor(coordinate: CLLocationCoordinate2D);
	constructor();
	initWithCoordinate(coordinate: CLLocationCoordinate2D): MKReverseGeocoder;
	start(): void;
	cancel(): void;
	init(): MKReverseGeocoder;
	static new(): MKReverseGeocoder;
	static allocWithZone(zone: any): MKReverseGeocoder;
	static alloc(): MKReverseGeocoder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKOverlayPathView extends MKOverlayView {
	fillColor: UIColor;
	strokeColor: UIColor;
	lineWidth: number;
	lineJoin: number;
	lineCap: number;
	miterLimit: number;
	lineDashPhase: number;
	lineDashPattern: NSArray;
	path: any;
	constructor(overlay: any);
	constructor(frame: CGRect);
	constructor();
	createPath(): void;
	invalidatePath(): void;
	applyStrokePropertiesToContextAtZoomScale(context: any, zoomScale: number): void;
	applyFillPropertiesToContextAtZoomScale(context: any, zoomScale: number): void;
	strokePathInContext(path: any, context: any): void;
	fillPathInContext(path: any, context: any): void;
	initWithOverlay(overlay: any): MKOverlayPathView;
	initWithFrame(frame: CGRect): MKOverlayPathView;
	init(): MKOverlayPathView;
	static new(): MKOverlayPathView;
	static allocWithZone(zone: any): MKOverlayPathView;
	static alloc(): MKOverlayPathView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKPolygonView extends MKOverlayPathView {
	polygon: MKPolygon;
	constructor(polygon: MKPolygon);
	constructor(overlay: any);
	constructor(frame: CGRect);
	constructor();
	initWithPolygon(polygon: MKPolygon): MKPolygonView;
	initWithOverlay(overlay: any): MKPolygonView;
	initWithFrame(frame: CGRect): MKPolygonView;
	init(): MKPolygonView;
	static new(): MKPolygonView;
	static allocWithZone(zone: any): MKPolygonView;
	static alloc(): MKPolygonView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKPolylineView extends MKOverlayPathView {
	polyline: MKPolyline;
	constructor(polyline: MKPolyline);
	constructor(overlay: any);
	constructor(frame: CGRect);
	constructor();
	initWithPolyline(polyline: MKPolyline): MKPolylineView;
	initWithOverlay(overlay: any): MKPolylineView;
	initWithFrame(frame: CGRect): MKPolylineView;
	init(): MKPolylineView;
	static new(): MKPolylineView;
	static allocWithZone(zone: any): MKPolylineView;
	static alloc(): MKPolylineView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKCircleView extends MKOverlayPathView {
	circle: MKCircle;
	constructor(circle: MKCircle);
	constructor(overlay: any);
	constructor(frame: CGRect);
	constructor();
	initWithCircle(circle: MKCircle): MKCircleView;
	initWithOverlay(overlay: any): MKCircleView;
	initWithFrame(frame: CGRect): MKCircleView;
	init(): MKCircleView;
	static new(): MKCircleView;
	static allocWithZone(zone: any): MKCircleView;
	static alloc(): MKCircleView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MKUserTrackingBarButtonItem extends UIBarButtonItem {
	mapView: MKMapView;
	constructor(mapView: MKMapView);
	constructor(image: UIImage, style: number, target: any, action: any);
	constructor(image: UIImage, landscapeImagePhone: UIImage, style: number, target: any, action: any);
	constructor(title: string, style: number, target: any, action: any);
	constructor(systemItem: number, target: any, action: any);
	constructor(customView: UIView);
	constructor();
	initWithMapView(mapView: MKMapView): MKUserTrackingBarButtonItem;
	initWithImageStyleTargetAction(image: UIImage, style: number, target: any, action: any): MKUserTrackingBarButtonItem;
	initWithImageLandscapeImagePhoneStyleTargetAction(image: UIImage, landscapeImagePhone: UIImage, style: number, target: any, action: any): MKUserTrackingBarButtonItem;
	initWithTitleStyleTargetAction(title: string, style: number, target: any, action: any): MKUserTrackingBarButtonItem;
	initWithBarButtonSystemItemTargetAction(systemItem: number, target: any, action: any): MKUserTrackingBarButtonItem;
	initWithCustomView(customView: UIView): MKUserTrackingBarButtonItem;
	init(): MKUserTrackingBarButtonItem;
	static new(): MKUserTrackingBarButtonItem;
	static allocWithZone(zone: any): MKUserTrackingBarButtonItem;
	static alloc(): MKUserTrackingBarButtonItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MFMailComposeViewController extends UINavigationController {
	mailComposeDelegate: any;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static canSendMail(): boolean;
	setSubject(subject: string): void;
	setToRecipients(toRecipients: NSArray): void;
	setCcRecipients(ccRecipients: NSArray): void;
	setBccRecipients(bccRecipients: NSArray): void;
	setMessageBodyIsHTML(body: string, isHTML: boolean): void;
	addAttachmentDataMimeTypeFileName(attachment: NSData, mimeType: string, filename: string): void;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): MFMailComposeViewController;
	initWithRootViewController(rootViewController: UIViewController): MFMailComposeViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): MFMailComposeViewController;
	init(): MFMailComposeViewController;
	static new(): MFMailComposeViewController;
	static allocWithZone(zone: any): MFMailComposeViewController;
	static alloc(): MFMailComposeViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MFMessageComposeViewController extends UINavigationController {
	messageComposeDelegate: any;
	recipients: NSArray;
	body: string;
	subject: string;
	attachments: NSArray;
	constructor(navigationBarClass: any, toolbarClass: any);
	constructor(rootViewController: UIViewController);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static canSendText(): boolean;
	static canSendSubject(): boolean;
	static canSendAttachments(): boolean;
	static isSupportedAttachmentUTI(uti: string): boolean;
	disableUserAttachments(): void;
	addAttachmentURLWithAlternateFilename(attachmentURL: NSURL, alternateFilename: string): boolean;
	addAttachmentDataTypeIdentifierFilename(attachmentData: NSData, uti: string, filename: string): boolean;
	initWithNavigationBarClassToolbarClass(navigationBarClass: any, toolbarClass: any): MFMessageComposeViewController;
	initWithRootViewController(rootViewController: UIViewController): MFMessageComposeViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): MFMessageComposeViewController;
	init(): MFMessageComposeViewController;
	static new(): MFMessageComposeViewController;
	static allocWithZone(zone: any): MFMessageComposeViewController;
	static alloc(): MFMessageComposeViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MCPeerID extends NSObject implements NSCopying, NSSecureCoding {
	displayName: string;
	constructor(myDisplayName: string);
	constructor();
	initWithDisplayName(myDisplayName: string): MCPeerID;
	init(): MCPeerID;
	static new(): MCPeerID;
	static allocWithZone(zone: any): MCPeerID;
	static alloc(): MCPeerID;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class MCSession extends NSObject {
	delegate: any;
	myPeerID: MCPeerID;
	securityIdentity: NSArray;
	encryptionPreference: number;
	connectedPeers: NSArray;
	constructor(myPeerID: MCPeerID);
	constructor(myPeerID: MCPeerID, identity: NSArray, encryptionPreference: number);
	constructor();
	initWithPeer(myPeerID: MCPeerID): MCSession;
	initWithPeerSecurityIdentityEncryptionPreference(myPeerID: MCPeerID, identity: NSArray, encryptionPreference: number): MCSession;
	sendDataToPeersWithModeError(data: NSData, peerIDs: NSArray, mode: number, error: any): boolean;
	disconnect(): void;
	sendResourceAtURLWithNameToPeerWithCompletionHandler(resourceURL: NSURL, resourceName: string, peerID: MCPeerID, completionHandler: (arg1: NSError) => void): NSProgress;
	startStreamWithNameToPeerError(streamName: string, peerID: MCPeerID, error: any): NSOutputStream;
	nearbyConnectionDataForPeerWithCompletionHandler(peerID: MCPeerID, completionHandler: (arg1: NSData, arg2: NSError) => void): void;
	connectPeerWithNearbyConnectionData(peerID: MCPeerID, data: NSData): void;
	cancelConnectPeer(peerID: MCPeerID): void;
	init(): MCSession;
	static new(): MCSession;
	static allocWithZone(zone: any): MCSession;
	static alloc(): MCSession;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MCNearbyServiceAdvertiser extends NSObject {
	delegate: any;
	myPeerID: MCPeerID;
	discoveryInfo: NSDictionary;
	serviceType: string;
	constructor(myPeerID: MCPeerID, info: NSDictionary, serviceType: string);
	constructor();
	initWithPeerDiscoveryInfoServiceType(myPeerID: MCPeerID, info: NSDictionary, serviceType: string): MCNearbyServiceAdvertiser;
	startAdvertisingPeer(): void;
	stopAdvertisingPeer(): void;
	init(): MCNearbyServiceAdvertiser;
	static new(): MCNearbyServiceAdvertiser;
	static allocWithZone(zone: any): MCNearbyServiceAdvertiser;
	static alloc(): MCNearbyServiceAdvertiser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MCNearbyServiceBrowser extends NSObject {
	delegate: any;
	myPeerID: MCPeerID;
	serviceType: string;
	constructor(myPeerID: MCPeerID, serviceType: string);
	constructor();
	initWithPeerServiceType(myPeerID: MCPeerID, serviceType: string): MCNearbyServiceBrowser;
	startBrowsingForPeers(): void;
	stopBrowsingForPeers(): void;
	invitePeerToSessionWithContextTimeout(peerID: MCPeerID, session: MCSession, context: NSData, timeout: number): void;
	init(): MCNearbyServiceBrowser;
	static new(): MCNearbyServiceBrowser;
	static allocWithZone(zone: any): MCNearbyServiceBrowser;
	static alloc(): MCNearbyServiceBrowser;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class MCBrowserViewController extends UIViewController implements MCNearbyServiceBrowserDelegate {
	delegate: any;
	browser: MCNearbyServiceBrowser;
	session: MCSession;
	minimumNumberOfPeers: number;
	maximumNumberOfPeers: number;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(serviceType: string, session: MCSession);
	constructor(browser: MCNearbyServiceBrowser, session: MCSession);
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	initWithServiceTypeSession(serviceType: string, session: MCSession): MCBrowserViewController;
	initWithBrowserSession(browser: MCNearbyServiceBrowser, session: MCSession): MCBrowserViewController;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): MCBrowserViewController;
	init(): MCBrowserViewController;
	static new(): MCBrowserViewController;
	static allocWithZone(zone: any): MCBrowserViewController;
	static alloc(): MCBrowserViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	browserFoundPeerWithDiscoveryInfo(browser: MCNearbyServiceBrowser, peerID: MCPeerID, info: NSDictionary): void;
	browserLostPeer(browser: MCNearbyServiceBrowser, peerID: MCPeerID): void;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class MCAdvertiserAssistant extends NSObject {
	delegate: any;
	session: MCSession;
	discoveryInfo: NSDictionary;
	serviceType: string;
	constructor(serviceType: string, info: NSDictionary, session: MCSession);
	constructor();
	initWithServiceTypeDiscoveryInfoSession(serviceType: string, info: NSDictionary, session: MCSession): MCAdvertiserAssistant;
	start(): void;
	stop(): void;
	init(): MCAdvertiserAssistant;
	static new(): MCAdvertiserAssistant;
	static allocWithZone(zone: any): MCAdvertiserAssistant;
	static alloc(): MCAdvertiserAssistant;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEVPNManager extends NSObject {
	onDemandRules: NSArray;
	onDemandEnabled: boolean;
	localizedDescription: string;
	protocol: NEVPNProtocol;
	connection: NEVPNConnection;
	enabled: boolean;
	constructor();
	static sharedManager(): NEVPNManager;
	loadFromPreferencesWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	removeFromPreferencesWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	saveToPreferencesWithCompletionHandler(completionHandler: (arg1: NSError) => void): void;
	init(): NEVPNManager;
	static new(): NEVPNManager;
	static allocWithZone(zone: any): NEVPNManager;
	static alloc(): NEVPNManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEVPNConnection extends NSObject {
	status: number;
	constructor();
	startVPNTunnelAndReturnError(error: any): boolean;
	stopVPNTunnel(): void;
	init(): NEVPNConnection;
	static new(): NEVPNConnection;
	static allocWithZone(zone: any): NEVPNConnection;
	static alloc(): NEVPNConnection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEVPNProtocol extends NSObject implements NSCopying, NSSecureCoding {
	serverAddress: string;
	username: string;
	passwordReference: NSData;
	identityData: NSData;
	identityDataPassword: string;
	disconnectOnSleep: boolean;
	constructor();
	init(): NEVPNProtocol;
	static new(): NEVPNProtocol;
	static allocWithZone(zone: any): NEVPNProtocol;
	static alloc(): NEVPNProtocol;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class NEVPNProtocolIPSec extends NEVPNProtocol {
	authenticationMethod: number;
	useExtendedAuthentication: boolean;
	sharedSecretReference: NSData;
	localIdentifier: string;
	remoteIdentifier: string;
	constructor();
	init(): NEVPNProtocolIPSec;
	static new(): NEVPNProtocolIPSec;
	static allocWithZone(zone: any): NEVPNProtocolIPSec;
	static alloc(): NEVPNProtocolIPSec;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEVPNIKEv2SecurityAssociationParameters extends NSObject implements NSSecureCoding, NSCopying {
	encryptionAlgorithm: number;
	integrityAlgorithm: number;
	diffieHellmanGroup: number;
	lifetimeMinutes: number;
	constructor();
	init(): NEVPNIKEv2SecurityAssociationParameters;
	static new(): NEVPNIKEv2SecurityAssociationParameters;
	static allocWithZone(zone: any): NEVPNIKEv2SecurityAssociationParameters;
	static alloc(): NEVPNIKEv2SecurityAssociationParameters;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NEVPNProtocolIKEv2 extends NEVPNProtocolIPSec {
	deadPeerDetectionRate: number;
	serverCertificateIssuerCommonName: string;
	serverCertificateCommonName: string;
	IKESecurityAssociationParameters: NEVPNIKEv2SecurityAssociationParameters;
	childSecurityAssociationParameters: NEVPNIKEv2SecurityAssociationParameters;
	constructor();
	init(): NEVPNProtocolIKEv2;
	static new(): NEVPNProtocolIKEv2;
	static allocWithZone(zone: any): NEVPNProtocolIKEv2;
	static alloc(): NEVPNProtocolIKEv2;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEOnDemandRule extends NSObject implements NSSecureCoding, NSCopying {
	action: number;
	DNSSearchDomainMatch: NSArray;
	DNSServerAddressMatch: NSArray;
	interfaceTypeMatch: number;
	SSIDMatch: NSArray;
	probeURL: NSURL;
	constructor();
	init(): NEOnDemandRule;
	static new(): NEOnDemandRule;
	static allocWithZone(zone: any): NEOnDemandRule;
	static alloc(): NEOnDemandRule;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NEOnDemandRuleConnect extends NEOnDemandRule {
	constructor();
	init(): NEOnDemandRuleConnect;
	static new(): NEOnDemandRuleConnect;
	static allocWithZone(zone: any): NEOnDemandRuleConnect;
	static alloc(): NEOnDemandRuleConnect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEOnDemandRuleDisconnect extends NEOnDemandRule {
	constructor();
	init(): NEOnDemandRuleDisconnect;
	static new(): NEOnDemandRuleDisconnect;
	static allocWithZone(zone: any): NEOnDemandRuleDisconnect;
	static alloc(): NEOnDemandRuleDisconnect;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEOnDemandRuleIgnore extends NEOnDemandRule {
	constructor();
	init(): NEOnDemandRuleIgnore;
	static new(): NEOnDemandRuleIgnore;
	static allocWithZone(zone: any): NEOnDemandRuleIgnore;
	static alloc(): NEOnDemandRuleIgnore;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEOnDemandRuleEvaluateConnection extends NEOnDemandRule {
	connectionRules: NSArray;
	constructor();
	init(): NEOnDemandRuleEvaluateConnection;
	static new(): NEOnDemandRuleEvaluateConnection;
	static allocWithZone(zone: any): NEOnDemandRuleEvaluateConnection;
	static alloc(): NEOnDemandRuleEvaluateConnection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class NEEvaluateConnectionRule extends NSObject implements NSSecureCoding, NSCopying {
	action: number;
	matchDomains: NSArray;
	useDNSServers: NSArray;
	probeURL: NSURL;
	constructor(domains: NSArray, action: number);
	constructor();
	initWithMatchDomainsAndAction(domains: NSArray, action: number): NEEvaluateConnectionRule;
	init(): NEEvaluateConnectionRule;
	static new(): NEEvaluateConnectionRule;
	static allocWithZone(zone: any): NEEvaluateConnectionRule;
	static alloc(): NEEvaluateConnectionRule;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	static supportsSecureCoding(): boolean;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class NCWidgetController extends NSObject {
	constructor();
	static widgetController(): NCWidgetController;
	setHasContentForWidgetWithBundleIdentifier(flag: boolean, bundleID: string): void;
	init(): NCWidgetController;
	static new(): NCWidgetController;
	static allocWithZone(zone: any): NCWidgetController;
	static alloc(): NCWidgetController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHPhotoLibrary extends NSObject {
	constructor();
	static sharedPhotoLibrary(): PHPhotoLibrary;
	static authorizationStatus(): number;
	static requestAuthorization(handler: (arg1: number) => void): void;
	performChangesCompletionHandler(changeBlock: () => void, completionHandler: (arg1: boolean, arg2: NSError) => void): void;
	performChangesAndWaitError(changeBlock: () => void, error: any): boolean;
	registerChangeObserver(observer: any): void;
	unregisterChangeObserver(observer: any): void;
	init(): PHPhotoLibrary;
	static new(): PHPhotoLibrary;
	static allocWithZone(zone: any): PHPhotoLibrary;
	static alloc(): PHPhotoLibrary;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHObject extends NSObject implements NSCopying {
	localIdentifier: string;
	constructor();
	init(): PHObject;
	static new(): PHObject;
	static allocWithZone(zone: any): PHObject;
	static alloc(): PHObject;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class PHObjectPlaceholder extends PHObject {
	constructor();
	init(): PHObjectPlaceholder;
	static new(): PHObjectPlaceholder;
	static allocWithZone(zone: any): PHObjectPlaceholder;
	static alloc(): PHObjectPlaceholder;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHAsset extends PHObject {
	mediaType: number;
	mediaSubtypes: number;
	pixelWidth: number;
	pixelHeight: number;
	creationDate: NSDate;
	modificationDate: NSDate;
	location: CLLocation;
	duration: number;
	hidden: boolean;
	favorite: boolean;
	burstIdentifier: string;
	burstSelectionTypes: number;
	representsBurst: boolean;
	constructor();
	canPerformEditOperation(editOperation: number): boolean;
	static fetchAssetsInAssetCollectionOptions(assetCollection: PHAssetCollection, options: PHFetchOptions): PHFetchResult;
	static fetchAssetsWithMediaTypeOptions(mediaType: number, options: PHFetchOptions): PHFetchResult;
	static fetchAssetsWithLocalIdentifiersOptions(identifiers: NSArray, options: PHFetchOptions): PHFetchResult;
	static fetchKeyAssetsInAssetCollectionOptions(assetCollection: PHAssetCollection, options: PHFetchOptions): PHFetchResult;
	static fetchAssetsWithBurstIdentifierOptions(burstIdentifier: string, options: PHFetchOptions): PHFetchResult;
	static fetchAssetsWithOptions(options: PHFetchOptions): PHFetchResult;
	static fetchAssetsWithALAssetURLsOptions(assetURLs: NSArray, options: PHFetchOptions): PHFetchResult;
	requestContentEditingInputWithOptionsCompletionHandler(options: PHContentEditingInputRequestOptions, completionHandler: (arg1: PHContentEditingInput, arg2: NSDictionary) => void): number;
	cancelContentEditingInputRequest(requestID: number): void;
	init(): PHAsset;
	static new(): PHAsset;
	static allocWithZone(zone: any): PHAsset;
	static alloc(): PHAsset;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHCollection extends PHObject {
	canContainAssets: boolean;
	canContainCollections: boolean;
	localizedTitle: string;
	constructor();
	canPerformEditOperation(anOperation: number): boolean;
	static fetchCollectionsInCollectionListOptions(collectionList: PHCollectionList, options: PHFetchOptions): PHFetchResult;
	static fetchTopLevelUserCollectionsWithOptions(options: PHFetchOptions): PHFetchResult;
	init(): PHCollection;
	static new(): PHCollection;
	static allocWithZone(zone: any): PHCollection;
	static alloc(): PHCollection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHAssetCollection extends PHCollection {
	assetCollectionType: number;
	assetCollectionSubtype: number;
	estimatedAssetCount: number;
	startDate: NSDate;
	endDate: NSDate;
	approximateLocation: CLLocation;
	localizedLocationNames: NSArray;
	constructor();
	static fetchAssetCollectionsWithLocalIdentifiersOptions(identifiers: NSArray, options: PHFetchOptions): PHFetchResult;
	static fetchAssetCollectionsWithTypeSubtypeOptions(type: number, subtype: number, options: PHFetchOptions): PHFetchResult;
	static fetchAssetCollectionsContainingAssetWithTypeOptions(asset: PHAsset, type: number, options: PHFetchOptions): PHFetchResult;
	static fetchAssetCollectionsWithALAssetGroupURLsOptions(assetGroupURLs: NSArray, options: PHFetchOptions): PHFetchResult;
	static fetchMomentsInMomentListOptions(momentList: PHCollectionList, options: PHFetchOptions): PHFetchResult;
	static fetchMomentsWithOptions(options: PHFetchOptions): PHFetchResult;
	static transientAssetCollectionWithAssetsTitle(assets: NSArray, title: string): PHAssetCollection;
	static transientAssetCollectionWithAssetFetchResultTitle(fetchResult: PHFetchResult, title: string): PHAssetCollection;
	init(): PHAssetCollection;
	static new(): PHAssetCollection;
	static allocWithZone(zone: any): PHAssetCollection;
	static alloc(): PHAssetCollection;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHCollectionList extends PHCollection {
	collectionListType: number;
	collectionListSubtype: number;
	startDate: NSDate;
	endDate: NSDate;
	localizedLocationNames: NSArray;
	constructor();
	static fetchCollectionListsContainingCollectionOptions(collection: PHCollection, options: PHFetchOptions): PHFetchResult;
	static fetchCollectionListsWithLocalIdentifiersOptions(identifiers: NSArray, options: PHFetchOptions): PHFetchResult;
	static fetchCollectionListsWithTypeSubtypeOptions(collectionListType: number, subtype: number, options: PHFetchOptions): PHFetchResult;
	static fetchMomentListsWithSubtypeContainingMomentOptions(momentListSubtype: number, moment: PHAssetCollection, options: PHFetchOptions): PHFetchResult;
	static fetchMomentListsWithSubtypeOptions(momentListSubtype: number, options: PHFetchOptions): PHFetchResult;
	static transientCollectionListWithCollectionsTitle(collections: NSArray, title: string): PHCollectionList;
	static transientCollectionListWithCollectionsFetchResultTitle(fetchResult: PHFetchResult, title: string): PHCollectionList;
	init(): PHCollectionList;
	static new(): PHCollectionList;
	static allocWithZone(zone: any): PHCollectionList;
	static alloc(): PHCollectionList;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHFetchOptions extends NSObject implements NSCopying {
	predicate: NSPredicate;
	sortDescriptors: NSArray;
	includeHiddenAssets: boolean;
	includeAllBurstAssets: boolean;
	wantsIncrementalChangeDetails: boolean;
	constructor();
	init(): PHFetchOptions;
	static new(): PHFetchOptions;
	static allocWithZone(zone: any): PHFetchOptions;
	static alloc(): PHFetchOptions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class PHFetchResult extends NSObject implements NSCopying, NSFastEnumeration {
	count: number;
	firstObject: any;
	lastObject: any;
	constructor();
	objectAtIndex(index: number): any;
	objectAtIndexedSubscript(idx: number): any;
	containsObject(anObject: any): boolean;
	indexOfObject(anObject: any): number;
	indexOfObjectInRange(anObject: any, range: NSRange): number;
	objectsAtIndexes(indexes: NSIndexSet): NSArray;
	enumerateObjectsUsingBlock(block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateObjectsWithOptionsUsingBlock(opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	enumerateObjectsAtIndexesOptionsUsingBlock(s: NSIndexSet, opts: number, block: (arg1: any, arg2: number, arg3: any) => void): void;
	countOfAssetsWithMediaType(mediaType: number): number;
	init(): PHFetchResult;
	static new(): PHFetchResult;
	static allocWithZone(zone: any): PHFetchResult;
	static alloc(): PHFetchResult;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
declare class PHChange extends NSObject {
	constructor();
	changeDetailsForObject(object: PHObject): PHObjectChangeDetails;
	changeDetailsForFetchResult(object: PHFetchResult): PHFetchResultChangeDetails;
	init(): PHChange;
	static new(): PHChange;
	static allocWithZone(zone: any): PHChange;
	static alloc(): PHChange;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHObjectChangeDetails extends NSObject {
	objectBeforeChanges: any;
	objectAfterChanges: any;
	assetContentChanged: boolean;
	objectWasDeleted: boolean;
	constructor();
	init(): PHObjectChangeDetails;
	static new(): PHObjectChangeDetails;
	static allocWithZone(zone: any): PHObjectChangeDetails;
	static alloc(): PHObjectChangeDetails;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHFetchResultChangeDetails extends NSObject {
	fetchResultBeforeChanges: PHFetchResult;
	fetchResultAfterChanges: PHFetchResult;
	hasIncrementalChanges: boolean;
	removedIndexes: NSIndexSet;
	removedObjects: NSArray;
	insertedIndexes: NSIndexSet;
	insertedObjects: NSArray;
	changedIndexes: NSIndexSet;
	changedObjects: NSArray;
	hasMoves: boolean;
	constructor();
	enumerateMovesWithBlock(handler: (arg1: number, arg2: number) => void): void;
	static changeDetailsFromFetchResultToFetchResultChangedObjects(fromResult: PHFetchResult, toResult: PHFetchResult, changedObjects: NSArray): PHFetchResultChangeDetails;
	init(): PHFetchResultChangeDetails;
	static new(): PHFetchResultChangeDetails;
	static allocWithZone(zone: any): PHFetchResultChangeDetails;
	static alloc(): PHFetchResultChangeDetails;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHContentEditingOutput extends NSObject {
	adjustmentData: PHAdjustmentData;
	renderedContentURL: NSURL;
	constructor(contentEditingInput: PHContentEditingInput);
	constructor(placeholderForCreatedAsset: PHObjectPlaceholder);
	constructor();
	initWithContentEditingInput(contentEditingInput: PHContentEditingInput): PHContentEditingOutput;
	initWithPlaceholderForCreatedAsset(placeholderForCreatedAsset: PHObjectPlaceholder): PHContentEditingOutput;
	init(): PHContentEditingOutput;
	static new(): PHContentEditingOutput;
	static allocWithZone(zone: any): PHContentEditingOutput;
	static alloc(): PHContentEditingOutput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHAssetChangeRequest extends NSObject {
	placeholderForCreatedAsset: PHObjectPlaceholder;
	creationDate: NSDate;
	location: CLLocation;
	favorite: boolean;
	hidden: boolean;
	contentEditingOutput: PHContentEditingOutput;
	constructor();
	static creationRequestForAssetFromImage(image: UIImage): PHAssetChangeRequest;
	static creationRequestForAssetFromImageAtFileURL(fileURL: NSURL): PHAssetChangeRequest;
	static creationRequestForAssetFromVideoAtFileURL(fileURL: NSURL): PHAssetChangeRequest;
	static deleteAssets(assets: any): void;
	static changeRequestForAsset(asset: PHAsset): PHAssetChangeRequest;
	revertAssetContentToOriginal(): void;
	init(): PHAssetChangeRequest;
	static new(): PHAssetChangeRequest;
	static allocWithZone(zone: any): PHAssetChangeRequest;
	static alloc(): PHAssetChangeRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHContentEditingInputRequestOptions extends NSObject {
	canHandleAdjustmentData: (arg1: PHAdjustmentData) => boolean;
	networkAccessAllowed: boolean;
	progressHandler: (arg1: number, arg2: any) => void;
	constructor();
	init(): PHContentEditingInputRequestOptions;
	static new(): PHContentEditingInputRequestOptions;
	static allocWithZone(zone: any): PHContentEditingInputRequestOptions;
	static alloc(): PHContentEditingInputRequestOptions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHAssetCollectionChangeRequest extends NSObject {
	placeholderForCreatedAssetCollection: PHObjectPlaceholder;
	title: string;
	constructor();
	static creationRequestForAssetCollectionWithTitle(title: string): PHAssetCollectionChangeRequest;
	static deleteAssetCollections(assetCollections: any): void;
	static changeRequestForAssetCollection(assetCollection: PHAssetCollection): PHAssetCollectionChangeRequest;
	static changeRequestForAssetCollectionAssets(assetCollection: PHAssetCollection, assets: PHFetchResult): PHAssetCollectionChangeRequest;
	addAssets(assets: any): void;
	insertAssetsAtIndexes(assets: any, indexes: NSIndexSet): void;
	removeAssets(assets: any): void;
	removeAssetsAtIndexes(indexes: NSIndexSet): void;
	replaceAssetsAtIndexesWithAssets(indexes: NSIndexSet, assets: any): void;
	moveAssetsAtIndexesToIndex(fromIndexes: NSIndexSet, toIndex: number): void;
	init(): PHAssetCollectionChangeRequest;
	static new(): PHAssetCollectionChangeRequest;
	static allocWithZone(zone: any): PHAssetCollectionChangeRequest;
	static alloc(): PHAssetCollectionChangeRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHCollectionListChangeRequest extends NSObject {
	placeholderForCreatedCollectionList: PHObjectPlaceholder;
	title: string;
	constructor();
	static creationRequestForCollectionListWithTitle(title: string): PHCollectionListChangeRequest;
	static deleteCollectionLists(collectionLists: any): void;
	static changeRequestForCollectionList(collectionList: PHCollectionList): PHCollectionListChangeRequest;
	static changeRequestForCollectionListChildCollections(collectionList: PHCollectionList, childCollections: PHFetchResult): PHCollectionListChangeRequest;
	addChildCollections(collections: any): void;
	insertChildCollectionsAtIndexes(collections: any, indexes: NSIndexSet): void;
	removeChildCollections(collections: any): void;
	removeChildCollectionsAtIndexes(indexes: NSIndexSet): void;
	replaceChildCollectionsAtIndexesWithChildCollections(indexes: NSIndexSet, collections: any): void;
	moveChildCollectionsAtIndexesToIndex(indexes: NSIndexSet, toIndex: number): void;
	init(): PHCollectionListChangeRequest;
	static new(): PHCollectionListChangeRequest;
	static allocWithZone(zone: any): PHCollectionListChangeRequest;
	static alloc(): PHCollectionListChangeRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHImageRequestOptions extends NSObject implements NSCopying {
	version: number;
	deliveryMode: number;
	resizeMode: number;
	normalizedCropRect: CGRect;
	networkAccessAllowed: boolean;
	synchronous: boolean;
	progressHandler: (arg1: number, arg2: NSError, arg3: any, arg4: NSDictionary) => void;
	constructor();
	init(): PHImageRequestOptions;
	static new(): PHImageRequestOptions;
	static allocWithZone(zone: any): PHImageRequestOptions;
	static alloc(): PHImageRequestOptions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class PHVideoRequestOptions extends NSObject {
	networkAccessAllowed: boolean;
	version: number;
	deliveryMode: number;
	progressHandler: (arg1: number, arg2: NSError, arg3: any, arg4: NSDictionary) => void;
	constructor();
	init(): PHVideoRequestOptions;
	static new(): PHVideoRequestOptions;
	static allocWithZone(zone: any): PHVideoRequestOptions;
	static alloc(): PHVideoRequestOptions;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHImageManager extends NSObject {
	constructor();
	static defaultManager(): PHImageManager;
	requestImageForAssetTargetSizeContentModeOptionsResultHandler(asset: PHAsset, targetSize: CGSize, contentMode: number, options: PHImageRequestOptions, resultHandler: (arg1: UIImage, arg2: NSDictionary) => void): number;
	requestImageDataForAssetOptionsResultHandler(asset: PHAsset, options: PHImageRequestOptions, resultHandler: (arg1: NSData, arg2: string, arg3: number, arg4: NSDictionary) => void): number;
	cancelImageRequest(requestID: number): void;
	requestPlayerItemForVideoOptionsResultHandler(asset: PHAsset, options: PHVideoRequestOptions, resultHandler: (arg1: AVPlayerItem, arg2: NSDictionary) => void): number;
	requestExportSessionForVideoOptionsExportPresetResultHandler(asset: PHAsset, options: PHVideoRequestOptions, exportPreset: string, resultHandler: (arg1: AVAssetExportSession, arg2: NSDictionary) => void): number;
	requestAVAssetForVideoOptionsResultHandler(asset: PHAsset, options: PHVideoRequestOptions, resultHandler: (arg1: AVAsset, arg2: AVAudioMix, arg3: NSDictionary) => void): number;
	init(): PHImageManager;
	static new(): PHImageManager;
	static allocWithZone(zone: any): PHImageManager;
	static alloc(): PHImageManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHCachingImageManager extends PHImageManager {
	allowsCachingHighQualityImages: boolean;
	constructor();
	startCachingImagesForAssetsTargetSizeContentModeOptions(assets: NSArray, targetSize: CGSize, contentMode: number, options: PHImageRequestOptions): void;
	stopCachingImagesForAssetsTargetSizeContentModeOptions(assets: NSArray, targetSize: CGSize, contentMode: number, options: PHImageRequestOptions): void;
	stopCachingImagesForAllAssets(): void;
	init(): PHCachingImageManager;
	static new(): PHCachingImageManager;
	static allocWithZone(zone: any): PHCachingImageManager;
	static alloc(): PHCachingImageManager;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHAdjustmentData extends NSObject {
	formatIdentifier: string;
	formatVersion: string;
	data: NSData;
	constructor(formatIdentifier: string, formatVersion: string, data: NSData);
	constructor();
	initWithFormatIdentifierFormatVersionData(formatIdentifier: string, formatVersion: string, data: NSData): PHAdjustmentData;
	init(): PHAdjustmentData;
	static new(): PHAdjustmentData;
	static allocWithZone(zone: any): PHAdjustmentData;
	static alloc(): PHAdjustmentData;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PHContentEditingInput extends NSObject {
	mediaType: number;
	mediaSubtypes: number;
	creationDate: NSDate;
	location: CLLocation;
	uniformTypeIdentifier: string;
	adjustmentData: PHAdjustmentData;
	displaySizeImage: UIImage;
	fullSizeImageURL: NSURL;
	fullSizeImageOrientation: number;
	avAsset: AVAsset;
	constructor();
	init(): PHContentEditingInput;
	static new(): PHContentEditingInput;
	static allocWithZone(zone: any): PHContentEditingInput;
	static alloc(): PHContentEditingInput;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PKPushCredentials extends NSObject {
	type: string;
	token: NSData;
	constructor();
	init(): PKPushCredentials;
	static new(): PKPushCredentials;
	static allocWithZone(zone: any): PKPushCredentials;
	static alloc(): PKPushCredentials;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PKPushPayload extends NSObject {
	type: string;
	dictionaryPayload: NSDictionary;
	constructor();
	init(): PKPushPayload;
	static new(): PKPushPayload;
	static allocWithZone(zone: any): PKPushPayload;
	static alloc(): PKPushPayload;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class PKPushRegistry extends NSObject {
	delegate: any;
	desiredPushTypes: NSSet;
	constructor(queue: NSObject);
	constructor();
	pushTokenForType(type: string): NSData;
	initWithQueue(queue: NSObject): PKPushRegistry;
	init(): PKPushRegistry;
	static new(): PKPushRegistry;
	static allocWithZone(zone: any): PKPushRegistry;
	static alloc(): PKPushRegistry;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class QLPreviewController extends UIViewController {
	dataSource: any;
	currentPreviewItemIndex: number;
	currentPreviewItem: any;
	delegate: any;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static canPreviewItem(item: any): boolean;
	reloadData(): void;
	refreshCurrentPreviewItem(): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): QLPreviewController;
	init(): QLPreviewController;
	static new(): QLPreviewController;
	static allocWithZone(zone: any): QLPreviewController;
	static alloc(): QLPreviewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SSReadingList extends NSObject {
	constructor();
	static defaultReadingList(): SSReadingList;
	static supportsURL(URL: NSURL): boolean;
	addReadingListItemWithURLTitlePreviewTextError(URL: NSURL, title: string, previewText: string, error: any): boolean;
	init(): SSReadingList;
	static new(): SSReadingList;
	static allocWithZone(zone: any): SSReadingList;
	static alloc(): SSReadingList;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SLRequest extends NSObject {
	account: ACAccount;
	requestMethod: number;
	URL: NSURL;
	parameters: NSDictionary;
	constructor();
	static requestForServiceTypeRequestMethodURLParameters(serviceType: string, requestMethod: number, url: NSURL, parameters: NSDictionary): SLRequest;
	addMultipartDataWithNameTypeFilename(data: NSData, name: string, type: string, filename: string): void;
	preparedURLRequest(): NSURLRequest;
	performRequestWithHandler(handler: (arg1: NSData, arg2: NSHTTPURLResponse, arg3: NSError) => void): void;
	init(): SLRequest;
	static new(): SLRequest;
	static allocWithZone(zone: any): SLRequest;
	static alloc(): SLRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SLComposeServiceViewController extends UIViewController implements UITextViewDelegate {
	textView: UITextView;
	contentText: string;
	placeholder: string;
	charactersRemaining: NSNumber;
	autoCompletionViewController: UIViewController;
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	presentationAnimationDidFinish(): void;
	didSelectPost(): void;
	didSelectCancel(): void;
	cancel(): void;
	isContentValid(): boolean;
	validateContent(): void;
	configurationItems(): NSArray;
	reloadConfigurationItems(): void;
	pushConfigurationViewController(viewController: UIViewController): void;
	popConfigurationViewController(): void;
	loadPreviewView(): UIView;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): SLComposeServiceViewController;
	init(): SLComposeServiceViewController;
	static new(): SLComposeServiceViewController;
	static allocWithZone(zone: any): SLComposeServiceViewController;
	static alloc(): SLComposeServiceViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
declare class SLComposeViewController extends UIViewController {
	serviceType: string;
	completionHandler: (arg1: number) => void;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static isAvailableForServiceType(serviceType: string): boolean;
	static composeViewControllerForServiceType(serviceType: string): SLComposeViewController;
	setInitialText(text: string): boolean;
	addImage(image: UIImage): boolean;
	removeAllImages(): boolean;
	addURL(url: NSURL): boolean;
	removeAllURLs(): boolean;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): SLComposeViewController;
	init(): SLComposeViewController;
	static new(): SLComposeViewController;
	static allocWithZone(zone: any): SLComposeViewController;
	static alloc(): SLComposeViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SLComposeSheetConfigurationItem extends NSObject {
	title: string;
	value: string;
	valuePending: boolean;
	tapHandler: () => void;
	constructor();
	init(): SLComposeSheetConfigurationItem;
	static new(): SLComposeSheetConfigurationItem;
	static allocWithZone(zone: any): SLComposeSheetConfigurationItem;
	static alloc(): SLComposeSheetConfigurationItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKNode extends UIResponder implements NSCopying, NSCoding {
	frame: CGRect;
	position: CGPoint;
	zPosition: number;
	zRotation: number;
	xScale: number;
	yScale: number;
	speed: number;
	alpha: number;
	paused: boolean;
	hidden: boolean;
	userInteractionEnabled: boolean;
	parent: SKNode;
	children: NSArray;
	name: string;
	scene: SKScene;
	physicsBody: SKPhysicsBody;
	userData: NSMutableDictionary;
	reachConstraints: SKReachConstraints;
	constraints: NSArray;
	constructor();
	static node(): SKNode;
	static nodeWithFileNamed(filename: string): SKNode;
	calculateAccumulatedFrame(): CGRect;
	setScale(scale: number): void;
	addChild(node: SKNode): void;
	insertChildAtIndex(node: SKNode, index: number): void;
	removeChildrenInArray(nodes: NSArray): void;
	removeAllChildren(): void;
	removeFromParent(): void;
	childNodeWithName(name: string): SKNode;
	enumerateChildNodesWithNameUsingBlock(name: string, block: (arg1: SKNode, arg2: any) => void): void;
	objectForKeyedSubscript(name: string): NSArray;
	inParentHierarchy(parent: SKNode): boolean;
	runAction(action: SKAction): void;
	runActionCompletion(action: SKAction, block: () => void): void;
	runActionWithKey(action: SKAction, key: string): void;
	hasActions(): boolean;
	actionForKey(key: string): SKAction;
	removeActionForKey(key: string): void;
	removeAllActions(): void;
	containsPoint(p: CGPoint): boolean;
	nodeAtPoint(p: CGPoint): SKNode;
	nodesAtPoint(p: CGPoint): NSArray;
	convertPointFromNode(point: CGPoint, node: SKNode): CGPoint;
	convertPointToNode(point: CGPoint, node: SKNode): CGPoint;
	intersectsNode(node: SKNode): boolean;
	init(): SKNode;
	static new(): SKNode;
	static allocWithZone(zone: any): SKNode;
	static alloc(): SKNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKTexture extends NSObject implements NSCopying, NSCoding {
	filteringMode: number;
	usesMipmaps: boolean;
	constructor();
	static textureWithImageNamed(name: string): SKTexture;
	static textureWithRectInTexture(rect: CGRect, texture: SKTexture): SKTexture;
	static textureVectorNoiseWithSmoothnessSize(smoothness: number, size: CGSize): SKTexture;
	static textureNoiseWithSmoothnessSizeGrayscale(smoothness: number, size: CGSize, grayscale: boolean): SKTexture;
	static textureWithCGImage(image: any): SKTexture;
	static textureWithImage(image: UIImage): SKTexture;
	static textureWithDataSize(pixelData: NSData, size: CGSize): SKTexture;
	static textureWithDataSizeFlipped(pixelData: NSData, size: CGSize, flipped: boolean): SKTexture;
	static textureWithDataSizeRowLengthAlignment(pixelData: NSData, size: CGSize, rowLength: number, alignment: number): SKTexture;
	textureByApplyingCIFilter(filter: CIFilter): SKTexture;
	textureByGeneratingNormalMap(): SKTexture;
	textureByGeneratingNormalMapWithSmoothnessContrast(smoothness: number, contrast: number): SKTexture;
	textureRect(): CGRect;
	size(): CGSize;
	static preloadTexturesWithCompletionHandler(textures: NSArray, completionHandler: () => void): void;
	preloadWithCompletionHandler(completionHandler: () => void): void;
	init(): SKTexture;
	static new(): SKTexture;
	static allocWithZone(zone: any): SKTexture;
	static alloc(): SKTexture;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKUniform extends NSObject implements NSCopying, NSCoding {
	name: string;
	uniformType: number;
	textureValue: SKTexture;
	floatValue: number;
	constructor(name: string);
	constructor(name: string, texture: SKTexture);
	constructor(name: string, value: number);
	constructor();
	static uniformWithName(name: string): SKUniform;
	static uniformWithNameTexture(name: string, texture: SKTexture): SKUniform;
	static uniformWithNameFloat(name: string, value: number): SKUniform;
	initWithName(name: string): SKUniform;
	initWithNameTexture(name: string, texture: SKTexture): SKUniform;
	initWithNameFloat(name: string, value: number): SKUniform;
	init(): SKUniform;
	static new(): SKUniform;
	static allocWithZone(zone: any): SKUniform;
	static alloc(): SKUniform;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKShader extends NSObject implements NSCopying, NSCoding {
	source: string;
	uniforms: NSArray;
	constructor(source: string);
	constructor(source: string, uniforms: NSArray);
	constructor();
	initWithSource(source: string): SKShader;
	initWithSourceUniforms(source: string, uniforms: NSArray): SKShader;
	static shader(): SKShader;
	static shaderWithSource(source: string): SKShader;
	static shaderWithSourceUniforms(source: string, uniforms: NSArray): SKShader;
	static shaderWithFileNamed(name: string): SKShader;
	addUniform(uniform: SKUniform): void;
	uniformNamed(name: string): SKUniform;
	removeUniformNamed(name: string): void;
	init(): SKShader;
	static new(): SKShader;
	static allocWithZone(zone: any): SKShader;
	static alloc(): SKShader;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKEffectNode extends SKNode {
	filter: CIFilter;
	shouldCenterFilter: boolean;
	shouldEnableEffects: boolean;
	shouldRasterize: boolean;
	blendMode: number;
	shader: SKShader;
	constructor();
	static node(): SKEffectNode;
	static nodeWithFileNamed(filename: string): SKEffectNode;
	init(): SKEffectNode;
	static new(): SKEffectNode;
	static allocWithZone(zone: any): SKEffectNode;
	static alloc(): SKEffectNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKScene extends SKEffectNode {
	size: CGSize;
	scaleMode: number;
	backgroundColor: UIColor;
	delegate: any;
	anchorPoint: CGPoint;
	physicsWorld: SKPhysicsWorld;
	view: SKView;
	constructor(size: CGSize);
	constructor();
	initWithSize(size: CGSize): SKScene;
	static sceneWithSize(size: CGSize): SKScene;
	convertPointFromView(point: CGPoint): CGPoint;
	convertPointToView(point: CGPoint): CGPoint;
	update(currentTime: number): void;
	didEvaluateActions(): void;
	didSimulatePhysics(): void;
	didApplyConstraints(): void;
	didFinishUpdate(): void;
	didMoveToView(view: SKView): void;
	willMoveFromView(view: SKView): void;
	didChangeSize(oldSize: CGSize): void;
	static node(): SKScene;
	static nodeWithFileNamed(filename: string): SKScene;
	init(): SKScene;
	static new(): SKScene;
	static allocWithZone(zone: any): SKScene;
	static alloc(): SKScene;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKSpriteNode extends SKNode {
	texture: SKTexture;
	normalTexture: SKTexture;
	lightingBitMask: number;
	shadowCastBitMask: number;
	shadowedBitMask: number;
	centerRect: CGRect;
	colorBlendFactor: number;
	color: UIColor;
	blendMode: number;
	anchorPoint: CGPoint;
	size: CGSize;
	shader: SKShader;
	constructor(texture: SKTexture, color: UIColor, size: CGSize);
	constructor(texture: SKTexture);
	constructor(name: string);
	constructor(color: UIColor, size: CGSize);
	constructor();
	static spriteNodeWithTextureSize(texture: SKTexture, size: CGSize): SKSpriteNode;
	static spriteNodeWithTexture(texture: SKTexture): SKSpriteNode;
	static spriteNodeWithTextureNormalMap(texture: SKTexture, normalMap: SKTexture): SKSpriteNode;
	static spriteNodeWithImageNamed(name: string): SKSpriteNode;
	static spriteNodeWithImageNamedNormalMapped(name: string, generateNormalMap: boolean): SKSpriteNode;
	static spriteNodeWithColorSize(color: UIColor, size: CGSize): SKSpriteNode;
	initWithTextureColorSize(texture: SKTexture, color: UIColor, size: CGSize): SKSpriteNode;
	initWithTexture(texture: SKTexture): SKSpriteNode;
	initWithImageNamed(name: string): SKSpriteNode;
	initWithColorSize(color: UIColor, size: CGSize): SKSpriteNode;
	static node(): SKSpriteNode;
	static nodeWithFileNamed(filename: string): SKSpriteNode;
	init(): SKSpriteNode;
	static new(): SKSpriteNode;
	static allocWithZone(zone: any): SKSpriteNode;
	static alloc(): SKSpriteNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKKeyframeSequence extends NSObject implements NSCoding, NSCopying {
	interpolationMode: number;
	repeatMode: number;
	constructor(values: NSArray, times: NSArray);
	constructor(numItems: number);
	constructor();
	initWithKeyframeValuesTimes(values: NSArray, times: NSArray): SKKeyframeSequence;
	initWithCapacity(numItems: number): SKKeyframeSequence;
	count(): number;
	addKeyframeValueTime(value: any, time: number): void;
	removeLastKeyframe(): void;
	removeKeyframeAtIndex(index: number): void;
	setKeyframeValueForIndex(value: any, index: number): void;
	setKeyframeTimeForIndex(time: number, index: number): void;
	setKeyframeValueTimeForIndex(value: any, time: number, index: number): void;
	getKeyframeValueForIndex(index: number): any;
	getKeyframeTimeForIndex(index: number): number;
	sampleAtTime(time: number): any;
	init(): SKKeyframeSequence;
	static new(): SKKeyframeSequence;
	static allocWithZone(zone: any): SKKeyframeSequence;
	static alloc(): SKKeyframeSequence;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class SKEmitterNode extends SKNode {
	particleTexture: SKTexture;
	particleZPosition: number;
	particleZPositionRange: number;
	particleZPositionSpeed: number;
	particleBlendMode: number;
	particleColor: UIColor;
	particleColorRedRange: number;
	particleColorGreenRange: number;
	particleColorBlueRange: number;
	particleColorAlphaRange: number;
	particleColorRedSpeed: number;
	particleColorGreenSpeed: number;
	particleColorBlueSpeed: number;
	particleColorAlphaSpeed: number;
	particleColorSequence: SKKeyframeSequence;
	particleColorBlendFactor: number;
	particleColorBlendFactorRange: number;
	particleColorBlendFactorSpeed: number;
	particleColorBlendFactorSequence: SKKeyframeSequence;
	particlePosition: CGPoint;
	particlePositionRange: CGVector;
	particleSpeed: number;
	particleSpeedRange: number;
	emissionAngle: number;
	emissionAngleRange: number;
	xAcceleration: number;
	yAcceleration: number;
	particleBirthRate: number;
	numParticlesToEmit: number;
	particleLifetime: number;
	particleLifetimeRange: number;
	particleRotation: number;
	particleRotationRange: number;
	particleRotationSpeed: number;
	particleSize: CGSize;
	particleScale: number;
	particleScaleRange: number;
	particleScaleSpeed: number;
	particleScaleSequence: SKKeyframeSequence;
	particleAlpha: number;
	particleAlphaRange: number;
	particleAlphaSpeed: number;
	particleAlphaSequence: SKKeyframeSequence;
	particleAction: SKAction;
	fieldBitMask: number;
	targetNode: SKNode;
	shader: SKShader;
	constructor();
	advanceSimulationTime(sec: number): void;
	resetSimulation(): void;
	static node(): SKEmitterNode;
	static nodeWithFileNamed(filename: string): SKEmitterNode;
	init(): SKEmitterNode;
	static new(): SKEmitterNode;
	static allocWithZone(zone: any): SKEmitterNode;
	static alloc(): SKEmitterNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKShapeNode extends SKNode {
	path: any;
	strokeColor: UIColor;
	fillColor: UIColor;
	blendMode: number;
	antialiased: boolean;
	lineWidth: number;
	glowWidth: number;
	lineCap: number;
	lineJoin: number;
	miterLimit: number;
	lineLength: number;
	fillTexture: SKTexture;
	fillShader: SKShader;
	strokeTexture: SKTexture;
	strokeShader: SKShader;
	constructor();
	static shapeNodeWithPath(path: any): SKShapeNode;
	static shapeNodeWithPathCentered(path: any, centered: boolean): SKShapeNode;
	static shapeNodeWithRect(rect: CGRect): SKShapeNode;
	static shapeNodeWithRectOfSize(size: CGSize): SKShapeNode;
	static shapeNodeWithRectCornerRadius(rect: CGRect, cornerRadius: number): SKShapeNode;
	static shapeNodeWithRectOfSizeCornerRadius(size: CGSize, cornerRadius: number): SKShapeNode;
	static shapeNodeWithCircleOfRadius(radius: number): SKShapeNode;
	static shapeNodeWithEllipseInRect(rect: CGRect): SKShapeNode;
	static shapeNodeWithEllipseOfSize(size: CGSize): SKShapeNode;
	static shapeNodeWithPointsCount(points: any, numPoints: number): SKShapeNode;
	static shapeNodeWithSplinePointsCount(points: any, numPoints: number): SKShapeNode;
	static node(): SKShapeNode;
	static nodeWithFileNamed(filename: string): SKShapeNode;
	init(): SKShapeNode;
	static new(): SKShapeNode;
	static allocWithZone(zone: any): SKShapeNode;
	static alloc(): SKShapeNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKAction extends NSObject implements NSCopying, NSCoding {
	duration: number;
	timingMode: number;
	timingFunction: (arg1: number) => number;
	speed: number;
	constructor();
	reversedAction(): SKAction;
	static moveByDuration(delta: CGVector, sec: number): SKAction;
	static moveByXYDuration(deltaX: number, deltaY: number, sec: number): SKAction;
	static moveToDuration(location: CGPoint, sec: number): SKAction;
	static moveToXDuration(x: number, sec: number): SKAction;
	static moveToYDuration(y: number, sec: number): SKAction;
	static rotateByAngleDuration(radians: number, sec: number): SKAction;
	static rotateToAngleDuration(radians: number, sec: number): SKAction;
	static rotateToAngleDurationShortestUnitArc(radians: number, sec: number, shortestUnitArc: boolean): SKAction;
	static resizeByWidthHeightDuration(width: number, height: number, duration: number): SKAction;
	static resizeToWidthHeightDuration(width: number, height: number, duration: number): SKAction;
	static resizeToWidthDuration(width: number, duration: number): SKAction;
	static resizeToHeightDuration(height: number, duration: number): SKAction;
	static scaleByDuration(scale: number, sec: number): SKAction;
	static scaleXByYDuration(xScale: number, yScale: number, sec: number): SKAction;
	static scaleToDuration(scale: number, sec: number): SKAction;
	static scaleXToYDuration(xScale: number, yScale: number, sec: number): SKAction;
	static scaleXToDuration(scale: number, sec: number): SKAction;
	static scaleYToDuration(scale: number, sec: number): SKAction;
	static sequence(actions: NSArray): SKAction;
	static group(actions: NSArray): SKAction;
	static repeatActionCount(action: SKAction, count: number): SKAction;
	static repeatActionForever(action: SKAction): SKAction;
	static fadeInWithDuration(sec: number): SKAction;
	static fadeOutWithDuration(sec: number): SKAction;
	static fadeAlphaByDuration(factor: number, sec: number): SKAction;
	static fadeAlphaToDuration(alpha: number, sec: number): SKAction;
	static hide(): SKAction;
	static unhide(): SKAction;
	static setTexture(texture: SKTexture): SKAction;
	static setTextureResize(texture: SKTexture, resize: boolean): SKAction;
	static animateWithTexturesTimePerFrame(textures: NSArray, sec: number): SKAction;
	static animateWithTexturesTimePerFrameResizeRestore(textures: NSArray, sec: number, resize: boolean, restore: boolean): SKAction;
	static playSoundFileNamedWaitForCompletion(soundFile: string, wait: boolean): SKAction;
	static colorizeWithColorColorBlendFactorDuration(color: UIColor, colorBlendFactor: number, sec: number): SKAction;
	static colorizeWithColorBlendFactorDuration(colorBlendFactor: number, sec: number): SKAction;
	static falloffToDuration(falloff: number, sec: number): SKAction;
	static falloffByDuration(falloff: number, sec: number): SKAction;
	static followPathDuration(path: any, sec: number): SKAction;
	static followPathAsOffsetOrientToPathDuration(path: any, offset: boolean, orient: boolean, sec: number): SKAction;
	static followPathSpeed(path: any, speed: number): SKAction;
	static followPathAsOffsetOrientToPathSpeed(path: any, offset: boolean, orient: boolean, speed: number): SKAction;
	static speedByDuration(speed: number, sec: number): SKAction;
	static speedToDuration(speed: number, sec: number): SKAction;
	static reachToRootNodeDuration(position: CGPoint, root: SKNode, sec: number): SKAction;
	static reachToRootNodeVelocity(position: CGPoint, root: SKNode, velocity: number): SKAction;
	static reachToNodeRootNodeDuration(node: SKNode, root: SKNode, sec: number): SKAction;
	static reachToNodeRootNodeVelocity(node: SKNode, root: SKNode, velocity: number): SKAction;
	static strengthToDuration(strength: number, sec: number): SKAction;
	static strengthByDuration(strength: number, sec: number): SKAction;
	static waitForDuration(sec: number): SKAction;
	static waitForDurationWithRange(sec: number, durationRange: number): SKAction;
	static removeFromParent(): SKAction;
	static performSelectorOnTarget(selector: any, target: any): SKAction;
	static runBlock(block: () => void): SKAction;
	static runBlockQueue(block: () => void, queue: NSObject): SKAction;
	static runActionOnChildWithName(action: SKAction, name: string): SKAction;
	static customActionWithDurationActionBlock(seconds: number, block: (arg1: SKNode, arg2: number) => void): SKAction;
	init(): SKAction;
	static new(): SKAction;
	static allocWithZone(zone: any): SKAction;
	static alloc(): SKAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKFieldNode extends SKNode {
	region: SKRegion;
	strength: number;
	falloff: number;
	minimumRadius: number;
	enabled: boolean;
	exclusive: boolean;
	categoryBitMask: number;
	smoothness: number;
	animationSpeed: number;
	texture: SKTexture;
	constructor();
	static dragField(): SKFieldNode;
	static vortexField(): SKFieldNode;
	static radialGravityField(): SKFieldNode;
	static velocityFieldWithTexture(velocityTexture: SKTexture): SKFieldNode;
	static noiseFieldWithSmoothnessAnimationSpeed(smoothness: number, speed: number): SKFieldNode;
	static turbulenceFieldWithSmoothnessAnimationSpeed(smoothness: number, speed: number): SKFieldNode;
	static springField(): SKFieldNode;
	static electricField(): SKFieldNode;
	static magneticField(): SKFieldNode;
	static node(): SKFieldNode;
	static nodeWithFileNamed(filename: string): SKFieldNode;
	init(): SKFieldNode;
	static new(): SKFieldNode;
	static allocWithZone(zone: any): SKFieldNode;
	static alloc(): SKFieldNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKLabelNode extends SKNode {
	verticalAlignmentMode: number;
	horizontalAlignmentMode: number;
	fontName: string;
	text: string;
	fontSize: number;
	fontColor: UIColor;
	colorBlendFactor: number;
	color: UIColor;
	blendMode: number;
	constructor(fontName: string);
	constructor();
	static labelNodeWithText(text: string): SKLabelNode;
	static labelNodeWithFontNamed(fontName: string): SKLabelNode;
	initWithFontNamed(fontName: string): SKLabelNode;
	static node(): SKLabelNode;
	static nodeWithFileNamed(filename: string): SKLabelNode;
	init(): SKLabelNode;
	static new(): SKLabelNode;
	static allocWithZone(zone: any): SKLabelNode;
	static alloc(): SKLabelNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKVideoNode extends SKNode {
	size: CGSize;
	anchorPoint: CGPoint;
	constructor(player: AVPlayer);
	constructor(videoFile: string);
	constructor(url: NSURL);
	constructor();
	static videoNodeWithAVPlayer(player: AVPlayer): SKVideoNode;
	static videoNodeWithVideoFileNamed(videoFile: string): SKVideoNode;
	static videoNodeWithVideoURL(videoURL: NSURL): SKVideoNode;
	initWithAVPlayer(player: AVPlayer): SKVideoNode;
	initWithVideoFileNamed(videoFile: string): SKVideoNode;
	initWithVideoURL(url: NSURL): SKVideoNode;
	play(): void;
	pause(): void;
	static node(): SKVideoNode;
	static nodeWithFileNamed(filename: string): SKVideoNode;
	init(): SKVideoNode;
	static new(): SKVideoNode;
	static allocWithZone(zone: any): SKVideoNode;
	static alloc(): SKVideoNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKCropNode extends SKNode {
	maskNode: SKNode;
	constructor();
	static node(): SKCropNode;
	static nodeWithFileNamed(filename: string): SKCropNode;
	init(): SKCropNode;
	static new(): SKCropNode;
	static allocWithZone(zone: any): SKCropNode;
	static alloc(): SKCropNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKLightNode extends SKNode {
	enabled: boolean;
	lightColor: UIColor;
	ambientColor: UIColor;
	shadowColor: UIColor;
	falloff: number;
	categoryBitMask: number;
	constructor();
	static node(): SKLightNode;
	static nodeWithFileNamed(filename: string): SKLightNode;
	init(): SKLightNode;
	static new(): SKLightNode;
	static allocWithZone(zone: any): SKLightNode;
	static alloc(): SKLightNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SK3DNode extends SKNode {
	viewportSize: CGSize;
	scnScene: any;
	sceneTime: number;
	playing: boolean;
	loops: boolean;
	pointOfView: any;
	autoenablesDefaultLighting: boolean;
	constructor(viewportSize: CGSize);
	constructor();
	initWithViewportSize(viewportSize: CGSize): SK3DNode;
	static nodeWithViewportSize(viewportSize: CGSize): SK3DNode;
	hitTestOptions(thePoint: CGPoint, options: NSDictionary): NSArray;
	static node(): SK3DNode;
	static nodeWithFileNamed(filename: string): SK3DNode;
	init(): SK3DNode;
	static new(): SK3DNode;
	static allocWithZone(zone: any): SK3DNode;
	static alloc(): SK3DNode;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKRegion extends NSObject implements NSCopying, NSCoding {
	path: any;
	constructor(radius: number);
	constructor(size: CGSize);
	constructor(path: any);
	constructor();
	static infiniteRegion(): SKRegion;
	initWithRadius(radius: number): SKRegion;
	initWithSize(size: CGSize): SKRegion;
	initWithPath(path: any): SKRegion;
	inverseRegion(): SKRegion;
	regionByUnionWithRegion(region: SKRegion): SKRegion;
	regionByDifferenceFromRegion(region: SKRegion): SKRegion;
	regionByIntersectionWithRegion(region: SKRegion): SKRegion;
	containsPoint(point: CGPoint): boolean;
	init(): SKRegion;
	static new(): SKRegion;
	static allocWithZone(zone: any): SKRegion;
	static alloc(): SKRegion;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKView extends UIView {
	paused: boolean;
	showsFPS: boolean;
	showsDrawCount: boolean;
	showsNodeCount: boolean;
	showsQuadCount: boolean;
	showsPhysics: boolean;
	showsFields: boolean;
	asynchronous: boolean;
	allowsTransparency: boolean;
	ignoresSiblingOrder: boolean;
	shouldCullNonVisibleNodes: boolean;
	frameInterval: number;
	scene: SKScene;
	constructor(frame: CGRect);
	constructor();
	presentScene(scene: SKScene): void;
	presentSceneTransition(scene: SKScene, transition: SKTransition): void;
	textureFromNode(node: SKNode): SKTexture;
	textureFromNodeCrop(node: SKNode, crop: CGRect): SKTexture;
	convertPointToScene(point: CGPoint, scene: SKScene): CGPoint;
	convertPointFromScene(point: CGPoint, scene: SKScene): CGPoint;
	initWithFrame(frame: CGRect): SKView;
	init(): SKView;
	static new(): SKView;
	static allocWithZone(zone: any): SKView;
	static alloc(): SKView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKTransition extends NSObject {
	pausesIncomingScene: boolean;
	pausesOutgoingScene: boolean;
	constructor();
	static crossFadeWithDuration(sec: number): SKTransition;
	static fadeWithDuration(sec: number): SKTransition;
	static fadeWithColorDuration(color: UIColor, sec: number): SKTransition;
	static flipHorizontalWithDuration(sec: number): SKTransition;
	static flipVerticalWithDuration(sec: number): SKTransition;
	static revealWithDirectionDuration(direction: number, sec: number): SKTransition;
	static moveInWithDirectionDuration(direction: number, sec: number): SKTransition;
	static pushWithDirectionDuration(direction: number, sec: number): SKTransition;
	static doorsOpenHorizontalWithDuration(sec: number): SKTransition;
	static doorsOpenVerticalWithDuration(sec: number): SKTransition;
	static doorsCloseHorizontalWithDuration(sec: number): SKTransition;
	static doorsCloseVerticalWithDuration(sec: number): SKTransition;
	static doorwayWithDuration(sec: number): SKTransition;
	static transitionWithCIFilterDuration(filter: CIFilter, sec: number): SKTransition;
	init(): SKTransition;
	static new(): SKTransition;
	static allocWithZone(zone: any): SKTransition;
	static alloc(): SKTransition;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKMutableTexture extends SKTexture {
	constructor(size: CGSize);
	constructor(size: CGSize, format: number);
	constructor();
	initWithSize(size: CGSize): SKMutableTexture;
	static mutableTextureWithSize(size: CGSize): SKMutableTexture;
	initWithSizePixelFormat(size: CGSize, format: number): SKMutableTexture;
	modifyPixelDataWithBlock(block: (arg1: any, arg2: number) => void): void;
	static textureWithImageNamed(name: string): SKMutableTexture;
	static textureWithRectInTexture(rect: CGRect, texture: SKTexture): SKMutableTexture;
	static textureVectorNoiseWithSmoothnessSize(smoothness: number, size: CGSize): SKMutableTexture;
	static textureNoiseWithSmoothnessSizeGrayscale(smoothness: number, size: CGSize, grayscale: boolean): SKMutableTexture;
	static textureWithCGImage(image: any): SKMutableTexture;
	static textureWithImage(image: UIImage): SKMutableTexture;
	static textureWithDataSize(pixelData: NSData, size: CGSize): SKMutableTexture;
	static textureWithDataSizeFlipped(pixelData: NSData, size: CGSize, flipped: boolean): SKMutableTexture;
	static textureWithDataSizeRowLengthAlignment(pixelData: NSData, size: CGSize, rowLength: number, alignment: number): SKMutableTexture;
	textureByApplyingCIFilter(filter: CIFilter): SKMutableTexture;
	textureByGeneratingNormalMap(): SKMutableTexture;
	textureByGeneratingNormalMapWithSmoothnessContrast(smoothness: number, contrast: number): SKMutableTexture;
	init(): SKMutableTexture;
	static new(): SKMutableTexture;
	static allocWithZone(zone: any): SKMutableTexture;
	static alloc(): SKMutableTexture;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKTextureAtlas extends NSObject implements NSCoding {
	textureNames: NSArray;
	constructor();
	static atlasNamed(name: string): SKTextureAtlas;
	static atlasWithDictionary(properties: NSDictionary): SKTextureAtlas;
	textureNamed(name: string): SKTexture;
	static preloadTextureAtlasesWithCompletionHandler(textureAtlases: NSArray, completionHandler: () => void): void;
	preloadWithCompletionHandler(completionHandler: () => void): void;
	init(): SKTextureAtlas;
	static new(): SKTextureAtlas;
	static allocWithZone(zone: any): SKTextureAtlas;
	static alloc(): SKTextureAtlas;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKRange extends NSObject implements NSCoding, NSCopying {
	lowerLimit: number;
	upperLimit: number;
	constructor(lower: number, upper: number);
	constructor();
	initWithLowerLimitUpperLimit(lower: number, upper: number): SKRange;
	static rangeWithLowerLimitUpperLimit(lower: number, upper: number): SKRange;
	static rangeWithLowerLimit(lower: number): SKRange;
	static rangeWithUpperLimit(upper: number): SKRange;
	static rangeWithConstantValue(value: number): SKRange;
	static rangeWithValueVariance(value: number, variance: number): SKRange;
	static rangeWithNoLimits(): SKRange;
	init(): SKRange;
	static new(): SKRange;
	static allocWithZone(zone: any): SKRange;
	static alloc(): SKRange;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class SKConstraint extends NSObject implements NSCoding, NSCopying {
	enabled: boolean;
	referenceNode: SKNode;
	constructor();
	static positionX(range: SKRange): SKConstraint;
	static positionY(range: SKRange): SKConstraint;
	static positionXY(xRange: SKRange, yRange: SKRange): SKConstraint;
	static distanceToNode(range: SKRange, node: SKNode): SKConstraint;
	static distanceToPoint(range: SKRange, point: CGPoint): SKConstraint;
	static distanceToPointInNode(range: SKRange, point: CGPoint, node: SKNode): SKConstraint;
	static zRotation(zRange: SKRange): SKConstraint;
	static orientToNodeOffset(node: SKNode, radians: SKRange): SKConstraint;
	static orientToPointOffset(point: CGPoint, radians: SKRange): SKConstraint;
	static orientToPointInNodeOffset(point: CGPoint, node: SKNode, radians: SKRange): SKConstraint;
	init(): SKConstraint;
	static new(): SKConstraint;
	static allocWithZone(zone: any): SKConstraint;
	static alloc(): SKConstraint;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
	copyWithZone(zone: any): any;
}
declare class SKReachConstraints extends NSObject implements NSCoding {
	lowerAngleLimit: number;
	upperAngleLimit: number;
	constructor(lowerAngleLimit: number, upperAngleLimit: number);
	constructor();
	initWithLowerAngleLimitUpperAngleLimit(lowerAngleLimit: number, upperAngleLimit: number): SKReachConstraints;
	init(): SKReachConstraints;
	static new(): SKReachConstraints;
	static allocWithZone(zone: any): SKReachConstraints;
	static alloc(): SKReachConstraints;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKPhysicsBody extends NSObject implements NSCopying, NSCoding {
	dynamic: boolean;
	usesPreciseCollisionDetection: boolean;
	allowsRotation: boolean;
	pinned: boolean;
	resting: boolean;
	friction: number;
	charge: number;
	restitution: number;
	linearDamping: number;
	angularDamping: number;
	density: number;
	mass: number;
	area: number;
	affectedByGravity: boolean;
	fieldBitMask: number;
	categoryBitMask: number;
	collisionBitMask: number;
	contactTestBitMask: number;
	joints: NSArray;
	node: SKNode;
	velocity: CGVector;
	angularVelocity: number;
	constructor();
	static bodyWithCircleOfRadius(r: number): SKPhysicsBody;
	static bodyWithCircleOfRadiusCenter(r: number, center: CGPoint): SKPhysicsBody;
	static bodyWithRectangleOfSize(s: CGSize): SKPhysicsBody;
	static bodyWithRectangleOfSizeCenter(s: CGSize, center: CGPoint): SKPhysicsBody;
	static bodyWithPolygonFromPath(path: any): SKPhysicsBody;
	static bodyWithEdgeFromPointToPoint(p1: CGPoint, p2: CGPoint): SKPhysicsBody;
	static bodyWithEdgeChainFromPath(path: any): SKPhysicsBody;
	static bodyWithEdgeLoopFromPath(path: any): SKPhysicsBody;
	static bodyWithEdgeLoopFromRect(rect: CGRect): SKPhysicsBody;
	static bodyWithTextureSize(texture: SKTexture, size: CGSize): SKPhysicsBody;
	static bodyWithTextureAlphaThresholdSize(texture: SKTexture, alphaThreshold: number, size: CGSize): SKPhysicsBody;
	static bodyWithBodies(bodies: NSArray): SKPhysicsBody;
	applyForce(force: CGVector): void;
	applyForceAtPoint(force: CGVector, point: CGPoint): void;
	applyTorque(torque: number): void;
	applyImpulse(impulse: CGVector): void;
	applyImpulseAtPoint(impulse: CGVector, point: CGPoint): void;
	applyAngularImpulse(impulse: number): void;
	allContactedBodies(): NSArray;
	init(): SKPhysicsBody;
	static new(): SKPhysicsBody;
	static allocWithZone(zone: any): SKPhysicsBody;
	static alloc(): SKPhysicsBody;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKPhysicsJoint extends NSObject implements NSCoding {
	bodyA: SKPhysicsBody;
	bodyB: SKPhysicsBody;
	reactionForce: CGVector;
	reactionTorque: number;
	constructor();
	init(): SKPhysicsJoint;
	static new(): SKPhysicsJoint;
	static allocWithZone(zone: any): SKPhysicsJoint;
	static alloc(): SKPhysicsJoint;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKPhysicsJointPin extends SKPhysicsJoint {
	shouldEnableLimits: boolean;
	lowerAngleLimit: number;
	upperAngleLimit: number;
	frictionTorque: number;
	rotationSpeed: number;
	constructor();
	static jointWithBodyABodyBAnchor(bodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchor: CGPoint): SKPhysicsJointPin;
	init(): SKPhysicsJointPin;
	static new(): SKPhysicsJointPin;
	static allocWithZone(zone: any): SKPhysicsJointPin;
	static alloc(): SKPhysicsJointPin;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPhysicsJointSpring extends SKPhysicsJoint {
	damping: number;
	frequency: number;
	constructor();
	static jointWithBodyABodyBAnchorAAnchorB(bodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchorA: CGPoint, anchorB: CGPoint): SKPhysicsJointSpring;
	init(): SKPhysicsJointSpring;
	static new(): SKPhysicsJointSpring;
	static allocWithZone(zone: any): SKPhysicsJointSpring;
	static alloc(): SKPhysicsJointSpring;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPhysicsJointFixed extends SKPhysicsJoint {
	constructor();
	static jointWithBodyABodyBAnchor(bodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchor: CGPoint): SKPhysicsJointFixed;
	init(): SKPhysicsJointFixed;
	static new(): SKPhysicsJointFixed;
	static allocWithZone(zone: any): SKPhysicsJointFixed;
	static alloc(): SKPhysicsJointFixed;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPhysicsJointSliding extends SKPhysicsJoint {
	shouldEnableLimits: boolean;
	lowerDistanceLimit: number;
	upperDistanceLimit: number;
	constructor();
	static jointWithBodyABodyBAnchorAxis(bodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchor: CGPoint, axis: CGVector): SKPhysicsJointSliding;
	init(): SKPhysicsJointSliding;
	static new(): SKPhysicsJointSliding;
	static allocWithZone(zone: any): SKPhysicsJointSliding;
	static alloc(): SKPhysicsJointSliding;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPhysicsJointLimit extends SKPhysicsJoint {
	maxLength: number;
	constructor();
	static jointWithBodyABodyBAnchorAAnchorB(bodyA: SKPhysicsBody, bodyB: SKPhysicsBody, anchorA: CGPoint, anchorB: CGPoint): SKPhysicsJointLimit;
	init(): SKPhysicsJointLimit;
	static new(): SKPhysicsJointLimit;
	static allocWithZone(zone: any): SKPhysicsJointLimit;
	static alloc(): SKPhysicsJointLimit;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPhysicsContact extends NSObject {
	bodyA: SKPhysicsBody;
	bodyB: SKPhysicsBody;
	contactPoint: CGPoint;
	contactNormal: CGVector;
	collisionImpulse: number;
	constructor();
	init(): SKPhysicsContact;
	static new(): SKPhysicsContact;
	static allocWithZone(zone: any): SKPhysicsContact;
	static alloc(): SKPhysicsContact;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPhysicsWorld extends NSObject implements NSCoding {
	gravity: CGVector;
	speed: number;
	contactDelegate: any;
	constructor();
	addJoint(joint: SKPhysicsJoint): void;
	removeJoint(joint: SKPhysicsJoint): void;
	removeAllJoints(): void;
	bodyAtPoint(point: CGPoint): SKPhysicsBody;
	bodyInRect(rect: CGRect): SKPhysicsBody;
	bodyAlongRayStartEnd(start: CGPoint, end: CGPoint): SKPhysicsBody;
	enumerateBodiesAtPointUsingBlock(point: CGPoint, block: (arg1: SKPhysicsBody, arg2: any) => void): void;
	enumerateBodiesInRectUsingBlock(rect: CGRect, block: (arg1: SKPhysicsBody, arg2: any) => void): void;
	enumerateBodiesAlongRayStartEndUsingBlock(start: CGPoint, end: CGPoint, block: (arg1: SKPhysicsBody, arg2: CGPoint, arg3: CGVector, arg4: any) => void): void;
	init(): SKPhysicsWorld;
	static new(): SKPhysicsWorld;
	static allocWithZone(zone: any): SKPhysicsWorld;
	static alloc(): SKPhysicsWorld;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
declare class SKDownload extends NSObject {
	downloadState: number;
	contentLength: number;
	contentIdentifier: string;
	contentURL: NSURL;
	contentVersion: string;
	error: NSError;
	progress: number;
	timeRemaining: number;
	transaction: SKPaymentTransaction;
	constructor();
	init(): SKDownload;
	static new(): SKDownload;
	static allocWithZone(zone: any): SKDownload;
	static alloc(): SKDownload;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPayment extends NSObject implements NSCopying, NSMutableCopying {
	productIdentifier: string;
	requestData: NSData;
	quantity: number;
	applicationUsername: string;
	constructor();
	static paymentWithProduct(product: SKProduct): SKPayment;
	static paymentWithProductIdentifier(identifier: string): any;
	init(): SKPayment;
	static new(): SKPayment;
	static allocWithZone(zone: any): SKPayment;
	static alloc(): SKPayment;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
	mutableCopyWithZone(zone: any): any;
}
declare class SKMutablePayment extends SKPayment {
	applicationUsername: string;
	productIdentifier: string;
	quantity: number;
	requestData: NSData;
	constructor();
	static paymentWithProduct(product: SKProduct): SKMutablePayment;
	init(): SKMutablePayment;
	static new(): SKMutablePayment;
	static allocWithZone(zone: any): SKMutablePayment;
	static alloc(): SKMutablePayment;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPaymentQueue extends NSObject {
	transactions: NSArray;
	constructor();
	static defaultQueue(): SKPaymentQueue;
	static canMakePayments(): boolean;
	addPayment(payment: SKPayment): void;
	restoreCompletedTransactions(): void;
	restoreCompletedTransactionsWithApplicationUsername(username: string): void;
	finishTransaction(transaction: SKPaymentTransaction): void;
	startDownloads(downloads: NSArray): void;
	pauseDownloads(downloads: NSArray): void;
	resumeDownloads(downloads: NSArray): void;
	cancelDownloads(downloads: NSArray): void;
	addTransactionObserver(observer: any): void;
	removeTransactionObserver(observer: any): void;
	init(): SKPaymentQueue;
	static new(): SKPaymentQueue;
	static allocWithZone(zone: any): SKPaymentQueue;
	static alloc(): SKPaymentQueue;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKPaymentTransaction extends NSObject {
	error: NSError;
	originalTransaction: SKPaymentTransaction;
	payment: SKPayment;
	downloads: NSArray;
	transactionDate: NSDate;
	transactionIdentifier: string;
	transactionReceipt: NSData;
	transactionState: number;
	constructor();
	init(): SKPaymentTransaction;
	static new(): SKPaymentTransaction;
	static allocWithZone(zone: any): SKPaymentTransaction;
	static alloc(): SKPaymentTransaction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKProduct extends NSObject {
	localizedDescription: string;
	localizedTitle: string;
	price: NSDecimalNumber;
	priceLocale: NSLocale;
	productIdentifier: string;
	downloadable: boolean;
	downloadContentLengths: NSArray;
	downloadContentVersion: string;
	constructor();
	init(): SKProduct;
	static new(): SKProduct;
	static allocWithZone(zone: any): SKProduct;
	static alloc(): SKProduct;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKRequest extends NSObject {
	delegate: any;
	constructor();
	cancel(): void;
	start(): void;
	init(): SKRequest;
	static new(): SKRequest;
	static allocWithZone(zone: any): SKRequest;
	static alloc(): SKRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKProductsRequest extends SKRequest {
	constructor(productIdentifiers: NSSet);
	constructor();
	initWithProductIdentifiers(productIdentifiers: NSSet): SKProductsRequest;
	init(): SKProductsRequest;
	static new(): SKProductsRequest;
	static allocWithZone(zone: any): SKProductsRequest;
	static alloc(): SKProductsRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKProductsResponse extends NSObject {
	products: NSArray;
	invalidProductIdentifiers: NSArray;
	constructor();
	init(): SKProductsResponse;
	static new(): SKProductsResponse;
	static allocWithZone(zone: any): SKProductsResponse;
	static alloc(): SKProductsResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKReceiptRefreshRequest extends SKRequest {
	receiptProperties: NSDictionary;
	constructor(properties: NSDictionary);
	constructor();
	initWithReceiptProperties(properties: NSDictionary): SKReceiptRefreshRequest;
	init(): SKReceiptRefreshRequest;
	static new(): SKReceiptRefreshRequest;
	static allocWithZone(zone: any): SKReceiptRefreshRequest;
	static alloc(): SKReceiptRefreshRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class SKStoreProductViewController extends UIViewController {
	delegate: any;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	loadProductWithParametersCompletionBlock(parameters: NSDictionary, block: (arg1: boolean, arg2: NSError) => void): void;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): SKStoreProductViewController;
	init(): SKStoreProductViewController;
	static new(): SKStoreProductViewController;
	static allocWithZone(zone: any): SKStoreProductViewController;
	static alloc(): SKStoreProductViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class TWRequest extends NSObject {
	account: ACAccount;
	requestMethod: number;
	URL: NSURL;
	parameters: NSDictionary;
	constructor(url: NSURL, parameters: NSDictionary, requestMethod: number);
	constructor();
	initWithURLParametersRequestMethod(url: NSURL, parameters: NSDictionary, requestMethod: number): TWRequest;
	addMultiPartDataWithNameType(data: NSData, name: string, type: string): void;
	signedURLRequest(): NSURLRequest;
	performRequestWithHandler(handler: (arg1: NSData, arg2: NSHTTPURLResponse, arg3: NSError) => void): void;
	init(): TWRequest;
	static new(): TWRequest;
	static allocWithZone(zone: any): TWRequest;
	static alloc(): TWRequest;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class TWTweetComposeViewController extends UIViewController {
	completionHandler: (arg1: number) => void;
	constructor(nibNameOrNil: string, nibBundleOrNil: NSBundle);
	constructor();
	static canSendTweet(): boolean;
	setInitialText(text: string): boolean;
	addImage(image: UIImage): boolean;
	removeAllImages(): boolean;
	addURL(url: NSURL): boolean;
	removeAllURLs(): boolean;
	initWithNibNameBundle(nibNameOrNil: string, nibBundleOrNil: NSBundle): TWTweetComposeViewController;
	init(): TWTweetComposeViewController;
	static new(): TWTweetComposeViewController;
	static allocWithZone(zone: any): TWTweetComposeViewController;
	static alloc(): TWTweetComposeViewController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKBackForwardListItem extends NSObject {
	URL: NSURL;
	title: string;
	initialURL: NSURL;
	constructor();
	init(): WKBackForwardListItem;
	static new(): WKBackForwardListItem;
	static allocWithZone(zone: any): WKBackForwardListItem;
	static alloc(): WKBackForwardListItem;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKBackForwardList extends NSObject {
	currentItem: WKBackForwardListItem;
	backItem: WKBackForwardListItem;
	forwardItem: WKBackForwardListItem;
	backList: NSArray;
	forwardList: NSArray;
	constructor();
	itemAtIndex(index: number): WKBackForwardListItem;
	init(): WKBackForwardList;
	static new(): WKBackForwardList;
	static allocWithZone(zone: any): WKBackForwardList;
	static alloc(): WKBackForwardList;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKFrameInfo extends NSObject implements NSCopying {
	mainFrame: boolean;
	request: NSURLRequest;
	constructor();
	init(): WKFrameInfo;
	static new(): WKFrameInfo;
	static allocWithZone(zone: any): WKFrameInfo;
	static alloc(): WKFrameInfo;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class WKNavigation extends NSObject {
	constructor();
	init(): WKNavigation;
	static new(): WKNavigation;
	static allocWithZone(zone: any): WKNavigation;
	static alloc(): WKNavigation;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKNavigationAction extends NSObject {
	sourceFrame: WKFrameInfo;
	targetFrame: WKFrameInfo;
	navigationType: number;
	request: NSURLRequest;
	constructor();
	init(): WKNavigationAction;
	static new(): WKNavigationAction;
	static allocWithZone(zone: any): WKNavigationAction;
	static alloc(): WKNavigationAction;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKNavigationResponse extends NSObject {
	forMainFrame: boolean;
	response: NSURLResponse;
	canShowMIMEType: boolean;
	constructor();
	init(): WKNavigationResponse;
	static new(): WKNavigationResponse;
	static allocWithZone(zone: any): WKNavigationResponse;
	static alloc(): WKNavigationResponse;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKPreferences extends NSObject {
	minimumFontSize: number;
	javaScriptEnabled: boolean;
	javaScriptCanOpenWindowsAutomatically: boolean;
	constructor();
	init(): WKPreferences;
	static new(): WKPreferences;
	static allocWithZone(zone: any): WKPreferences;
	static alloc(): WKPreferences;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKProcessPool extends NSObject {
	constructor();
	init(): WKProcessPool;
	static new(): WKProcessPool;
	static allocWithZone(zone: any): WKProcessPool;
	static alloc(): WKProcessPool;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKScriptMessage extends NSObject {
	body: any;
	webView: WKWebView;
	frameInfo: WKFrameInfo;
	name: string;
	constructor();
	init(): WKScriptMessage;
	static new(): WKScriptMessage;
	static allocWithZone(zone: any): WKScriptMessage;
	static alloc(): WKScriptMessage;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKUserContentController extends NSObject {
	userScripts: NSArray;
	constructor();
	addUserScript(userScript: WKUserScript): void;
	removeAllUserScripts(): void;
	addScriptMessageHandlerName(scriptMessageHandler: any, name: string): void;
	removeScriptMessageHandlerForName(name: string): void;
	init(): WKUserContentController;
	static new(): WKUserContentController;
	static allocWithZone(zone: any): WKUserContentController;
	static alloc(): WKUserContentController;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKUserScript extends NSObject implements NSCopying {
	source: string;
	injectionTime: number;
	forMainFrameOnly: boolean;
	constructor(source: string, injectionTime: number, forMainFrameOnly: boolean);
	constructor();
	initWithSourceInjectionTimeForMainFrameOnly(source: string, injectionTime: number, forMainFrameOnly: boolean): WKUserScript;
	init(): WKUserScript;
	static new(): WKUserScript;
	static allocWithZone(zone: any): WKUserScript;
	static alloc(): WKUserScript;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class WKWebView extends UIView {
	configuration: WKWebViewConfiguration;
	navigationDelegate: any;
	UIDelegate: any;
	backForwardList: WKBackForwardList;
	title: string;
	URL: NSURL;
	loading: boolean;
	estimatedProgress: number;
	hasOnlySecureContent: boolean;
	canGoBack: boolean;
	canGoForward: boolean;
	allowsBackForwardNavigationGestures: boolean;
	scrollView: UIScrollView;
	constructor(frame: CGRect, configuration: WKWebViewConfiguration);
	constructor(frame: CGRect);
	constructor();
	initWithFrameConfiguration(frame: CGRect, configuration: WKWebViewConfiguration): WKWebView;
	loadRequest(request: NSURLRequest): WKNavigation;
	loadHTMLStringBaseURL(string: string, baseURL: NSURL): WKNavigation;
	goToBackForwardListItem(item: WKBackForwardListItem): WKNavigation;
	goBack(): WKNavigation;
	goForward(): WKNavigation;
	reload(): WKNavigation;
	reloadFromOrigin(): WKNavigation;
	stopLoading(): void;
	evaluateJavaScriptCompletionHandler(javaScriptString: string, completionHandler: (arg1: any, arg2: NSError) => void): void;
	initWithFrame(frame: CGRect): WKWebView;
	init(): WKWebView;
	static new(): WKWebView;
	static allocWithZone(zone: any): WKWebView;
	static alloc(): WKWebView;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
declare class WKWebViewConfiguration extends NSObject implements NSCopying {
	processPool: WKProcessPool;
	preferences: WKPreferences;
	userContentController: WKUserContentController;
	suppressesIncrementalRendering: boolean;
	allowsInlineMediaPlayback: boolean;
	mediaPlaybackRequiresUserAction: boolean;
	mediaPlaybackAllowsAirPlay: boolean;
	selectionGranularity: number;
	constructor();
	init(): WKWebViewConfiguration;
	static new(): WKWebViewConfiguration;
	static allocWithZone(zone: any): WKWebViewConfiguration;
	static alloc(): WKWebViewConfiguration;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
	copyWithZone(zone: any): any;
}
declare class WKWindowFeatures extends NSObject {
	menuBarVisibility: NSNumber;
	statusBarVisibility: NSNumber;
	toolbarsVisibility: NSNumber;
	allowsResizing: NSNumber;
	x: NSNumber;
	y: NSNumber;
	width: NSNumber;
	height: NSNumber;
	constructor();
	init(): WKWindowFeatures;
	static new(): WKWindowFeatures;
	static allocWithZone(zone: any): WKWindowFeatures;
	static alloc(): WKWindowFeatures;
	static extend(methods: any, exposedMethods?: {name?: string; protocols?: any[]; exposedMethods?: {[name: string]: string}}): any;
}
interface NSObjectProtocol {
	hash: number;
	superclass: any;
	description: string;
	debugDescription: string;
	isEqual(object: any): boolean;
	class(): any;
	self(): any;
	performSelector(aSelector: any): any;
	performSelectorWithObject(aSelector: any, object: any): any;
	performSelectorWithObjectWithObject(aSelector: any, object1: any, object2: any): any;
	isProxy(): boolean;
	isKindOfClass(aClass: any): boolean;
	isMemberOfClass(aClass: any): boolean;
	conformsToProtocol(aProtocol: any): boolean;
	respondsToSelector(aSelector: any): boolean;
	retain(): any;
	release(): void;
	autorelease(): any;
	retainCount(): number;
	zone(): any;
}
interface OS_dispatch_object {
}
interface OS_dispatch_queue {
}
interface OS_dispatch_queue_attr {
}
interface OS_dispatch_source {
}
interface OS_dispatch_group {
}
interface OS_dispatch_semaphore {
}
interface OS_dispatch_dataProtocol {
}
interface OS_dispatch_io {
}
interface NSCopying {
	copyWithZone(zone: any): any;
}
interface NSMutableCopying {
	mutableCopyWithZone(zone: any): any;
}
interface NSCoding {
	encodeWithCoder(aCoder: NSCoder): void;
	initWithCoder(aDecoder: NSCoder): any;
}
interface NSSecureCoding {
}
interface NSDiscardableContent {
	beginContentAccess(): boolean;
	endContentAccess(): void;
	discardContentIfPossible(): void;
	isContentDiscarded(): boolean;
}
interface NSFastEnumeration {
	countByEnumeratingWithStateObjectsCount(state: any, buffer: any, len: number): number;
}
interface NSDecimalNumberBehaviors {
	roundingMode(): number;
	scale(): number;
	exceptionDuringOperationErrorLeftOperandRightOperand(operation: any, error: number, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber): NSDecimalNumber;
}
interface NSFileManagerDelegate {
	fileManagerShouldCopyItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;
	fileManagerShouldCopyItemAtURLToURL?(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
	fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;
	fileManagerShouldProceedAfterErrorCopyingItemAtURLToURL?(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
	fileManagerShouldMoveItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;
	fileManagerShouldMoveItemAtURLToURL?(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
	fileManagerShouldProceedAfterErrorMovingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;
	fileManagerShouldProceedAfterErrorMovingItemAtURLToURL?(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
	fileManagerShouldLinkItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;
	fileManagerShouldLinkItemAtURLToURL?(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;
	fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;
	fileManagerShouldProceedAfterErrorLinkingItemAtURLToURL?(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;
	fileManagerShouldRemoveItemAtPath?(fileManager: NSFileManager, path: string): boolean;
	fileManagerShouldRemoveItemAtURL?(fileManager: NSFileManager, URL: NSURL): boolean;
	fileManagerShouldProceedAfterErrorRemovingItemAtPath?(fileManager: NSFileManager, error: NSError, path: string): boolean;
	fileManagerShouldProceedAfterErrorRemovingItemAtURL?(fileManager: NSFileManager, error: NSError, URL: NSURL): boolean;
}
interface NSKeyedArchiverDelegate {
	archiverWillEncodeObject?(archiver: NSKeyedArchiver, object: any): any;
	archiverDidEncodeObject?(archiver: NSKeyedArchiver, object: any): void;
	archiverWillReplaceObjectWithObject?(archiver: NSKeyedArchiver, object: any, newObject: any): void;
	archiverWillFinish?(archiver: NSKeyedArchiver): void;
	archiverDidFinish?(archiver: NSKeyedArchiver): void;
}
interface NSKeyedUnarchiverDelegate {
	unarchiverCannotDecodeObjectOfClassNameOriginalClasses?(unarchiver: NSKeyedUnarchiver, name: string, classNames: NSArray): any;
	unarchiverDidDecodeObject?(unarchiver: NSKeyedUnarchiver, object: any): any;
	unarchiverWillReplaceObjectWithObject?(unarchiver: NSKeyedUnarchiver, object: any, newObject: any): void;
	unarchiverWillFinish?(unarchiver: NSKeyedUnarchiver): void;
	unarchiverDidFinish?(unarchiver: NSKeyedUnarchiver): void;
}
interface NSLocking {
	lock(): void;
	unlock(): void;
}
interface NSPortDelegate {
	handlePortMessage?(message: any): void;
}
interface NSMachPortDelegate {
	handleMachMessage?(msg: any): void;
}
interface NSStreamDelegate {
	streamHandleEvent?(aStream: NSStream, eventCode: number): void;
}
interface NSURLAuthenticationChallengeSender {
	useCredentialForAuthenticationChallenge(credential: NSURLCredential, challenge: NSURLAuthenticationChallenge): void;
	continueWithoutCredentialForAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
	cancelAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;
	performDefaultHandlingForAuthenticationChallenge?(challenge: NSURLAuthenticationChallenge): void;
	rejectProtectionSpaceAndContinueWithChallenge?(challenge: NSURLAuthenticationChallenge): void;
}
interface NSURLConnectionDelegate {
	connectionDidFailWithError?(connection: NSURLConnection, error: NSError): void;
	connectionShouldUseCredentialStorage?(connection: NSURLConnection): boolean;
	connectionWillSendRequestForAuthenticationChallenge?(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
	connectionCanAuthenticateAgainstProtectionSpace?(connection: NSURLConnection, protectionSpace: NSURLProtectionSpace): boolean;
	connectionDidReceiveAuthenticationChallenge?(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
	connectionDidCancelAuthenticationChallenge?(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
}
interface NSURLConnectionDataDelegate {
	connectionWillSendRequestRedirectResponse?(connection: NSURLConnection, request: NSURLRequest, response: NSURLResponse): NSURLRequest;
	connectionDidReceiveResponse?(connection: NSURLConnection, response: NSURLResponse): void;
	connectionDidReceiveData?(connection: NSURLConnection, data: NSData): void;
	connectionNeedNewBodyStream?(connection: NSURLConnection, request: NSURLRequest): NSInputStream;
	connectionDidSendBodyDataTotalBytesWrittenTotalBytesExpectedToWrite?(connection: NSURLConnection, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
	connectionWillCacheResponse?(connection: NSURLConnection, cachedResponse: NSCachedURLResponse): NSCachedURLResponse;
	connectionDidFinishLoading?(connection: NSURLConnection): void;
}
interface NSURLConnectionDownloadDelegate {
	connectionDidWriteDataTotalBytesWrittenExpectedTotalBytes?(connection: NSURLConnection, bytesWritten: number, totalBytesWritten: number, expectedTotalBytes: number): void;
	connectionDidResumeDownloadingTotalBytesWrittenExpectedTotalBytes?(connection: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;
	connectionDidFinishDownloadingDestinationURL(connection: NSURLConnection, destinationURL: NSURL): void;
}
interface NSURLProtocolClient {
	URLProtocolWasRedirectedToRequestRedirectResponse(protocol: NSURLProtocol, request: NSURLRequest, redirectResponse: NSURLResponse): void;
	URLProtocolCachedResponseIsValid(protocol: NSURLProtocol, cachedResponse: NSCachedURLResponse): void;
	URLProtocolDidReceiveResponseCacheStoragePolicy(protocol: NSURLProtocol, response: NSURLResponse, policy: number): void;
	URLProtocolDidLoadData(protocol: NSURLProtocol, data: NSData): void;
	URLProtocolDidFinishLoading(protocol: NSURLProtocol): void;
	URLProtocolDidFailWithError(protocol: NSURLProtocol, error: NSError): void;
	URLProtocolDidReceiveAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
	URLProtocolDidCancelAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
}
interface NSXMLParserDelegate {
	parserDidStartDocument?(parser: NSXMLParser): void;
	parserDidEndDocument?(parser: NSXMLParser): void;
	parserFoundNotationDeclarationWithNamePublicIDSystemID?(parser: NSXMLParser, name: string, publicID: string, systemID: string): void;
	parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName?(parser: NSXMLParser, name: string, publicID: string, systemID: string, notationName: string): void;
	parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue?(parser: NSXMLParser, attributeName: string, elementName: string, type: string, defaultValue: string): void;
	parserFoundElementDeclarationWithNameModel?(parser: NSXMLParser, elementName: string, model: string): void;
	parserFoundInternalEntityDeclarationWithNameValue?(parser: NSXMLParser, name: string, value: string): void;
	parserFoundExternalEntityDeclarationWithNamePublicIDSystemID?(parser: NSXMLParser, name: string, publicID: string, systemID: string): void;
	parserDidStartElementNamespaceURIQualifiedNameAttributes?(parser: NSXMLParser, elementName: string, namespaceURI: string, qName: string, attributeDict: NSDictionary): void;
	parserDidEndElementNamespaceURIQualifiedName?(parser: NSXMLParser, elementName: string, namespaceURI: string, qName: string): void;
	parserDidStartMappingPrefixToURI?(parser: NSXMLParser, prefix: string, namespaceURI: string): void;
	parserDidEndMappingPrefix?(parser: NSXMLParser, prefix: string): void;
	parserFoundCharacters?(parser: NSXMLParser, string: string): void;
	parserFoundIgnorableWhitespace?(parser: NSXMLParser, whitespaceString: string): void;
	parserFoundProcessingInstructionWithTargetData?(parser: NSXMLParser, target: string, data: string): void;
	parserFoundComment?(parser: NSXMLParser, comment: string): void;
	parserFoundCDATA?(parser: NSXMLParser, CDATABlock: NSData): void;
	parserResolveExternalEntityNameSystemID?(parser: NSXMLParser, name: string, systemID: string): NSData;
	parserParseErrorOccurred?(parser: NSXMLParser, parseError: NSError): void;
	parserValidationErrorOccurred?(parser: NSXMLParser, validationError: NSError): void;
}
interface NSCacheDelegate {
	cacheWillEvictObject?(cache: NSCache, obj: any): void;
}
interface NSExtensionRequestHandling {
	beginRequestWithExtensionContext(context: NSExtensionContext): void;
}
interface NSFilePresenter {
	presentedItemURL: NSURL;
	presentedItemOperationQueue: NSOperationQueue;
	relinquishPresentedItemToReader?(reader: (arg1: () => void) => void): void;
	relinquishPresentedItemToWriter?(writer: (arg1: () => void) => void): void;
	savePresentedItemChangesWithCompletionHandler?(completionHandler: (arg1: NSError) => void): void;
	accommodatePresentedItemDeletionWithCompletionHandler?(completionHandler: (arg1: NSError) => void): void;
	presentedItemDidMoveToURL?(newURL: NSURL): void;
	presentedItemDidChange?(): void;
	presentedItemDidGainVersion?(version: NSFileVersion): void;
	presentedItemDidLoseVersion?(version: NSFileVersion): void;
	presentedItemDidResolveConflictVersion?(version: NSFileVersion): void;
	accommodatePresentedSubitemDeletionAtURLCompletionHandler?(url: NSURL, completionHandler: (arg1: NSError) => void): void;
	presentedSubitemDidAppearAtURL?(url: NSURL): void;
	presentedSubitemAtURLDidMoveToURL?(oldURL: NSURL, newURL: NSURL): void;
	presentedSubitemDidChangeAtURL?(url: NSURL): void;
	presentedSubitemAtURLDidGainVersion?(url: NSURL, version: NSFileVersion): void;
	presentedSubitemAtURLDidLoseVersion?(url: NSURL, version: NSFileVersion): void;
	presentedSubitemAtURLDidResolveConflictVersion?(url: NSURL, version: NSFileVersion): void;
}
interface NSMetadataQueryDelegate {
	metadataQueryReplacementObjectForResultObject?(query: NSMetadataQuery, result: NSMetadataItem): any;
	metadataQueryReplacementValueForAttributeValue?(query: NSMetadataQuery, attrName: string, attrValue: any): any;
}
interface NSNetServiceDelegate {
	netServiceWillPublish?(sender: NSNetService): void;
	netServiceDidPublish?(sender: NSNetService): void;
	netServiceDidNotPublish?(sender: NSNetService, errorDict: NSDictionary): void;
	netServiceWillResolve?(sender: NSNetService): void;
	netServiceDidResolveAddress?(sender: NSNetService): void;
	netServiceDidNotResolve?(sender: NSNetService, errorDict: NSDictionary): void;
	netServiceDidStop?(sender: NSNetService): void;
	netServiceDidUpdateTXTRecordData?(sender: NSNetService, data: NSData): void;
	netServiceDidAcceptConnectionWithInputStreamOutputStream?(sender: NSNetService, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}
interface NSNetServiceBrowserDelegate {
	netServiceBrowserWillSearch?(aNetServiceBrowser: NSNetServiceBrowser): void;
	netServiceBrowserDidStopSearch?(aNetServiceBrowser: NSNetServiceBrowser): void;
	netServiceBrowserDidNotSearch?(aNetServiceBrowser: NSNetServiceBrowser, errorDict: NSDictionary): void;
	netServiceBrowserDidFindDomainMoreComing?(aNetServiceBrowser: NSNetServiceBrowser, domainString: string, moreComing: boolean): void;
	netServiceBrowserDidFindServiceMoreComing?(aNetServiceBrowser: NSNetServiceBrowser, aNetService: NSNetService, moreComing: boolean): void;
	netServiceBrowserDidRemoveDomainMoreComing?(aNetServiceBrowser: NSNetServiceBrowser, domainString: string, moreComing: boolean): void;
	netServiceBrowserDidRemoveServiceMoreComing?(aNetServiceBrowser: NSNetServiceBrowser, aNetService: NSNetService, moreComing: boolean): void;
}
interface NSURLSessionDelegate {
	URLSessionDidBecomeInvalidWithError?(session: NSURLSession, error: NSError): void;
	URLSessionDidReceiveChallengeCompletionHandler?(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: (arg1: number, arg2: NSURLCredential) => void): void;
	URLSessionDidFinishEventsForBackgroundURLSession?(session: NSURLSession): void;
}
interface NSURLSessionTaskDelegate {
	URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler?(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: (arg1: NSURLRequest) => void): void;
	URLSessionTaskDidReceiveChallengeCompletionHandler?(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: (arg1: number, arg2: NSURLCredential) => void): void;
	URLSessionTaskNeedNewBodyStream?(session: NSURLSession, task: NSURLSessionTask, completionHandler: (arg1: NSInputStream) => void): void;
	URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend?(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;
	URLSessionTaskDidCompleteWithError?(session: NSURLSession, task: NSURLSessionTask, error: NSError): void;
}
interface NSURLSessionDataDelegate {
	URLSessionDataTaskDidReceiveResponseCompletionHandler?(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: (arg1: number) => void): void;
	URLSessionDataTaskDidBecomeDownloadTask?(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;
	URLSessionDataTaskDidReceiveData?(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;
	URLSessionDataTaskWillCacheResponseCompletionHandler?(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: (arg1: NSCachedURLResponse) => void): void;
}
interface NSURLSessionDownloadDelegate {
	URLSessionDownloadTaskDidFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;
	URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite?(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;
	URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes?(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
}
interface NSUserActivityDelegate {
	userActivityWillSave?(userActivity: NSUserActivity): void;
	userActivityWasContinued?(userActivity: NSUserActivity): void;
	userActivityDidReceiveInputStreamOutputStream?(userActivity: NSUserActivity, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}
interface UIInputViewAudioFeedback {
	enableInputClicksWhenVisible: boolean;
}
interface UIAppearanceContainer {
}
interface UIAppearance {
}
interface UIDynamicItem {
	center: CGPoint;
	bounds: CGRect;
	transform: CGAffineTransform;
}
interface UILayoutSupport {
	length: number;
}
interface UITraitEnvironment {
	traitCollection: UITraitCollection;
	traitCollectionDidChange(previousTraitCollection: UITraitCollection): void;
}
interface UICoordinateSpace {
	bounds: CGRect;
	convertPointToCoordinateSpace(point: CGPoint, coordinateSpace: any): CGPoint;
	convertPointFromCoordinateSpace(point: CGPoint, coordinateSpace: any): CGPoint;
	convertRectToCoordinateSpace(rect: CGRect, coordinateSpace: any): CGRect;
	convertRectFromCoordinateSpace(rect: CGRect, coordinateSpace: any): CGRect;
}
interface UITextInputTraits {
	autocapitalizationType: number;
	autocorrectionType: number;
	spellCheckingType: number;
	keyboardType: number;
	keyboardAppearance: number;
	returnKeyType: number;
	enablesReturnKeyAutomatically: boolean;
	secureTextEntry: boolean;
}
interface UIKeyInput {
	hasText(): boolean;
	insertText(text: string): void;
	deleteBackward(): void;
}
interface UITextInput {
	selectedTextRange: UITextRange;
	markedTextRange: UITextRange;
	markedTextStyle: NSDictionary;
	beginningOfDocument: UITextPosition;
	endOfDocument: UITextPosition;
	inputDelegate: any;
	tokenizer: any;
	textInputView: UIView;
	selectionAffinity: number;
	textInRange(range: UITextRange): string;
	replaceRangeWithText(range: UITextRange, text: string): void;
	setMarkedTextSelectedRange(markedText: string, selectedRange: NSRange): void;
	unmarkText(): void;
	textRangeFromPositionToPosition(fromPosition: UITextPosition, toPosition: UITextPosition): UITextRange;
	positionFromPositionOffset(position: UITextPosition, offset: number): UITextPosition;
	positionFromPositionInDirectionOffset(position: UITextPosition, direction: number, offset: number): UITextPosition;
	comparePositionToPosition(position: UITextPosition, other: UITextPosition): number;
	offsetFromPositionToPosition(from: UITextPosition, toPosition: UITextPosition): number;
	positionWithinRangeFarthestInDirection(range: UITextRange, direction: number): UITextPosition;
	characterRangeByExtendingPositionInDirection(position: UITextPosition, direction: number): UITextRange;
	baseWritingDirectionForPositionInDirection(position: UITextPosition, direction: number): number;
	setBaseWritingDirectionForRange(writingDirection: number, range: UITextRange): void;
	firstRectForRange(range: UITextRange): CGRect;
	caretRectForPosition(position: UITextPosition): CGRect;
	selectionRectsForRange(range: UITextRange): NSArray;
	closestPositionToPoint(point: CGPoint): UITextPosition;
	closestPositionToPointWithinRange(point: CGPoint, range: UITextRange): UITextPosition;
	characterRangeAtPoint(point: CGPoint): UITextRange;
	shouldChangeTextInRangeReplacementText?(range: UITextRange, text: string): boolean;
	textStylingAtPositionInDirection?(position: UITextPosition, direction: number): NSDictionary;
	positionWithinRangeAtCharacterOffset?(range: UITextRange, offset: number): UITextPosition;
	characterOffsetOfPositionWithinRange?(position: UITextPosition, range: UITextRange): number;
	insertDictationResult?(dictationResult: NSArray): void;
	dictationRecordingDidEnd?(): void;
	dictationRecognitionFailed?(): void;
	insertDictationResultPlaceholder?(): any;
	frameForDictationResultPlaceholder?(placeholder: any): CGRect;
	removeDictationResultPlaceholderWillInsertResult?(placeholder: any, willInsertResult: boolean): void;
}
interface UITextInputDelegate {
	selectionWillChange(textInput: any): void;
	selectionDidChange(textInput: any): void;
	textWillChange(textInput: any): void;
	textDidChange(textInput: any): void;
}
interface UITextInputTokenizer {
	rangeEnclosingPositionWithGranularityInDirection(position: UITextPosition, granularity: number, direction: number): UITextRange;
	isPositionAtBoundaryInDirection(position: UITextPosition, granularity: number, direction: number): boolean;
	positionFromPositionToBoundaryInDirection(position: UITextPosition, granularity: number, direction: number): UITextPosition;
	isPositionWithinTextUnitInDirection(position: UITextPosition, granularity: number, direction: number): boolean;
}
interface UITextFieldDelegate {
	textFieldShouldBeginEditing?(textField: UITextField): boolean;
	textFieldDidBeginEditing?(textField: UITextField): void;
	textFieldShouldEndEditing?(textField: UITextField): boolean;
	textFieldDidEndEditing?(textField: UITextField): void;
	textFieldShouldChangeCharactersInRangeReplacementString?(textField: UITextField, range: NSRange, string: string): boolean;
	textFieldShouldClear?(textField: UITextField): boolean;
	textFieldShouldReturn?(textField: UITextField): boolean;
}
interface UIActionSheetDelegate {
	actionSheetClickedButtonAtIndex?(actionSheet: UIActionSheet, buttonIndex: number): void;
	actionSheetCancel?(actionSheet: UIActionSheet): void;
	willPresentActionSheet?(actionSheet: UIActionSheet): void;
	didPresentActionSheet?(actionSheet: UIActionSheet): void;
	actionSheetWillDismissWithButtonIndex?(actionSheet: UIActionSheet, buttonIndex: number): void;
	actionSheetDidDismissWithButtonIndex?(actionSheet: UIActionSheet, buttonIndex: number): void;
}
interface UIAlertViewDelegate {
	alertViewClickedButtonAtIndex?(alertView: UIAlertView, buttonIndex: number): void;
	alertViewCancel?(alertView: UIAlertView): void;
	willPresentAlertView?(alertView: UIAlertView): void;
	didPresentAlertView?(alertView: UIAlertView): void;
	alertViewWillDismissWithButtonIndex?(alertView: UIAlertView, buttonIndex: number): void;
	alertViewDidDismissWithButtonIndex?(alertView: UIAlertView, buttonIndex: number): void;
	alertViewShouldEnableFirstOtherButton?(alertView: UIAlertView): boolean;
}
interface UIApplicationDelegate {
	window: UIWindow;
	applicationDidFinishLaunching?(application: UIApplication): void;
	applicationWillFinishLaunchingWithOptions?(application: UIApplication, launchOptions: NSDictionary): boolean;
	applicationDidFinishLaunchingWithOptions?(application: UIApplication, launchOptions: NSDictionary): boolean;
	applicationDidBecomeActive?(application: UIApplication): void;
	applicationWillResignActive?(application: UIApplication): void;
	applicationHandleOpenURL?(application: UIApplication, url: NSURL): boolean;
	applicationOpenURLSourceApplicationAnnotation?(application: UIApplication, url: NSURL, sourceApplication: string, annotation: any): boolean;
	applicationDidReceiveMemoryWarning?(application: UIApplication): void;
	applicationWillTerminate?(application: UIApplication): void;
	applicationSignificantTimeChange?(application: UIApplication): void;
	applicationWillChangeStatusBarOrientationDuration?(application: UIApplication, newStatusBarOrientation: number, duration: number): void;
	applicationDidChangeStatusBarOrientation?(application: UIApplication, oldStatusBarOrientation: number): void;
	applicationWillChangeStatusBarFrame?(application: UIApplication, newStatusBarFrame: CGRect): void;
	applicationDidChangeStatusBarFrame?(application: UIApplication, oldStatusBarFrame: CGRect): void;
	applicationDidRegisterUserNotificationSettings?(application: UIApplication, notificationSettings: UIUserNotificationSettings): void;
	applicationDidRegisterForRemoteNotificationsWithDeviceToken?(application: UIApplication, deviceToken: NSData): void;
	applicationDidFailToRegisterForRemoteNotificationsWithError?(application: UIApplication, error: NSError): void;
	applicationDidReceiveRemoteNotification?(application: UIApplication, userInfo: NSDictionary): void;
	applicationDidReceiveLocalNotification?(application: UIApplication, notification: UILocalNotification): void;
	applicationHandleActionWithIdentifierForLocalNotificationCompletionHandler?(application: UIApplication, identifier: string, notification: UILocalNotification, completionHandler: () => void): void;
	applicationHandleActionWithIdentifierForRemoteNotificationCompletionHandler?(application: UIApplication, identifier: string, userInfo: NSDictionary, completionHandler: () => void): void;
	applicationDidReceiveRemoteNotificationFetchCompletionHandler?(application: UIApplication, userInfo: NSDictionary, completionHandler: (arg1: number) => void): void;
	applicationPerformFetchWithCompletionHandler?(application: UIApplication, completionHandler: (arg1: number) => void): void;
	applicationHandleEventsForBackgroundURLSessionCompletionHandler?(application: UIApplication, identifier: string, completionHandler: () => void): void;
	applicationDidEnterBackground?(application: UIApplication): void;
	applicationWillEnterForeground?(application: UIApplication): void;
	applicationProtectedDataWillBecomeUnavailable?(application: UIApplication): void;
	applicationProtectedDataDidBecomeAvailable?(application: UIApplication): void;
	applicationSupportedInterfaceOrientationsForWindow?(application: UIApplication, window: UIWindow): number;
	applicationShouldAllowExtensionPointIdentifier?(application: UIApplication, extensionPointIdentifier: string): boolean;
	applicationViewControllerWithRestorationIdentifierPathCoder?(application: UIApplication, identifierComponents: NSArray, coder: NSCoder): UIViewController;
	applicationShouldSaveApplicationState?(application: UIApplication, coder: NSCoder): boolean;
	applicationShouldRestoreApplicationState?(application: UIApplication, coder: NSCoder): boolean;
	applicationWillEncodeRestorableStateWithCoder?(application: UIApplication, coder: NSCoder): void;
	applicationDidDecodeRestorableStateWithCoder?(application: UIApplication, coder: NSCoder): void;
	applicationWillContinueUserActivityWithType?(application: UIApplication, userActivityType: string): boolean;
	applicationContinueUserActivityRestorationHandler?(application: UIApplication, userActivity: NSUserActivity, restorationHandler: (arg1: NSArray) => void): boolean;
	applicationDidFailToContinueUserActivityWithTypeError?(application: UIApplication, userActivityType: string, error: NSError): void;
	applicationDidUpdateUserActivity?(application: UIApplication, userActivity: NSUserActivity): void;
}
interface UIViewControllerRestoration {
}
interface UIDataSourceModelAssociation {
	modelIdentifierForElementAtIndexPathInView(idx: NSIndexPath, view: UIView): string;
	indexPathForElementWithModelIdentifierInView(identifier: string, view: UIView): NSIndexPath;
}
interface UIStateRestoring {
	restorationParent: any;
	objectRestorationClass: any;
	encodeRestorableStateWithCoder?(coder: NSCoder): void;
	decodeRestorableStateWithCoder?(coder: NSCoder): void;
	applicationFinishedRestoringState?(): void;
}
interface UIObjectRestoration {
}
interface UIContentContainer {
	preferredContentSize: CGSize;
	preferredContentSizeDidChangeForChildContentContainer(container: any): void;
	systemLayoutFittingSizeDidChangeForChildContentContainer(container: any): void;
	sizeForChildContentContainerWithParentContainerSize(container: any, parentSize: CGSize): CGSize;
	viewWillTransitionToSizeWithTransitionCoordinator(size: CGSize, coordinator: any): void;
	willTransitionToTraitCollectionWithTransitionCoordinator(newCollection: UITraitCollection, coordinator: any): void;
}
interface UIGestureRecognizerDelegate {
	gestureRecognizerShouldBegin?(gestureRecognizer: UIGestureRecognizer): boolean;
	gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer?(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;
	gestureRecognizerShouldRequireFailureOfGestureRecognizer?(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;
	gestureRecognizerShouldBeRequiredToFailByGestureRecognizer?(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;
	gestureRecognizerShouldReceiveTouch?(gestureRecognizer: UIGestureRecognizer, touch: UITouch): boolean;
}
interface UINavigationControllerDelegate {
	navigationControllerWillShowViewControllerAnimated?(navigationController: UINavigationController, viewController: UIViewController, animated: boolean): void;
	navigationControllerDidShowViewControllerAnimated?(navigationController: UINavigationController, viewController: UIViewController, animated: boolean): void;
	navigationControllerSupportedInterfaceOrientations?(navigationController: UINavigationController): number;
	navigationControllerPreferredInterfaceOrientationForPresentation?(navigationController: UINavigationController): number;
	navigationControllerInteractionControllerForAnimationController?(navigationController: UINavigationController, animationController: any): any;
	navigationControllerAnimationControllerForOperationFromViewControllerToViewController?(navigationController: UINavigationController, operation: number, fromVC: UIViewController, toVC: UIViewController): any;
}
interface UIAccelerometerDelegate {
	accelerometerDidAccelerate?(accelerometer: UIAccelerometer, acceleration: UIAcceleration): void;
}
interface UIScrollViewDelegate {
	scrollViewDidScroll?(scrollView: UIScrollView): void;
	scrollViewDidZoom?(scrollView: UIScrollView): void;
	scrollViewWillBeginDragging?(scrollView: UIScrollView): void;
	scrollViewWillEndDraggingWithVelocityTargetContentOffset?(scrollView: UIScrollView, velocity: CGPoint, targetContentOffset: any): void;
	scrollViewDidEndDraggingWillDecelerate?(scrollView: UIScrollView, decelerate: boolean): void;
	scrollViewWillBeginDecelerating?(scrollView: UIScrollView): void;
	scrollViewDidEndDecelerating?(scrollView: UIScrollView): void;
	scrollViewDidEndScrollingAnimation?(scrollView: UIScrollView): void;
	viewForZoomingInScrollView?(scrollView: UIScrollView): UIView;
	scrollViewWillBeginZoomingWithView?(scrollView: UIScrollView, view: UIView): void;
	scrollViewDidEndZoomingWithViewAtScale?(scrollView: UIScrollView, view: UIView, scale: number): void;
	scrollViewShouldScrollToTop?(scrollView: UIScrollView): boolean;
	scrollViewDidScrollToTop?(scrollView: UIScrollView): void;
}
interface UITableViewDelegate {
	tableViewWillDisplayCellForRowAtIndexPath?(tableView: UITableView, cell: UITableViewCell, indexPath: NSIndexPath): void;
	tableViewWillDisplayHeaderViewForSection?(tableView: UITableView, view: UIView, section: number): void;
	tableViewWillDisplayFooterViewForSection?(tableView: UITableView, view: UIView, section: number): void;
	tableViewDidEndDisplayingCellForRowAtIndexPath?(tableView: UITableView, cell: UITableViewCell, indexPath: NSIndexPath): void;
	tableViewDidEndDisplayingHeaderViewForSection?(tableView: UITableView, view: UIView, section: number): void;
	tableViewDidEndDisplayingFooterViewForSection?(tableView: UITableView, view: UIView, section: number): void;
	tableViewHeightForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;
	tableViewHeightForHeaderInSection?(tableView: UITableView, section: number): number;
	tableViewHeightForFooterInSection?(tableView: UITableView, section: number): number;
	tableViewEstimatedHeightForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;
	tableViewEstimatedHeightForHeaderInSection?(tableView: UITableView, section: number): number;
	tableViewEstimatedHeightForFooterInSection?(tableView: UITableView, section: number): number;
	tableViewViewForHeaderInSection?(tableView: UITableView, section: number): UIView;
	tableViewViewForFooterInSection?(tableView: UITableView, section: number): UIView;
	tableViewAccessoryTypeForRowWithIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;
	tableViewAccessoryButtonTappedForRowWithIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewShouldHighlightRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;
	tableViewDidHighlightRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewDidUnhighlightRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewWillSelectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): NSIndexPath;
	tableViewWillDeselectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): NSIndexPath;
	tableViewDidSelectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewDidDeselectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewEditingStyleForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;
	tableViewTitleForDeleteConfirmationButtonForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): string;
	tableViewEditActionsForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): NSArray;
	tableViewShouldIndentWhileEditingRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;
	tableViewWillBeginEditingRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewDidEndEditingRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;
	tableViewTargetIndexPathForMoveFromRowAtIndexPathToProposedIndexPath?(tableView: UITableView, sourceIndexPath: NSIndexPath, proposedDestinationIndexPath: NSIndexPath): NSIndexPath;
	tableViewIndentationLevelForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;
	tableViewShouldShowMenuForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;
	tableViewCanPerformActionForRowAtIndexPathWithSender?(tableView: UITableView, action: any, indexPath: NSIndexPath, sender: any): boolean;
	tableViewPerformActionForRowAtIndexPathWithSender?(tableView: UITableView, action: any, indexPath: NSIndexPath, sender: any): void;
}
interface UITableViewDataSource {
	tableViewNumberOfRowsInSection(tableView: UITableView, section: number): number;
	tableViewCellForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UITableViewCell;
	numberOfSectionsInTableView?(tableView: UITableView): number;
	tableViewTitleForHeaderInSection?(tableView: UITableView, section: number): string;
	tableViewTitleForFooterInSection?(tableView: UITableView, section: number): string;
	tableViewCanEditRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;
	tableViewCanMoveRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;
	sectionIndexTitlesForTableView?(tableView: UITableView): NSArray;
	tableViewSectionForSectionIndexTitleAtIndex?(tableView: UITableView, title: string, index: number): number;
	tableViewCommitEditingStyleForRowAtIndexPath?(tableView: UITableView, editingStyle: number, indexPath: NSIndexPath): void;
	tableViewMoveRowAtIndexPathToIndexPath?(tableView: UITableView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;
}
interface UIPickerViewDataSource {
	numberOfComponentsInPickerView(pickerView: UIPickerView): number;
	pickerViewNumberOfRowsInComponent(pickerView: UIPickerView, component: number): number;
}
interface UIPickerViewDelegate {
	pickerViewWidthForComponent?(pickerView: UIPickerView, component: number): number;
	pickerViewRowHeightForComponent?(pickerView: UIPickerView, component: number): number;
	pickerViewTitleForRowForComponent?(pickerView: UIPickerView, row: number, component: number): string;
	pickerViewAttributedTitleForRowForComponent?(pickerView: UIPickerView, row: number, component: number): NSAttributedString;
	pickerViewViewForRowForComponentReusingView?(pickerView: UIPickerView, row: number, component: number, view: UIView): UIView;
	pickerViewDidSelectRowInComponent?(pickerView: UIPickerView, row: number, component: number): void;
}
interface UIPickerViewAccessibilityDelegate {
	pickerViewAccessibilityLabelForComponent?(pickerView: UIPickerView, component: number): string;
	pickerViewAccessibilityHintForComponent?(pickerView: UIPickerView, component: number): string;
}
interface UIScrollViewAccessibilityDelegate {
	accessibilityScrollStatusForScrollView?(scrollView: UIScrollView): string;
}
interface UIAccessibilityIdentification {
	accessibilityIdentifier: string;
}
interface UIGuidedAccessRestrictionDelegate {
	guidedAccessRestrictionIdentifiers(): NSArray;
	guidedAccessRestrictionWithIdentifierDidChangeState(restrictionIdentifier: string, newRestrictionState: number): void;
	textForGuidedAccessRestrictionWithIdentifier(restrictionIdentifier: string): string;
	detailTextForGuidedAccessRestrictionWithIdentifier?(restrictionIdentifier: string): string;
}
interface UIAccessibilityReadingContent {
	accessibilityLineNumberForPoint(point: CGPoint): number;
	accessibilityContentForLineNumber(lineNumber: number): string;
	accessibilityFrameForLineNumber(lineNumber: number): CGRect;
	accessibilityPageContent(): string;
}
interface UIActivityItemSource {
	activityViewControllerPlaceholderItem(activityViewController: UIActivityViewController): any;
	activityViewControllerItemForActivityType(activityViewController: UIActivityViewController, activityType: string): any;
	activityViewControllerSubjectForActivityType?(activityViewController: UIActivityViewController, activityType: string): string;
	activityViewControllerDataTypeIdentifierForActivityType?(activityViewController: UIActivityViewController, activityType: string): string;
	activityViewControllerThumbnailImageForActivityTypeSuggestedSize?(activityViewController: UIActivityViewController, activityType: string, size: CGSize): UIImage;
}
interface UIBarPositioning {
	barPosition: number;
}
interface UIBarPositioningDelegate {
	positionForBar?(bar: any): number;
}
interface UICollectionViewDataSource {
	collectionViewNumberOfItemsInSection(collectionView: UICollectionView, section: number): number;
	collectionViewCellForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): UICollectionViewCell;
	numberOfSectionsInCollectionView?(collectionView: UICollectionView): number;
	collectionViewViewForSupplementaryElementOfKindAtIndexPath?(collectionView: UICollectionView, kind: string, indexPath: NSIndexPath): UICollectionReusableView;
}
interface UICollectionViewDelegate {
	collectionViewShouldHighlightItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;
	collectionViewDidHighlightItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;
	collectionViewDidUnhighlightItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;
	collectionViewShouldSelectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;
	collectionViewShouldDeselectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;
	collectionViewDidSelectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;
	collectionViewDidDeselectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;
	collectionViewWillDisplayCellForItemAtIndexPath?(collectionView: UICollectionView, cell: UICollectionViewCell, indexPath: NSIndexPath): void;
	collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath?(collectionView: UICollectionView, view: UICollectionReusableView, elementKind: string, indexPath: NSIndexPath): void;
	collectionViewDidEndDisplayingCellForItemAtIndexPath?(collectionView: UICollectionView, cell: UICollectionViewCell, indexPath: NSIndexPath): void;
	collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath?(collectionView: UICollectionView, view: UICollectionReusableView, elementKind: string, indexPath: NSIndexPath): void;
	collectionViewShouldShowMenuForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;
	collectionViewCanPerformActionForItemAtIndexPathWithSender?(collectionView: UICollectionView, action: any, indexPath: NSIndexPath, sender: any): boolean;
	collectionViewPerformActionForItemAtIndexPathWithSender?(collectionView: UICollectionView, action: any, indexPath: NSIndexPath, sender: any): void;
	collectionViewTransitionLayoutForOldLayoutNewLayout?(collectionView: UICollectionView, fromLayout: UICollectionViewLayout, toLayout: UICollectionViewLayout): UICollectionViewTransitionLayout;
}
interface UICollectionViewDelegateFlowLayout {
	collectionViewLayoutSizeForItemAtIndexPath?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, indexPath: NSIndexPath): CGSize;
	collectionViewLayoutInsetForSectionAtIndex?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): UIEdgeInsets;
	collectionViewLayoutMinimumLineSpacingForSectionAtIndex?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): number;
	collectionViewLayoutMinimumInteritemSpacingForSectionAtIndex?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): number;
	collectionViewLayoutReferenceSizeForHeaderInSection?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): CGSize;
	collectionViewLayoutReferenceSizeForFooterInSection?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): CGSize;
}
interface UIDocumentInteractionControllerDelegate {
	documentInteractionControllerViewControllerForPreview?(controller: UIDocumentInteractionController): UIViewController;
	documentInteractionControllerRectForPreview?(controller: UIDocumentInteractionController): CGRect;
	documentInteractionControllerViewForPreview?(controller: UIDocumentInteractionController): UIView;
	documentInteractionControllerWillBeginPreview?(controller: UIDocumentInteractionController): void;
	documentInteractionControllerDidEndPreview?(controller: UIDocumentInteractionController): void;
	documentInteractionControllerWillPresentOptionsMenu?(controller: UIDocumentInteractionController): void;
	documentInteractionControllerDidDismissOptionsMenu?(controller: UIDocumentInteractionController): void;
	documentInteractionControllerWillPresentOpenInMenu?(controller: UIDocumentInteractionController): void;
	documentInteractionControllerDidDismissOpenInMenu?(controller: UIDocumentInteractionController): void;
	documentInteractionControllerWillBeginSendingToApplication?(controller: UIDocumentInteractionController, application: string): void;
	documentInteractionControllerDidEndSendingToApplication?(controller: UIDocumentInteractionController, application: string): void;
	documentInteractionControllerCanPerformAction?(controller: UIDocumentInteractionController, action: any): boolean;
	documentInteractionControllerPerformAction?(controller: UIDocumentInteractionController, action: any): boolean;
}
interface UIDocumentPickerDelegate {
	documentPickerDidPickDocumentAtURL(controller: UIDocumentPickerViewController, url: NSURL): void;
	documentPickerWasCancelled?(controller: UIDocumentPickerViewController): void;
}
interface UIDocumentMenuDelegate {
	documentMenuDidPickDocumentPicker(documentMenu: UIDocumentMenuViewController, documentPicker: UIDocumentPickerViewController): void;
	documentMenuWasCancelled?(documentMenu: UIDocumentMenuViewController): void;
}
interface UIImagePickerControllerDelegate {
	imagePickerControllerDidFinishPickingImageEditingInfo?(picker: UIImagePickerController, image: UIImage, editingInfo: NSDictionary): void;
	imagePickerControllerDidFinishPickingMediaWithInfo?(picker: UIImagePickerController, info: NSDictionary): void;
	imagePickerControllerDidCancel?(picker: UIImagePickerController): void;
}
interface UITextDocumentProxy {
	documentContextBeforeInput: string;
	documentContextAfterInput: string;
	adjustTextPositionByCharacterOffset(offset: number): void;
}
interface UINavigationBarDelegate {
	navigationBarShouldPushItem?(navigationBar: UINavigationBar, item: UINavigationItem): boolean;
	navigationBarDidPushItem?(navigationBar: UINavigationBar, item: UINavigationItem): void;
	navigationBarShouldPopItem?(navigationBar: UINavigationBar, item: UINavigationItem): boolean;
	navigationBarDidPopItem?(navigationBar: UINavigationBar, item: UINavigationItem): void;
}
interface UIPageViewControllerDelegate {
	pageViewControllerWillTransitionToViewControllers?(pageViewController: UIPageViewController, pendingViewControllers: NSArray): void;
	pageViewControllerDidFinishAnimatingPreviousViewControllersTransitionCompleted?(pageViewController: UIPageViewController, finished: boolean, previousViewControllers: NSArray, completed: boolean): void;
	pageViewControllerSpineLocationForInterfaceOrientation?(pageViewController: UIPageViewController, orientation: number): number;
	pageViewControllerSupportedInterfaceOrientations?(pageViewController: UIPageViewController): number;
	pageViewControllerPreferredInterfaceOrientationForPresentation?(pageViewController: UIPageViewController): number;
}
interface UIPageViewControllerDataSource {
	pageViewControllerViewControllerBeforeViewController(pageViewController: UIPageViewController, viewController: UIViewController): UIViewController;
	pageViewControllerViewControllerAfterViewController(pageViewController: UIPageViewController, viewController: UIViewController): UIViewController;
	presentationCountForPageViewController?(pageViewController: UIPageViewController): number;
	presentationIndexForPageViewController?(pageViewController: UIPageViewController): number;
}
interface UIPopoverControllerDelegate {
	popoverControllerShouldDismissPopover?(popoverController: UIPopoverController): boolean;
	popoverControllerDidDismissPopover?(popoverController: UIPopoverController): void;
	popoverControllerWillRepositionPopoverToRectInView?(popoverController: UIPopoverController, rect: any, view: any): void;
}
interface UIPopoverBackgroundViewMethods {
}
interface UIPrinterPickerControllerDelegate {
	printerPickerControllerParentViewController?(printerPickerController: UIPrinterPickerController): UIViewController;
	printerPickerControllerShouldShowPrinter?(printerPickerController: UIPrinterPickerController, printer: UIPrinter): boolean;
	printerPickerControllerWillPresent?(printerPickerController: UIPrinterPickerController): void;
	printerPickerControllerDidPresent?(printerPickerController: UIPrinterPickerController): void;
	printerPickerControllerWillDismiss?(printerPickerController: UIPrinterPickerController): void;
	printerPickerControllerDidDismiss?(printerPickerController: UIPrinterPickerController): void;
	printerPickerControllerDidSelectPrinter?(printerPickerController: UIPrinterPickerController): void;
}
interface UIPrintInteractionControllerDelegate {
	printInteractionControllerParentViewController?(printInteractionController: UIPrintInteractionController): UIViewController;
	printInteractionControllerChoosePaper?(printInteractionController: UIPrintInteractionController, paperList: NSArray): UIPrintPaper;
	printInteractionControllerWillPresentPrinterOptions?(printInteractionController: UIPrintInteractionController): void;
	printInteractionControllerDidPresentPrinterOptions?(printInteractionController: UIPrintInteractionController): void;
	printInteractionControllerWillDismissPrinterOptions?(printInteractionController: UIPrintInteractionController): void;
	printInteractionControllerDidDismissPrinterOptions?(printInteractionController: UIPrintInteractionController): void;
	printInteractionControllerWillStartJob?(printInteractionController: UIPrintInteractionController): void;
	printInteractionControllerDidFinishJob?(printInteractionController: UIPrintInteractionController): void;
	printInteractionControllerCutLengthForPaper?(printInteractionController: UIPrintInteractionController, paper: UIPrintPaper): number;
}
interface UISearchBarDelegate {
	searchBarShouldBeginEditing?(searchBar: UISearchBar): boolean;
	searchBarTextDidBeginEditing?(searchBar: UISearchBar): void;
	searchBarShouldEndEditing?(searchBar: UISearchBar): boolean;
	searchBarTextDidEndEditing?(searchBar: UISearchBar): void;
	searchBarTextDidChange?(searchBar: UISearchBar, searchText: string): void;
	searchBarShouldChangeTextInRangeReplacementText?(searchBar: UISearchBar, range: NSRange, text: string): boolean;
	searchBarSearchButtonClicked?(searchBar: UISearchBar): void;
	searchBarBookmarkButtonClicked?(searchBar: UISearchBar): void;
	searchBarCancelButtonClicked?(searchBar: UISearchBar): void;
	searchBarResultsListButtonClicked?(searchBar: UISearchBar): void;
	searchBarSelectedScopeButtonIndexDidChange?(searchBar: UISearchBar, selectedScope: number): void;
}
interface UIViewControllerTransitionCoordinatorContext {
	isAnimated(): boolean;
	presentationStyle(): number;
	initiallyInteractive(): boolean;
	isInteractive(): boolean;
	isCancelled(): boolean;
	transitionDuration(): number;
	percentComplete(): number;
	completionVelocity(): number;
	completionCurve(): number;
	viewControllerForKey(key: string): UIViewController;
	viewForKey(key: string): UIView;
	containerView(): UIView;
	targetTransform(): CGAffineTransform;
}
interface UIViewControllerTransitionCoordinator {
	animateAlongsideTransitionCompletion(animation: (arg1: any) => void, completion: (arg1: any) => void): boolean;
	animateAlongsideTransitionInViewAnimationCompletion(view: UIView, animation: (arg1: any) => void, completion: (arg1: any) => void): boolean;
	notifyWhenInteractionEndsUsingBlock(handler: (arg1: any) => void): void;
}
interface UIAdaptivePresentationControllerDelegate {
	adaptivePresentationStyleForPresentationController?(controller: UIPresentationController): number;
	presentationControllerViewControllerForAdaptivePresentationStyle?(controller: UIPresentationController, style: number): UIViewController;
}
interface UIViewControllerContextTransitioning {
	containerView(): UIView;
	isAnimated(): boolean;
	isInteractive(): boolean;
	transitionWasCancelled(): boolean;
	presentationStyle(): number;
	updateInteractiveTransition(percentComplete: number): void;
	finishInteractiveTransition(): void;
	cancelInteractiveTransition(): void;
	completeTransition(didComplete: boolean): void;
	viewControllerForKey(key: string): UIViewController;
	viewForKey(key: string): UIView;
	targetTransform(): CGAffineTransform;
	initialFrameForViewController(vc: UIViewController): CGRect;
	finalFrameForViewController(vc: UIViewController): CGRect;
}
interface UIViewControllerAnimatedTransitioning {
	transitionDuration(transitionContext: any): number;
	animateTransition(transitionContext: any): void;
	animationEnded?(transitionCompleted: boolean): void;
}
interface UIViewControllerInteractiveTransitioning {
	startInteractiveTransition(transitionContext: any): void;
	completionSpeed?(): number;
	completionCurve?(): number;
}
interface UIViewControllerTransitioningDelegate {
	animationControllerForPresentedControllerPresentingControllerSourceController?(presented: UIViewController, presenting: UIViewController, source: UIViewController): any;
	animationControllerForDismissedController?(dismissed: UIViewController): any;
	interactionControllerForPresentation?(animator: any): any;
	interactionControllerForDismissal?(animator: any): any;
	presentationControllerForPresentedViewControllerPresentingViewControllerSourceViewController?(presented: UIViewController, presenting: UIViewController, source: UIViewController): UIPresentationController;
}
interface UISearchControllerDelegate {
	willPresentSearchController?(searchController: UISearchController): void;
	didPresentSearchController?(searchController: UISearchController): void;
	willDismissSearchController?(searchController: UISearchController): void;
	didDismissSearchController?(searchController: UISearchController): void;
	presentSearchController?(searchController: UISearchController): void;
}
interface UISearchResultsUpdating {
	updateSearchResultsForSearchController(searchController: UISearchController): void;
}
interface UISearchDisplayDelegate {
	searchDisplayControllerWillBeginSearch?(controller: UISearchDisplayController): void;
	searchDisplayControllerDidBeginSearch?(controller: UISearchDisplayController): void;
	searchDisplayControllerWillEndSearch?(controller: UISearchDisplayController): void;
	searchDisplayControllerDidEndSearch?(controller: UISearchDisplayController): void;
	searchDisplayControllerDidLoadSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;
	searchDisplayControllerWillUnloadSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;
	searchDisplayControllerWillShowSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;
	searchDisplayControllerDidShowSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;
	searchDisplayControllerWillHideSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;
	searchDisplayControllerDidHideSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;
	searchDisplayControllerShouldReloadTableForSearchString?(controller: UISearchDisplayController, searchString: string): boolean;
	searchDisplayControllerShouldReloadTableForSearchScope?(controller: UISearchDisplayController, searchOption: number): boolean;
}
interface UISplitViewControllerDelegate {
	splitViewControllerWillChangeToDisplayMode?(svc: UISplitViewController, displayMode: number): void;
	targetDisplayModeForActionInSplitViewController?(svc: UISplitViewController): number;
	splitViewControllerShowViewControllerSender?(splitViewController: UISplitViewController, vc: UIViewController, sender: any): boolean;
	splitViewControllerShowDetailViewControllerSender?(splitViewController: UISplitViewController, vc: UIViewController, sender: any): boolean;
	primaryViewControllerForCollapsingSplitViewController?(splitViewController: UISplitViewController): UIViewController;
	primaryViewControllerForExpandingSplitViewController?(splitViewController: UISplitViewController): UIViewController;
	splitViewControllerCollapseSecondaryViewControllerOntoPrimaryViewController?(splitViewController: UISplitViewController, secondaryViewController: UIViewController, primaryViewController: UIViewController): boolean;
	splitViewControllerSeparateSecondaryViewControllerFromPrimaryViewController?(splitViewController: UISplitViewController, primaryViewController: UIViewController): UIViewController;
	splitViewControllerSupportedInterfaceOrientations?(splitViewController: UISplitViewController): number;
	splitViewControllerPreferredInterfaceOrientationForPresentation?(splitViewController: UISplitViewController): number;
	splitViewControllerWillHideViewControllerWithBarButtonItemForPopoverController?(svc: UISplitViewController, aViewController: UIViewController, barButtonItem: UIBarButtonItem, pc: UIPopoverController): void;
	splitViewControllerWillShowViewControllerInvalidatingBarButtonItem?(svc: UISplitViewController, aViewController: UIViewController, barButtonItem: UIBarButtonItem): void;
	splitViewControllerPopoverControllerWillPresentViewController?(svc: UISplitViewController, pc: UIPopoverController, aViewController: UIViewController): void;
	splitViewControllerShouldHideViewControllerInOrientation?(svc: UISplitViewController, vc: UIViewController, orientation: number): boolean;
}
interface UITabBarDelegate {
	tabBarDidSelectItem?(tabBar: UITabBar, item: UITabBarItem): void;
	tabBarWillBeginCustomizingItems?(tabBar: UITabBar, items: NSArray): void;
	tabBarDidBeginCustomizingItems?(tabBar: UITabBar, items: NSArray): void;
	tabBarWillEndCustomizingItemsChanged?(tabBar: UITabBar, items: NSArray, changed: boolean): void;
	tabBarDidEndCustomizingItemsChanged?(tabBar: UITabBar, items: NSArray, changed: boolean): void;
}
interface UITabBarControllerDelegate {
	tabBarControllerShouldSelectViewController?(tabBarController: UITabBarController, viewController: UIViewController): boolean;
	tabBarControllerDidSelectViewController?(tabBarController: UITabBarController, viewController: UIViewController): void;
	tabBarControllerWillBeginCustomizingViewControllers?(tabBarController: UITabBarController, viewControllers: NSArray): void;
	tabBarControllerWillEndCustomizingViewControllersChanged?(tabBarController: UITabBarController, viewControllers: NSArray, changed: boolean): void;
	tabBarControllerDidEndCustomizingViewControllersChanged?(tabBarController: UITabBarController, viewControllers: NSArray, changed: boolean): void;
	tabBarControllerSupportedInterfaceOrientations?(tabBarController: UITabBarController): number;
	tabBarControllerPreferredInterfaceOrientationForPresentation?(tabBarController: UITabBarController): number;
	tabBarControllerInteractionControllerForAnimationController?(tabBarController: UITabBarController, animationController: any): any;
	tabBarControllerAnimationControllerForTransitionFromViewControllerToViewController?(tabBarController: UITabBarController, fromVC: UIViewController, toVC: UIViewController): any;
}
interface UITextViewDelegate {
	textViewShouldBeginEditing?(textView: UITextView): boolean;
	textViewShouldEndEditing?(textView: UITextView): boolean;
	textViewDidBeginEditing?(textView: UITextView): void;
	textViewDidEndEditing?(textView: UITextView): void;
	textViewShouldChangeTextInRangeReplacementText?(textView: UITextView, range: NSRange, text: string): boolean;
	textViewDidChange?(textView: UITextView): void;
	textViewDidChangeSelection?(textView: UITextView): void;
	textViewShouldInteractWithURLInRange?(textView: UITextView, URL: NSURL, characterRange: NSRange): boolean;
	textViewShouldInteractWithTextAttachmentInRange?(textView: UITextView, textAttachment: NSTextAttachment, characterRange: NSRange): boolean;
}
interface UIToolbarDelegate {
}
interface UIVideoEditorControllerDelegate {
	videoEditorControllerDidSaveEditedVideoToPath?(editor: UIVideoEditorController, editedVideoPath: string): void;
	videoEditorControllerDidFailWithError?(editor: UIVideoEditorController, error: NSError): void;
	videoEditorControllerDidCancel?(editor: UIVideoEditorController): void;
}
interface UIWebViewDelegate {
	webViewShouldStartLoadWithRequestNavigationType?(webView: UIWebView, request: NSURLRequest, navigationType: number): boolean;
	webViewDidStartLoad?(webView: UIWebView): void;
	webViewDidFinishLoad?(webView: UIWebView): void;
	webViewDidFailLoadWithError?(webView: UIWebView, error: NSError): void;
}
interface NSTextStorageDelegate {
	textStorageWillProcessEditingRangeChangeInLength?(textStorage: NSTextStorage, editedMask: number, editedRange: NSRange, delta: number): void;
	textStorageDidProcessEditingRangeChangeInLength?(textStorage: NSTextStorage, editedMask: number, editedRange: NSRange, delta: number): void;
}
interface NSLayoutManagerDelegate {
	layoutManagerShouldGenerateGlyphsPropertiesCharacterIndexesFontForGlyphRange?(layoutManager: NSLayoutManager, glyphs: any, props: any, charIndexes: any, aFont: UIFont, glyphRange: NSRange): number;
	layoutManagerLineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(layoutManager: NSLayoutManager, glyphIndex: number, rect: CGRect): number;
	layoutManagerParagraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect?(layoutManager: NSLayoutManager, glyphIndex: number, rect: CGRect): number;
	layoutManagerParagraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(layoutManager: NSLayoutManager, glyphIndex: number, rect: CGRect): number;
	layoutManagerShouldUseActionForControlCharacterAtIndex?(layoutManager: NSLayoutManager, action: number, charIndex: number): number;
	layoutManagerShouldBreakLineByWordBeforeCharacterAtIndex?(layoutManager: NSLayoutManager, charIndex: number): boolean;
	layoutManagerShouldBreakLineByHyphenatingBeforeCharacterAtIndex?(layoutManager: NSLayoutManager, charIndex: number): boolean;
	layoutManagerBoundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex?(layoutManager: NSLayoutManager, glyphIndex: number, textContainer: NSTextContainer, proposedRect: CGRect, glyphPosition: CGPoint, charIndex: number): CGRect;
	layoutManagerDidInvalidateLayout?(sender: NSLayoutManager): void;
	layoutManagerDidCompleteLayoutForTextContainerAtEnd?(layoutManager: NSLayoutManager, textContainer: NSTextContainer, layoutFinishedFlag: boolean): void;
	layoutManagerTextContainerDidChangeGeometryFromSize?(layoutManager: NSLayoutManager, textContainer: NSTextContainer, oldSize: CGSize): void;
}
interface NSTextLayoutOrientationProvider {
	layoutOrientation: number;
}
interface NSTextAttachmentContainer {
	imageForBoundsTextContainerCharacterIndex(imageBounds: CGRect, textContainer: NSTextContainer, charIndex: number): UIImage;
	attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(textContainer: NSTextContainer, lineFrag: CGRect, position: CGPoint, charIndex: number): CGRect;
}
interface UIPopoverPresentationControllerDelegate {
	prepareForPopoverPresentation?(popoverPresentationController: UIPopoverPresentationController): void;
	popoverPresentationControllerShouldDismissPopover?(popoverPresentationController: UIPopoverPresentationController): boolean;
	popoverPresentationControllerDidDismissPopover?(popoverPresentationController: UIPopoverPresentationController): void;
	popoverPresentationControllerWillRepositionPopoverToRectInView?(popoverPresentationController: UIPopoverPresentationController, rect: any, view: any): void;
}
interface UIDynamicAnimatorDelegate {
	dynamicAnimatorWillResume?(animator: UIDynamicAnimator): void;
	dynamicAnimatorDidPause?(animator: UIDynamicAnimator): void;
}
interface UICollisionBehaviorDelegate {
	collisionBehaviorBeganContactForItemWithItemAtPoint?(behavior: UICollisionBehavior, item1: any, item2: any, p: CGPoint): void;
	collisionBehaviorEndedContactForItemWithItem?(behavior: UICollisionBehavior, item1: any, item2: any): void;
	collisionBehaviorBeganContactForItemWithBoundaryIdentifierAtPoint?(behavior: UICollisionBehavior, item: any, identifier: any, p: CGPoint): void;
	collisionBehaviorEndedContactForItemWithBoundaryIdentifier?(behavior: UICollisionBehavior, item: any, identifier: any): void;
}
interface EAGLDrawable {
	drawableProperties: NSDictionary;
}
interface MTLCommandEncoder {
	device: any;
	label: string;
	endEncoding(): void;
	insertDebugSignpost(string: string): void;
	pushDebugGroup(string: string): void;
	popDebugGroup(): void;
}
interface MTLResource {
	label: string;
	device: any;
	cpuCacheMode: number;
	setPurgeableState(state: number): number;
}
interface MTLBuffer {
	length: number;
	contents(): any;
	newTextureWithDescriptorOffsetBytesPerRow(descriptor: MTLTextureDescriptor, offset: number, bytesPerRow: number): any;
}
interface MTLFunction {
	device: any;
	functionType: number;
	vertexAttributes: NSArray;
	name: string;
}
interface MTLLibrary {
	label: string;
	device: any;
	functionNames: NSArray;
	newFunctionWithName(functionName: string): any;
}
interface MTLDevice {
	name: string;
	newCommandQueue(): any;
	newCommandQueueWithMaxCommandBufferCount(maxCommandBufferCount: number): any;
	newBufferWithLengthOptions(length: number, options: number): any;
	newBufferWithBytesLengthOptions(pointer: any, length: number, options: number): any;
	newBufferWithBytesNoCopyLengthOptionsDeallocator(pointer: any, length: number, options: number, deallocator: (arg1: any, arg2: number) => void): any;
	newDepthStencilStateWithDescriptor(descriptor: MTLDepthStencilDescriptor): any;
	newTextureWithDescriptor(descriptor: MTLTextureDescriptor): any;
	newSamplerStateWithDescriptor(descriptor: MTLSamplerDescriptor): any;
	newDefaultLibrary(): any;
	newLibraryWithFileError(filepath: string, error: any): any;
	newLibraryWithDataError(data: NSObject, error: any): any;
	newLibraryWithSourceOptionsError(source: string, options: MTLCompileOptions, error: any): any;
	newLibraryWithSourceOptionsCompletionHandler(source: string, options: MTLCompileOptions, completionHandler: (arg1: any, arg2: NSError) => void): void;
	newRenderPipelineStateWithDescriptorError(descriptor: MTLRenderPipelineDescriptor, error: any): any;
	newRenderPipelineStateWithDescriptorOptionsReflectionError(descriptor: MTLRenderPipelineDescriptor, options: number, reflection: any, error: any): any;
	newRenderPipelineStateWithDescriptorCompletionHandler(descriptor: MTLRenderPipelineDescriptor, completionHandler: (arg1: any, arg2: NSError) => void): void;
	newRenderPipelineStateWithDescriptorOptionsCompletionHandler(descriptor: MTLRenderPipelineDescriptor, options: number, completionHandler: (arg1: any, arg2: MTLRenderPipelineReflection, arg3: NSError) => void): void;
	newComputePipelineStateWithFunctionError(computeFunction: any, error: any): any;
	newComputePipelineStateWithFunctionOptionsReflectionError(computeFunction: any, options: number, reflection: any, error: any): any;
	newComputePipelineStateWithFunctionCompletionHandler(computeFunction: any, completionHandler: (arg1: any, arg2: NSError) => void): void;
	newComputePipelineStateWithFunctionOptionsCompletionHandler(computeFunction: any, options: number, completionHandler: (arg1: any, arg2: MTLComputePipelineReflection, arg3: NSError) => void): void;
	supportsFeatureSet(featureSet: number): boolean;
}
interface MTLTexture {
	rootResource: any;
	textureType: number;
	pixelFormat: number;
	width: number;
	height: number;
	depth: number;
	mipmapLevelCount: number;
	sampleCount: number;
	arrayLength: number;
	framebufferOnly: boolean;
	getBytesBytesPerRowBytesPerImageFromRegionMipmapLevelSlice(pixelBytes: any, bytesPerRow: number, bytesPerImage: number, region: MTLRegion, level: number, slice: number): void;
	replaceRegionMipmapLevelSliceWithBytesBytesPerRowBytesPerImage(region: MTLRegion, level: number, slice: number, pixelBytes: any, bytesPerRow: number, bytesPerImage: number): void;
	getBytesBytesPerRowFromRegionMipmapLevel(pixelBytes: any, bytesPerRow: number, region: MTLRegion, level: number): void;
	replaceRegionMipmapLevelWithBytesBytesPerRow(region: MTLRegion, level: number, pixelBytes: any, bytesPerRow: number): void;
	newTextureViewWithPixelFormat(pixelFormat: number): any;
}
interface MTLBlitCommandEncoder {
	copyFromTextureSourceSliceSourceLevelSourceOriginSourceSizeToTextureDestinationSliceDestinationLevelDestinationOrigin(sourceTexture: any, sourceSlice: number, sourceLevel: number, sourceOrigin: MTLOrigin, sourceSize: MTLSize, destinationTexture: any, destinationSlice: number, destinationLevel: number, destinationOrigin: MTLOrigin): void;
	copyFromBufferSourceOffsetSourceBytesPerRowSourceBytesPerImageSourceSizeToTextureDestinationSliceDestinationLevelDestinationOrigin(sourceBuffer: any, sourceOffset: number, sourceBytesPerRow: number, sourceBytesPerImage: number, sourceSize: MTLSize, destinationTexture: any, destinationSlice: number, destinationLevel: number, destinationOrigin: MTLOrigin): void;
	copyFromTextureSourceSliceSourceLevelSourceOriginSourceSizeToBufferDestinationOffsetDestinationBytesPerRowDestinationBytesPerImage(sourceTexture: any, sourceSlice: number, sourceLevel: number, sourceOrigin: MTLOrigin, sourceSize: MTLSize, destinationBuffer: any, destinationOffset: number, destinationBytesPerRow: number, destinationBytesPerImage: number): void;
	generateMipmapsForTexture(texture: any): void;
	fillBufferRangeValue(buffer: any, range: NSRange, value: number): void;
	copyFromBufferSourceOffsetToBufferDestinationOffsetSize(sourceBuffer: any, sourceOffset: number, destinationBuffer: any, destinationOffset: number, size: number): void;
}
interface MTLCommandBuffer {
	device: any;
	commandQueue: any;
	retainedReferences: boolean;
	label: string;
	status: number;
	error: NSError;
	enqueue(): void;
	commit(): void;
	addScheduledHandler(block: (arg1: any) => void): void;
	presentDrawable(drawable: any): void;
	presentDrawableAtTime(drawable: any, presentationTime: number): void;
	waitUntilScheduled(): void;
	addCompletedHandler(block: (arg1: any) => void): void;
	waitUntilCompleted(): void;
	blitCommandEncoder(): any;
	renderCommandEncoderWithDescriptor(renderPassDescriptor: MTLRenderPassDescriptor): any;
	computeCommandEncoder(): any;
	parallelRenderCommandEncoderWithDescriptor(renderPassDescriptor: MTLRenderPassDescriptor): any;
}
interface MTLComputeCommandEncoder {
	setComputePipelineState(state: any): void;
	setBufferOffsetAtIndex(buffer: any, offset: number, index: number): void;
	setBuffersOffsetsWithRange(buffers: any, offsets: any, range: NSRange): void;
	setTextureAtIndex(texture: any, index: number): void;
	setTexturesWithRange(textures: any, range: NSRange): void;
	setSamplerStateAtIndex(sampler: any, index: number): void;
	setSamplerStatesWithRange(samplers: any, range: NSRange): void;
	setSamplerStateLodMinClampLodMaxClampAtIndex(sampler: any, lodMinClamp: number, lodMaxClamp: number, index: number): void;
	setSamplerStatesLodMinClampsLodMaxClampsWithRange(samplers: any, lodMinClamps: any, lodMaxClamps: any, range: NSRange): void;
	setThreadgroupMemoryLengthAtIndex(length: number, index: number): void;
	dispatchThreadgroupsThreadsPerThreadgroup(threadgroupsPerGrid: MTLSize, threadsPerThreadgroup: MTLSize): void;
}
interface MTLCommandQueue {
	label: string;
	device: any;
	commandBuffer(): any;
	commandBufferWithUnretainedReferences(): any;
	insertDebugCaptureBoundary(): void;
}
interface MTLDepthStencilState {
	label: string;
	device: any;
}
interface MTLDrawable {
	present(): void;
	presentAtTime(presentationTime: number): void;
}
interface MTLComputePipelineState {
	device: any;
	maxTotalThreadsPerThreadgroup: number;
	threadExecutionWidth: number;
}
interface MTLRenderPipelineState {
	label: string;
	device: any;
}
interface MTLParallelRenderCommandEncoder {
	renderCommandEncoder(): any;
}
interface MTLRenderCommandEncoder {
	setRenderPipelineState(pipelineState: any): void;
	setVertexBufferOffsetAtIndex(buffer: any, offset: number, index: number): void;
	setVertexBuffersOffsetsWithRange(buffers: any, offsets: any, range: NSRange): void;
	setVertexTextureAtIndex(texture: any, index: number): void;
	setVertexTexturesWithRange(textures: any, range: NSRange): void;
	setVertexSamplerStateAtIndex(sampler: any, index: number): void;
	setVertexSamplerStatesWithRange(samplers: any, range: NSRange): void;
	setVertexSamplerStateLodMinClampLodMaxClampAtIndex(sampler: any, lodMinClamp: number, lodMaxClamp: number, index: number): void;
	setVertexSamplerStatesLodMinClampsLodMaxClampsWithRange(samplers: any, lodMinClamps: any, lodMaxClamps: any, range: NSRange): void;
	setViewport(viewport: MTLViewport): void;
	setFrontFacingWinding(frontFacingWinding: number): void;
	setCullMode(cullMode: number): void;
	setDepthBiasSlopeScaleClamp(depthBias: number, slopeScale: number, clamp: number): void;
	setScissorRect(rect: MTLScissorRect): void;
	setTriangleFillMode(fillMode: number): void;
	setFragmentBufferOffsetAtIndex(buffer: any, offset: number, index: number): void;
	setFragmentBuffersOffsetsWithRange(buffers: any, offset: any, range: NSRange): void;
	setFragmentTextureAtIndex(texture: any, index: number): void;
	setFragmentTexturesWithRange(textures: any, range: NSRange): void;
	setFragmentSamplerStateAtIndex(sampler: any, index: number): void;
	setFragmentSamplerStatesWithRange(samplers: any, range: NSRange): void;
	setFragmentSamplerStateLodMinClampLodMaxClampAtIndex(sampler: any, lodMinClamp: number, lodMaxClamp: number, index: number): void;
	setFragmentSamplerStatesLodMinClampsLodMaxClampsWithRange(samplers: any, lodMinClamps: any, lodMaxClamps: any, range: NSRange): void;
	setBlendColorRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): void;
	setDepthStencilState(depthStencilState: any): void;
	setStencilReferenceValue(referenceValue: number): void;
	setVisibilityResultModeOffset(mode: number, offset: number): void;
	drawPrimitivesVertexStartVertexCountInstanceCount(primitiveType: number, vertexStart: number, vertexCount: number, instanceCount: number): void;
	drawPrimitivesVertexStartVertexCount(primitiveType: number, vertexStart: number, vertexCount: number): void;
	drawIndexedPrimitivesIndexCountIndexTypeIndexBufferIndexBufferOffsetInstanceCount(primitiveType: number, indexCount: number, indexType: number, indexBuffer: any, indexBufferOffset: number, instanceCount: number): void;
	drawIndexedPrimitivesIndexCountIndexTypeIndexBufferIndexBufferOffset(primitiveType: number, indexCount: number, indexType: number, indexBuffer: any, indexBufferOffset: number): void;
}
interface MTLSamplerState {
	label: string;
	device: any;
}
interface ABPeoplePickerNavigationControllerDelegate {
	peoplePickerNavigationControllerDidSelectPerson?(peoplePicker: ABPeoplePickerNavigationController, person: any): void;
	peoplePickerNavigationControllerDidSelectPersonPropertyIdentifier?(peoplePicker: ABPeoplePickerNavigationController, person: any, property: number, identifier: number): void;
	peoplePickerNavigationControllerDidCancel?(peoplePicker: ABPeoplePickerNavigationController): void;
	peoplePickerNavigationControllerShouldContinueAfterSelectingPerson?(peoplePicker: ABPeoplePickerNavigationController, person: any): boolean;
	peoplePickerNavigationControllerShouldContinueAfterSelectingPersonPropertyIdentifier?(peoplePicker: ABPeoplePickerNavigationController, person: any, property: number, identifier: number): boolean;
}
interface ABPersonViewControllerDelegate {
	personViewControllerShouldPerformDefaultActionForPersonPropertyIdentifier(personViewController: ABPersonViewController, person: any, property: number, identifier: number): boolean;
}
interface ABNewPersonViewControllerDelegate {
	newPersonViewControllerDidCompleteWithNewPerson(newPersonView: ABNewPersonViewController, person: any): void;
}
interface ABUnknownPersonViewControllerDelegate {
	unknownPersonViewControllerDidResolveToPerson(unknownCardViewController: ABUnknownPersonViewController, person: any): void;
	unknownPersonViewControllerShouldPerformDefaultActionForPersonPropertyIdentifier?(personViewController: ABUnknownPersonViewController, person: any, property: number, identifier: number): boolean;
}
interface CAMediaTiming {
	beginTime: number;
	duration: number;
	speed: number;
	timeOffset: number;
	repeatCount: number;
	repeatDuration: number;
	autoreverses: boolean;
	fillMode: string;
}
interface CAAction {
	runActionForKeyObjectArguments(event: string, anObject: any, dict: NSDictionary): void;
}
interface AVAudioMixing {
	volume: number;
}
interface AVAudioStereoMixing {
	pan: number;
}
interface AVAudio3DMixing {
	renderingAlgorithm: number;
	rate: number;
	reverbBlend: number;
	obstruction: number;
	occlusion: number;
	position: AVAudio3DPoint;
}
interface AVAudioPlayerDelegate {
	audioPlayerDidFinishPlayingSuccessfully?(player: AVAudioPlayer, flag: boolean): void;
	audioPlayerDecodeErrorDidOccurError?(player: AVAudioPlayer, error: NSError): void;
	audioPlayerBeginInterruption?(player: AVAudioPlayer): void;
	audioPlayerEndInterruptionWithOptions?(player: AVAudioPlayer, flags: number): void;
	audioPlayerEndInterruptionWithFlags?(player: AVAudioPlayer, flags: number): void;
	audioPlayerEndInterruption?(player: AVAudioPlayer): void;
}
interface AVAudioRecorderDelegate {
	audioRecorderDidFinishRecordingSuccessfully?(recorder: AVAudioRecorder, flag: boolean): void;
	audioRecorderEncodeErrorDidOccurError?(recorder: AVAudioRecorder, error: NSError): void;
	audioRecorderBeginInterruption?(recorder: AVAudioRecorder): void;
	audioRecorderEndInterruptionWithOptions?(recorder: AVAudioRecorder, flags: number): void;
	audioRecorderEndInterruptionWithFlags?(recorder: AVAudioRecorder, flags: number): void;
	audioRecorderEndInterruption?(recorder: AVAudioRecorder): void;
}
interface AVAudioSessionDelegate {
	beginInterruption?(): void;
	endInterruptionWithFlags?(flags: number): void;
	endInterruption?(): void;
	inputIsAvailableChanged?(isInputAvailable: boolean): void;
}
interface AVAsynchronousKeyValueLoading {
	statusOfValueForKeyError(key: string, outError: any): number;
	loadValuesAsynchronouslyForKeysCompletionHandler(keys: NSArray, handler: () => void): void;
}
interface AVVideoCompositing {
	sourcePixelBufferAttributes: NSDictionary;
	requiredPixelBufferAttributesForRenderContext: NSDictionary;
	renderContextChanged(newRenderContext: AVVideoCompositionRenderContext): void;
	startVideoCompositionRequest(asyncVideoCompositionRequest: AVAsynchronousVideoCompositionRequest): void;
	cancelAllPendingVideoCompositionRequests?(): void;
}
interface AVVideoCompositionInstructionProtocol {
	timeRange: CMTimeRange;
	enablePostProcessing: boolean;
	containsTweening: boolean;
	requiredSourceTrackIDs: NSArray;
	passthroughTrackID: number;
}
interface AVVideoCompositionValidationHandling {
	videoCompositionShouldContinueValidatingAfterFindingInvalidValueForKey?(videoComposition: AVVideoComposition, key: string): boolean;
	videoCompositionShouldContinueValidatingAfterFindingEmptyTimeRange?(videoComposition: AVVideoComposition, timeRange: CMTimeRange): boolean;
	videoCompositionShouldContinueValidatingAfterFindingInvalidTimeRangeInInstruction?(videoComposition: AVVideoComposition, videoCompositionInstruction: any): boolean;
	videoCompositionShouldContinueValidatingAfterFindingInvalidTrackIDInInstructionLayerInstructionAsset?(videoComposition: AVVideoComposition, videoCompositionInstruction: any, layerInstruction: AVVideoCompositionLayerInstruction, asset: AVAsset): boolean;
}
interface AVAssetResourceLoaderDelegate {
	resourceLoaderShouldWaitForLoadingOfRequestedResource?(resourceLoader: AVAssetResourceLoader, loadingRequest: AVAssetResourceLoadingRequest): boolean;
	resourceLoaderShouldWaitForRenewalOfRequestedResource?(resourceLoader: AVAssetResourceLoader, renewalRequest: AVAssetResourceRenewalRequest): boolean;
	resourceLoaderDidCancelLoadingRequest?(resourceLoader: AVAssetResourceLoader, loadingRequest: AVAssetResourceLoadingRequest): void;
	resourceLoaderShouldWaitForResponseToAuthenticationChallenge?(resourceLoader: AVAssetResourceLoader, authenticationChallenge: NSURLAuthenticationChallenge): boolean;
	resourceLoaderDidCancelAuthenticationChallenge?(resourceLoader: AVAssetResourceLoader, authenticationChallenge: NSURLAuthenticationChallenge): void;
}
interface AVCaptureVideoDataOutputSampleBufferDelegate {
	captureOutputDidOutputSampleBufferFromConnection?(captureOutput: AVCaptureOutput, sampleBuffer: any, connection: AVCaptureConnection): void;
	captureOutputDidDropSampleBufferFromConnection?(captureOutput: AVCaptureOutput, sampleBuffer: any, connection: AVCaptureConnection): void;
}
interface AVCaptureAudioDataOutputSampleBufferDelegate {
	captureOutputDidOutputSampleBufferFromConnection?(captureOutput: AVCaptureOutput, sampleBuffer: any, connection: AVCaptureConnection): void;
}
interface AVCaptureFileOutputRecordingDelegate {
	captureOutputDidStartRecordingToOutputFileAtURLFromConnections?(captureOutput: AVCaptureFileOutput, fileURL: NSURL, connections: NSArray): void;
	captureOutputDidFinishRecordingToOutputFileAtURLFromConnectionsError(captureOutput: AVCaptureFileOutput, outputFileURL: NSURL, connections: NSArray, error: NSError): void;
}
interface AVCaptureMetadataOutputObjectsDelegate {
	captureOutputDidOutputMetadataObjectsFromConnection?(captureOutput: AVCaptureOutput, metadataObjects: NSArray, connection: AVCaptureConnection): void;
}
interface AVPlayerItemOutputPullDelegate {
	outputMediaDataWillChange?(sender: AVPlayerItemOutput): void;
	outputSequenceWasFlushed?(output: AVPlayerItemOutput): void;
}
interface AVPlayerItemLegibleOutputPushDelegate {
	legibleOutputDidOutputAttributedStringsNativeSampleBuffersForItemTime?(output: AVPlayerItemLegibleOutput, strings: NSArray, nativeSamples: NSArray, itemTime: CMTime): void;
}
interface AVPlayerItemOutputPushDelegate {
	outputSequenceWasFlushed?(output: AVPlayerItemOutput): void;
}
interface AVPlayerItemMetadataOutputPushDelegate {
	metadataOutputDidOutputTimedMetadataGroupsFromPlayerItemTrack?(output: AVPlayerItemMetadataOutput, groups: NSArray, track: AVPlayerItemTrack): void;
}
interface AVSpeechSynthesizerDelegate {
	speechSynthesizerDidStartSpeechUtterance?(synthesizer: AVSpeechSynthesizer, utterance: AVSpeechUtterance): void;
	speechSynthesizerDidFinishSpeechUtterance?(synthesizer: AVSpeechSynthesizer, utterance: AVSpeechUtterance): void;
	speechSynthesizerDidPauseSpeechUtterance?(synthesizer: AVSpeechSynthesizer, utterance: AVSpeechUtterance): void;
	speechSynthesizerDidContinueSpeechUtterance?(synthesizer: AVSpeechSynthesizer, utterance: AVSpeechUtterance): void;
	speechSynthesizerDidCancelSpeechUtterance?(synthesizer: AVSpeechSynthesizer, utterance: AVSpeechUtterance): void;
	speechSynthesizerWillSpeakRangeOfSpeechStringUtterance?(synthesizer: AVSpeechSynthesizer, characterRange: NSRange, utterance: AVSpeechUtterance): void;
}
interface CKRecordValue {
}
interface CLLocationManagerDelegate {
	locationManagerDidUpdateToLocationFromLocation?(manager: CLLocationManager, newLocation: CLLocation, oldLocation: CLLocation): void;
	locationManagerDidUpdateLocations?(manager: CLLocationManager, locations: NSArray): void;
	locationManagerDidUpdateHeading?(manager: CLLocationManager, newHeading: CLHeading): void;
	locationManagerShouldDisplayHeadingCalibration?(manager: CLLocationManager): boolean;
	locationManagerDidDetermineStateForRegion?(manager: CLLocationManager, state: number, region: CLRegion): void;
	locationManagerDidRangeBeaconsInRegion?(manager: CLLocationManager, beacons: NSArray, region: CLBeaconRegion): void;
	locationManagerRangingBeaconsDidFailForRegionWithError?(manager: CLLocationManager, region: CLBeaconRegion, error: NSError): void;
	locationManagerDidEnterRegion?(manager: CLLocationManager, region: CLRegion): void;
	locationManagerDidExitRegion?(manager: CLLocationManager, region: CLRegion): void;
	locationManagerDidFailWithError?(manager: CLLocationManager, error: NSError): void;
	locationManagerMonitoringDidFailForRegionWithError?(manager: CLLocationManager, region: CLRegion, error: NSError): void;
	locationManagerDidChangeAuthorizationStatus?(manager: CLLocationManager, status: number): void;
	locationManagerDidStartMonitoringForRegion?(manager: CLLocationManager, region: CLRegion): void;
	locationManagerDidPauseLocationUpdates?(manager: CLLocationManager): void;
	locationManagerDidResumeLocationUpdates?(manager: CLLocationManager): void;
	locationManagerDidFinishDeferredUpdatesWithError?(manager: CLLocationManager, error: NSError): void;
	locationManagerDidVisit?(manager: CLLocationManager, visit: CLVisit): void;
}
interface CBCentralManagerDelegate {
	centralManagerDidUpdateState(central: CBCentralManager): void;
	centralManagerWillRestoreState?(central: CBCentralManager, dict: NSDictionary): void;
	centralManagerDidRetrievePeripherals?(central: CBCentralManager, peripherals: NSArray): void;
	centralManagerDidRetrieveConnectedPeripherals?(central: CBCentralManager, peripherals: NSArray): void;
	centralManagerDidDiscoverPeripheralAdvertisementDataRSSI?(central: CBCentralManager, peripheral: CBPeripheral, advertisementData: NSDictionary, RSSI: NSNumber): void;
	centralManagerDidConnectPeripheral?(central: CBCentralManager, peripheral: CBPeripheral): void;
	centralManagerDidFailToConnectPeripheralError?(central: CBCentralManager, peripheral: CBPeripheral, error: NSError): void;
	centralManagerDidDisconnectPeripheralError?(central: CBCentralManager, peripheral: CBPeripheral, error: NSError): void;
}
interface CBPeripheralManagerDelegate {
	peripheralManagerDidUpdateState(peripheral: CBPeripheralManager): void;
	peripheralManagerWillRestoreState?(peripheral: CBPeripheralManager, dict: NSDictionary): void;
	peripheralManagerDidStartAdvertisingError?(peripheral: CBPeripheralManager, error: NSError): void;
	peripheralManagerDidAddServiceError?(peripheral: CBPeripheralManager, service: CBService, error: NSError): void;
	peripheralManagerCentralDidSubscribeToCharacteristic?(peripheral: CBPeripheralManager, central: CBCentral, characteristic: CBCharacteristic): void;
	peripheralManagerCentralDidUnsubscribeFromCharacteristic?(peripheral: CBPeripheralManager, central: CBCentral, characteristic: CBCharacteristic): void;
	peripheralManagerDidReceiveReadRequest?(peripheral: CBPeripheralManager, request: CBATTRequest): void;
	peripheralManagerDidReceiveWriteRequests?(peripheral: CBPeripheralManager, requests: NSArray): void;
	peripheralManagerIsReadyToUpdateSubscribers?(peripheral: CBPeripheralManager): void;
}
interface CBPeripheralDelegate {
	peripheralDidUpdateName?(peripheral: CBPeripheral): void;
	peripheralDidInvalidateServices?(peripheral: CBPeripheral): void;
	peripheralDidModifyServices?(peripheral: CBPeripheral, invalidatedServices: NSArray): void;
	peripheralDidUpdateRSSIError?(peripheral: CBPeripheral, error: NSError): void;
	peripheralDidReadRSSIError?(peripheral: CBPeripheral, RSSI: NSNumber, error: NSError): void;
	peripheralDidDiscoverServices?(peripheral: CBPeripheral, error: NSError): void;
	peripheralDidDiscoverIncludedServicesForServiceError?(peripheral: CBPeripheral, service: CBService, error: NSError): void;
	peripheralDidDiscoverCharacteristicsForServiceError?(peripheral: CBPeripheral, service: CBService, error: NSError): void;
	peripheralDidUpdateValueForCharacteristicError?(peripheral: CBPeripheral, characteristic: CBCharacteristic, error: NSError): void;
	peripheralDidWriteValueForCharacteristicError?(peripheral: CBPeripheral, characteristic: CBCharacteristic, error: NSError): void;
	peripheralDidUpdateNotificationStateForCharacteristicError?(peripheral: CBPeripheral, characteristic: CBCharacteristic, error: NSError): void;
	peripheralDidDiscoverDescriptorsForCharacteristicError?(peripheral: CBPeripheral, characteristic: CBCharacteristic, error: NSError): void;
	peripheralDidUpdateValueForDescriptorError?(peripheral: CBPeripheral, descriptor: CBDescriptor, error: NSError): void;
	peripheralDidWriteValueForDescriptorError?(peripheral: CBPeripheral, descriptor: CBDescriptor, error: NSError): void;
}
interface EKEventEditViewDelegate {
	eventEditViewControllerDidCompleteWithAction(controller: EKEventEditViewController, action: number): void;
	eventEditViewControllerDefaultCalendarForNewEvents?(controller: EKEventEditViewController): EKCalendar;
}
interface EKEventViewDelegate {
	eventViewControllerDidCompleteWithAction(controller: EKEventViewController, action: number): void;
}
interface EKCalendarChooserDelegate {
	calendarChooserSelectionDidChange?(calendarChooser: EKCalendarChooser): void;
	calendarChooserDidFinish?(calendarChooser: EKCalendarChooser): void;
	calendarChooserDidCancel?(calendarChooser: EKCalendarChooser): void;
}
interface GKGameCenterControllerDelegate {
	gameCenterViewControllerDidFinish(gameCenterViewController: GKGameCenterViewController): void;
}
interface GKAchievementViewControllerDelegate {
	achievementViewControllerDidFinish(viewController: GKAchievementViewController): void;
}
interface GKChallengeEventHandlerDelegate {
	localPlayerDidSelectChallenge?(challenge: GKChallenge): void;
	shouldShowBannerForLocallyReceivedChallenge?(challenge: GKChallenge): boolean;
	localPlayerDidReceiveChallenge?(challenge: GKChallenge): void;
	shouldShowBannerForLocallyCompletedChallenge?(challenge: GKChallenge): boolean;
	localPlayerDidCompleteChallenge?(challenge: GKChallenge): void;
	shouldShowBannerForRemotelyCompletedChallenge?(challenge: GKChallenge): boolean;
	remotePlayerDidCompleteChallenge?(challenge: GKChallenge): void;
}
interface GKChallengeListener {
	playerWantsToPlayChallenge?(player: GKPlayer, challenge: GKChallenge): void;
	playerDidReceiveChallenge?(player: GKPlayer, challenge: GKChallenge): void;
	playerDidCompleteChallengeIssuedByFriend?(player: GKPlayer, challenge: GKChallenge, friendPlayer: GKPlayer): void;
	playerIssuedChallengeWasCompletedByFriend?(player: GKPlayer, challenge: GKChallenge, friendPlayer: GKPlayer): void;
}
interface GKFriendRequestComposeViewControllerDelegate {
	friendRequestComposeViewControllerDidFinish(viewController: GKFriendRequestComposeViewController): void;
}
interface GKLeaderboardViewControllerDelegate {
	leaderboardViewControllerDidFinish(viewController: GKLeaderboardViewController): void;
}
interface GKTurnBasedEventListener {
	playerDidRequestMatchWithOtherPlayers?(player: GKPlayer, playersToInvite: NSArray): void;
	playerReceivedTurnEventForMatchDidBecomeActive?(player: GKPlayer, match: GKTurnBasedMatch, didBecomeActive: boolean): void;
	playerMatchEnded?(player: GKPlayer, match: GKTurnBasedMatch): void;
	playerReceivedExchangeRequestForMatch?(player: GKPlayer, exchange: GKTurnBasedExchange, match: GKTurnBasedMatch): void;
	playerReceivedExchangeCancellationForMatch?(player: GKPlayer, exchange: GKTurnBasedExchange, match: GKTurnBasedMatch): void;
	playerReceivedExchangeRepliesForCompletedExchangeForMatch?(player: GKPlayer, replies: NSArray, exchange: GKTurnBasedExchange, match: GKTurnBasedMatch): void;
	playerDidRequestMatchWithPlayers?(player: GKPlayer, playerIDsToInvite: NSArray): void;
}
interface GKTurnBasedEventHandlerDelegate {
	handleInviteFromGameCenter(playersToInvite: NSArray): void;
	handleTurnEventForMatchDidBecomeActive(match: GKTurnBasedMatch, didBecomeActive: boolean): void;
	handleTurnEventForMatch?(match: GKTurnBasedMatch): void;
	handleMatchEnded?(match: GKTurnBasedMatch): void;
}
interface GKInviteEventListener {
	playerDidAcceptInvite?(player: GKPlayer, invite: GKInvite): void;
	playerDidRequestMatchWithRecipients?(player: GKPlayer, recipientPlayers: NSArray): void;
	playerDidRequestMatchWithPlayers?(player: GKPlayer, playerIDsToInvite: NSArray): void;
}
interface GKSavedGameListener {
	playerDidModifySavedGame?(player: GKPlayer, savedGame: GKSavedGame): void;
	playerHasConflictingSavedGames?(player: GKPlayer, savedGames: NSArray): void;
}
interface GKLocalPlayerListener {
}
interface GKMatchDelegate {
	matchDidReceiveDataFromRemotePlayer?(match: GKMatch, data: NSData, player: GKPlayer): void;
	matchDidReceiveDataFromPlayer?(match: GKMatch, data: NSData, playerID: string): void;
	matchPlayerDidChangeConnectionState?(match: GKMatch, player: GKPlayer, state: number): void;
	matchPlayerDidChangeState?(match: GKMatch, playerID: string, state: number): void;
	matchDidFailWithError?(match: GKMatch, error: NSError): void;
	matchShouldReinviteDisconnectedPlayer?(match: GKMatch, player: GKPlayer): boolean;
	matchShouldReinvitePlayer?(match: GKMatch, playerID: string): boolean;
}
interface GKMatchmakerViewControllerDelegate {
	matchmakerViewControllerWasCancelled(viewController: GKMatchmakerViewController): void;
	matchmakerViewControllerDidFailWithError(viewController: GKMatchmakerViewController, error: NSError): void;
	matchmakerViewControllerDidFindMatch?(viewController: GKMatchmakerViewController, match: GKMatch): void;
	matchmakerViewControllerDidFindHostedPlayers?(viewController: GKMatchmakerViewController, players: NSArray): void;
	matchmakerViewControllerDidFindPlayers?(viewController: GKMatchmakerViewController, playerIDs: NSArray): void;
	matchmakerViewControllerHostedPlayerDidAccept?(viewController: GKMatchmakerViewController, player: GKPlayer): void;
	matchmakerViewControllerDidReceiveAcceptFromHostedPlayer?(viewController: GKMatchmakerViewController, playerID: string): void;
}
interface GKSessionDelegate {
	sessionPeerDidChangeState?(session: GKSession, peerID: string, state: number): void;
	sessionDidReceiveConnectionRequestFromPeer?(session: GKSession, peerID: string): void;
	sessionConnectionWithPeerFailedWithError?(session: GKSession, peerID: string, error: NSError): void;
	sessionDidFailWithError?(session: GKSession, error: NSError): void;
}
interface GKVoiceChatClient {
	voiceChatServiceSendDataToParticipantID(voiceChatService: GKVoiceChatService, data: NSData, participantID: string): void;
	participantID(): string;
	voiceChatServiceSendRealTimeDataToParticipantID?(voiceChatService: GKVoiceChatService, data: NSData, participantID: string): void;
	voiceChatServiceDidStartWithParticipantID?(voiceChatService: GKVoiceChatService, participantID: string): void;
	voiceChatServiceDidNotStartWithParticipantIDError?(voiceChatService: GKVoiceChatService, participantID: string, error: NSError): void;
	voiceChatServiceDidStopWithParticipantIDError?(voiceChatService: GKVoiceChatService, participantID: string, error: NSError): void;
	voiceChatServiceDidReceiveInvitationFromParticipantIDCallID?(voiceChatService: GKVoiceChatService, participantID: string, callID: number): void;
}
interface GKPeerPickerControllerDelegate {
	peerPickerControllerDidSelectConnectionType?(picker: GKPeerPickerController, type: number): void;
	peerPickerControllerSessionForConnectionType?(picker: GKPeerPickerController, type: number): GKSession;
	peerPickerControllerDidConnectPeerToSession?(picker: GKPeerPickerController, peerID: string, session: GKSession): void;
	peerPickerControllerDidCancel?(picker: GKPeerPickerController): void;
}
interface GKTurnBasedMatchmakerViewControllerDelegate {
	turnBasedMatchmakerViewControllerWasCancelled(viewController: GKTurnBasedMatchmakerViewController): void;
	turnBasedMatchmakerViewControllerDidFailWithError(viewController: GKTurnBasedMatchmakerViewController, error: NSError): void;
	turnBasedMatchmakerViewControllerDidFindMatch(viewController: GKTurnBasedMatchmakerViewController, match: GKTurnBasedMatch): void;
	turnBasedMatchmakerViewControllerPlayerQuitForMatch(viewController: GKTurnBasedMatchmakerViewController, match: GKTurnBasedMatch): void;
}
interface GLKViewDelegate {
	glkViewDrawInRect(view: GLKView, rect: CGRect): void;
}
interface GLKViewControllerDelegate {
	glkViewControllerUpdate(controller: GLKViewController): void;
	glkViewControllerWillPause?(controller: GLKViewController, pause: boolean): void;
}
interface GLKNamedEffect {
	prepareToDraw(): void;
}
interface HMHomeManagerDelegate {
	homeManagerDidUpdateHomes?(manager: HMHomeManager): void;
	homeManagerDidUpdatePrimaryHome?(manager: HMHomeManager): void;
	homeManagerDidAddHome?(manager: HMHomeManager, home: HMHome): void;
	homeManagerDidRemoveHome?(manager: HMHomeManager, home: HMHome): void;
}
interface HMAccessoryBrowserDelegate {
	accessoryBrowserDidFindNewAccessory?(browser: HMAccessoryBrowser, accessory: HMAccessory): void;
	accessoryBrowserDidRemoveNewAccessory?(browser: HMAccessoryBrowser, accessory: HMAccessory): void;
}
interface HMHomeDelegate {
	homeDidUpdateName?(home: HMHome): void;
	homeDidAddAccessory?(home: HMHome, accessory: HMAccessory): void;
	homeDidRemoveAccessory?(home: HMHome, accessory: HMAccessory): void;
	homeDidAddUser?(home: HMHome, user: HMUser): void;
	homeDidRemoveUser?(home: HMHome, user: HMUser): void;
	homeDidUpdateRoomForAccessory?(home: HMHome, room: HMRoom, accessory: HMAccessory): void;
	homeDidAddRoom?(home: HMHome, room: HMRoom): void;
	homeDidRemoveRoom?(home: HMHome, room: HMRoom): void;
	homeDidUpdateNameForRoom?(home: HMHome, room: HMRoom): void;
	homeDidAddZone?(home: HMHome, zone: HMZone): void;
	homeDidRemoveZone?(home: HMHome, zone: HMZone): void;
	homeDidUpdateNameForZone?(home: HMHome, zone: HMZone): void;
	homeDidAddRoomToZone?(home: HMHome, room: HMRoom, zone: HMZone): void;
	homeDidRemoveRoomFromZone?(home: HMHome, room: HMRoom, zone: HMZone): void;
	homeDidAddServiceGroup?(home: HMHome, group: HMServiceGroup): void;
	homeDidRemoveServiceGroup?(home: HMHome, group: HMServiceGroup): void;
	homeDidUpdateNameForServiceGroup?(home: HMHome, group: HMServiceGroup): void;
	homeDidAddServiceToServiceGroup?(home: HMHome, service: HMService, group: HMServiceGroup): void;
	homeDidRemoveServiceFromServiceGroup?(home: HMHome, service: HMService, group: HMServiceGroup): void;
	homeDidAddActionSet?(home: HMHome, actionSet: HMActionSet): void;
	homeDidRemoveActionSet?(home: HMHome, actionSet: HMActionSet): void;
	homeDidUpdateNameForActionSet?(home: HMHome, actionSet: HMActionSet): void;
	homeDidUpdateActionsForActionSet?(home: HMHome, actionSet: HMActionSet): void;
	homeDidAddTrigger?(home: HMHome, trigger: HMTrigger): void;
	homeDidRemoveTrigger?(home: HMHome, trigger: HMTrigger): void;
	homeDidUpdateNameForTrigger?(home: HMHome, trigger: HMTrigger): void;
	homeDidUpdateTrigger?(home: HMHome, trigger: HMTrigger): void;
	homeDidUnblockAccessory?(home: HMHome, accessory: HMAccessory): void;
	homeDidEncounterErrorForAccessory?(home: HMHome, error: NSError, accessory: HMAccessory): void;
}
interface HMAccessoryDelegate {
	accessoryDidUpdateName?(accessory: HMAccessory): void;
	accessoryDidUpdateNameForService?(accessory: HMAccessory, service: HMService): void;
	accessoryDidUpdateAssociatedServiceTypeForService?(accessory: HMAccessory, service: HMService): void;
	accessoryDidUpdateServices?(accessory: HMAccessory): void;
	accessoryDidUpdateReachability?(accessory: HMAccessory): void;
	accessoryServiceDidUpdateValueForCharacteristic?(accessory: HMAccessory, service: HMService, characteristic: HMCharacteristic): void;
}
interface MPMediaPickerControllerDelegate {
	mediaPickerDidPickMediaItems?(mediaPicker: MPMediaPickerController, mediaItemCollection: MPMediaItemCollection): void;
	mediaPickerDidCancel?(mediaPicker: MPMediaPickerController): void;
}
interface MPMediaPlayback {
	isPreparedToPlay: boolean;
	currentPlaybackTime: number;
	currentPlaybackRate: number;
	prepareToPlay(): void;
	play(): void;
	pause(): void;
	stop(): void;
	beginSeekingForward(): void;
	beginSeekingBackward(): void;
	endSeeking(): void;
}
interface MPPlayableContentDataSource {
	beginLoadingChildItemsAtIndexPathCompletionHandler?(indexPath: NSIndexPath, completionHandler: (arg1: NSError) => void): void;
	childItemsDisplayPlaybackProgressAtIndexPath?(indexPath: NSIndexPath): boolean;
	numberOfChildItemsAtIndexPath(indexPath: NSIndexPath): number;
	contentItemAtIndexPath(indexPath: NSIndexPath): MPContentItem;
}
interface MPPlayableContentDelegate {
	playableContentManagerInitiatePlaybackOfContentItemAtIndexPathCompletionHandler?(contentManager: MPPlayableContentManager, indexPath: NSIndexPath, completionHandler: (arg1: NSError) => void): void;
}
interface JSExport {
}
interface MKAnnotation {
	coordinate: CLLocationCoordinate2D;
	title: string;
	subtitle: string;
	setCoordinate?(newCoordinate: CLLocationCoordinate2D): void;
}
interface MKOverlay {
	boundingMapRect: MKMapRect;
	intersectsMapRect?(mapRect: MKMapRect): boolean;
	canReplaceMapContent?(): boolean;
}
interface MKMapViewDelegate {
	mapViewRegionWillChangeAnimated?(mapView: MKMapView, animated: boolean): void;
	mapViewRegionDidChangeAnimated?(mapView: MKMapView, animated: boolean): void;
	mapViewWillStartLoadingMap?(mapView: MKMapView): void;
	mapViewDidFinishLoadingMap?(mapView: MKMapView): void;
	mapViewDidFailLoadingMapWithError?(mapView: MKMapView, error: NSError): void;
	mapViewWillStartRenderingMap?(mapView: MKMapView): void;
	mapViewDidFinishRenderingMapFullyRendered?(mapView: MKMapView, fullyRendered: boolean): void;
	mapViewViewForAnnotation?(mapView: MKMapView, annotation: any): MKAnnotationView;
	mapViewDidAddAnnotationViews?(mapView: MKMapView, views: NSArray): void;
	mapViewAnnotationViewCalloutAccessoryControlTapped?(mapView: MKMapView, view: MKAnnotationView, control: UIControl): void;
	mapViewDidSelectAnnotationView?(mapView: MKMapView, view: MKAnnotationView): void;
	mapViewDidDeselectAnnotationView?(mapView: MKMapView, view: MKAnnotationView): void;
	mapViewWillStartLocatingUser?(mapView: MKMapView): void;
	mapViewDidStopLocatingUser?(mapView: MKMapView): void;
	mapViewDidUpdateUserLocation?(mapView: MKMapView, userLocation: MKUserLocation): void;
	mapViewDidFailToLocateUserWithError?(mapView: MKMapView, error: NSError): void;
	mapViewAnnotationViewDidChangeDragStateFromOldState?(mapView: MKMapView, view: MKAnnotationView, newState: number, oldState: number): void;
	mapViewDidChangeUserTrackingModeAnimated?(mapView: MKMapView, mode: number, animated: boolean): void;
	mapViewRendererForOverlay?(mapView: MKMapView, overlay: any): MKOverlayRenderer;
	mapViewDidAddOverlayRenderers?(mapView: MKMapView, renderers: NSArray): void;
	mapViewViewForOverlay?(mapView: MKMapView, overlay: any): MKOverlayView;
	mapViewDidAddOverlayViews?(mapView: MKMapView, overlayViews: NSArray): void;
}
interface MKReverseGeocoderDelegate {
	reverseGeocoderDidFindPlacemark(geocoder: MKReverseGeocoder, placemark: MKPlacemark): void;
	reverseGeocoderDidFailWithError(geocoder: MKReverseGeocoder, error: NSError): void;
}
interface MFMailComposeViewControllerDelegate {
	mailComposeControllerDidFinishWithResultError?(controller: MFMailComposeViewController, result: number, error: NSError): void;
}
interface MFMessageComposeViewControllerDelegate {
	messageComposeViewControllerDidFinishWithResult(controller: MFMessageComposeViewController, result: number): void;
}
interface MCSessionDelegate {
	sessionPeerDidChangeState(session: MCSession, peerID: MCPeerID, state: number): void;
	sessionDidReceiveDataFromPeer(session: MCSession, data: NSData, peerID: MCPeerID): void;
	sessionDidReceiveStreamWithNameFromPeer(session: MCSession, stream: NSInputStream, streamName: string, peerID: MCPeerID): void;
	sessionDidStartReceivingResourceWithNameFromPeerWithProgress(session: MCSession, resourceName: string, peerID: MCPeerID, progress: NSProgress): void;
	sessionDidFinishReceivingResourceWithNameFromPeerAtURLWithError(session: MCSession, resourceName: string, peerID: MCPeerID, localURL: NSURL, error: NSError): void;
	sessionDidReceiveCertificateFromPeerCertificateHandler?(session: MCSession, certificate: NSArray, peerID: MCPeerID, certificateHandler: (arg1: boolean) => void): void;
}
interface MCNearbyServiceAdvertiserDelegate {
	advertiserDidReceiveInvitationFromPeerWithContextInvitationHandler(advertiser: MCNearbyServiceAdvertiser, peerID: MCPeerID, context: NSData, invitationHandler: (arg1: boolean, arg2: MCSession) => void): void;
	advertiserDidNotStartAdvertisingPeer?(advertiser: MCNearbyServiceAdvertiser, error: NSError): void;
}
interface MCNearbyServiceBrowserDelegate {
	browserFoundPeerWithDiscoveryInfo(browser: MCNearbyServiceBrowser, peerID: MCPeerID, info: NSDictionary): void;
	browserLostPeer(browser: MCNearbyServiceBrowser, peerID: MCPeerID): void;
	browserDidNotStartBrowsingForPeers?(browser: MCNearbyServiceBrowser, error: NSError): void;
}
interface MCBrowserViewControllerDelegate {
	browserViewControllerDidFinish(browserViewController: MCBrowserViewController): void;
	browserViewControllerWasCancelled(browserViewController: MCBrowserViewController): void;
	browserViewControllerShouldPresentNearbyPeerWithDiscoveryInfo?(browserViewController: MCBrowserViewController, peerID: MCPeerID, info: NSDictionary): boolean;
}
interface MCAdvertiserAssistantDelegate {
	advertiserAssistantWillPresentInvitation?(advertiserAssistant: MCAdvertiserAssistant): void;
	advertiserAssistantDidDismissInvitation?(advertiserAssistant: MCAdvertiserAssistant): void;
}
interface NCWidgetProviding {
	widgetPerformUpdateWithCompletionHandler?(completionHandler: (arg1: number) => void): void;
	widgetMarginInsetsForProposedMarginInsets?(defaultMarginInsets: UIEdgeInsets): UIEdgeInsets;
}
interface PHPhotoLibraryChangeObserver {
	photoLibraryDidChange(changeInstance: PHChange): void;
}
interface PHContentEditingController {
	shouldShowCancelConfirmation: boolean;
	canHandleAdjustmentData(adjustmentData: PHAdjustmentData): boolean;
	startContentEditingWithInputPlaceholderImage(contentEditingInput: PHContentEditingInput, placeholderImage: UIImage): void;
	finishContentEditingWithCompletionHandler(completionHandler: (arg1: PHContentEditingOutput) => void): void;
	cancelContentEditing(): void;
}
interface PKPushRegistryDelegate {
	pushRegistryDidUpdatePushCredentialsForType(registry: PKPushRegistry, credentials: PKPushCredentials, type: string): void;
	pushRegistryDidReceiveIncomingPushWithPayloadForType(registry: PKPushRegistry, payload: PKPushPayload, type: string): void;
	pushRegistryDidInvalidatePushTokenForType?(registry: PKPushRegistry, type: string): void;
}
interface QLPreviewControllerDataSource {
	numberOfPreviewItemsInPreviewController(controller: QLPreviewController): number;
	previewControllerPreviewItemAtIndex(controller: QLPreviewController, index: number): any;
}
interface QLPreviewControllerDelegate {
	previewControllerWillDismiss?(controller: QLPreviewController): void;
	previewControllerDidDismiss?(controller: QLPreviewController): void;
	previewControllerShouldOpenURLForPreviewItem?(controller: QLPreviewController, url: NSURL, item: any): boolean;
	previewControllerFrameForPreviewItemInSourceView?(controller: QLPreviewController, item: any, view: any): CGRect;
	previewControllerTransitionImageForPreviewItemContentRect?(controller: QLPreviewController, item: any, contentRect: any): UIImage;
}
interface QLPreviewItem {
	previewItemURL: NSURL;
	previewItemTitle: string;
}
interface SKSceneDelegate {
	updateForScene?(currentTime: number, scene: SKScene): void;
	didEvaluateActionsForScene?(scene: SKScene): void;
	didSimulatePhysicsForScene?(scene: SKScene): void;
	didApplyConstraintsForScene?(scene: SKScene): void;
	didFinishUpdateForScene?(scene: SKScene): void;
}
interface SKPhysicsContactDelegate {
	didBeginContact?(contact: SKPhysicsContact): void;
	didEndContact?(contact: SKPhysicsContact): void;
}
interface SKPaymentTransactionObserver {
	paymentQueueUpdatedTransactions(queue: SKPaymentQueue, transactions: NSArray): void;
	paymentQueueRemovedTransactions?(queue: SKPaymentQueue, transactions: NSArray): void;
	paymentQueueRestoreCompletedTransactionsFailedWithError?(queue: SKPaymentQueue, error: NSError): void;
	paymentQueueRestoreCompletedTransactionsFinished?(queue: SKPaymentQueue): void;
	paymentQueueUpdatedDownloads?(queue: SKPaymentQueue, downloads: NSArray): void;
}
interface SKRequestDelegate {
	requestDidFinish?(request: SKRequest): void;
	requestDidFailWithError?(request: SKRequest, error: NSError): void;
}
interface SKProductsRequestDelegate {
	productsRequestDidReceiveResponse(request: SKProductsRequest, response: SKProductsResponse): void;
}
interface SKStoreProductViewControllerDelegate {
	productViewControllerDidFinish?(viewController: SKStoreProductViewController): void;
}
interface WKNavigationDelegate {
	webViewDecidePolicyForNavigationActionDecisionHandler?(webView: WKWebView, navigationAction: WKNavigationAction, decisionHandler: (arg1: number) => void): void;
	webViewDecidePolicyForNavigationResponseDecisionHandler?(webView: WKWebView, navigationResponse: WKNavigationResponse, decisionHandler: (arg1: number) => void): void;
	webViewDidStartProvisionalNavigation?(webView: WKWebView, navigation: WKNavigation): void;
	webViewDidReceiveServerRedirectForProvisionalNavigation?(webView: WKWebView, navigation: WKNavigation): void;
	webViewDidFailProvisionalNavigationWithError?(webView: WKWebView, navigation: WKNavigation, error: NSError): void;
	webViewDidCommitNavigation?(webView: WKWebView, navigation: WKNavigation): void;
	webViewDidFinishNavigation?(webView: WKWebView, navigation: WKNavigation): void;
	webViewDidFailNavigationWithError?(webView: WKWebView, navigation: WKNavigation, error: NSError): void;
	webViewDidReceiveAuthenticationChallengeCompletionHandler?(webView: WKWebView, challenge: NSURLAuthenticationChallenge, completionHandler: (arg1: number, arg2: NSURLCredential) => void): void;
}
interface WKScriptMessageHandler {
	userContentControllerDidReceiveScriptMessage(userContentController: WKUserContentController, message: WKScriptMessage): void;
}
interface WKUIDelegate {
	webViewCreateWebViewWithConfigurationForNavigationActionWindowFeatures?(webView: WKWebView, configuration: WKWebViewConfiguration, navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures): WKWebView;
	webViewRunJavaScriptAlertPanelWithMessageInitiatedByFrameCompletionHandler?(webView: WKWebView, message: string, frame: WKFrameInfo, completionHandler: () => void): void;
	webViewRunJavaScriptConfirmPanelWithMessageInitiatedByFrameCompletionHandler?(webView: WKWebView, message: string, frame: WKFrameInfo, completionHandler: (arg1: boolean) => void): void;
	webViewRunJavaScriptTextInputPanelWithPromptDefaultTextInitiatedByFrameCompletionHandler?(webView: WKWebView, prompt: string, defaultText: string, frame: WKFrameInfo, completionHandler: (arg1: string) => void): void;
}
declare var NSObjectProtocol;
declare var OS_dispatch_object;
declare var OS_dispatch_queue;
declare var OS_dispatch_queue_attr;
declare var OS_dispatch_source;
declare var OS_dispatch_group;
declare var OS_dispatch_semaphore;
declare var OS_dispatch_dataProtocol;
declare var OS_dispatch_io;
declare var NSCopying;
declare var NSMutableCopying;
declare var NSCoding;
declare var NSSecureCoding;
declare var NSDiscardableContent;
declare var NSFastEnumeration;
declare var NSDecimalNumberBehaviors;
declare var NSFileManagerDelegate;
declare var NSKeyedArchiverDelegate;
declare var NSKeyedUnarchiverDelegate;
declare var NSLocking;
declare var NSPortDelegate;
declare var NSMachPortDelegate;
declare var NSStreamDelegate;
declare var NSURLAuthenticationChallengeSender;
declare var NSURLConnectionDelegate;
declare var NSURLConnectionDataDelegate;
declare var NSURLConnectionDownloadDelegate;
declare var NSURLProtocolClient;
declare var NSXMLParserDelegate;
declare var NSCacheDelegate;
declare var NSExtensionRequestHandling;
declare var NSFilePresenter;
declare var NSMetadataQueryDelegate;
declare var NSNetServiceDelegate;
declare var NSNetServiceBrowserDelegate;
declare var NSURLSessionDelegate;
declare var NSURLSessionTaskDelegate;
declare var NSURLSessionDataDelegate;
declare var NSURLSessionDownloadDelegate;
declare var NSUserActivityDelegate;
declare var UIInputViewAudioFeedback;
declare var UIAppearanceContainer;
declare var UIAppearance;
declare var UIDynamicItem;
declare var UILayoutSupport;
declare var UITraitEnvironment;
declare var UICoordinateSpace;
declare var UITextInputTraits;
declare var UIKeyInput;
declare var UITextInput;
declare var UITextInputDelegate;
declare var UITextInputTokenizer;
declare var UITextFieldDelegate;
declare var UIActionSheetDelegate;
declare var UIAlertViewDelegate;
declare var UIApplicationDelegate;
declare var UIViewControllerRestoration;
declare var UIDataSourceModelAssociation;
declare var UIStateRestoring;
declare var UIObjectRestoration;
declare var UIContentContainer;
declare var UIGestureRecognizerDelegate;
declare var UINavigationControllerDelegate;
declare var UIAccelerometerDelegate;
declare var UIScrollViewDelegate;
declare var UITableViewDelegate;
declare var UITableViewDataSource;
declare var UIPickerViewDataSource;
declare var UIPickerViewDelegate;
declare var UIPickerViewAccessibilityDelegate;
declare var UIScrollViewAccessibilityDelegate;
declare var UIAccessibilityIdentification;
declare var UIGuidedAccessRestrictionDelegate;
declare var UIAccessibilityReadingContent;
declare var UIActivityItemSource;
declare var UIBarPositioning;
declare var UIBarPositioningDelegate;
declare var UICollectionViewDataSource;
declare var UICollectionViewDelegate;
declare var UICollectionViewDelegateFlowLayout;
declare var UIDocumentInteractionControllerDelegate;
declare var UIDocumentPickerDelegate;
declare var UIDocumentMenuDelegate;
declare var UIImagePickerControllerDelegate;
declare var UITextDocumentProxy;
declare var UINavigationBarDelegate;
declare var UIPageViewControllerDelegate;
declare var UIPageViewControllerDataSource;
declare var UIPopoverControllerDelegate;
declare var UIPopoverBackgroundViewMethods;
declare var UIPrinterPickerControllerDelegate;
declare var UIPrintInteractionControllerDelegate;
declare var UISearchBarDelegate;
declare var UIViewControllerTransitionCoordinatorContext;
declare var UIViewControllerTransitionCoordinator;
declare var UIAdaptivePresentationControllerDelegate;
declare var UIViewControllerContextTransitioning;
declare var UIViewControllerAnimatedTransitioning;
declare var UIViewControllerInteractiveTransitioning;
declare var UIViewControllerTransitioningDelegate;
declare var UISearchControllerDelegate;
declare var UISearchResultsUpdating;
declare var UISearchDisplayDelegate;
declare var UISplitViewControllerDelegate;
declare var UITabBarDelegate;
declare var UITabBarControllerDelegate;
declare var UITextViewDelegate;
declare var UIToolbarDelegate;
declare var UIVideoEditorControllerDelegate;
declare var UIWebViewDelegate;
declare var NSTextStorageDelegate;
declare var NSLayoutManagerDelegate;
declare var NSTextLayoutOrientationProvider;
declare var NSTextAttachmentContainer;
declare var UIPopoverPresentationControllerDelegate;
declare var UIDynamicAnimatorDelegate;
declare var UICollisionBehaviorDelegate;
declare var EAGLDrawable;
declare var MTLCommandEncoder;
declare var MTLResource;
declare var MTLBuffer;
declare var MTLFunction;
declare var MTLLibrary;
declare var MTLDevice;
declare var MTLTexture;
declare var MTLBlitCommandEncoder;
declare var MTLCommandBuffer;
declare var MTLComputeCommandEncoder;
declare var MTLCommandQueue;
declare var MTLDepthStencilState;
declare var MTLDrawable;
declare var MTLComputePipelineState;
declare var MTLRenderPipelineState;
declare var MTLParallelRenderCommandEncoder;
declare var MTLRenderCommandEncoder;
declare var MTLSamplerState;
declare var ABPeoplePickerNavigationControllerDelegate;
declare var ABPersonViewControllerDelegate;
declare var ABNewPersonViewControllerDelegate;
declare var ABUnknownPersonViewControllerDelegate;
declare var CAMediaTiming;
declare var CAAction;
declare var AVAudioMixing;
declare var AVAudioStereoMixing;
declare var AVAudio3DMixing;
declare var AVAudioPlayerDelegate;
declare var AVAudioRecorderDelegate;
declare var AVAudioSessionDelegate;
declare var AVAsynchronousKeyValueLoading;
declare var AVVideoCompositing;
declare var AVVideoCompositionInstructionProtocol;
declare var AVVideoCompositionValidationHandling;
declare var AVAssetResourceLoaderDelegate;
declare var AVCaptureVideoDataOutputSampleBufferDelegate;
declare var AVCaptureAudioDataOutputSampleBufferDelegate;
declare var AVCaptureFileOutputRecordingDelegate;
declare var AVCaptureMetadataOutputObjectsDelegate;
declare var AVPlayerItemOutputPullDelegate;
declare var AVPlayerItemLegibleOutputPushDelegate;
declare var AVPlayerItemOutputPushDelegate;
declare var AVPlayerItemMetadataOutputPushDelegate;
declare var AVSpeechSynthesizerDelegate;
declare var CKRecordValue;
declare var CLLocationManagerDelegate;
declare var CBCentralManagerDelegate;
declare var CBPeripheralManagerDelegate;
declare var CBPeripheralDelegate;
declare var EKEventEditViewDelegate;
declare var EKEventViewDelegate;
declare var EKCalendarChooserDelegate;
declare var GKGameCenterControllerDelegate;
declare var GKAchievementViewControllerDelegate;
declare var GKChallengeEventHandlerDelegate;
declare var GKChallengeListener;
declare var GKFriendRequestComposeViewControllerDelegate;
declare var GKLeaderboardViewControllerDelegate;
declare var GKTurnBasedEventListener;
declare var GKTurnBasedEventHandlerDelegate;
declare var GKInviteEventListener;
declare var GKSavedGameListener;
declare var GKLocalPlayerListener;
declare var GKMatchDelegate;
declare var GKMatchmakerViewControllerDelegate;
declare var GKSessionDelegate;
declare var GKVoiceChatClient;
declare var GKPeerPickerControllerDelegate;
declare var GKTurnBasedMatchmakerViewControllerDelegate;
declare var GLKViewDelegate;
declare var GLKViewControllerDelegate;
declare var GLKNamedEffect;
declare var HMHomeManagerDelegate;
declare var HMAccessoryBrowserDelegate;
declare var HMHomeDelegate;
declare var HMAccessoryDelegate;
declare var MPMediaPickerControllerDelegate;
declare var MPMediaPlayback;
declare var MPPlayableContentDataSource;
declare var MPPlayableContentDelegate;
declare var JSExport;
declare var MKAnnotation;
declare var MKOverlay;
declare var MKMapViewDelegate;
declare var MKReverseGeocoderDelegate;
declare var MFMailComposeViewControllerDelegate;
declare var MFMessageComposeViewControllerDelegate;
declare var MCSessionDelegate;
declare var MCNearbyServiceAdvertiserDelegate;
declare var MCNearbyServiceBrowserDelegate;
declare var MCBrowserViewControllerDelegate;
declare var MCAdvertiserAssistantDelegate;
declare var NCWidgetProviding;
declare var PHPhotoLibraryChangeObserver;
declare var PHContentEditingController;
declare var PKPushRegistryDelegate;
declare var QLPreviewControllerDataSource;
declare var QLPreviewControllerDelegate;
declare var QLPreviewItem;
declare var SKSceneDelegate;
declare var SKPhysicsContactDelegate;
declare var SKPaymentTransactionObserver;
declare var SKRequestDelegate;
declare var SKProductsRequestDelegate;
declare var SKStoreProductViewControllerDelegate;
declare var WKNavigationDelegate;
declare var WKScriptMessageHandler;
declare var WKUIDelegate;
interface __darwin_pthread_handler_rec {
	__routine: (arg1: any) => void;
	__arg: any;
	__next: any;
}
interface _opaque_pthread_attr_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_cond_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_condattr_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_mutex_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_mutexattr_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_once_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_rwlock_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_rwlockattr_t {
	__sig: number;
	__opaque: string[];
}
interface _opaque_pthread_t {
	__sig: number;
	__cleanup_stack: any;
	__opaque: string[];
}
interface fd_set {
	fds_bits: number[];
}
interface objc_object {
	isa: any;
}
interface __float2 {
	__sinval: number;
	__cosval: number;
}
interface __double2 {
	__sinval: number;
	__cosval: number;
}
interface exception {
	type: number;
	name: string;
	arg1: number;
	arg2: number;
	retval: number;
}
interface accessx_descriptor {
	ad_name_offset: number;
	ad_flags: number;
	ad_pad: number[];
}
interface timespec {
	tv_sec: number;
	tv_nsec: number;
}
interface timeval {
	tv_sec: number;
	tv_usec: number;
}
interface wide {
	lo: number;
	hi: number;
}
interface UnsignedWide {
	lo: number;
	hi: number;
}
interface Float80 {
	exp: number;
	man: number[];
}
interface Float96 {
	exp: number[];
	man: number[];
}
interface Float32Point {
	x: number;
	y: number;
}
interface ProcessSerialNumber {
	highLongOfPSN: number;
	lowLongOfPSN: number;
}
interface Point {
	v: number;
	h: number;
}
interface Rect {
	top: number;
	left: number;
	bottom: number;
	right: number;
}
interface FixedPoint {
	x: number;
	y: number;
}
interface FixedRect {
	left: number;
	top: number;
	right: number;
	bottom: number;
}
interface TimeRecord {
	value: wide;
	scale: number;
	base: any;
}
interface NumVersion {
	nonRelRev: number;
	stage: number;
	minorAndBugRev: number;
	majorRev: number;
}
interface VersRec {
	numericVersion: NumVersion;
	countryCode: number;
	shortVersion: number[];
	reserved: number[];
}
interface _RuneEntry {
	__min: number;
	__max: number;
	__map: number;
	__types: any;
}
interface _RuneRange {
	__nranges: number;
	__ranges: any;
}
interface _RuneCharClass {
	__name: string[];
	__mask: number;
}
interface _RuneLocale {
	__magic: string[];
	__encoding: string[];
	__sgetrune: (arg1: string, arg2: number, arg3: any) => number;
	__sputrune: (arg1: number, arg2: string, arg3: number, arg4: any) => number;
	__invalid_rune: number;
	__runetype: number[];
	__maplower: number[];
	__mapupper: number[];
	__runetype_ext: _RuneRange;
	__maplower_ext: _RuneRange;
	__mapupper_ext: _RuneRange;
	__variable: any;
	__variable_len: number;
	__ncharclasses: number;
	__charclasses: any;
}
interface lconv {
	decimal_point: string;
	thousands_sep: string;
	grouping: string;
	int_curr_symbol: string;
	currency_symbol: string;
	mon_decimal_point: string;
	mon_thousands_sep: string;
	mon_grouping: string;
	positive_sign: string;
	negative_sign: string;
	int_frac_digits: string;
	frac_digits: string;
	p_cs_precedes: string;
	p_sep_by_space: string;
	n_cs_precedes: string;
	n_sep_by_space: string;
	p_sign_posn: string;
	n_sign_posn: string;
	int_p_cs_precedes: string;
	int_n_cs_precedes: string;
	int_p_sep_by_space: string;
	int_n_sep_by_space: string;
	int_p_sign_posn: string;
	int_n_sign_posn: string;
}
interface __darwin_arm_exception_state {
	__exception: number;
	__fsr: number;
	__far: number;
}
interface __darwin_arm_exception_state64 {
	__far: number;
	__esr: number;
	__exception: number;
}
interface __darwin_arm_thread_state {
	__r: number[];
	__sp: number;
	__lr: number;
	__pc: number;
	__cpsr: number;
}
interface __darwin_arm_thread_state64 {
	__x: number[];
	__fp: number;
	__lr: number;
	__sp: number;
	__pc: number;
	__cpsr: number;
	__pad: number;
}
interface __darwin_arm_vfp_state {
	__r: number[];
	__fpscr: number;
}
interface __darwin_arm_neon_state64 {
	opaque: string[];
}
interface __darwin_arm_neon_state {
	opaque: string[];
}
interface __darwin_arm_debug_state {
	__bvr: number[];
	__bcr: number[];
	__wvr: number[];
	__wcr: number[];
}
interface __darwin_arm_debug_state32 {
	__bvr: number[];
	__bcr: number[];
	__wvr: number[];
	__wcr: number[];
	__mdscr_el1: number;
}
interface __darwin_arm_debug_state64 {
	__bvr: number[];
	__bcr: number[];
	__wvr: number[];
	__wcr: number[];
	__mdscr_el1: number;
}
interface __darwin_mcontext32 {
	__es: __darwin_arm_exception_state;
	__ss: __darwin_arm_thread_state;
	__fs: __darwin_arm_vfp_state;
}
interface __darwin_mcontext64 {
	__es: __darwin_arm_exception_state64;
	__ss: __darwin_arm_thread_state64;
	__ns: __darwin_arm_neon_state64;
}
interface __darwin_sigaltstack {
	ss_sp: any;
	ss_size: number;
	ss_flags: number;
}
interface __darwin_ucontext {
	uc_onstack: number;
	uc_sigmask: number;
	uc_stack: __darwin_sigaltstack;
	uc_link: any;
	uc_mcsize: number;
	uc_mcontext: any;
}
interface sigvecStruct {
	sv_handler: (arg1: number) => void;
	sv_mask: number;
	sv_flags: number;
}
interface sigstack {
	ss_sp: string;
	ss_onstack: number;
}
interface __sbuf {
	_base: string;
	_size: number;
}
interface FILE {
	_p: string;
	_r: number;
	_w: number;
	_flags: number;
	_file: number;
	_bf: __sbuf;
	_lbfsize: number;
	_cookie: any;
	_close: (arg1: any) => number;
	_read: (arg1: any, arg2: string, arg3: number) => number;
	_seek: (arg1: any, arg2: number, arg3: number) => number;
	_write: (arg1: any, arg2: string, arg3: number) => number;
	_ub: __sbuf;
	_extra: any;
	_ur: number;
	_ubuf: number[];
	_nbuf: number[];
	_lb: __sbuf;
	_blksize: number;
	_offset: number;
}
interface rusage {
	ru_utime: timeval;
	ru_stime: timeval;
	ru_maxrss: number;
	ru_ixrss: number;
	ru_idrss: number;
	ru_isrss: number;
	ru_minflt: number;
	ru_majflt: number;
	ru_nswap: number;
	ru_inblock: number;
	ru_oublock: number;
	ru_msgsnd: number;
	ru_msgrcv: number;
	ru_nsignals: number;
	ru_nvcsw: number;
	ru_nivcsw: number;
}
interface rusage_info_v0 {
	ri_uuid: number[];
	ri_user_time: number;
	ri_system_time: number;
	ri_pkg_idle_wkups: number;
	ri_interrupt_wkups: number;
	ri_pageins: number;
	ri_wired_size: number;
	ri_resident_size: number;
	ri_phys_footprint: number;
	ri_proc_start_abstime: number;
	ri_proc_exit_abstime: number;
}
interface rusage_info_v1 {
	ri_uuid: number[];
	ri_user_time: number;
	ri_system_time: number;
	ri_pkg_idle_wkups: number;
	ri_interrupt_wkups: number;
	ri_pageins: number;
	ri_wired_size: number;
	ri_resident_size: number;
	ri_phys_footprint: number;
	ri_proc_start_abstime: number;
	ri_proc_exit_abstime: number;
	ri_child_user_time: number;
	ri_child_system_time: number;
	ri_child_pkg_idle_wkups: number;
	ri_child_interrupt_wkups: number;
	ri_child_pageins: number;
	ri_child_elapsed_abstime: number;
}
interface rusage_info_v2 {
	ri_uuid: number[];
	ri_user_time: number;
	ri_system_time: number;
	ri_pkg_idle_wkups: number;
	ri_interrupt_wkups: number;
	ri_pageins: number;
	ri_wired_size: number;
	ri_resident_size: number;
	ri_phys_footprint: number;
	ri_proc_start_abstime: number;
	ri_proc_exit_abstime: number;
	ri_child_user_time: number;
	ri_child_system_time: number;
	ri_child_pkg_idle_wkups: number;
	ri_child_interrupt_wkups: number;
	ri_child_pageins: number;
	ri_child_elapsed_abstime: number;
	ri_diskio_bytesread: number;
	ri_diskio_byteswritten: number;
}
interface rusage_info_v3 {
	ri_uuid: number[];
	ri_user_time: number;
	ri_system_time: number;
	ri_pkg_idle_wkups: number;
	ri_interrupt_wkups: number;
	ri_pageins: number;
	ri_wired_size: number;
	ri_resident_size: number;
	ri_phys_footprint: number;
	ri_proc_start_abstime: number;
	ri_proc_exit_abstime: number;
	ri_child_user_time: number;
	ri_child_system_time: number;
	ri_child_pkg_idle_wkups: number;
	ri_child_interrupt_wkups: number;
	ri_child_pageins: number;
	ri_child_elapsed_abstime: number;
	ri_diskio_bytesread: number;
	ri_diskio_byteswritten: number;
	ri_cpu_time_qos_default: number;
	ri_cpu_time_qos_maintenance: number;
	ri_cpu_time_qos_background: number;
	ri_cpu_time_qos_utility: number;
	ri_cpu_time_qos_legacy: number;
	ri_cpu_time_qos_user_initiated: number;
	ri_cpu_time_qos_user_interactive: number;
	ri_billed_system_time: number;
	ri_serviced_system_time: number;
}
interface rlimit {
	rlim_cur: number;
	rlim_max: number;
}
interface proc_rlimit_control_wakeupmon {
	wm_flags: number;
	wm_rate: number;
}
interface div_t {
	quot: number;
	rem: number;
}
interface ldiv_t {
	quot: number;
	rem: number;
}
interface lldiv_t {
	quot: number;
	rem: number;
}
interface tm {
	tm_sec: number;
	tm_min: number;
	tm_hour: number;
	tm_mday: number;
	tm_mon: number;
	tm_year: number;
	tm_wday: number;
	tm_yday: number;
	tm_isdst: number;
	tm_gmtoff: number;
	tm_zone: string;
}
interface imaxdiv_t {
	quot: number;
	rem: number;
}
interface mach_port_status_t {
	mps_pset: number;
	mps_seqno: number;
	mps_mscount: number;
	mps_qlimit: number;
	mps_msgcount: number;
	mps_sorights: number;
	mps_srights: number;
	mps_pdrequest: number;
	mps_nsrequest: number;
	mps_flags: number;
}
interface mach_port_limits_t {
	mpl_qlimit: number;
}
interface mach_port_info_ext_t {
	mpie_status: mach_port_status_t;
	mpie_boost_cnt: number;
	reserved: number[];
}
interface mach_port_qos_t {
	name: number;
	prealloc: number;
	pad1: number;
	len: number;
}
interface mach_port_options_t {
	flags: number;
	mpl: mach_port_limits_t;
	reserved: number[];
}
interface flockStruct {
	l_start: number;
	l_len: number;
	l_pid: number;
	l_type: number;
	l_whence: number;
}
interface flocktimeout {
	fl: flockStruct;
	timeout: timespec;
}
interface radvisory {
	ra_offset: number;
	ra_count: number;
}
interface fcodeblobs_t {
	f_cd_hash: any;
	f_hash_size: number;
	f_cd_buffer: any;
	f_cd_size: number;
	f_out_size: any;
	f_arch: number;
	__padding: number;
}
interface fsignatures_t {
	fs_file_start: number;
	fs_blob_start: any;
	fs_blob_size: number;
}
interface fstore_t {
	fst_flags: number;
	fst_posmode: number;
	fst_offset: number;
	fst_length: number;
	fst_bytesalloc: number;
}
interface fbootstraptransfer_t {
	fbt_offset: number;
	fbt_length: number;
	fbt_buffer: any;
}
interface log2phys {
	l2p_flags: number;
	l2p_contigbytes: number;
	l2p_devoffset: number;
}
interface time_value {
	seconds: number;
	microseconds: number;
}
interface mach_timespec {
	tv_sec: number;
	tv_nsec: number;
}
interface mach_msg_type_descriptor_t {
	pad1: number;
	pad2: number;
	pad3: number;
	type: number;
}
interface mach_msg_port_descriptor_t {
	name: number;
	pad1: number;
	pad2: number;
	disposition: number;
	type: number;
}
interface mach_msg_ool_descriptor32_t {
	address: number;
	size: number;
	deallocate: number;
	copy: number;
	pad1: number;
	type: number;
}
interface mach_msg_ool_descriptor64_t {
	address: number;
	deallocate: number;
	copy: number;
	pad1: number;
	type: number;
	size: number;
}
interface mach_msg_ool_descriptor_t {
	address: any;
	size: number;
	deallocate: number;
	copy: number;
	pad1: number;
	type: number;
}
interface mach_msg_ool_ports_descriptor32_t {
	address: number;
	count: number;
	deallocate: number;
	copy: number;
	disposition: number;
	type: number;
}
interface mach_msg_ool_ports_descriptor64_t {
	address: number;
	deallocate: number;
	copy: number;
	disposition: number;
	type: number;
	count: number;
}
interface mach_msg_ool_ports_descriptor_t {
	address: any;
	count: number;
	deallocate: number;
	copy: number;
	disposition: number;
	type: number;
}
interface mach_msg_body_t {
	msgh_descriptor_count: number;
}
interface mach_msg_header_t {
	msgh_bits: number;
	msgh_size: number;
	msgh_remote_port: number;
	msgh_local_port: number;
	msgh_voucher_port: number;
	msgh_id: number;
}
interface mach_msg_base_t {
	header: mach_msg_header_t;
	body: mach_msg_body_t;
}
interface mach_msg_trailer_t {
	msgh_trailer_type: number;
	msgh_trailer_size: number;
}
interface mach_msg_seqno_trailer_t {
	msgh_trailer_type: number;
	msgh_trailer_size: number;
	msgh_seqno: number;
}
interface security_token_t {
	val: number[];
}
interface mach_msg_security_trailer_t {
	msgh_trailer_type: number;
	msgh_trailer_size: number;
	msgh_seqno: number;
	msgh_sender: security_token_t;
}
interface audit_token_t {
	val: number[];
}
interface mach_msg_audit_trailer_t {
	msgh_trailer_type: number;
	msgh_trailer_size: number;
	msgh_seqno: number;
	msgh_sender: security_token_t;
	msgh_audit: audit_token_t;
}
interface mach_msg_context_trailer_t {
	msgh_trailer_type: number;
	msgh_trailer_size: number;
	msgh_seqno: number;
	msgh_sender: security_token_t;
	msgh_audit: audit_token_t;
	msgh_context: number;
}
interface msg_labels_t {
	sender: number;
}
interface mach_msg_mac_trailer_t {
	msgh_trailer_type: number;
	msgh_trailer_size: number;
	msgh_seqno: number;
	msgh_sender: security_token_t;
	msgh_audit: audit_token_t;
	msgh_context: number;
	msgh_ad: number;
	msgh_labels: msg_labels_t;
}
interface mach_msg_empty_send_t {
	header: mach_msg_header_t;
}
interface mach_msg_empty_rcv_t {
	header: mach_msg_header_t;
	trailer: mach_msg_trailer_t;
}
interface guid_t {
	g_guid: number[];
}
interface ntsid_t {
	sid_kind: number;
	sid_authcount: number;
	sid_authority: number[];
	sid_authorities: number[];
}
interface kauth_identity_extlookup {
	el_seqno: number;
	el_result: number;
	el_flags: number;
	el_info_pid: number;
	el_extend: number;
	el_info_reserved_1: number;
	el_uid: number;
	el_uguid: guid_t;
	el_uguid_valid: number;
	el_usid: ntsid_t;
	el_usid_valid: number;
	el_gid: number;
	el_gguid: guid_t;
	el_gguid_valid: number;
	el_gsid: ntsid_t;
	el_gsid_valid: number;
	el_member_valid: number;
	el_sup_grp_cnt: number;
	el_sup_groups: number[];
}
interface kauth_cache_sizes {
	kcs_group_size: number;
	kcs_id_size: number;
}
interface kauth_ace {
	ace_applicable: guid_t;
	ace_flags: number;
	ace_rights: number;
}
interface kauth_acl {
	acl_entrycount: number;
	acl_flags: number;
	acl_ace: kauth_ace[];
}
interface kauth_filesec {
	fsec_magic: number;
	fsec_owner: guid_t;
	fsec_group: guid_t;
	fsec_acl: kauth_acl;
}
interface iovec {
	iov_base: any;
	iov_len: number;
}
interface linger {
	l_onoff: number;
	l_linger: number;
}
interface so_np_extensions {
	npx_flags: number;
	npx_mask: number;
}
interface sockaddr {
	sa_len: number;
	sa_family: number;
	sa_data: string[];
}
interface sockproto {
	sp_family: number;
	sp_protocol: number;
}
interface sockaddr_storage {
	ss_len: number;
	ss_family: number;
	__ss_pad1: string[];
	__ss_align: number;
	__ss_pad2: string[];
}
interface msghdr {
	msg_name: any;
	msg_namelen: number;
	msg_iov: any;
	msg_iovlen: number;
	msg_control: any;
	msg_controllen: number;
	msg_flags: number;
}
interface cmsghdr {
	cmsg_len: number;
	cmsg_level: number;
	cmsg_type: number;
}
interface sf_hdtr {
	headers: any;
	hdr_cnt: number;
	trailers: any;
	trl_cnt: number;
}
interface itimerval {
	it_interval: timeval;
	it_value: timeval;
}
interface timezone {
	tz_minuteswest: number;
	tz_dsttime: number;
}
interface clockinfo {
	hz: number;
	tick: number;
	tickadj: number;
	stathz: number;
	profhz: number;
}
interface au_tid {
	port: number;
	machine: number;
}
interface au_tid_addr {
	at_port: number;
	at_type: number;
	at_addr: number[];
}
interface au_mask {
	am_success: number;
	am_failure: number;
}
interface auditinfo {
	ai_auid: number;
	ai_mask: au_mask;
	ai_termid: au_tid;
	ai_asid: number;
}
interface auditinfo_addr {
	ai_auid: number;
	ai_mask: au_mask;
	ai_termid: au_tid_addr;
	ai_asid: number;
	ai_flags: number;
}
interface auditpinfo {
	ap_pid: number;
	ap_auid: number;
	ap_mask: au_mask;
	ap_termid: au_tid;
	ap_asid: number;
}
interface auditpinfo_addr {
	ap_pid: number;
	ap_auid: number;
	ap_mask: au_mask;
	ap_termid: au_tid_addr;
	ap_asid: number;
	ap_flags: number;
}
interface au_session {
	as_aia_p: any;
	as_mask: au_mask;
}
interface au_qctrl {
	aq_hiwater: number;
	aq_lowater: number;
	aq_bufsz: number;
	aq_delay: number;
	aq_minfree: number;
}
interface audit_stat {
	as_version: number;
	as_numevent: number;
	as_generated: number;
	as_nonattrib: number;
	as_kernel: number;
	as_audit: number;
	as_auditctl: number;
	as_enqueue: number;
	as_written: number;
	as_wblocked: number;
	as_rblocked: number;
	as_dropped: number;
	as_totalsize: number;
	as_memused: number;
}
interface audit_fstat {
	af_filesz: number;
	af_currsz: number;
}
interface au_evclass_map {
	ec_number: number;
	ec_class: number;
}
interface ucred {
	cr_link: {tqe_next: any; tqe_prev: any};
	cr_ref: number;
	cr_posix: posix_cred;
	cr_label: any;
	cr_audit: au_session;
}
interface posix_cred {
	cr_uid: number;
	cr_ruid: number;
	cr_svuid: number;
	cr_ngroups: number;
	cr_groups: number[];
	cr_rgid: number;
	cr_svgid: number;
	cr_gmuid: number;
	cr_flags: number;
}
interface xucred {
	cr_version: number;
	cr_uid: number;
	cr_ngroups: number;
	cr_groups: number[];
}
interface keventStruct {
	ident: number;
	filter: number;
	flags: number;
	fflags: number;
	data: number;
	udata: any;
}
interface kevent64_s {
	ident: number;
	filter: number;
	flags: number;
	fflags: number;
	data: number;
	udata: number;
	ext: number[];
}
interface klist {
	slh_first: any;
}
interface vmspace {
	dummy: number;
	dummy2: string;
	dummy3: number[];
	dummy4: string[];
}
interface ctlname {
	ctl_name: string;
	ctl_type: number;
}
interface _pcred {
	pc_lock: string[];
	pc_ucred: any;
	p_ruid: number;
	p_svuid: number;
	p_rgid: number;
	p_svgid: number;
	p_refcnt: number;
}
interface _ucred {
	cr_ref: number;
	cr_uid: number;
	cr_ngroups: number;
	cr_groups: number[];
}
interface eproc {
	e_paddr: any;
	e_sess: any;
	e_pcred: _pcred;
	e_ucred: _ucred;
	e_vm: vmspace;
	e_ppid: number;
	e_pgid: number;
	e_jobc: number;
	e_tdev: number;
	e_tpgid: number;
	e_tsess: any;
	e_wmesg: string[];
	e_xsize: number;
	e_xrssize: number;
	e_xccount: number;
	e_xswrss: number;
	e_flag: number;
	e_login: string[];
	e_spare: number[];
}
interface kinfo_lctx {
	id: number;
	mc: number;
}
interface xsw_usage {
	xsu_total: number;
	xsu_avail: number;
	xsu_used: number;
	xsu_pagesize: number;
	xsu_encrypted: number;
}
interface loadavg {
	ldavg: number[];
	fscale: number;
}
interface CGPoint {
	x: number;
	y: number;
}
interface CGSize {
	width: number;
	height: number;
}
interface CGVector {
	dx: number;
	dy: number;
}
interface CGRect {
	origin: CGPoint;
	size: CGSize;
}
interface CGAffineTransform {
	a: number;
	b: number;
	c: number;
	d: number;
	tx: number;
	ty: number;
}
interface CGDataProviderSequentialCallbacks {
	version: number;
	getBytes: (arg1: any, arg2: any, arg3: number) => number;
	skipForward: (arg1: any, arg2: number) => number;
	rewind: (arg1: any) => void;
	releaseInfo: (arg1: any) => void;
}
interface CGDataProviderDirectCallbacks {
	version: number;
	getBytePointer: (arg1: any) => any;
	releaseBytePointer: (arg1: any, arg2: any) => void;
	getBytesAtPosition: (arg1: any, arg2: any, arg3: number, arg4: number) => number;
	releaseInfo: (arg1: any) => void;
}
interface CGPatternCallbacks {
	version: number;
	drawPattern: (arg1: any, arg2: any) => void;
	releaseInfo: (arg1: any) => void;
}
interface CGPathElement {
	type: number;
	points: any;
}
interface CGFunctionCallbacks {
	version: number;
	evaluate: (arg1: any, arg2: any, arg3: any) => void;
	releaseInfo: (arg1: any) => void;
}
interface CGDataConsumerCallbacks {
	putBytes: (arg1: any, arg2: any, arg3: number) => number;
	releaseConsumer: (arg1: any) => void;
}
interface CFRange {
	location: number;
	length: number;
}
interface CFAllocatorContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
	allocate: (arg1: number, arg2: number, arg3: any) => any;
	reallocate: (arg1: any, arg2: number, arg3: number, arg4: any) => any;
	deallocate: (arg1: any, arg2: any) => void;
	preferredSize: (arg1: number, arg2: number, arg3: any) => number;
}
interface CFDictionaryKeyCallBacks {
	version: number;
	retain: (arg1: any, arg2: any) => any;
	release: (arg1: any, arg2: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
	hash: (arg1: any) => number;
}
interface CFDictionaryValueCallBacks {
	version: number;
	retain: (arg1: any, arg2: any) => any;
	release: (arg1: any, arg2: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
}
interface CFArrayCallBacks {
	version: number;
	retain: (arg1: any, arg2: any) => any;
	release: (arg1: any, arg2: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
}
interface CFStringInlineBuffer {
	buffer: number[];
	theString: string;
	directUniCharBuffer: any;
	directCStringBuffer: string;
	rangeToBuffer: CFRange;
	bufferedRangeStart: number;
	bufferedRangeEnd: number;
}
interface CFGregorianDate {
	year: number;
	month: string;
	day: string;
	hour: string;
	minute: string;
	second: number;
}
interface CFGregorianUnits {
	years: number;
	months: number;
	days: number;
	hours: number;
	minutes: number;
	seconds: number;
}
interface CFBagCallBacks {
	version: number;
	retain: (arg1: any, arg2: any) => any;
	release: (arg1: any, arg2: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
	hash: (arg1: any) => number;
}
interface CFBinaryHeapCompareContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFBinaryHeapCallBacks {
	version: number;
	retain: (arg1: any, arg2: any) => any;
	release: (arg1: any, arg2: any) => void;
	copyDescription: (arg1: any) => string;
	compare: (arg1: any, arg2: any, arg3: any) => number;
}
interface CFSwappedFloat32 {
	v: number;
}
interface CFSwappedFloat64 {
	v: number;
}
interface CFRunLoopSourceContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
	hash: (arg1: any) => number;
	schedule: (arg1: any, arg2: any, arg3: string) => void;
	cancel: (arg1: any, arg2: any, arg3: string) => void;
	perform: (arg1: any) => void;
}
interface CFRunLoopSourceContext1 {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
	hash: (arg1: any) => number;
	getPort: (arg1: any) => number;
	perform: (arg1: any, arg2: number, arg3: any, arg4: any) => any;
}
interface CFRunLoopObserverContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFRunLoopTimerContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFSocketSignature {
	protocolFamily: number;
	socketType: number;
	protocol: number;
	address: NSData;
}
interface CFSocketContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFStreamClientContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFStreamError {
	domain: number;
	error: number;
}
interface CFSetCallBacks {
	version: number;
	retain: (arg1: any, arg2: any) => any;
	release: (arg1: any, arg2: any) => void;
	copyDescription: (arg1: any) => string;
	equal: (arg1: any, arg2: any) => boolean;
	hash: (arg1: any) => number;
}
interface CFTreeContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFUUIDBytes {
	byte0: number;
	byte1: number;
	byte2: number;
	byte3: number;
	byte4: number;
	byte5: number;
	byte6: number;
	byte7: number;
	byte8: number;
	byte9: number;
	byte10: number;
	byte11: number;
	byte12: number;
	byte13: number;
	byte14: number;
	byte15: number;
}
interface CFMessagePortContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFMachPortContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFFileDescriptorContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface IUnknownVTbl {
	_reserved: any;
	QueryInterface: (arg1: any, arg2: CFUUIDBytes, arg3: any) => number;
	AddRef: (arg1: any) => number;
	Release: (arg1: any) => number;
}
interface CVSMPTETime {
	subframes: number;
	subframeDivisor: number;
	counter: number;
	type: number;
	flags: number;
	hours: number;
	minutes: number;
	seconds: number;
	frames: number;
}
interface CVTime {
	timeValue: number;
	timeScale: number;
	flags: number;
}
interface CVTimeStamp {
	version: number;
	videoTimeScale: number;
	videoTime: number;
	hostTime: number;
	rateScalar: number;
	videoRefreshPeriod: number;
	smpteTime: CVSMPTETime;
	flags: number;
	reserved: number;
}
interface CVPlanarComponentInfo {
	offset: number;
	rowBytes: number;
}
interface CVPlanarPixelBufferInfo {
	componentInfo: CVPlanarComponentInfo[];
}
interface CVPlanarPixelBufferInfo_YCbCrPlanar {
	componentInfoY: CVPlanarComponentInfo;
	componentInfoCb: CVPlanarComponentInfo;
	componentInfoCr: CVPlanarComponentInfo;
}
interface CVPlanarPixelBufferInfo_YCbCrBiPlanar {
	componentInfoY: CVPlanarComponentInfo;
	componentInfoCbCr: CVPlanarComponentInfo;
}
interface CVFillExtendedPixelsCallBackData {
	version: number;
	fillCallBack: (arg1: any, arg2: any) => boolean;
	refCon: any;
}
interface NSFastEnumerationState {
	state: number;
	itemsPtr: any;
	mutationsPtr: any;
	extra: number[];
}
interface NSRange {
	location: number;
	length: number;
}
interface NSSwappedFloat {
	v: number;
}
interface NSSwappedDouble {
	v: number;
}
interface NSDecimal {
	_exponent: number;
	_length: number;
	_isNegative: number;
	_isCompact: number;
	_reserved: number;
	_mantissa: number[];
}
interface NSOperatingSystemVersion {
	majorVersion: number;
	minorVersion: number;
	patchVersion: number;
}
interface _predicateFlags {
	_evaluationBlocked: number;
	_reservedPredicateFlags: number;
}
interface _expressionFlags {
	_evaluationBlocked: number;
	_reservedExpressionFlags: number;
}
interface CFHostClientContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface CFNetServiceClientContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface UIEdgeInsets {
	top: number;
	left: number;
	bottom: number;
	right: number;
}
interface UIOffset {
	horizontal: number;
	vertical: number;
}
interface __docFlags {
	inClose: number;
	isOpen: number;
	inOpen: number;
	isAutosavingBecauseOfTimer: number;
	versionWithoutRecentChangesIsNotLastOpened: number;
	ignoreUndoAndRedoNotifications: number;
	editingDisabled: number;
	isRegisteredAsFilePresenter: number;
	movingFile: number;
	savingError: number;
	inConflict: number;
	needToStopAccessingSecurityScopedResource: number;
}
interface __mdocFlags {
	shouldWriteAdditionalContent: number;
	_reserved: number;
}
interface MTLOrigin {
	x: number;
	y: number;
	z: number;
}
interface MTLSize {
	width: number;
	height: number;
	depth: number;
}
interface MTLRegion {
	origin: MTLOrigin;
	size: MTLSize;
}
interface MTLClearColor {
	red: number;
	green: number;
	blue: number;
	alpha: number;
}
interface MTLScissorRect {
	x: number;
	y: number;
	width: number;
	height: number;
}
interface MTLViewport {
	originX: number;
	originY: number;
	width: number;
	height: number;
	znear: number;
	zfar: number;
}
interface CTParagraphStyleSetting {
	spec: number;
	valueSize: number;
	value: any;
}
interface CTRunDelegateCallbacks {
	version: number;
	dealloc: (arg1: any) => void;
	getAscent: (arg1: any) => number;
	getDescent: (arg1: any) => number;
	getWidth: (arg1: any) => number;
}
interface SFNTLookupBinarySearchHeader {
	unitSize: number;
	nUnits: number;
	searchRange: number;
	entrySelector: number;
	rangeShift: number;
}
interface SFNTLookupArrayHeader {
	lookupValues: number[];
}
interface SFNTLookupTrimmedArrayHeader {
	firstGlyph: number;
	count: number;
	valueArray: number[];
}
interface SFNTLookupSegment {
	lastGlyph: number;
	firstGlyph: number;
	value: number[];
}
interface SFNTLookupSegmentHeader {
	binSearch: SFNTLookupBinarySearchHeader;
	segments: SFNTLookupSegment[];
}
interface SFNTLookupSingle {
	glyph: number;
	value: number[];
}
interface SFNTLookupSingleHeader {
	binSearch: SFNTLookupBinarySearchHeader;
	entries: SFNTLookupSingle[];
}
interface STHeader {
	filler: number;
	nClasses: number;
	classTableOffset: number;
	stateArrayOffset: number;
	entryTableOffset: number;
}
interface STClassTable {
	firstGlyph: number;
	nGlyphs: number;
	classes: number[];
}
interface STEntryZero {
	newState: number;
	flags: number;
}
interface STEntryOne {
	newState: number;
	flags: number;
	offset1: number;
}
interface STEntryTwo {
	newState: number;
	flags: number;
	offset1: number;
	offset2: number;
}
interface STXHeader {
	nClasses: number;
	classTableOffset: number;
	stateArrayOffset: number;
	entryTableOffset: number;
}
interface STXEntryZero {
	newState: number;
	flags: number;
}
interface STXEntryOne {
	newState: number;
	flags: number;
	index1: number;
}
interface STXEntryTwo {
	newState: number;
	flags: number;
	index1: number;
	index2: number;
}
interface LcarCaretClassEntry {
	count: number;
	partials: number[];
}
interface JustPCDecompositionAction {
	lowerLimit: number;
	upperLimit: number;
	order: number;
	count: number;
	glyphs: number[];
}
interface JustPCConditionalAddAction {
	substThreshold: number;
	addGlyph: number;
	substGlyph: number;
}
interface JustPCDuctilityAction {
	ductilityAxis: number;
	minimumLimit: number;
	noStretchValue: number;
	maximumLimit: number;
}
interface JustPCGlyphRepeatAddAction {
	flags: number;
	glyph: number;
}
interface JustPCActionSubrecord {
	theClass: number;
	theType: number;
	length: number;
	data: number;
}
interface JustPCAction {
	actionCount: number;
	actions: JustPCActionSubrecord[];
}
interface JustWidthDeltaEntry {
	justClass: number;
	beforeGrowLimit: number;
	beforeShrinkLimit: number;
	afterGrowLimit: number;
	afterShrinkLimit: number;
	growFlags: number;
	shrinkFlags: number;
}
interface JustWidthDeltaGroup {
	count: number;
	entries: JustWidthDeltaEntry[];
}
interface JustTable {
	version: number;
	format: number;
	horizHeaderOffset: number;
	vertHeaderOffset: number;
}
interface OpbdSideValues {
	leftSideShift: number;
	topSideShift: number;
	rightSideShift: number;
	bottomSideShift: number;
}
interface MortRearrangementSubtable {
	header: STHeader;
}
interface MortContextualSubtable {
	header: STHeader;
	substitutionTableOffset: number;
}
interface MortLigatureSubtable {
	header: STHeader;
	ligatureActionTableOffset: number;
	componentTableOffset: number;
	ligatureTableOffset: number;
}
interface MortInsertionSubtable {
	header: STHeader;
}
interface MortFeatureEntry {
	featureType: number;
	featureSelector: number;
	enableFlags: number;
	disableFlags: number;
}
interface MortChain {
	defaultFlags: number;
	length: number;
	nFeatures: number;
	nSubtables: number;
	featureEntries: MortFeatureEntry[];
}
interface MortTable {
	version: number;
	nChains: number;
	chains: MortChain[];
}
interface MorxRearrangementSubtable {
	header: STXHeader;
}
interface MorxContextualSubtable {
	header: STXHeader;
	substitutionTableOffset: number;
}
interface MorxLigatureSubtable {
	header: STXHeader;
	ligatureActionTableOffset: number;
	componentTableOffset: number;
	ligatureTableOffset: number;
}
interface MorxInsertionSubtable {
	header: STXHeader;
	insertionGlyphTableOffset: number;
}
interface MorxChain {
	defaultFlags: number;
	length: number;
	nFeatures: number;
	nSubtables: number;
	featureEntries: MortFeatureEntry[];
}
interface MorxTable {
	version: number;
	nChains: number;
	chains: MorxChain[];
}
interface PropLookupSegment {
	lastGlyph: number;
	firstGlyph: number;
	value: number;
}
interface PropLookupSingle {
	glyph: number;
	props: number;
}
interface TrakTableEntry {
	track: number;
	nameTableIndex: number;
	sizesOffset: number;
}
interface TrakTableData {
	nTracks: number;
	nSizes: number;
	sizeTableOffset: number;
	trakTable: TrakTableEntry[];
}
interface TrakTable {
	version: number;
	format: number;
	horizOffset: number;
	vertOffset: number;
}
interface KernVersion0Header {
	version: number;
	nTables: number;
	firstSubtable: number[];
}
interface KernTableHeader {
	version: number;
	nTables: number;
	firstSubtable: number[];
}
interface KernKerningPair {
	left: number;
	right: number;
}
interface KernOrderedListEntry {
	pair: KernKerningPair;
	value: number;
}
interface KernOrderedListHeader {
	nPairs: number;
	searchRange: number;
	entrySelector: number;
	rangeShift: number;
	table: number[];
}
interface KernStateHeader {
	header: STHeader;
	valueTable: number;
	firstTable: number[];
}
interface KernStateEntry {
	newState: number;
	flags: number;
}
interface KernOffsetTable {
	firstGlyph: number;
	nGlyphs: number;
	offsetTable: number[];
}
interface KernSimpleArrayHeader {
	rowWidth: number;
	leftOffsetTable: number;
	rightOffsetTable: number;
	theArray: number;
	firstTable: number[];
}
interface KernIndexArrayHeader {
	glyphCount: number;
	kernValueCount: number;
	leftClassCount: number;
	rightClassCount: number;
	flags: number;
	kernValue: number[];
	leftClass: number[];
	rightClass: number[];
	kernIndex: number[];
}
interface KerxTableHeader {
	version: number;
	nTables: number;
	firstSubtable: number[];
}
interface KerxKerningPair {
	left: number;
	right: number;
}
interface KerxOrderedListEntry {
	pair: KerxKerningPair;
	value: number;
}
interface KerxOrderedListHeader {
	nPairs: number;
	searchRange: number;
	entrySelector: number;
	rangeShift: number;
	table: number[];
}
interface KerxStateHeader {
	header: STXHeader;
	valueTable: number;
	firstTable: number[];
}
interface KerxStateEntry {
	newState: number;
	flags: number;
	valueIndex: number;
}
interface KerxControlPointHeader {
	header: STXHeader;
	flags: number;
	firstTable: number[];
}
interface KerxControlPointEntry {
	newState: number;
	flags: number;
	actionIndex: number;
}
interface KerxControlPointAction {
	markControlPoint: number;
	currControlPoint: number;
}
interface KerxAnchorPointAction {
	markAnchorPoint: number;
	currAnchorPoint: number;
}
interface KerxCoordinateAction {
	markX: number;
	markY: number;
	currX: number;
	currY: number;
}
interface KerxSimpleArrayHeader {
	rowWidth: number;
	leftOffsetTable: number;
	rightOffsetTable: number;
	theArray: number;
	firstTable: number[];
}
interface KerxIndexArrayHeader {
	glyphCount: number;
	kernValueCount: number;
	leftClassCount: number;
	rightClassCount: number;
	flags: number;
	kernValue: number[];
	leftClass: number[];
	rightClass: number[];
	kernIndex: number[];
}
interface BslnFormat0Part {
	deltas: number[];
}
interface BslnFormat2Part {
	stdGlyph: number;
	ctlPoints: number[];
}
interface ALMXGlyphEntry {
	GlyphIndexOffset: number;
	HorizontalAdvance: number;
	XOffsetToHOrigin: number;
	VerticalAdvance: number;
	YOffsetToVOrigin: number;
}
interface ROTAGlyphEntry {
	GlyphIndexOffset: number;
	HBaselineOffset: number;
	VBaselineOffset: number;
}
interface AnchorPoint {
	x: number;
	y: number;
}
interface AnchorPointTable {
	nPoints: number;
	points: AnchorPoint[];
}
interface AnkrTable {
	version: number;
	flags: number;
	lookupTableOffset: number;
	anchorPointTableOffset: number;
}
interface LtagStringRange {
	offset: number;
	length: number;
}
interface LtagTable {
	version: number;
	flags: number;
	numTags: number;
	tagRange: LtagStringRange[];
}
interface sfntDirectoryEntry {
	tableTag: number;
	checkSum: number;
	offset: number;
	length: number;
}
interface sfntDirectory {
	format: number;
	numOffsets: number;
	searchRange: number;
	entrySelector: number;
	rangeShift: number;
	table: sfntDirectoryEntry[];
}
interface sfntCMapSubHeader {
	format: number;
	length: number;
	languageID: number;
}
interface sfntCMapExtendedSubHeader {
	format: number;
	reserved: number;
	length: number;
	language: number;
}
interface sfntCMapEncoding {
	platformID: number;
	scriptID: number;
	offset: number;
}
interface sfntCMapHeader {
	version: number;
	numTables: number;
	encoding: sfntCMapEncoding[];
}
interface sfntNameRecord {
	platformID: number;
	scriptID: number;
	languageID: number;
	nameID: number;
	length: number;
	offset: number;
}
interface sfntNameHeader {
	format: number;
	count: number;
	stringOffset: number;
	rec: sfntNameRecord[];
}
interface sfntVariationAxis {
	axisTag: number;
	minValue: number;
	defaultValue: number;
	maxValue: number;
	flags: number;
	nameID: number;
}
interface sfntInstance {
	nameID: number;
	flags: number;
	coord: number[];
}
interface sfntVariationHeader {
	version: number;
	offsetToData: number;
	countSizePairs: number;
	axisCount: number;
	axisSize: number;
	instanceCount: number;
	instanceSize: number;
	axis: sfntVariationAxis[];
	instance: sfntInstance[];
}
interface sfntFontDescriptor {
	name: number;
	value: number;
}
interface sfntDescriptorHeader {
	version: number;
	descriptorCount: number;
	descriptor: sfntFontDescriptor[];
}
interface sfntFeatureName {
	featureType: number;
	settingCount: number;
	offsetToSettings: number;
	featureFlags: number;
	nameID: number;
}
interface sfntFontFeatureSetting {
	setting: number;
	nameID: number;
}
interface sfntFontRunFeature {
	featureType: number;
	setting: number;
}
interface sfntFeatureHeader {
	version: number;
	featureNameCount: number;
	featureSetCount: number;
	reserved: number;
	names: sfntFeatureName[];
	settings: sfntFontFeatureSetting[];
	runs: sfntFontRunFeature[];
}
interface FontVariation {
	name: number;
	value: number;
}
interface CATransform3D {
	m11: number;
	m12: number;
	m13: number;
	m14: number;
	m21: number;
	m22: number;
	m23: number;
	m24: number;
	m31: number;
	m32: number;
	m33: number;
	m34: number;
	m41: number;
	m42: number;
	m43: number;
	m44: number;
}
interface _CALayerIvars {
	refcount: number;
	magic: number;
	layer: any;
	unused1: any[];
}
interface AudioValueRange {
	mMinimum: number;
	mMaximum: number;
}
interface AudioValueTranslation {
	mInputData: any;
	mInputDataSize: number;
	mOutputData: any;
	mOutputDataSize: number;
}
interface AudioBuffer {
	mNumberChannels: number;
	mDataByteSize: number;
	mData: any;
}
interface AudioBufferList {
	mNumberBuffers: number;
	mBuffers: AudioBuffer[];
}
interface AudioStreamBasicDescription {
	mSampleRate: number;
	mFormatID: number;
	mFormatFlags: number;
	mBytesPerPacket: number;
	mFramesPerPacket: number;
	mBytesPerFrame: number;
	mChannelsPerFrame: number;
	mBitsPerChannel: number;
	mReserved: number;
}
interface AudioStreamPacketDescription {
	mStartOffset: number;
	mVariableFramesInPacket: number;
	mDataByteSize: number;
}
interface SMPTETime {
	mSubframes: number;
	mSubframeDivisor: number;
	mCounter: number;
	mType: number;
	mFlags: number;
	mHours: number;
	mMinutes: number;
	mSeconds: number;
	mFrames: number;
}
interface AudioTimeStamp {
	mSampleTime: number;
	mHostTime: number;
	mRateScalar: number;
	mWordClockTime: number;
	mSMPTETime: SMPTETime;
	mFlags: number;
	mReserved: number;
}
interface AudioClassDescription {
	mType: number;
	mSubType: number;
	mManufacturer: number;
}
interface AudioChannelDescription {
	mChannelLabel: number;
	mChannelFlags: number;
	mCoordinates: number[];
}
interface AudioChannelLayout {
	mChannelLayoutTag: number;
	mChannelBitmap: number;
	mNumberChannelDescriptions: number;
	mChannelDescriptions: AudioChannelDescription[];
}
interface AudioFile_SMPTE_Time {
	mHours: string;
	mMinutes: number;
	mSeconds: number;
	mFrames: number;
	mSubFrameSampleOffset: number;
}
interface AudioFileMarker {
	mFramePosition: number;
	mName: string;
	mMarkerID: number;
	mSMPTETime: AudioFile_SMPTE_Time;
	mType: number;
	mReserved: number;
	mChannel: number;
}
interface AudioFileMarkerList {
	mSMPTE_TimeType: number;
	mNumberMarkers: number;
	mMarkers: AudioFileMarker[];
}
interface AudioFileRegion {
	mRegionID: number;
	mName: string;
	mFlags: number;
	mNumberMarkers: number;
	mMarkers: AudioFileMarker[];
}
interface AudioFileRegionList {
	mSMPTE_TimeType: number;
	mNumberRegions: number;
	mRegions: AudioFileRegion[];
}
interface AudioFramePacketTranslation {
	mFrame: number;
	mPacket: number;
	mFrameOffsetInPacket: number;
}
interface AudioBytePacketTranslation {
	mByte: number;
	mPacket: number;
	mByteOffsetInPacket: number;
	mFlags: number;
}
interface AudioFilePacketTableInfo {
	mNumberValidFrames: number;
	mPrimingFrames: number;
	mRemainderFrames: number;
}
interface AudioFileTypeAndFormatID {
	mFileType: number;
	mFormatID: number;
}
interface AudioPanningInfo {
	mPanningMode: number;
	mCoordinateFlags: number;
	mCoordinates: number[];
	mGainScale: number;
	mOutputChannelMap: any;
}
interface AudioBalanceFade {
	mLeftRightBalance: number;
	mBackFrontFade: number;
	mType: number;
	mChannelLayout: any;
}
interface AudioFormatInfo {
	mASBD: AudioStreamBasicDescription;
	mMagicCookie: any;
	mMagicCookieSize: number;
}
interface ExtendedAudioFormatInfo {
	mASBD: AudioStreamBasicDescription;
	mMagicCookie: any;
	mMagicCookieSize: number;
	mClassDescription: AudioClassDescription;
}
interface AudioFormatListItem {
	mASBD: AudioStreamBasicDescription;
	mChannelLayoutTag: number;
}
interface AudioQueueBuffer {
	mAudioDataBytesCapacity: number;
	mAudioData: any;
	mAudioDataByteSize: number;
	mUserData: any;
	mPacketDescriptionCapacity: number;
	mPacketDescriptions: any;
	mPacketDescriptionCount: number;
}
interface AudioQueueParameterEvent {
	mID: number;
	mValue: number;
}
interface AudioQueueLevelMeterState {
	mAveragePower: number;
	mPeakPower: number;
}
interface AudioQueueChannelAssignment {
	mDeviceUID: string;
	mChannelNumber: number;
}
interface AudioUnitNodeConnection {
	sourceNode: number;
	sourceOutputNumber: number;
	destNode: number;
	destInputNumber: number;
}
interface AUNodeRenderCallback {
	destNode: number;
	destInputNumber: number;
	cback: AURenderCallbackStruct;
}
interface AudioConverterPrimeInfo {
	leadingFrames: number;
	trailingFrames: number;
}
interface MIDINoteMessage {
	channel: number;
	note: number;
	velocity: number;
	releaseVelocity: number;
	duration: number;
}
interface MIDIChannelMessage {
	status: number;
	data1: number;
	data2: number;
	reserved: number;
}
interface MIDIRawData {
	length: number;
	data: number[];
}
interface MIDIMetaEvent {
	metaEventType: number;
	unused1: number;
	unused2: number;
	unused3: number;
	dataLength: number;
	data: number[];
}
interface MusicEventUserData {
	length: number;
	data: number[];
}
interface ExtendedNoteOnEvent {
	instrumentID: number;
	groupID: number;
	duration: number;
	extendedParams: MusicDeviceNoteParams;
}
interface ParameterEvent {
	parameterID: number;
	scope: number;
	element: number;
	value: number;
}
interface ExtendedTempoEvent {
	bpm: number;
}
interface AUPresetEvent {
	scope: number;
	element: number;
	preset: any;
}
interface CABarBeatTime {
	bar: number;
	beat: number;
	subbeat: number;
	subbeatDivisor: number;
	reserved: number;
}
interface MusicTrackLoopInfo {
	loopDuration: number;
	numberOfLoops: number;
}
interface CAFFileHeader {
	mFileType: number;
	mFileVersion: number;
	mFileFlags: number;
}
interface CAFChunkHeader {
	mChunkType: number;
	mChunkSize: number;
}
interface CAF_UUID_ChunkHeader {
	mHeader: CAFChunkHeader;
	mUUID: number[];
}
interface CAFAudioDescription {
	mSampleRate: number;
	mFormatID: number;
	mFormatFlags: number;
	mBytesPerPacket: number;
	mFramesPerPacket: number;
	mChannelsPerFrame: number;
	mBitsPerChannel: number;
}
interface CAFAudioFormatListItem {
	mFormat: CAFAudioDescription;
	mChannelLayoutTag: number;
}
interface CAFPacketTableHeader {
	mNumberPackets: number;
	mNumberValidFrames: number;
	mPrimingFrames: number;
	mRemainderFrames: number;
	mPacketDescriptions: number[];
}
interface CAFDataChunk {
	mEditCount: number;
	mData: number[];
}
interface CAF_SMPTE_Time {
	mHours: string;
	mMinutes: string;
	mSeconds: string;
	mFrames: string;
	mSubFrameSampleOffset: number;
}
interface CAFMarker {
	mType: number;
	mFramePosition: number;
	mMarkerID: number;
	mSMPTETime: CAF_SMPTE_Time;
	mChannel: number;
}
interface CAFMarkerChunk {
	mSMPTE_TimeType: number;
	mNumberMarkers: number;
	mMarkers: CAFMarker[];
}
interface CAFRegion {
	mRegionID: number;
	mFlags: number;
	mNumberMarkers: number;
	mMarkers: CAFMarker[];
}
interface CAFRegionChunk {
	mSMPTE_TimeType: number;
	mNumberRegions: number;
	mRegions: CAFRegion[];
}
interface CAFInstrumentChunk {
	mBaseNote: number;
	mMIDILowNote: number;
	mMIDIHighNote: number;
	mMIDILowVelocity: number;
	mMIDIHighVelocity: number;
	mdBGain: number;
	mStartRegionID: number;
	mSustainRegionID: number;
	mReleaseRegionID: number;
	mInstrumentID: number;
}
interface CAFStringID {
	mStringID: number;
	mStringStartByteOffset: number;
}
interface CAFStrings {
	mNumEntries: number;
	mStringsIDs: CAFStringID[];
}
interface CAFInfoStrings {
	mNumEntries: number;
}
interface CAFPositionPeak {
	mValue: number;
	mFrameNumber: number;
}
interface CAFPeakChunk {
	mEditCount: number;
	mPeaks: CAFPositionPeak[];
}
interface CAFOverviewSample {
	mMinValue: number;
	mMaxValue: number;
}
interface CAFOverviewChunk {
	mEditCount: number;
	mNumFramesPerOVWSample: number;
	mData: CAFOverviewSample[];
}
interface CAFUMIDChunk {
	mBytes: number[];
}
interface AudioComponentDescription {
	componentType: number;
	componentSubType: number;
	componentManufacturer: number;
	componentFlags: number;
	componentFlagsMask: number;
}
interface AudioComponentPlugInInterface {
	Open: (arg1: any, arg2: any) => number;
	Close: (arg1: any) => number;
	Lookup: (arg1: number) => (arg1: any) => number;
	reserved: any;
}
interface AudioUnitParameter {
	mAudioUnit: any;
	mParameterID: number;
	mScope: number;
	mElement: number;
}
interface AudioUnitProperty {
	mAudioUnit: any;
	mPropertyID: number;
	mScope: number;
	mElement: number;
}
interface AudioUnitConnection {
	sourceAudioUnit: any;
	sourceOutputNumber: number;
	destInputNumber: number;
}
interface AUChannelInfo {
	inChannels: number;
	outChannels: number;
}
interface AudioUnitExternalBuffer {
	buffer: string;
	size: number;
}
interface AURenderCallbackStruct {
	inputProc: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: number, arg6: any) => number;
	inputProcRefCon: any;
}
interface AUPreset {
	presetNumber: number;
	presetName: string;
}
interface AudioUnitFrequencyResponseBin {
	mFrequency: number;
	mMagnitude: number;
}
interface HostCallbackInfo {
	hostUserData: any;
	beatAndTempoProc: (arg1: any, arg2: any, arg3: any) => number;
	musicalTimeLocationProc: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any) => number;
	transportStateProc: (arg1: any, arg2: string, arg3: string, arg4: any, arg5: string, arg6: any, arg7: any) => number;
	transportStateProc2: (arg1: any, arg2: string, arg3: string, arg4: string, arg5: any, arg6: string, arg7: any, arg8: any) => number;
}
interface AUDependentParameter {
	mScope: number;
	mParameterID: number;
}
interface AUInputSamplesInOutputCallbackStruct {
	inputToOutputCallback: (arg1: any, arg2: any, arg3: number, arg4: number) => void;
	userData: any;
}
interface AudioUnitParameterHistoryInfo {
	updatesPerSecond: number;
	historyDurationInSeconds: number;
}
interface AudioUnitParameterInfo {
	name: string[];
	unitName: string;
	clumpID: number;
	cfNameString: string;
	unit: number;
	minValue: number;
	maxValue: number;
	defaultValue: number;
	flags: number;
}
interface AudioUnitParameterIDName {
	inID: number;
	inDesiredLength: number;
	outName: string;
}
interface AudioUnitParameterStringFromValue {
	inParamID: number;
	inValue: any;
	outString: string;
}
interface AudioUnitParameterValueFromString {
	inParamID: number;
	inString: string;
	outValue: number;
}
interface AudioOutputUnitMIDICallbacks {
	userData: any;
	MIDIEventProc: (arg1: any, arg2: number, arg3: number, arg4: number, arg5: number) => void;
	MIDISysExProc: (arg1: any, arg2: string, arg3: number) => void;
}
interface AudioOutputUnitStartAtTimeParams {
	mTimestamp: AudioTimeStamp;
	mFlags: number;
}
interface AudioUnitMeterClipping {
	peakValueSinceLastCall: number;
	sawInfinity: boolean;
	sawNotANumber: boolean;
}
interface MixerDistanceParams {
	mReferenceDistance: number;
	mMaxDistance: number;
	mMaxAttenuation: number;
}
interface ScheduledAudioSlice {
	mTimeStamp: AudioTimeStamp;
	mCompletionProc: (arg1: any, arg2: any) => void;
	mCompletionProcUserData: any;
	mFlags: number;
	mReserved: number;
	mReserved2: any;
	mNumberFrames: number;
	mBufferList: any;
}
interface ScheduledAudioFileRegion {
	mTimeStamp: AudioTimeStamp;
	mCompletionProc: (arg1: any, arg2: any, arg3: number) => void;
	mCompletionProcUserData: any;
	mAudioFile: any;
	mLoopCount: number;
	mStartFrame: number;
	mFramesToPlay: number;
}
interface AUSamplerInstrumentData {
	fileURL: NSURL;
	instrumentType: number;
	bankMSB: number;
	bankLSB: number;
	presetID: number;
}
interface AUSamplerBankPresetData {
	bankURL: NSURL;
	bankMSB: number;
	bankLSB: number;
	presetID: number;
	reserved: number;
}
interface MusicDeviceStdNoteParams {
	argCount: number;
	mPitch: number;
	mVelocity: number;
}
interface NoteParamsControlValue {
	mID: number;
	mValue: number;
}
interface MusicDeviceNoteParams {
	argCount: number;
	mPitch: number;
	mVelocity: number;
	mControls: NoteParamsControlValue[];
}
interface AVAudio3DPoint {
	x: number;
	y: number;
	z: number;
}
interface AVAudio3DVectorOrientation {
	forward: AVAudio3DPoint;
	up: AVAudio3DPoint;
}
interface AVAudio3DAngularOrientation {
	yaw: number;
	pitch: number;
	roll: number;
}
interface AVPixelAspectRatio {
	horizontalSpacing: number;
	verticalSpacing: number;
}
interface AVEdgeWidths {
	left: number;
	top: number;
	right: number;
	bottom: number;
}
interface AVCaptureWhiteBalanceGains {
	redGain: number;
	greenGain: number;
	blueGain: number;
}
interface AVCaptureWhiteBalanceChromaticityValues {
	x: number;
	y: number;
}
interface AVCaptureWhiteBalanceTemperatureAndTintValues {
	temperature: number;
	tint: number;
}
interface CMTime {
	value: number;
	timescale: number;
	flags: number;
	epoch: number;
}
interface CMTimeRange {
	start: CMTime;
	duration: CMTime;
}
interface CMTimeMapping {
	source: CMTimeRange;
	target: CMTimeRange;
}
interface CMBlockBufferCustomBlockSource {
	version: number;
	AllocateBlock: (arg1: any, arg2: number) => any;
	FreeBlock: (arg1: any, arg2: any, arg3: number) => void;
	refCon: any;
}
interface CMVideoDimensions {
	width: number;
	height: number;
}
interface CMSampleTimingInfo {
	duration: CMTime;
	presentationTimeStamp: CMTime;
	decodeTimeStamp: CMTime;
}
interface CMBufferCallbacks {
	version: number;
	refcon: any;
	getDecodeTimeStamp: (arg1: any, arg2: any) => CMTime;
	getPresentationTimeStamp: (arg1: any, arg2: any) => CMTime;
	getDuration: (arg1: any, arg2: any) => CMTime;
	isDataReady: (arg1: any, arg2: any) => boolean;
	compare: (arg1: any, arg2: any, arg3: any) => number;
	dataBecameReadyNotification: string;
	getSize: (arg1: any, arg2: any) => number;
}
interface MTAudioProcessingTapCallbacks {
	version: number;
	clientInfo: any;
	init: (arg1: any, arg2: any, arg3: any) => void;
	finalize: (arg1: any) => void;
	prepare: (arg1: any, arg2: number, arg3: any) => void;
	unprepare: (arg1: any) => void;
	process: (arg1: any, arg2: number, arg3: number, arg4: any, arg5: any, arg6: any) => void;
}
interface CLLocationCoordinate2D {
	latitude: number;
	longitude: number;
}
interface CMAcceleration {
	x: number;
	y: number;
	z: number;
}
interface CMRotationMatrix {
	m11: number;
	m12: number;
	m13: number;
	m21: number;
	m22: number;
	m23: number;
	m31: number;
	m32: number;
	m33: number;
}
interface CMQuaternion {
	x: number;
	y: number;
	z: number;
	w: number;
}
interface CMRotationRate {
	x: number;
	y: number;
	z: number;
}
interface CMMagneticField {
	x: number;
	y: number;
	z: number;
}
interface CMCalibratedMagneticField {
	field: CMMagneticField;
	accuracy: number;
}
interface CTError {
	domain: number;
	error: number;
}
interface JSStaticValue {
	name: string;
	getProperty: (arg1: any, arg2: any, arg3: any, arg4: any) => any;
	setProperty: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any) => boolean;
	attributes: number;
}
interface JSStaticFunction {
	name: string;
	callAsFunction: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: any, arg6: any) => any;
	attributes: number;
}
interface JSClassDefinition {
	version: number;
	attributes: number;
	className: string;
	parentClass: any;
	staticValues: any;
	staticFunctions: any;
	initialize: (arg1: any, arg2: any) => void;
	finalize: (arg1: any) => void;
	hasProperty: (arg1: any, arg2: any, arg3: any) => boolean;
	getProperty: (arg1: any, arg2: any, arg3: any, arg4: any) => any;
	setProperty: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any) => boolean;
	deleteProperty: (arg1: any, arg2: any, arg3: any, arg4: any) => boolean;
	getPropertyNames: (arg1: any, arg2: any, arg3: any) => void;
	callAsFunction: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: any, arg6: any) => any;
	callAsConstructor: (arg1: any, arg2: any, arg3: number, arg4: any, arg5: any) => any;
	hasInstance: (arg1: any, arg2: any, arg3: any, arg4: any) => boolean;
	convertToType: (arg1: any, arg2: any, arg3: number, arg4: any) => any;
}
interface MKCoordinateSpan {
	latitudeDelta: number;
	longitudeDelta: number;
}
interface MKCoordinateRegion {
	center: CLLocationCoordinate2D;
	span: MKCoordinateSpan;
}
interface MKMapPoint {
	x: number;
	y: number;
}
interface MKMapSize {
	width: number;
	height: number;
}
interface MKMapRect {
	origin: MKMapPoint;
	size: MKMapSize;
}
interface MKTileOverlayPath {
	x: number;
	y: number;
	z: number;
	contentScaleFactor: number;
}
interface SCDynamicStoreContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface SCPreferencesContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface SCNetworkReachabilityContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface SCNetworkConnectionContext {
	version: number;
	info: any;
	retain: (arg1: any) => any;
	release: (arg1: any) => void;
	copyDescription: (arg1: any) => string;
}
interface VTDecompressionOutputCallbackRecord {
	decompressionOutputCallback: (arg1: any, arg2: any, arg3: number, arg4: number, arg5: any, arg6: CMTime, arg7: CMTime) => void;
	decompressionOutputRefCon: any;
}
interface sqlite3_file {
	pMethods: any;
}
interface sqlite3_io_methods {
	iVersion: number;
	xClose: (arg1: any) => number;
	xRead: (arg1: any, arg2: any, arg3: number, arg4: number) => number;
	xWrite: (arg1: any, arg2: any, arg3: number, arg4: number) => number;
	xTruncate: (arg1: any, arg2: number) => number;
	xSync: (arg1: any, arg2: number) => number;
	xFileSize: (arg1: any, arg2: any) => number;
	xLock: (arg1: any, arg2: number) => number;
	xUnlock: (arg1: any, arg2: number) => number;
	xCheckReservedLock: (arg1: any, arg2: any) => number;
	xFileControl: (arg1: any, arg2: number, arg3: any) => number;
	xSectorSize: (arg1: any) => number;
	xDeviceCharacteristics: (arg1: any) => number;
	xShmMap: (arg1: any, arg2: number, arg3: number, arg4: number, arg5: any) => number;
	xShmLock: (arg1: any, arg2: number, arg3: number, arg4: number) => number;
	xShmBarrier: (arg1: any) => void;
	xShmUnmap: (arg1: any, arg2: number) => number;
}
interface sqlite3_vfs {
	iVersion: number;
	szOsFile: number;
	mxPathname: number;
	pNext: any;
	zName: string;
	pAppData: any;
	xOpen: (arg1: any, arg2: string, arg3: any, arg4: number, arg5: any) => number;
	xDelete: (arg1: any, arg2: string, arg3: number) => number;
	xAccess: (arg1: any, arg2: string, arg3: number, arg4: any) => number;
	xFullPathname: (arg1: any, arg2: string, arg3: number, arg4: string) => number;
	xDlOpen: (arg1: any, arg2: string) => any;
	xDlError: (arg1: any, arg2: number, arg3: string) => void;
	xDlSym: (arg1: any, arg2: any, arg3: string) => () => void;
	xDlClose: (arg1: any, arg2: any) => void;
	xRandomness: (arg1: any, arg2: number, arg3: string) => number;
	xSleep: (arg1: any, arg2: number) => number;
	xCurrentTime: (arg1: any, arg2: any) => number;
	xGetLastError: (arg1: any, arg2: number, arg3: string) => number;
	xCurrentTimeInt64: (arg1: any, arg2: any) => number;
	xSetSystemCall: (arg1: any, arg2: string, arg3: () => void) => number;
	xGetSystemCall: (arg1: any, arg2: string) => () => void;
	xNextSystemCall: (arg1: any, arg2: string) => string;
}
interface sqlite3_mem_methods {
	xMalloc: (arg1: number) => any;
	xFree: (arg1: any) => void;
	xRealloc: (arg1: any, arg2: number) => any;
	xSize: (arg1: any) => number;
	xRoundup: (arg1: number) => number;
	xInit: (arg1: any) => number;
	xShutdown: (arg1: any) => void;
	pAppData: any;
}
interface sqlite3_module {
	iVersion: number;
	xCreate: (arg1: any, arg2: any, arg3: number, arg4: any, arg5: any, arg6: any) => number;
	xConnect: (arg1: any, arg2: any, arg3: number, arg4: any, arg5: any, arg6: any) => number;
	xBestIndex: (arg1: any, arg2: any) => number;
	xDisconnect: (arg1: any) => number;
	xDestroy: (arg1: any) => number;
	xOpen: (arg1: any, arg2: any) => number;
	xClose: (arg1: any) => number;
	xFilter: (arg1: any, arg2: number, arg3: string, arg4: number, arg5: any) => number;
	xNext: (arg1: any) => number;
	xEof: (arg1: any) => number;
	xColumn: (arg1: any, arg2: any, arg3: number) => number;
	xRowid: (arg1: any, arg2: any) => number;
	xUpdate: (arg1: any, arg2: number, arg3: any, arg4: any) => number;
	xBegin: (arg1: any) => number;
	xSync: (arg1: any) => number;
	xCommit: (arg1: any) => number;
	xRollback: (arg1: any) => number;
	xFindFunction: (arg1: any, arg2: number, arg3: string, arg4: any, arg5: any) => number;
	xRename: (arg1: any, arg2: string) => number;
	xSavepoint: (arg1: any, arg2: number) => number;
	xRelease: (arg1: any, arg2: number) => number;
	xRollbackTo: (arg1: any, arg2: number) => number;
}
interface sqlite3_index_info {
	nConstraint: number;
	aConstraint: any;
	nOrderBy: number;
	aOrderBy: any;
	aConstraintUsage: any;
	idxNum: number;
	idxStr: string;
	needToFreeIdxStr: number;
	orderByConsumed: number;
	estimatedCost: number;
}
interface sqlite3_index_constraint {
	iColumn: number;
	op: number;
	usable: number;
	iTermOffset: number;
}
interface sqlite3_index_orderby {
	iColumn: number;
	desc: number;
}
interface sqlite3_index_constraint_usage {
	argvIndex: number;
	omit: number;
}
interface sqlite3_vtab {
	pModule: any;
	nRef: number;
	zErrMsg: string;
}
interface sqlite3_vtab_cursor {
	pVtab: any;
}
interface sqlite3_mutex_methods {
	xMutexInit: () => number;
	xMutexEnd: () => number;
	xMutexAlloc: (arg1: number) => any;
	xMutexFree: (arg1: any) => void;
	xMutexEnter: (arg1: any) => void;
	xMutexTry: (arg1: any) => number;
	xMutexLeave: (arg1: any) => void;
	xMutexHeld: (arg1: any) => number;
	xMutexNotheld: (arg1: any) => number;
}
interface sqlite3_pcache_page {
	pBuf: any;
	pExtra: any;
}
interface sqlite3_pcache_methods2 {
	iVersion: number;
	pArg: any;
	xInit: (arg1: any) => number;
	xShutdown: (arg1: any) => void;
	xCreate: (arg1: number, arg2: number, arg3: number) => any;
	xCachesize: (arg1: any, arg2: number) => void;
	xPagecount: (arg1: any) => number;
	xFetch: (arg1: any, arg2: number, arg3: number) => any;
	xUnpin: (arg1: any, arg2: any, arg3: number) => void;
	xRekey: (arg1: any, arg2: any, arg3: number, arg4: number) => void;
	xTruncate: (arg1: any, arg2: number) => void;
	xDestroy: (arg1: any) => void;
	xShrink: (arg1: any) => void;
}
interface sqlite3_pcache_methods {
	pArg: any;
	xInit: (arg1: any) => number;
	xShutdown: (arg1: any) => void;
	xCreate: (arg1: number, arg2: number) => any;
	xCachesize: (arg1: any, arg2: number) => void;
	xPagecount: (arg1: any) => number;
	xFetch: (arg1: any, arg2: number, arg3: number) => any;
	xUnpin: (arg1: any, arg2: any, arg3: number) => void;
	xRekey: (arg1: any, arg2: any, arg3: number, arg4: number) => void;
	xTruncate: (arg1: any, arg2: number) => void;
	xDestroy: (arg1: any) => void;
}
interface sqlite3_rtree_geometry {
	pContext: any;
	nParam: number;
	aParam: any;
	pUser: any;
	xDelUser: (arg1: any) => void;
}
declare enum idtype_t {
	P_ALL,
	P_PID,
	P_PGID
}
declare enum mach_port_guard_exception_codes {
	kGUARD_EXC_DESTROY,
	kGUARD_EXC_MOD_REFS,
	kGUARD_EXC_SET_CONTEXT,
	kGUARD_EXC_UNGUARDED,
	kGUARD_EXC_INCORRECT_GUARD
}
declare enum filesec_property_t {
	FILESEC_OWNER,
	FILESEC_GROUP,
	FILESEC_UUID,
	FILESEC_MODE,
	FILESEC_ACL,
	FILESEC_GRPUUID,
	FILESEC_ACL_RAW,
	FILESEC_ACL_ALLOCSIZE
}
declare enum qos_class_t {
	QOS_CLASS_USER_INTERACTIVE,
	QOS_CLASS_USER_INITIATED,
	QOS_CLASS_DEFAULT,
	QOS_CLASS_UTILITY,
	QOS_CLASS_BACKGROUND,
	QOS_CLASS_UNSPECIFIED
}
declare enum dispatch_block_flags_t {
	DISPATCH_BLOCK_BARRIER,
	DISPATCH_BLOCK_DETACHED,
	DISPATCH_BLOCK_ASSIGN_CURRENT,
	DISPATCH_BLOCK_NO_QOS_CLASS,
	DISPATCH_BLOCK_INHERIT_QOS_CLASS,
	DISPATCH_BLOCK_ENFORCE_QOS_CLASS
}
declare enum acl_perm_t {
	ACL_READ_DATA,
	ACL_LIST_DIRECTORY,
	ACL_WRITE_DATA,
	ACL_ADD_FILE,
	ACL_EXECUTE,
	ACL_SEARCH,
	ACL_DELETE,
	ACL_APPEND_DATA,
	ACL_ADD_SUBDIRECTORY,
	ACL_DELETE_CHILD,
	ACL_READ_ATTRIBUTES,
	ACL_WRITE_ATTRIBUTES,
	ACL_READ_EXTATTRIBUTES,
	ACL_WRITE_EXTATTRIBUTES,
	ACL_READ_SECURITY,
	ACL_WRITE_SECURITY,
	ACL_CHANGE_OWNER,
	ACL_SYNCHRONIZE
}
declare enum acl_tag_t {
	ACL_UNDEFINED_TAG,
	ACL_EXTENDED_ALLOW,
	ACL_EXTENDED_DENY
}
declare enum acl_type_t {
	ACL_TYPE_EXTENDED,
	ACL_TYPE_ACCESS,
	ACL_TYPE_DEFAULT,
	ACL_TYPE_AFS,
	ACL_TYPE_CODA,
	ACL_TYPE_NTFS,
	ACL_TYPE_NWFS
}
declare enum acl_entry_id_t {
	ACL_FIRST_ENTRY,
	ACL_NEXT_ENTRY,
	ACL_LAST_ENTRY
}
declare enum acl_flag_t {
	ACL_FLAG_DEFER_INHERIT,
	ACL_FLAG_NO_INHERIT,
	ACL_ENTRY_INHERITED,
	ACL_ENTRY_FILE_INHERIT,
	ACL_ENTRY_DIRECTORY_INHERIT,
	ACL_ENTRY_LIMIT_INHERIT,
	ACL_ENTRY_ONLY_INHERIT
}
declare enum CGRectEdge {
	CGRectMinXEdge,
	CGRectMinYEdge,
	CGRectMaxXEdge,
	CGRectMaxYEdge
}
declare enum CGColorRenderingIntent {
	kCGRenderingIntentDefault,
	kCGRenderingIntentAbsoluteColorimetric,
	kCGRenderingIntentRelativeColorimetric,
	kCGRenderingIntentPerceptual,
	kCGRenderingIntentSaturation
}
declare enum CGColorSpaceModel {
	kCGColorSpaceModelUnknown,
	kCGColorSpaceModelMonochrome,
	kCGColorSpaceModelRGB,
	kCGColorSpaceModelCMYK,
	kCGColorSpaceModelLab,
	kCGColorSpaceModelDeviceN,
	kCGColorSpaceModelIndexed,
	kCGColorSpaceModelPattern
}
declare enum CGPatternTiling {
	kCGPatternTilingNoDistortion,
	kCGPatternTilingConstantSpacingMinimalDistortion,
	kCGPatternTilingConstantSpacing
}
declare enum CGFontPostScriptFormat {
	kCGFontPostScriptFormatType1,
	kCGFontPostScriptFormatType3,
	kCGFontPostScriptFormatType42
}
declare enum CGImageAlphaInfo {
	kCGImageAlphaNone,
	kCGImageAlphaPremultipliedLast,
	kCGImageAlphaPremultipliedFirst,
	kCGImageAlphaLast,
	kCGImageAlphaFirst,
	kCGImageAlphaNoneSkipLast,
	kCGImageAlphaNoneSkipFirst,
	kCGImageAlphaOnly
}
declare enum CGBitmapInfo {
	kCGBitmapAlphaInfoMask,
	kCGBitmapFloatComponents,
	kCGBitmapByteOrderMask,
	kCGBitmapByteOrderDefault,
	kCGBitmapByteOrder16Little,
	kCGBitmapByteOrder32Little,
	kCGBitmapByteOrder16Big,
	kCGBitmapByteOrder32Big
}
declare enum CGLineJoin {
	kCGLineJoinMiter,
	kCGLineJoinRound,
	kCGLineJoinBevel
}
declare enum CGLineCap {
	kCGLineCapButt,
	kCGLineCapRound,
	kCGLineCapSquare
}
declare enum CGPathElementType {
	kCGPathElementMoveToPoint,
	kCGPathElementAddLineToPoint,
	kCGPathElementAddQuadCurveToPoint,
	kCGPathElementAddCurveToPoint,
	kCGPathElementCloseSubpath
}
declare enum CGPDFObjectType {
	kCGPDFObjectTypeNull,
	kCGPDFObjectTypeBoolean,
	kCGPDFObjectTypeInteger,
	kCGPDFObjectTypeReal,
	kCGPDFObjectTypeName,
	kCGPDFObjectTypeString,
	kCGPDFObjectTypeArray,
	kCGPDFObjectTypeDictionary,
	kCGPDFObjectTypeStream
}
declare enum CGPDFDataFormat {
	CGPDFDataFormatRaw,
	CGPDFDataFormatJPEGEncoded,
	CGPDFDataFormatJPEG2000
}
declare enum CGPDFBox {
	kCGPDFMediaBox,
	kCGPDFCropBox,
	kCGPDFBleedBox,
	kCGPDFTrimBox,
	kCGPDFArtBox
}
declare enum CGPathDrawingMode {
	kCGPathFill,
	kCGPathEOFill,
	kCGPathStroke,
	kCGPathFillStroke,
	kCGPathEOFillStroke
}
declare enum CGTextDrawingMode {
	kCGTextFill,
	kCGTextStroke,
	kCGTextFillStroke,
	kCGTextInvisible,
	kCGTextFillClip,
	kCGTextStrokeClip,
	kCGTextFillStrokeClip,
	kCGTextClip
}
declare enum CGTextEncoding {
	kCGEncodingFontSpecific,
	kCGEncodingMacRoman
}
declare enum CGInterpolationQuality {
	kCGInterpolationDefault,
	kCGInterpolationNone,
	kCGInterpolationLow,
	kCGInterpolationMedium,
	kCGInterpolationHigh
}
declare enum CGBlendMode {
	kCGBlendModeNormal,
	kCGBlendModeMultiply,
	kCGBlendModeScreen,
	kCGBlendModeOverlay,
	kCGBlendModeDarken,
	kCGBlendModeLighten,
	kCGBlendModeColorDodge,
	kCGBlendModeColorBurn,
	kCGBlendModeSoftLight,
	kCGBlendModeHardLight,
	kCGBlendModeDifference,
	kCGBlendModeExclusion,
	kCGBlendModeHue,
	kCGBlendModeSaturation,
	kCGBlendModeColor,
	kCGBlendModeLuminosity,
	kCGBlendModeClear,
	kCGBlendModeCopy,
	kCGBlendModeSourceIn,
	kCGBlendModeSourceOut,
	kCGBlendModeSourceAtop,
	kCGBlendModeDestinationOver,
	kCGBlendModeDestinationIn,
	kCGBlendModeDestinationOut,
	kCGBlendModeDestinationAtop,
	kCGBlendModeXOR,
	kCGBlendModePlusDarker,
	kCGBlendModePlusLighter
}
declare enum _CGError {
	kCGErrorSuccess,
	kCGErrorFailure,
	kCGErrorIllegalArgument,
	kCGErrorInvalidConnection,
	kCGErrorInvalidContext,
	kCGErrorCannotComplete,
	kCGErrorNotImplemented,
	kCGErrorRangeCheck,
	kCGErrorTypeCheck,
	kCGErrorInvalidOperation,
	kCGErrorNoneAvailable
}
declare enum CFComparisonResult {
	kCFCompareLessThan,
	kCFCompareEqualTo,
	kCFCompareGreaterThan
}
declare enum CFDataSearchFlags {
	kCFDataSearchBackwards,
	kCFDataSearchAnchored
}
declare enum CFCharacterSetPredefinedSet {
	kCFCharacterSetControl,
	kCFCharacterSetWhitespace,
	kCFCharacterSetWhitespaceAndNewline,
	kCFCharacterSetDecimalDigit,
	kCFCharacterSetLetter,
	kCFCharacterSetLowercaseLetter,
	kCFCharacterSetUppercaseLetter,
	kCFCharacterSetNonBase,
	kCFCharacterSetDecomposable,
	kCFCharacterSetAlphaNumeric,
	kCFCharacterSetPunctuation,
	kCFCharacterSetCapitalizedLetter,
	kCFCharacterSetSymbol,
	kCFCharacterSetNewline,
	kCFCharacterSetIllegal
}
declare enum CFLocaleLanguageDirection {
	kCFLocaleLanguageDirectionUnknown,
	kCFLocaleLanguageDirectionLeftToRight,
	kCFLocaleLanguageDirectionRightToLeft,
	kCFLocaleLanguageDirectionTopToBottom,
	kCFLocaleLanguageDirectionBottomToTop
}
declare enum CFStringBuiltInEncodings {
	kCFStringEncodingMacRoman,
	kCFStringEncodingWindowsLatin1,
	kCFStringEncodingISOLatin1,
	kCFStringEncodingNextStepLatin,
	kCFStringEncodingASCII,
	kCFStringEncodingUnicode,
	kCFStringEncodingUTF8,
	kCFStringEncodingNonLossyASCII,
	kCFStringEncodingUTF16,
	kCFStringEncodingUTF16BE,
	kCFStringEncodingUTF16LE,
	kCFStringEncodingUTF32,
	kCFStringEncodingUTF32BE,
	kCFStringEncodingUTF32LE
}
declare enum CFStringCompareFlags {
	kCFCompareCaseInsensitive,
	kCFCompareBackwards,
	kCFCompareAnchored,
	kCFCompareNonliteral,
	kCFCompareLocalized,
	kCFCompareNumerically,
	kCFCompareDiacriticInsensitive,
	kCFCompareWidthInsensitive,
	kCFCompareForcedOrdering
}
declare enum CFStringNormalizationForm {
	kCFStringNormalizationFormD,
	kCFStringNormalizationFormKD,
	kCFStringNormalizationFormC,
	kCFStringNormalizationFormKC
}
declare enum CFURLPathStyle {
	kCFURLPOSIXPathStyle,
	kCFURLHFSPathStyle,
	kCFURLWindowsPathStyle
}
declare enum CFURLComponentType {
	kCFURLComponentScheme,
	kCFURLComponentNetLocation,
	kCFURLComponentPath,
	kCFURLComponentResourceSpecifier,
	kCFURLComponentUser,
	kCFURLComponentPassword,
	kCFURLComponentUserInfo,
	kCFURLComponentHost,
	kCFURLComponentPort,
	kCFURLComponentParameterString,
	kCFURLComponentQuery,
	kCFURLComponentFragment
}
declare enum CFURLBookmarkCreationOptions {
	kCFURLBookmarkCreationMinimalBookmarkMask,
	kCFURLBookmarkCreationSuitableForBookmarkFile,
	kCFURLBookmarkCreationPreferFileIDResolutionMask
}
declare enum CFURLBookmarkResolutionOptions {
	kCFURLBookmarkResolutionWithoutUIMask,
	kCFURLBookmarkResolutionWithoutMountingMask,
	kCFBookmarkResolutionWithoutUIMask,
	kCFBookmarkResolutionWithoutMountingMask
}
declare enum CFGregorianUnitFlags {
	kCFGregorianUnitsYears,
	kCFGregorianUnitsMonths,
	kCFGregorianUnitsDays,
	kCFGregorianUnitsHours,
	kCFGregorianUnitsMinutes,
	kCFGregorianUnitsSeconds,
	kCFGregorianAllUnits
}
declare enum __CFByteOrder {
	CFByteOrderUnknown,
	CFByteOrderLittleEndian,
	CFByteOrderBigEndian
}
declare enum CFTimeZoneNameStyle {
	kCFTimeZoneNameStyleStandard,
	kCFTimeZoneNameStyleShortStandard,
	kCFTimeZoneNameStyleDaylightSaving,
	kCFTimeZoneNameStyleShortDaylightSaving,
	kCFTimeZoneNameStyleGeneric,
	kCFTimeZoneNameStyleShortGeneric
}
declare enum CFCalendarUnit {
	kCFCalendarUnitEra,
	kCFCalendarUnitYear,
	kCFCalendarUnitMonth,
	kCFCalendarUnitDay,
	kCFCalendarUnitHour,
	kCFCalendarUnitMinute,
	kCFCalendarUnitSecond,
	kCFCalendarUnitWeek,
	kCFCalendarUnitWeekday,
	kCFCalendarUnitWeekdayOrdinal,
	kCFCalendarUnitQuarter,
	kCFCalendarUnitWeekOfMonth,
	kCFCalendarUnitWeekOfYear,
	kCFCalendarUnitYearForWeekOfYear
}
declare enum CFDateFormatterStyle {
	kCFDateFormatterNoStyle,
	kCFDateFormatterShortStyle,
	kCFDateFormatterMediumStyle,
	kCFDateFormatterLongStyle,
	kCFDateFormatterFullStyle
}
declare enum CFNumberType {
	kCFNumberSInt8Type,
	kCFNumberSInt16Type,
	kCFNumberSInt32Type,
	kCFNumberSInt64Type,
	kCFNumberFloat32Type,
	kCFNumberFloat64Type,
	kCFNumberCharType,
	kCFNumberShortType,
	kCFNumberIntType,
	kCFNumberLongType,
	kCFNumberLongLongType,
	kCFNumberFloatType,
	kCFNumberDoubleType,
	kCFNumberCFIndexType,
	kCFNumberNSIntegerType,
	kCFNumberCGFloatType,
	kCFNumberMaxType
}
declare enum CFNumberFormatterStyle {
	kCFNumberFormatterNoStyle,
	kCFNumberFormatterDecimalStyle,
	kCFNumberFormatterCurrencyStyle,
	kCFNumberFormatterPercentStyle,
	kCFNumberFormatterScientificStyle,
	kCFNumberFormatterSpellOutStyle
}
declare enum CFNumberFormatterOptionFlags {
	kCFNumberFormatterParseIntegersOnly
}
declare enum CFNumberFormatterRoundingMode {
	kCFNumberFormatterRoundCeiling,
	kCFNumberFormatterRoundFloor,
	kCFNumberFormatterRoundDown,
	kCFNumberFormatterRoundUp,
	kCFNumberFormatterRoundHalfEven,
	kCFNumberFormatterRoundHalfDown,
	kCFNumberFormatterRoundHalfUp
}
declare enum CFNumberFormatterPadPosition {
	kCFNumberFormatterPadBeforePrefix,
	kCFNumberFormatterPadAfterPrefix,
	kCFNumberFormatterPadBeforeSuffix,
	kCFNumberFormatterPadAfterSuffix
}
declare enum CFRunLoopActivity {
	kCFRunLoopEntry,
	kCFRunLoopBeforeTimers,
	kCFRunLoopBeforeSources,
	kCFRunLoopBeforeWaiting,
	kCFRunLoopAfterWaiting,
	kCFRunLoopExit,
	kCFRunLoopAllActivities
}
declare enum CFSocketError {
	kCFSocketSuccess,
	kCFSocketError,
	kCFSocketTimeout
}
declare enum CFSocketCallBackType {
	kCFSocketNoCallBack,
	kCFSocketReadCallBack,
	kCFSocketAcceptCallBack,
	kCFSocketDataCallBack,
	kCFSocketConnectCallBack,
	kCFSocketWriteCallBack
}
declare enum CFStreamStatus {
	kCFStreamStatusNotOpen,
	kCFStreamStatusOpening,
	kCFStreamStatusOpen,
	kCFStreamStatusReading,
	kCFStreamStatusWriting,
	kCFStreamStatusAtEnd,
	kCFStreamStatusClosed,
	kCFStreamStatusError
}
declare enum CFStreamEventType {
	kCFStreamEventNone,
	kCFStreamEventOpenCompleted,
	kCFStreamEventHasBytesAvailable,
	kCFStreamEventCanAcceptBytes,
	kCFStreamEventErrorOccurred,
	kCFStreamEventEndEncountered
}
declare enum CFStreamErrorDomain {
	kCFStreamErrorDomainCustom,
	kCFStreamErrorDomainPOSIX,
	kCFStreamErrorDomainMacOSStatus
}
declare enum CFPropertyListMutabilityOptions {
	kCFPropertyListImmutable,
	kCFPropertyListMutableContainers,
	kCFPropertyListMutableContainersAndLeaves
}
declare enum CFPropertyListFormat {
	kCFPropertyListOpenStepFormat,
	kCFPropertyListXMLFormat_v1_0,
	kCFPropertyListBinaryFormat_v1_0
}
declare enum CFStringEncodings {
	kCFStringEncodingMacJapanese,
	kCFStringEncodingMacChineseTrad,
	kCFStringEncodingMacKorean,
	kCFStringEncodingMacArabic,
	kCFStringEncodingMacHebrew,
	kCFStringEncodingMacGreek,
	kCFStringEncodingMacCyrillic,
	kCFStringEncodingMacDevanagari,
	kCFStringEncodingMacGurmukhi,
	kCFStringEncodingMacGujarati,
	kCFStringEncodingMacOriya,
	kCFStringEncodingMacBengali,
	kCFStringEncodingMacTamil,
	kCFStringEncodingMacTelugu,
	kCFStringEncodingMacKannada,
	kCFStringEncodingMacMalayalam,
	kCFStringEncodingMacSinhalese,
	kCFStringEncodingMacBurmese,
	kCFStringEncodingMacKhmer,
	kCFStringEncodingMacThai,
	kCFStringEncodingMacLaotian,
	kCFStringEncodingMacGeorgian,
	kCFStringEncodingMacArmenian,
	kCFStringEncodingMacChineseSimp,
	kCFStringEncodingMacTibetan,
	kCFStringEncodingMacMongolian,
	kCFStringEncodingMacEthiopic,
	kCFStringEncodingMacCentralEurRoman,
	kCFStringEncodingMacVietnamese,
	kCFStringEncodingMacExtArabic,
	kCFStringEncodingMacSymbol,
	kCFStringEncodingMacDingbats,
	kCFStringEncodingMacTurkish,
	kCFStringEncodingMacCroatian,
	kCFStringEncodingMacIcelandic,
	kCFStringEncodingMacRomanian,
	kCFStringEncodingMacCeltic,
	kCFStringEncodingMacGaelic,
	kCFStringEncodingMacFarsi,
	kCFStringEncodingMacUkrainian,
	kCFStringEncodingMacInuit,
	kCFStringEncodingMacVT100,
	kCFStringEncodingMacHFS,
	kCFStringEncodingISOLatin2,
	kCFStringEncodingISOLatin3,
	kCFStringEncodingISOLatin4,
	kCFStringEncodingISOLatinCyrillic,
	kCFStringEncodingISOLatinArabic,
	kCFStringEncodingISOLatinGreek,
	kCFStringEncodingISOLatinHebrew,
	kCFStringEncodingISOLatin5,
	kCFStringEncodingISOLatin6,
	kCFStringEncodingISOLatinThai,
	kCFStringEncodingISOLatin7,
	kCFStringEncodingISOLatin8,
	kCFStringEncodingISOLatin9,
	kCFStringEncodingISOLatin10,
	kCFStringEncodingDOSLatinUS,
	kCFStringEncodingDOSGreek,
	kCFStringEncodingDOSBalticRim,
	kCFStringEncodingDOSLatin1,
	kCFStringEncodingDOSGreek1,
	kCFStringEncodingDOSLatin2,
	kCFStringEncodingDOSCyrillic,
	kCFStringEncodingDOSTurkish,
	kCFStringEncodingDOSPortuguese,
	kCFStringEncodingDOSIcelandic,
	kCFStringEncodingDOSHebrew,
	kCFStringEncodingDOSCanadianFrench,
	kCFStringEncodingDOSArabic,
	kCFStringEncodingDOSNordic,
	kCFStringEncodingDOSRussian,
	kCFStringEncodingDOSGreek2,
	kCFStringEncodingDOSThai,
	kCFStringEncodingDOSJapanese,
	kCFStringEncodingDOSChineseSimplif,
	kCFStringEncodingDOSKorean,
	kCFStringEncodingDOSChineseTrad,
	kCFStringEncodingWindowsLatin2,
	kCFStringEncodingWindowsCyrillic,
	kCFStringEncodingWindowsGreek,
	kCFStringEncodingWindowsLatin5,
	kCFStringEncodingWindowsHebrew,
	kCFStringEncodingWindowsArabic,
	kCFStringEncodingWindowsBalticRim,
	kCFStringEncodingWindowsVietnamese,
	kCFStringEncodingWindowsKoreanJohab,
	kCFStringEncodingANSEL,
	kCFStringEncodingJIS_X0201_76,
	kCFStringEncodingJIS_X0208_83,
	kCFStringEncodingJIS_X0208_90,
	kCFStringEncodingJIS_X0212_90,
	kCFStringEncodingJIS_C6226_78,
	kCFStringEncodingShiftJIS_X0213,
	kCFStringEncodingShiftJIS_X0213_MenKuTen,
	kCFStringEncodingGB_2312_80,
	kCFStringEncodingGBK_95,
	kCFStringEncodingGB_18030_2000,
	kCFStringEncodingKSC_5601_87,
	kCFStringEncodingKSC_5601_92_Johab,
	kCFStringEncodingCNS_11643_92_P1,
	kCFStringEncodingCNS_11643_92_P2,
	kCFStringEncodingCNS_11643_92_P3,
	kCFStringEncodingISO_2022_JP,
	kCFStringEncodingISO_2022_JP_2,
	kCFStringEncodingISO_2022_JP_1,
	kCFStringEncodingISO_2022_JP_3,
	kCFStringEncodingISO_2022_CN,
	kCFStringEncodingISO_2022_CN_EXT,
	kCFStringEncodingISO_2022_KR,
	kCFStringEncodingEUC_JP,
	kCFStringEncodingEUC_CN,
	kCFStringEncodingEUC_TW,
	kCFStringEncodingEUC_KR,
	kCFStringEncodingShiftJIS,
	kCFStringEncodingKOI8_R,
	kCFStringEncodingBig5,
	kCFStringEncodingMacRomanLatin1,
	kCFStringEncodingHZ_GB_2312,
	kCFStringEncodingBig5_HKSCS_1999,
	kCFStringEncodingVISCII,
	kCFStringEncodingKOI8_U,
	kCFStringEncodingBig5_E,
	kCFStringEncodingNextStepJapanese,
	kCFStringEncodingEBCDIC_US,
	kCFStringEncodingEBCDIC_CP037,
	kCFStringEncodingUTF7,
	kCFStringEncodingUTF7_IMAP,
	kCFStringEncodingShiftJIS_X0213_00
}
declare enum CFURLError {
	kCFURLUnknownError,
	kCFURLUnknownSchemeError,
	kCFURLResourceNotFoundError,
	kCFURLResourceAccessViolationError,
	kCFURLRemoteHostUnavailableError,
	kCFURLImproperArgumentsError,
	kCFURLUnknownPropertyKeyError,
	kCFURLPropertyKeyUnavailableError,
	kCFURLTimeoutError
}
declare enum CFNotificationSuspensionBehavior {
	CFNotificationSuspensionBehaviorDrop,
	CFNotificationSuspensionBehaviorCoalesce,
	CFNotificationSuspensionBehaviorHold,
	CFNotificationSuspensionBehaviorDeliverImmediately
}
declare enum CFURLEnumeratorOptions {
	kCFURLEnumeratorDefaultBehavior,
	kCFURLEnumeratorDescendRecursively,
	kCFURLEnumeratorSkipInvisibles,
	kCFURLEnumeratorGenerateFileReferenceURLs,
	kCFURLEnumeratorSkipPackageContents,
	kCFURLEnumeratorIncludeDirectoriesPreOrder,
	kCFURLEnumeratorIncludeDirectoriesPostOrder
}
declare enum CFURLEnumeratorResult {
	kCFURLEnumeratorSuccess,
	kCFURLEnumeratorEnd,
	kCFURLEnumeratorError,
	kCFURLEnumeratorDirectoryPostOrderSuccess
}
declare enum CFFileSecurityClearOptions {
	kCFFileSecurityClearOwner,
	kCFFileSecurityClearGroup,
	kCFFileSecurityClearMode,
	kCFFileSecurityClearOwnerUUID,
	kCFFileSecurityClearGroupUUID,
	kCFFileSecurityClearAccessControlList
}
declare enum CFStringTokenizerTokenType {
	kCFStringTokenizerTokenNone,
	kCFStringTokenizerTokenNormal,
	kCFStringTokenizerTokenHasSubTokensMask,
	kCFStringTokenizerTokenHasDerivedSubTokensMask,
	kCFStringTokenizerTokenHasHasNumbersMask,
	kCFStringTokenizerTokenHasNonLettersMask,
	kCFStringTokenizerTokenIsCJWordMask
}
declare enum _CVReturn {
	kCVReturnSuccess,
	kCVReturnFirst,
	kCVReturnError,
	kCVReturnInvalidArgument,
	kCVReturnAllocationFailed,
	kCVReturnInvalidDisplay,
	kCVReturnDisplayLinkAlreadyRunning,
	kCVReturnDisplayLinkNotRunning,
	kCVReturnDisplayLinkCallbacksNotSet,
	kCVReturnInvalidPixelFormat,
	kCVReturnInvalidSize,
	kCVReturnInvalidPixelBufferAttributes,
	kCVReturnPixelBufferNotOpenGLCompatible,
	kCVReturnPixelBufferNotMetalCompatible,
	kCVReturnWouldExceedAllocationThreshold,
	kCVReturnPoolAllocationFailed,
	kCVReturnInvalidPoolAttributes,
	kCVReturnLast
}
declare enum CVPixelBufferLockFlags {
	kCVPixelBufferLock_ReadOnly
}
declare enum NSComparisonResult {
	NSOrderedAscending,
	NSOrderedSame,
	NSOrderedDescending
}
declare enum NSEnumerationOptions {
	NSEnumerationConcurrent,
	NSEnumerationReverse
}
declare enum NSSortOptions {
	NSSortConcurrent,
	NSSortStable
}
declare enum NSQualityOfService {
	NSQualityOfServiceUserInteractive,
	NSQualityOfServiceUserInitiated,
	NSQualityOfServiceUtility,
	NSQualityOfServiceBackground,
	NSQualityOfServiceDefault
}
declare enum NSBinarySearchingOptions {
	NSBinarySearchingFirstEqual,
	NSBinarySearchingLastEqual,
	NSBinarySearchingInsertionIndex
}
declare enum NSCalendarUnit {
	NSCalendarUnitEra,
	NSCalendarUnitYear,
	NSCalendarUnitMonth,
	NSCalendarUnitDay,
	NSCalendarUnitHour,
	NSCalendarUnitMinute,
	NSCalendarUnitSecond,
	NSCalendarUnitWeekday,
	NSCalendarUnitWeekdayOrdinal,
	NSCalendarUnitQuarter,
	NSCalendarUnitWeekOfMonth,
	NSCalendarUnitWeekOfYear,
	NSCalendarUnitYearForWeekOfYear,
	NSCalendarUnitNanosecond,
	NSCalendarUnitCalendar,
	NSCalendarUnitTimeZone,
	NSEraCalendarUnit,
	NSYearCalendarUnit,
	NSMonthCalendarUnit,
	NSDayCalendarUnit,
	NSHourCalendarUnit,
	NSMinuteCalendarUnit,
	NSSecondCalendarUnit,
	NSWeekCalendarUnit,
	NSWeekdayCalendarUnit,
	NSWeekdayOrdinalCalendarUnit,
	NSQuarterCalendarUnit,
	NSWeekOfMonthCalendarUnit,
	NSWeekOfYearCalendarUnit,
	NSYearForWeekOfYearCalendarUnit,
	NSCalendarCalendarUnit,
	NSTimeZoneCalendarUnit
}
declare enum NSCalendarOptions {
	NSCalendarWrapComponents,
	NSCalendarMatchStrictly,
	NSCalendarSearchBackwards,
	NSCalendarMatchPreviousTimePreservingSmallerUnits,
	NSCalendarMatchNextTimePreservingSmallerUnits,
	NSCalendarMatchNextTime,
	NSCalendarMatchFirst,
	NSCalendarMatchLast
}
declare enum NSStringCompareOptions {
	NSCaseInsensitiveSearch,
	NSLiteralSearch,
	NSBackwardsSearch,
	NSAnchoredSearch,
	NSNumericSearch,
	NSDiacriticInsensitiveSearch,
	NSWidthInsensitiveSearch,
	NSForcedOrderingSearch,
	NSRegularExpressionSearch
}
declare enum NSStringEncodingConversionOptions {
	NSStringEncodingConversionAllowLossy,
	NSStringEncodingConversionExternalRepresentation
}
declare enum NSStringEnumerationOptions {
	NSStringEnumerationByLines,
	NSStringEnumerationByParagraphs,
	NSStringEnumerationByComposedCharacterSequences,
	NSStringEnumerationByWords,
	NSStringEnumerationBySentences,
	NSStringEnumerationReverse,
	NSStringEnumerationSubstringNotRequired,
	NSStringEnumerationLocalized
}
declare enum NSDataReadingOptions {
	NSDataReadingMappedIfSafe,
	NSDataReadingUncached,
	NSDataReadingMappedAlways,
	NSDataReadingMapped,
	NSMappedRead,
	NSUncachedRead
}
declare enum NSDataWritingOptions {
	NSDataWritingAtomic,
	NSDataWritingWithoutOverwriting,
	NSDataWritingFileProtectionNone,
	NSDataWritingFileProtectionComplete,
	NSDataWritingFileProtectionCompleteUnlessOpen,
	NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication,
	NSDataWritingFileProtectionMask,
	NSAtomicWrite
}
declare enum NSDataSearchOptions {
	NSDataSearchBackwards,
	NSDataSearchAnchored
}
declare enum NSDataBase64EncodingOptions {
	NSDataBase64Encoding64CharacterLineLength,
	NSDataBase64Encoding76CharacterLineLength,
	NSDataBase64EncodingEndLineWithCarriageReturn,
	NSDataBase64EncodingEndLineWithLineFeed
}
declare enum NSDataBase64DecodingOptions {
	NSDataBase64DecodingIgnoreUnknownCharacters
}
declare enum NSFormattingContext {
	NSFormattingContextUnknown,
	NSFormattingContextDynamic,
	NSFormattingContextStandalone,
	NSFormattingContextListItem,
	NSFormattingContextBeginningOfSentence,
	NSFormattingContextMiddleOfSentence
}
declare enum NSFormattingUnitStyle {
	NSFormattingUnitStyleShort,
	NSFormattingUnitStyleMedium,
	NSFormattingUnitStyleLong
}
declare enum NSDateFormatterStyle {
	NSDateFormatterNoStyle,
	NSDateFormatterShortStyle,
	NSDateFormatterMediumStyle,
	NSDateFormatterLongStyle,
	NSDateFormatterFullStyle
}
declare enum NSDateFormatterBehavior {
	NSDateFormatterBehaviorDefault,
	NSDateFormatterBehavior10_4
}
declare enum NSDateIntervalFormatterStyle {
	NSDateIntervalFormatterNoStyle,
	NSDateIntervalFormatterShortStyle,
	NSDateIntervalFormatterMediumStyle,
	NSDateIntervalFormatterLongStyle,
	NSDateIntervalFormatterFullStyle
}
declare enum NSMassFormatterUnit {
	NSMassFormatterUnitGram,
	NSMassFormatterUnitKilogram,
	NSMassFormatterUnitOunce,
	NSMassFormatterUnitPound,
	NSMassFormatterUnitStone
}
declare enum NSLengthFormatterUnit {
	NSLengthFormatterUnitMillimeter,
	NSLengthFormatterUnitCentimeter,
	NSLengthFormatterUnitMeter,
	NSLengthFormatterUnitKilometer,
	NSLengthFormatterUnitInch,
	NSLengthFormatterUnitFoot,
	NSLengthFormatterUnitYard,
	NSLengthFormatterUnitMile
}
declare enum NSEnergyFormatterUnit {
	NSEnergyFormatterUnitJoule,
	NSEnergyFormatterUnitKilojoule,
	NSEnergyFormatterUnitCalorie,
	NSEnergyFormatterUnitKilocalorie
}
declare enum NSRoundingMode {
	NSRoundPlain,
	NSRoundDown,
	NSRoundUp,
	NSRoundBankers
}
declare enum NSCalculationError {
	NSCalculationNoError,
	NSCalculationLossOfPrecision,
	NSCalculationUnderflow,
	NSCalculationOverflow,
	NSCalculationDivideByZero
}
declare enum NSSearchPathDirectory {
	NSApplicationDirectory,
	NSDemoApplicationDirectory,
	NSDeveloperApplicationDirectory,
	NSAdminApplicationDirectory,
	NSLibraryDirectory,
	NSDeveloperDirectory,
	NSUserDirectory,
	NSDocumentationDirectory,
	NSDocumentDirectory,
	NSCoreServiceDirectory,
	NSAutosavedInformationDirectory,
	NSDesktopDirectory,
	NSCachesDirectory,
	NSApplicationSupportDirectory,
	NSDownloadsDirectory,
	NSInputMethodsDirectory,
	NSMoviesDirectory,
	NSMusicDirectory,
	NSPicturesDirectory,
	NSPrinterDescriptionDirectory,
	NSSharedPublicDirectory,
	NSPreferencePanesDirectory,
	NSItemReplacementDirectory,
	NSAllApplicationsDirectory,
	NSAllLibrariesDirectory
}
declare enum NSSearchPathDomainMask {
	NSUserDomainMask,
	NSLocalDomainMask,
	NSNetworkDomainMask,
	NSSystemDomainMask,
	NSAllDomainsMask
}
declare enum NSVolumeEnumerationOptions {
	NSVolumeEnumerationSkipHiddenVolumes,
	NSVolumeEnumerationProduceFileReferenceURLs
}
declare enum NSDirectoryEnumerationOptions {
	NSDirectoryEnumerationSkipsSubdirectoryDescendants,
	NSDirectoryEnumerationSkipsPackageDescendants,
	NSDirectoryEnumerationSkipsHiddenFiles
}
declare enum NSFileManagerItemReplacementOptions {
	NSFileManagerItemReplacementUsingNewMetadataOnly,
	NSFileManagerItemReplacementWithoutDeletingBackupItem
}
declare enum NSURLRelationship {
	NSURLRelationshipContains,
	NSURLRelationshipSame,
	NSURLRelationshipOther
}
declare enum NSHTTPCookieAcceptPolicy {
	NSHTTPCookieAcceptPolicyAlways,
	NSHTTPCookieAcceptPolicyNever,
	NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain
}
declare enum NSJSONReadingOptions {
	NSJSONReadingMutableContainers,
	NSJSONReadingMutableLeaves,
	NSJSONReadingAllowFragments
}
declare enum NSJSONWritingOptions {
	NSJSONWritingPrettyPrinted
}
declare enum NSKeyValueObservingOptions {
	NSKeyValueObservingOptionNew,
	NSKeyValueObservingOptionOld,
	NSKeyValueObservingOptionInitial,
	NSKeyValueObservingOptionPrior
}
declare enum NSKeyValueChange {
	NSKeyValueChangeSetting,
	NSKeyValueChangeInsertion,
	NSKeyValueChangeRemoval,
	NSKeyValueChangeReplacement
}
declare enum NSKeyValueSetMutationKind {
	NSKeyValueUnionSetMutation,
	NSKeyValueMinusSetMutation,
	NSKeyValueIntersectSetMutation,
	NSKeyValueSetSetMutation
}
declare enum NSPropertyListMutabilityOptions {
	NSPropertyListImmutable,
	NSPropertyListMutableContainers,
	NSPropertyListMutableContainersAndLeaves
}
declare enum NSPropertyListFormat {
	NSPropertyListOpenStepFormat,
	NSPropertyListXMLFormat_v1_0,
	NSPropertyListBinaryFormat_v1_0
}
declare enum NSLocaleLanguageDirection {
	NSLocaleLanguageDirectionUnknown,
	NSLocaleLanguageDirectionLeftToRight,
	NSLocaleLanguageDirectionRightToLeft,
	NSLocaleLanguageDirectionTopToBottom,
	NSLocaleLanguageDirectionBottomToTop
}
declare enum NSPostingStyle {
	NSPostWhenIdle,
	NSPostASAP,
	NSPostNow
}
declare enum NSNotificationCoalescing {
	NSNotificationNoCoalescing,
	NSNotificationCoalescingOnName,
	NSNotificationCoalescingOnSender
}
declare enum NSNumberFormatterBehavior {
	NSNumberFormatterBehaviorDefault,
	NSNumberFormatterBehavior10_4
}
declare enum NSNumberFormatterStyle {
	NSNumberFormatterNoStyle,
	NSNumberFormatterDecimalStyle,
	NSNumberFormatterCurrencyStyle,
	NSNumberFormatterPercentStyle,
	NSNumberFormatterScientificStyle,
	NSNumberFormatterSpellOutStyle
}
declare enum NSNumberFormatterPadPosition {
	NSNumberFormatterPadBeforePrefix,
	NSNumberFormatterPadAfterPrefix,
	NSNumberFormatterPadBeforeSuffix,
	NSNumberFormatterPadAfterSuffix
}
declare enum NSNumberFormatterRoundingMode {
	NSNumberFormatterRoundCeiling,
	NSNumberFormatterRoundFloor,
	NSNumberFormatterRoundDown,
	NSNumberFormatterRoundUp,
	NSNumberFormatterRoundHalfEven,
	NSNumberFormatterRoundHalfDown,
	NSNumberFormatterRoundHalfUp
}
declare enum NSOperationQueuePriority {
	NSOperationQueuePriorityVeryLow,
	NSOperationQueuePriorityLow,
	NSOperationQueuePriorityNormal,
	NSOperationQueuePriorityHigh,
	NSOperationQueuePriorityVeryHigh
}
declare enum NSActivityOptions {
	NSActivityIdleDisplaySleepDisabled,
	NSActivityIdleSystemSleepDisabled,
	NSActivitySuddenTerminationDisabled,
	NSActivityAutomaticTerminationDisabled,
	NSActivityUserInitiated,
	NSActivityUserInitiatedAllowingIdleSystemSleep,
	NSActivityBackground,
	NSActivityLatencyCritical
}
declare enum NSTextCheckingType {
	NSTextCheckingTypeOrthography,
	NSTextCheckingTypeSpelling,
	NSTextCheckingTypeGrammar,
	NSTextCheckingTypeDate,
	NSTextCheckingTypeAddress,
	NSTextCheckingTypeLink,
	NSTextCheckingTypeQuote,
	NSTextCheckingTypeDash,
	NSTextCheckingTypeReplacement,
	NSTextCheckingTypeCorrection,
	NSTextCheckingTypeRegularExpression,
	NSTextCheckingTypePhoneNumber,
	NSTextCheckingTypeTransitInformation
}
declare enum NSRegularExpressionOptions {
	NSRegularExpressionCaseInsensitive,
	NSRegularExpressionAllowCommentsAndWhitespace,
	NSRegularExpressionIgnoreMetacharacters,
	NSRegularExpressionDotMatchesLineSeparators,
	NSRegularExpressionAnchorsMatchLines,
	NSRegularExpressionUseUnixLineSeparators,
	NSRegularExpressionUseUnicodeWordBoundaries
}
declare enum NSMatchingOptions {
	NSMatchingReportProgress,
	NSMatchingReportCompletion,
	NSMatchingAnchored,
	NSMatchingWithTransparentBounds,
	NSMatchingWithoutAnchoringBounds
}
declare enum NSMatchingFlags {
	NSMatchingProgress,
	NSMatchingCompleted,
	NSMatchingHitEnd,
	NSMatchingRequiredEnd,
	NSMatchingInternalError
}
declare enum NSStreamStatus {
	NSStreamStatusNotOpen,
	NSStreamStatusOpening,
	NSStreamStatusOpen,
	NSStreamStatusReading,
	NSStreamStatusWriting,
	NSStreamStatusAtEnd,
	NSStreamStatusClosed,
	NSStreamStatusError
}
declare enum NSStreamEvent {
	NSStreamEventNone,
	NSStreamEventOpenCompleted,
	NSStreamEventHasBytesAvailable,
	NSStreamEventHasSpaceAvailable,
	NSStreamEventErrorOccurred,
	NSStreamEventEndEncountered
}
declare enum NSTimeZoneNameStyle {
	NSTimeZoneNameStyleStandard,
	NSTimeZoneNameStyleShortStandard,
	NSTimeZoneNameStyleDaylightSaving,
	NSTimeZoneNameStyleShortDaylightSaving,
	NSTimeZoneNameStyleGeneric,
	NSTimeZoneNameStyleShortGeneric
}
declare enum NSURLBookmarkCreationOptions {
	NSURLBookmarkCreationPreferFileIDResolution,
	NSURLBookmarkCreationMinimalBookmark,
	NSURLBookmarkCreationSuitableForBookmarkFile
}
declare enum NSURLBookmarkResolutionOptions {
	NSURLBookmarkResolutionWithoutUI,
	NSURLBookmarkResolutionWithoutMounting
}
declare enum NSURLCacheStoragePolicy {
	NSURLCacheStorageAllowed,
	NSURLCacheStorageAllowedInMemoryOnly,
	NSURLCacheStorageNotAllowed
}
declare enum NSURLCredentialPersistence {
	NSURLCredentialPersistenceNone,
	NSURLCredentialPersistenceForSession,
	NSURLCredentialPersistencePermanent,
	NSURLCredentialPersistenceSynchronizable
}
declare enum NSURLRequestCachePolicy {
	NSURLRequestUseProtocolCachePolicy,
	NSURLRequestReloadIgnoringLocalCacheData,
	NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
	NSURLRequestReloadIgnoringCacheData,
	NSURLRequestReturnCacheDataElseLoad,
	NSURLRequestReturnCacheDataDontLoad,
	NSURLRequestReloadRevalidatingCacheData
}
declare enum NSURLRequestNetworkServiceType {
	NSURLNetworkServiceTypeDefault,
	NSURLNetworkServiceTypeVoIP,
	NSURLNetworkServiceTypeVideo,
	NSURLNetworkServiceTypeBackground,
	NSURLNetworkServiceTypeVoice
}
declare enum NSXMLParserExternalEntityResolvingPolicy {
	NSXMLParserResolveExternalEntitiesNever,
	NSXMLParserResolveExternalEntitiesNoNetwork,
	NSXMLParserResolveExternalEntitiesSameOriginOnly,
	NSXMLParserResolveExternalEntitiesAlways
}
declare enum NSXMLParserError {
	NSXMLParserInternalError,
	NSXMLParserOutOfMemoryError,
	NSXMLParserDocumentStartError,
	NSXMLParserEmptyDocumentError,
	NSXMLParserPrematureDocumentEndError,
	NSXMLParserInvalidHexCharacterRefError,
	NSXMLParserInvalidDecimalCharacterRefError,
	NSXMLParserInvalidCharacterRefError,
	NSXMLParserInvalidCharacterError,
	NSXMLParserCharacterRefAtEOFError,
	NSXMLParserCharacterRefInPrologError,
	NSXMLParserCharacterRefInEpilogError,
	NSXMLParserCharacterRefInDTDError,
	NSXMLParserEntityRefAtEOFError,
	NSXMLParserEntityRefInPrologError,
	NSXMLParserEntityRefInEpilogError,
	NSXMLParserEntityRefInDTDError,
	NSXMLParserParsedEntityRefAtEOFError,
	NSXMLParserParsedEntityRefInPrologError,
	NSXMLParserParsedEntityRefInEpilogError,
	NSXMLParserParsedEntityRefInInternalSubsetError,
	NSXMLParserEntityReferenceWithoutNameError,
	NSXMLParserEntityReferenceMissingSemiError,
	NSXMLParserParsedEntityRefNoNameError,
	NSXMLParserParsedEntityRefMissingSemiError,
	NSXMLParserUndeclaredEntityError,
	NSXMLParserUnparsedEntityError,
	NSXMLParserEntityIsExternalError,
	NSXMLParserEntityIsParameterError,
	NSXMLParserUnknownEncodingError,
	NSXMLParserEncodingNotSupportedError,
	NSXMLParserStringNotStartedError,
	NSXMLParserStringNotClosedError,
	NSXMLParserNamespaceDeclarationError,
	NSXMLParserEntityNotStartedError,
	NSXMLParserEntityNotFinishedError,
	NSXMLParserLessThanSymbolInAttributeError,
	NSXMLParserAttributeNotStartedError,
	NSXMLParserAttributeNotFinishedError,
	NSXMLParserAttributeHasNoValueError,
	NSXMLParserAttributeRedefinedError,
	NSXMLParserLiteralNotStartedError,
	NSXMLParserLiteralNotFinishedError,
	NSXMLParserCommentNotFinishedError,
	NSXMLParserProcessingInstructionNotStartedError,
	NSXMLParserProcessingInstructionNotFinishedError,
	NSXMLParserNotationNotStartedError,
	NSXMLParserNotationNotFinishedError,
	NSXMLParserAttributeListNotStartedError,
	NSXMLParserAttributeListNotFinishedError,
	NSXMLParserMixedContentDeclNotStartedError,
	NSXMLParserMixedContentDeclNotFinishedError,
	NSXMLParserElementContentDeclNotStartedError,
	NSXMLParserElementContentDeclNotFinishedError,
	NSXMLParserXMLDeclNotStartedError,
	NSXMLParserXMLDeclNotFinishedError,
	NSXMLParserConditionalSectionNotStartedError,
	NSXMLParserConditionalSectionNotFinishedError,
	NSXMLParserExternalSubsetNotFinishedError,
	NSXMLParserDOCTYPEDeclNotFinishedError,
	NSXMLParserMisplacedCDATAEndStringError,
	NSXMLParserCDATANotFinishedError,
	NSXMLParserMisplacedXMLDeclarationError,
	NSXMLParserSpaceRequiredError,
	NSXMLParserSeparatorRequiredError,
	NSXMLParserNMTOKENRequiredError,
	NSXMLParserNAMERequiredError,
	NSXMLParserPCDATARequiredError,
	NSXMLParserURIRequiredError,
	NSXMLParserPublicIdentifierRequiredError,
	NSXMLParserLTRequiredError,
	NSXMLParserGTRequiredError,
	NSXMLParserLTSlashRequiredError,
	NSXMLParserEqualExpectedError,
	NSXMLParserTagNameMismatchError,
	NSXMLParserUnfinishedTagError,
	NSXMLParserStandaloneValueError,
	NSXMLParserInvalidEncodingNameError,
	NSXMLParserCommentContainsDoubleHyphenError,
	NSXMLParserInvalidEncodingError,
	NSXMLParserExternalStandaloneEntityError,
	NSXMLParserInvalidConditionalSectionError,
	NSXMLParserEntityValueRequiredError,
	NSXMLParserNotWellBalancedError,
	NSXMLParserExtraContentError,
	NSXMLParserInvalidCharacterInEntityError,
	NSXMLParserParsedEntityRefInInternalError,
	NSXMLParserEntityRefLoopError,
	NSXMLParserEntityBoundaryError,
	NSXMLParserInvalidURIError,
	NSXMLParserURIFragmentError,
	NSXMLParserNoDTDError,
	NSXMLParserDelegateAbortedParseError
}
declare enum NSAttributedStringEnumerationOptions {
	NSAttributedStringEnumerationReverse,
	NSAttributedStringEnumerationLongestEffectiveRangeNotRequired
}
declare enum NSByteCountFormatterUnits {
	NSByteCountFormatterUseDefault,
	NSByteCountFormatterUseBytes,
	NSByteCountFormatterUseKB,
	NSByteCountFormatterUseMB,
	NSByteCountFormatterUseGB,
	NSByteCountFormatterUseTB,
	NSByteCountFormatterUsePB,
	NSByteCountFormatterUseEB,
	NSByteCountFormatterUseZB,
	NSByteCountFormatterUseYBOrHigher,
	NSByteCountFormatterUseAll
}
declare enum NSByteCountFormatterCountStyle {
	NSByteCountFormatterCountStyleFile,
	NSByteCountFormatterCountStyleMemory,
	NSByteCountFormatterCountStyleDecimal,
	NSByteCountFormatterCountStyleBinary
}
declare enum NSComparisonPredicateOptions {
	NSCaseInsensitivePredicateOption,
	NSDiacriticInsensitivePredicateOption,
	NSNormalizedPredicateOption
}
declare enum NSComparisonPredicateModifier {
	NSDirectPredicateModifier,
	NSAllPredicateModifier,
	NSAnyPredicateModifier
}
declare enum NSPredicateOperatorType {
	NSLessThanPredicateOperatorType,
	NSLessThanOrEqualToPredicateOperatorType,
	NSGreaterThanPredicateOperatorType,
	NSGreaterThanOrEqualToPredicateOperatorType,
	NSEqualToPredicateOperatorType,
	NSNotEqualToPredicateOperatorType,
	NSMatchesPredicateOperatorType,
	NSLikePredicateOperatorType,
	NSBeginsWithPredicateOperatorType,
	NSEndsWithPredicateOperatorType,
	NSInPredicateOperatorType,
	NSCustomSelectorPredicateOperatorType,
	NSContainsPredicateOperatorType,
	NSBetweenPredicateOperatorType
}
declare enum NSCompoundPredicateType {
	NSNotPredicateType,
	NSAndPredicateType,
	NSOrPredicateType
}
declare enum NSDateComponentsFormatterUnitsStyle {
	NSDateComponentsFormatterUnitsStylePositional,
	NSDateComponentsFormatterUnitsStyleAbbreviated,
	NSDateComponentsFormatterUnitsStyleShort,
	NSDateComponentsFormatterUnitsStyleFull,
	NSDateComponentsFormatterUnitsStyleSpellOut
}
declare enum NSDateComponentsFormatterZeroFormattingBehavior {
	NSDateComponentsFormatterZeroFormattingBehaviorNone,
	NSDateComponentsFormatterZeroFormattingBehaviorDefault,
	NSDateComponentsFormatterZeroFormattingBehaviorDropLeading,
	NSDateComponentsFormatterZeroFormattingBehaviorDropMiddle,
	NSDateComponentsFormatterZeroFormattingBehaviorDropTrailing,
	NSDateComponentsFormatterZeroFormattingBehaviorDropAll,
	NSDateComponentsFormatterZeroFormattingBehaviorPad
}
declare enum NSExpressionType {
	NSConstantValueExpressionType,
	NSEvaluatedObjectExpressionType,
	NSVariableExpressionType,
	NSKeyPathExpressionType,
	NSFunctionExpressionType,
	NSUnionSetExpressionType,
	NSIntersectSetExpressionType,
	NSMinusSetExpressionType,
	NSSubqueryExpressionType,
	NSAggregateExpressionType,
	NSAnyKeyExpressionType,
	NSBlockExpressionType
}
declare enum NSItemProviderErrorCode {
	NSItemProviderUnknownError,
	NSItemProviderItemUnavailableError,
	NSItemProviderUnexpectedValueClassError
}
declare enum NSFileCoordinatorReadingOptions {
	NSFileCoordinatorReadingWithoutChanges,
	NSFileCoordinatorReadingResolvesSymbolicLink,
	NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly,
	NSFileCoordinatorReadingForUploading
}
declare enum NSFileCoordinatorWritingOptions {
	NSFileCoordinatorWritingForDeleting,
	NSFileCoordinatorWritingForMoving,
	NSFileCoordinatorWritingForMerging,
	NSFileCoordinatorWritingForReplacing,
	NSFileCoordinatorWritingContentIndependentMetadataOnly
}
declare enum NSFileVersionAddingOptions {
	NSFileVersionAddingByMoving
}
declare enum NSFileVersionReplacingOptions {
	NSFileVersionReplacingByMoving
}
declare enum NSFileWrapperReadingOptions {
	NSFileWrapperReadingImmediate,
	NSFileWrapperReadingWithoutMapping
}
declare enum NSFileWrapperWritingOptions {
	NSFileWrapperWritingAtomic,
	NSFileWrapperWritingWithNameUpdating
}
declare enum NSLinguisticTaggerOptions {
	NSLinguisticTaggerOmitWords,
	NSLinguisticTaggerOmitPunctuation,
	NSLinguisticTaggerOmitWhitespace,
	NSLinguisticTaggerOmitOther,
	NSLinguisticTaggerJoinNames
}
declare enum NSNetServicesError {
	NSNetServicesUnknownError,
	NSNetServicesCollisionError,
	NSNetServicesNotFoundError,
	NSNetServicesActivityInProgress,
	NSNetServicesBadArgumentError,
	NSNetServicesCancelledError,
	NSNetServicesInvalidError,
	NSNetServicesTimeoutError
}
declare enum NSNetServiceOptions {
	NSNetServiceNoAutoRename,
	NSNetServiceListenForConnections
}
declare enum NSURLSessionTaskState {
	NSURLSessionTaskStateRunning,
	NSURLSessionTaskStateSuspended,
	NSURLSessionTaskStateCanceling,
	NSURLSessionTaskStateCompleted
}
declare enum NSURLSessionAuthChallengeDisposition {
	NSURLSessionAuthChallengeUseCredential,
	NSURLSessionAuthChallengePerformDefaultHandling,
	NSURLSessionAuthChallengeCancelAuthenticationChallenge,
	NSURLSessionAuthChallengeRejectProtectionSpace
}
declare enum NSURLSessionResponseDisposition {
	NSURLSessionResponseCancel,
	NSURLSessionResponseAllow,
	NSURLSessionResponseBecomeDownload
}
declare enum SecAccessControlCreateFlags {
	kSecAccessControlUserPresence
}
declare enum SSLProtocol {
	kSSLProtocolUnknown,
	kSSLProtocol3,
	kTLSProtocol1,
	kTLSProtocol11,
	kTLSProtocol12,
	kDTLSProtocol1,
	kSSLProtocol2,
	kSSLProtocol3Only,
	kTLSProtocol1Only,
	kSSLProtocolAll
}
declare enum SSLSessionOption {
	kSSLSessionOptionBreakOnServerAuth,
	kSSLSessionOptionBreakOnCertRequested,
	kSSLSessionOptionBreakOnClientAuth,
	kSSLSessionOptionFalseStart,
	kSSLSessionOptionSendOneByteRecord
}
declare enum SSLSessionState {
	kSSLIdle,
	kSSLHandshake,
	kSSLConnected,
	kSSLClosed,
	kSSLAborted
}
declare enum SSLClientCertificateState {
	kSSLClientCertNone,
	kSSLClientCertRequested,
	kSSLClientCertSent,
	kSSLClientCertRejected
}
declare enum SSLProtocolSide {
	kSSLServerSide,
	kSSLClientSide
}
declare enum SSLConnectionType {
	kSSLStreamType,
	kSSLDatagramType
}
declare enum SSLAuthenticate {
	kNeverAuthenticate,
	kAlwaysAuthenticate,
	kTryAuthenticate
}
declare enum CFNetworkErrors {
	kCFHostErrorHostNotFound,
	kCFHostErrorUnknown,
	kCFSOCKSErrorUnknownClientVersion,
	kCFSOCKSErrorUnsupportedServerVersion,
	kCFSOCKS4ErrorRequestFailed,
	kCFSOCKS4ErrorIdentdFailed,
	kCFSOCKS4ErrorIdConflict,
	kCFSOCKS4ErrorUnknownStatusCode,
	kCFSOCKS5ErrorBadState,
	kCFSOCKS5ErrorBadResponseAddr,
	kCFSOCKS5ErrorBadCredentials,
	kCFSOCKS5ErrorUnsupportedNegotiationMethod,
	kCFSOCKS5ErrorNoAcceptableMethod,
	kCFFTPErrorUnexpectedStatusCode,
	kCFErrorHTTPAuthenticationTypeUnsupported,
	kCFErrorHTTPBadCredentials,
	kCFErrorHTTPConnectionLost,
	kCFErrorHTTPParseFailure,
	kCFErrorHTTPRedirectionLoopDetected,
	kCFErrorHTTPBadURL,
	kCFErrorHTTPProxyConnectionFailure,
	kCFErrorHTTPBadProxyCredentials,
	kCFErrorPACFileError,
	kCFErrorPACFileAuth,
	kCFErrorHTTPSProxyConnectionFailure,
	kCFStreamErrorHTTPSProxyFailureUnexpectedResponseToCONNECTMethod,
	kCFURLErrorBackgroundSessionInUseByAnotherProcess,
	kCFURLErrorBackgroundSessionWasDisconnected,
	kCFURLErrorUnknown,
	kCFURLErrorCancelled,
	kCFURLErrorBadURL,
	kCFURLErrorTimedOut,
	kCFURLErrorUnsupportedURL,
	kCFURLErrorCannotFindHost,
	kCFURLErrorCannotConnectToHost,
	kCFURLErrorNetworkConnectionLost,
	kCFURLErrorDNSLookupFailed,
	kCFURLErrorHTTPTooManyRedirects,
	kCFURLErrorResourceUnavailable,
	kCFURLErrorNotConnectedToInternet,
	kCFURLErrorRedirectToNonExistentLocation,
	kCFURLErrorBadServerResponse,
	kCFURLErrorUserCancelledAuthentication,
	kCFURLErrorUserAuthenticationRequired,
	kCFURLErrorZeroByteResource,
	kCFURLErrorCannotDecodeRawData,
	kCFURLErrorCannotDecodeContentData,
	kCFURLErrorCannotParseResponse,
	kCFURLErrorInternationalRoamingOff,
	kCFURLErrorCallIsActive,
	kCFURLErrorDataNotAllowed,
	kCFURLErrorRequestBodyStreamExhausted,
	kCFURLErrorFileDoesNotExist,
	kCFURLErrorFileIsDirectory,
	kCFURLErrorNoPermissionsToReadFile,
	kCFURLErrorDataLengthExceedsMaximum,
	kCFURLErrorSecureConnectionFailed,
	kCFURLErrorServerCertificateHasBadDate,
	kCFURLErrorServerCertificateUntrusted,
	kCFURLErrorServerCertificateHasUnknownRoot,
	kCFURLErrorServerCertificateNotYetValid,
	kCFURLErrorClientCertificateRejected,
	kCFURLErrorClientCertificateRequired,
	kCFURLErrorCannotLoadFromNetwork,
	kCFURLErrorCannotCreateFile,
	kCFURLErrorCannotOpenFile,
	kCFURLErrorCannotCloseFile,
	kCFURLErrorCannotWriteToFile,
	kCFURLErrorCannotRemoveFile,
	kCFURLErrorCannotMoveFile,
	kCFURLErrorDownloadDecodingFailedMidStream,
	kCFURLErrorDownloadDecodingFailedToComplete,
	kCFHTTPCookieCannotParseCookieFile,
	kCFNetServiceErrorUnknown,
	kCFNetServiceErrorCollision,
	kCFNetServiceErrorNotFound,
	kCFNetServiceErrorInProgress,
	kCFNetServiceErrorBadArgument,
	kCFNetServiceErrorCancel,
	kCFNetServiceErrorInvalid,
	kCFNetServiceErrorTimeout,
	kCFNetServiceErrorDNSServiceFailure
}
declare enum CFHostInfoType {
	kCFHostAddresses,
	kCFHostNames,
	kCFHostReachability
}
declare enum CFNetServicesError {
	kCFNetServicesErrorUnknown,
	kCFNetServicesErrorCollision,
	kCFNetServicesErrorNotFound,
	kCFNetServicesErrorInProgress,
	kCFNetServicesErrorBadArgument,
	kCFNetServicesErrorCancel,
	kCFNetServicesErrorInvalid,
	kCFNetServicesErrorTimeout
}
declare enum CFNetServiceMonitorType {
	kCFNetServiceMonitorTXT
}
declare enum CFNetServiceRegisterFlags {
	kCFNetServiceFlagNoAutoRename
}
declare enum CFNetServiceBrowserFlags {
	kCFNetServiceFlagMoreComing,
	kCFNetServiceFlagIsDomain,
	kCFNetServiceFlagIsDefault,
	kCFNetServiceFlagIsRegistrationDomain,
	kCFNetServiceFlagRemove
}
declare enum CFStreamErrorHTTP {
	kCFStreamErrorHTTPParseFailure,
	kCFStreamErrorHTTPRedirectionLoop,
	kCFStreamErrorHTTPBadURL
}
declare enum CFStreamErrorHTTPAuthentication {
	kCFStreamErrorHTTPAuthenticationTypeUnsupported,
	kCFStreamErrorHTTPAuthenticationBadUserName,
	kCFStreamErrorHTTPAuthenticationBadPassword
}
declare enum CFNetDiagnosticStatusValues {
	kCFNetDiagnosticNoErr,
	kCFNetDiagnosticErr,
	kCFNetDiagnosticConnectionUp,
	kCFNetDiagnosticConnectionIndeterminate,
	kCFNetDiagnosticConnectionDown
}
declare enum ACAccountCredentialRenewResult {
	ACAccountCredentialRenewResultRenewed,
	ACAccountCredentialRenewResultRejected,
	ACAccountCredentialRenewResultFailed
}
declare enum ACErrorCode {
	ACErrorUnknown,
	ACErrorAccountMissingRequiredProperty,
	ACErrorAccountAuthenticationFailed,
	ACErrorAccountTypeInvalid,
	ACErrorAccountAlreadyExists,
	ACErrorAccountNotFound,
	ACErrorPermissionDenied,
	ACErrorAccessInfoInvalid,
	ACErrorClientPermissionDenied,
	ACErrorAccessDeniedByProtectionPolicy,
	ACErrorCredentialNotFound,
	ACErrorFetchCredentialFailed,
	ACErrorStoreCredentialFailed,
	ACErrorRemoveCredentialFailed,
	ACErrorUpdatingNonexistentAccount,
	ACErrorInvalidClientBundleID,
	ACErrorDeniedByPlugin,
	ACErrorCoreDataSaveFailed,
	ACErrorFailedSerializingAccountInfo,
	ACErrorInvalidCommand,
	ACErrorMissingMessageID
}
declare enum ABAuthorizationStatus {
	kABAuthorizationStatusNotDetermined,
	kABAuthorizationStatusRestricted,
	kABAuthorizationStatusDenied,
	kABAuthorizationStatusAuthorized
}
declare enum ABPersonImageFormat {
	kABPersonImageFormatThumbnail,
	kABPersonImageFormatOriginalSize
}
declare enum UIEventType {
	UIEventTypeTouches,
	UIEventTypeMotion,
	UIEventTypeRemoteControl
}
declare enum UIEventSubtype {
	UIEventSubtypeNone,
	UIEventSubtypeMotionShake,
	UIEventSubtypeRemoteControlPlay,
	UIEventSubtypeRemoteControlPause,
	UIEventSubtypeRemoteControlStop,
	UIEventSubtypeRemoteControlTogglePlayPause,
	UIEventSubtypeRemoteControlNextTrack,
	UIEventSubtypeRemoteControlPreviousTrack,
	UIEventSubtypeRemoteControlBeginSeekingBackward,
	UIEventSubtypeRemoteControlEndSeekingBackward,
	UIEventSubtypeRemoteControlBeginSeekingForward,
	UIEventSubtypeRemoteControlEndSeekingForward
}
declare enum UIKeyModifierFlags {
	UIKeyModifierAlphaShift,
	UIKeyModifierShift,
	UIKeyModifierControl,
	UIKeyModifierAlternate,
	UIKeyModifierCommand,
	UIKeyModifierNumericPad
}
declare enum UIFontDescriptorSymbolicTraits {
	UIFontDescriptorTraitItalic,
	UIFontDescriptorTraitBold,
	UIFontDescriptorTraitExpanded,
	UIFontDescriptorTraitCondensed,
	UIFontDescriptorTraitMonoSpace,
	UIFontDescriptorTraitVertical,
	UIFontDescriptorTraitUIOptimized,
	UIFontDescriptorTraitTightLeading,
	UIFontDescriptorTraitLooseLeading,
	UIFontDescriptorClassMask,
	UIFontDescriptorClassUnknown,
	UIFontDescriptorClassOldStyleSerifs,
	UIFontDescriptorClassTransitionalSerifs,
	UIFontDescriptorClassModernSerifs,
	UIFontDescriptorClassClarendonSerifs,
	UIFontDescriptorClassSlabSerifs,
	UIFontDescriptorClassFreeformSerifs,
	UIFontDescriptorClassSansSerif,
	UIFontDescriptorClassOrnamentals,
	UIFontDescriptorClassScripts,
	UIFontDescriptorClassSymbolic
}
declare enum UIBarStyle {
	UIBarStyleDefault,
	UIBarStyleBlack,
	UIBarStyleBlackOpaque,
	UIBarStyleBlackTranslucent
}
declare enum UIUserInterfaceSizeClass {
	UIUserInterfaceSizeClassUnspecified,
	UIUserInterfaceSizeClassCompact,
	UIUserInterfaceSizeClassRegular
}
declare enum UIDeviceOrientation {
	UIDeviceOrientationUnknown,
	UIDeviceOrientationPortrait,
	UIDeviceOrientationPortraitUpsideDown,
	UIDeviceOrientationLandscapeLeft,
	UIDeviceOrientationLandscapeRight,
	UIDeviceOrientationFaceUp,
	UIDeviceOrientationFaceDown
}
declare enum UIDeviceBatteryState {
	UIDeviceBatteryStateUnknown,
	UIDeviceBatteryStateUnplugged,
	UIDeviceBatteryStateCharging,
	UIDeviceBatteryStateFull
}
declare enum UIUserInterfaceIdiom {
	UIUserInterfaceIdiomUnspecified,
	UIUserInterfaceIdiomPhone,
	UIUserInterfaceIdiomPad
}
declare enum UIRectEdge {
	UIRectEdgeNone,
	UIRectEdgeTop,
	UIRectEdgeLeft,
	UIRectEdgeBottom,
	UIRectEdgeRight,
	UIRectEdgeAll
}
declare enum NSLayoutRelation {
	NSLayoutRelationLessThanOrEqual,
	NSLayoutRelationEqual,
	NSLayoutRelationGreaterThanOrEqual
}
declare enum NSLayoutAttribute {
	NSLayoutAttributeLeft,
	NSLayoutAttributeRight,
	NSLayoutAttributeTop,
	NSLayoutAttributeBottom,
	NSLayoutAttributeLeading,
	NSLayoutAttributeTrailing,
	NSLayoutAttributeWidth,
	NSLayoutAttributeHeight,
	NSLayoutAttributeCenterX,
	NSLayoutAttributeCenterY,
	NSLayoutAttributeBaseline,
	NSLayoutAttributeLastBaseline,
	NSLayoutAttributeFirstBaseline,
	NSLayoutAttributeLeftMargin,
	NSLayoutAttributeRightMargin,
	NSLayoutAttributeTopMargin,
	NSLayoutAttributeBottomMargin,
	NSLayoutAttributeLeadingMargin,
	NSLayoutAttributeTrailingMargin,
	NSLayoutAttributeCenterXWithinMargins,
	NSLayoutAttributeCenterYWithinMargins,
	NSLayoutAttributeNotAnAttribute
}
declare enum NSLayoutFormatOptions {
	NSLayoutFormatAlignAllLeft,
	NSLayoutFormatAlignAllRight,
	NSLayoutFormatAlignAllTop,
	NSLayoutFormatAlignAllBottom,
	NSLayoutFormatAlignAllLeading,
	NSLayoutFormatAlignAllTrailing,
	NSLayoutFormatAlignAllCenterX,
	NSLayoutFormatAlignAllCenterY,
	NSLayoutFormatAlignAllBaseline,
	NSLayoutFormatAlignAllLastBaseline,
	NSLayoutFormatAlignAllFirstBaseline,
	NSLayoutFormatAlignmentMask,
	NSLayoutFormatDirectionLeadingToTrailing,
	NSLayoutFormatDirectionLeftToRight,
	NSLayoutFormatDirectionRightToLeft,
	NSLayoutFormatDirectionMask
}
declare enum UIViewAnimationCurve {
	UIViewAnimationCurveEaseInOut,
	UIViewAnimationCurveEaseIn,
	UIViewAnimationCurveEaseOut,
	UIViewAnimationCurveLinear
}
declare enum UIViewContentMode {
	UIViewContentModeScaleToFill,
	UIViewContentModeScaleAspectFit,
	UIViewContentModeScaleAspectFill,
	UIViewContentModeRedraw,
	UIViewContentModeCenter,
	UIViewContentModeTop,
	UIViewContentModeBottom,
	UIViewContentModeLeft,
	UIViewContentModeRight,
	UIViewContentModeTopLeft,
	UIViewContentModeTopRight,
	UIViewContentModeBottomLeft,
	UIViewContentModeBottomRight
}
declare enum UIViewAnimationTransition {
	UIViewAnimationTransitionNone,
	UIViewAnimationTransitionFlipFromLeft,
	UIViewAnimationTransitionFlipFromRight,
	UIViewAnimationTransitionCurlUp,
	UIViewAnimationTransitionCurlDown
}
declare enum UIViewAutoresizing {
	UIViewAutoresizingNone,
	UIViewAutoresizingFlexibleLeftMargin,
	UIViewAutoresizingFlexibleWidth,
	UIViewAutoresizingFlexibleRightMargin,
	UIViewAutoresizingFlexibleTopMargin,
	UIViewAutoresizingFlexibleHeight,
	UIViewAutoresizingFlexibleBottomMargin
}
declare enum UIViewAnimationOptions {
	UIViewAnimationOptionLayoutSubviews,
	UIViewAnimationOptionAllowUserInteraction,
	UIViewAnimationOptionBeginFromCurrentState,
	UIViewAnimationOptionRepeat,
	UIViewAnimationOptionAutoreverse,
	UIViewAnimationOptionOverrideInheritedDuration,
	UIViewAnimationOptionOverrideInheritedCurve,
	UIViewAnimationOptionAllowAnimatedContent,
	UIViewAnimationOptionShowHideTransitionViews,
	UIViewAnimationOptionOverrideInheritedOptions,
	UIViewAnimationOptionCurveEaseInOut,
	UIViewAnimationOptionCurveEaseIn,
	UIViewAnimationOptionCurveEaseOut,
	UIViewAnimationOptionCurveLinear,
	UIViewAnimationOptionTransitionNone,
	UIViewAnimationOptionTransitionFlipFromLeft,
	UIViewAnimationOptionTransitionFlipFromRight,
	UIViewAnimationOptionTransitionCurlUp,
	UIViewAnimationOptionTransitionCurlDown,
	UIViewAnimationOptionTransitionCrossDissolve,
	UIViewAnimationOptionTransitionFlipFromTop,
	UIViewAnimationOptionTransitionFlipFromBottom
}
declare enum UIViewKeyframeAnimationOptions {
	UIViewKeyframeAnimationOptionLayoutSubviews,
	UIViewKeyframeAnimationOptionAllowUserInteraction,
	UIViewKeyframeAnimationOptionBeginFromCurrentState,
	UIViewKeyframeAnimationOptionRepeat,
	UIViewKeyframeAnimationOptionAutoreverse,
	UIViewKeyframeAnimationOptionOverrideInheritedDuration,
	UIViewKeyframeAnimationOptionOverrideInheritedOptions,
	UIViewKeyframeAnimationOptionCalculationModeLinear,
	UIViewKeyframeAnimationOptionCalculationModeDiscrete,
	UIViewKeyframeAnimationOptionCalculationModePaced,
	UIViewKeyframeAnimationOptionCalculationModeCubic,
	UIViewKeyframeAnimationOptionCalculationModeCubicPaced
}
declare enum UISystemAnimation {
	UISystemAnimationDelete
}
declare enum UIViewTintAdjustmentMode {
	UIViewTintAdjustmentModeAutomatic,
	UIViewTintAdjustmentModeNormal,
	UIViewTintAdjustmentModeDimmed
}
declare enum UILayoutConstraintAxis {
	UILayoutConstraintAxisHorizontal,
	UILayoutConstraintAxisVertical
}
declare enum UIControlEvents {
	UIControlEventTouchDown,
	UIControlEventTouchDownRepeat,
	UIControlEventTouchDragInside,
	UIControlEventTouchDragOutside,
	UIControlEventTouchDragEnter,
	UIControlEventTouchDragExit,
	UIControlEventTouchUpInside,
	UIControlEventTouchUpOutside,
	UIControlEventTouchCancel,
	UIControlEventValueChanged,
	UIControlEventEditingDidBegin,
	UIControlEventEditingChanged,
	UIControlEventEditingDidEnd,
	UIControlEventEditingDidEndOnExit,
	UIControlEventAllTouchEvents,
	UIControlEventAllEditingEvents,
	UIControlEventApplicationReserved,
	UIControlEventSystemReserved,
	UIControlEventAllEvents
}
declare enum UIControlContentVerticalAlignment {
	UIControlContentVerticalAlignmentCenter,
	UIControlContentVerticalAlignmentTop,
	UIControlContentVerticalAlignmentBottom,
	UIControlContentVerticalAlignmentFill
}
declare enum UIControlContentHorizontalAlignment {
	UIControlContentHorizontalAlignmentCenter,
	UIControlContentHorizontalAlignmentLeft,
	UIControlContentHorizontalAlignmentRight,
	UIControlContentHorizontalAlignmentFill
}
declare enum UIControlState {
	UIControlStateNormal,
	UIControlStateHighlighted,
	UIControlStateDisabled,
	UIControlStateSelected,
	UIControlStateApplication,
	UIControlStateReserved
}
declare enum NSTextAlignment {
	NSTextAlignmentLeft,
	NSTextAlignmentCenter,
	NSTextAlignmentRight,
	NSTextAlignmentJustified,
	NSTextAlignmentNatural
}
declare enum NSWritingDirection {
	NSWritingDirectionNatural,
	NSWritingDirectionLeftToRight,
	NSWritingDirectionRightToLeft
}
declare enum NSLineBreakMode {
	NSLineBreakByWordWrapping,
	NSLineBreakByCharWrapping,
	NSLineBreakByClipping,
	NSLineBreakByTruncatingHead,
	NSLineBreakByTruncatingTail,
	NSLineBreakByTruncatingMiddle
}
declare enum UILineBreakMode {
	UILineBreakModeWordWrap,
	UILineBreakModeCharacterWrap,
	UILineBreakModeClip,
	UILineBreakModeHeadTruncation,
	UILineBreakModeTailTruncation,
	UILineBreakModeMiddleTruncation
}
declare enum UITextAlignment {
	UITextAlignmentLeft,
	UITextAlignmentCenter,
	UITextAlignmentRight
}
declare enum UIBaselineAdjustment {
	UIBaselineAdjustmentAlignBaselines,
	UIBaselineAdjustmentAlignCenters,
	UIBaselineAdjustmentNone
}
declare enum UITextAutocapitalizationType {
	UITextAutocapitalizationTypeNone,
	UITextAutocapitalizationTypeWords,
	UITextAutocapitalizationTypeSentences,
	UITextAutocapitalizationTypeAllCharacters
}
declare enum UITextAutocorrectionType {
	UITextAutocorrectionTypeDefault,
	UITextAutocorrectionTypeNo,
	UITextAutocorrectionTypeYes
}
declare enum UITextSpellCheckingType {
	UITextSpellCheckingTypeDefault,
	UITextSpellCheckingTypeNo,
	UITextSpellCheckingTypeYes
}
declare enum UIKeyboardType {
	UIKeyboardTypeDefault,
	UIKeyboardTypeASCIICapable,
	UIKeyboardTypeNumbersAndPunctuation,
	UIKeyboardTypeURL,
	UIKeyboardTypeNumberPad,
	UIKeyboardTypePhonePad,
	UIKeyboardTypeNamePhonePad,
	UIKeyboardTypeEmailAddress,
	UIKeyboardTypeDecimalPad,
	UIKeyboardTypeTwitter,
	UIKeyboardTypeWebSearch,
	UIKeyboardTypeAlphabet
}
declare enum UIKeyboardAppearance {
	UIKeyboardAppearanceDefault,
	UIKeyboardAppearanceDark,
	UIKeyboardAppearanceLight,
	UIKeyboardAppearanceAlert
}
declare enum UIReturnKeyType {
	UIReturnKeyDefault,
	UIReturnKeyGo,
	UIReturnKeyGoogle,
	UIReturnKeyJoin,
	UIReturnKeyNext,
	UIReturnKeyRoute,
	UIReturnKeySearch,
	UIReturnKeySend,
	UIReturnKeyYahoo,
	UIReturnKeyDone,
	UIReturnKeyEmergencyCall
}
declare enum UITextStorageDirection {
	UITextStorageDirectionForward,
	UITextStorageDirectionBackward
}
declare enum UITextLayoutDirection {
	UITextLayoutDirectionRight,
	UITextLayoutDirectionLeft,
	UITextLayoutDirectionUp,
	UITextLayoutDirectionDown
}
declare enum UITextWritingDirection {
	UITextWritingDirectionNatural,
	UITextWritingDirectionLeftToRight,
	UITextWritingDirectionRightToLeft
}
declare enum UITextGranularity {
	UITextGranularityCharacter,
	UITextGranularityWord,
	UITextGranularitySentence,
	UITextGranularityParagraph,
	UITextGranularityLine,
	UITextGranularityDocument
}
declare enum UITextBorderStyle {
	UITextBorderStyleNone,
	UITextBorderStyleLine,
	UITextBorderStyleBezel,
	UITextBorderStyleRoundedRect
}
declare enum UITextFieldViewMode {
	UITextFieldViewModeNever,
	UITextFieldViewModeWhileEditing,
	UITextFieldViewModeUnlessEditing,
	UITextFieldViewModeAlways
}
declare enum UIActionSheetStyle {
	UIActionSheetStyleAutomatic,
	UIActionSheetStyleDefault,
	UIActionSheetStyleBlackTranslucent,
	UIActionSheetStyleBlackOpaque
}
declare enum UIAlertViewStyle {
	UIAlertViewStyleDefault,
	UIAlertViewStyleSecureTextInput,
	UIAlertViewStylePlainTextInput,
	UIAlertViewStyleLoginAndPasswordInput
}
declare enum UIStatusBarStyle {
	UIStatusBarStyleDefault,
	UIStatusBarStyleLightContent,
	UIStatusBarStyleBlackTranslucent,
	UIStatusBarStyleBlackOpaque
}
declare enum UIStatusBarAnimation {
	UIStatusBarAnimationNone,
	UIStatusBarAnimationFade,
	UIStatusBarAnimationSlide
}
declare enum UIInterfaceOrientation {
	UIInterfaceOrientationUnknown,
	UIInterfaceOrientationPortrait,
	UIInterfaceOrientationPortraitUpsideDown,
	UIInterfaceOrientationLandscapeLeft,
	UIInterfaceOrientationLandscapeRight
}
declare enum UIInterfaceOrientationMask {
	UIInterfaceOrientationMaskPortrait,
	UIInterfaceOrientationMaskLandscapeLeft,
	UIInterfaceOrientationMaskLandscapeRight,
	UIInterfaceOrientationMaskPortraitUpsideDown,
	UIInterfaceOrientationMaskLandscape,
	UIInterfaceOrientationMaskAll,
	UIInterfaceOrientationMaskAllButUpsideDown
}
declare enum UIRemoteNotificationType {
	UIRemoteNotificationTypeNone,
	UIRemoteNotificationTypeBadge,
	UIRemoteNotificationTypeSound,
	UIRemoteNotificationTypeAlert,
	UIRemoteNotificationTypeNewsstandContentAvailability
}
declare enum UIBackgroundFetchResult {
	UIBackgroundFetchResultNewData,
	UIBackgroundFetchResultNoData,
	UIBackgroundFetchResultFailed
}
declare enum UIBackgroundRefreshStatus {
	UIBackgroundRefreshStatusRestricted,
	UIBackgroundRefreshStatusDenied,
	UIBackgroundRefreshStatusAvailable
}
declare enum UIApplicationState {
	UIApplicationStateActive,
	UIApplicationStateInactive,
	UIApplicationStateBackground
}
declare enum UIUserInterfaceLayoutDirection {
	UIUserInterfaceLayoutDirectionLeftToRight,
	UIUserInterfaceLayoutDirectionRightToLeft
}
declare enum UIModalTransitionStyle {
	UIModalTransitionStyleCoverVertical,
	UIModalTransitionStyleFlipHorizontal,
	UIModalTransitionStyleCrossDissolve,
	UIModalTransitionStylePartialCurl
}
declare enum UIModalPresentationStyle {
	UIModalPresentationFullScreen,
	UIModalPresentationPageSheet,
	UIModalPresentationFormSheet,
	UIModalPresentationCurrentContext,
	UIModalPresentationCustom,
	UIModalPresentationOverFullScreen,
	UIModalPresentationOverCurrentContext,
	UIModalPresentationPopover,
	UIModalPresentationNone
}
declare enum UIGestureRecognizerState {
	UIGestureRecognizerStatePossible,
	UIGestureRecognizerStateBegan,
	UIGestureRecognizerStateChanged,
	UIGestureRecognizerStateEnded,
	UIGestureRecognizerStateCancelled,
	UIGestureRecognizerStateFailed,
	UIGestureRecognizerStateRecognized
}
declare enum UINavigationControllerOperation {
	UINavigationControllerOperationNone,
	UINavigationControllerOperationPush,
	UINavigationControllerOperationPop
}
declare enum UIRectCorner {
	UIRectCornerTopLeft,
	UIRectCornerTopRight,
	UIRectCornerBottomLeft,
	UIRectCornerBottomRight,
	UIRectCornerAllCorners
}
declare enum UIScrollViewIndicatorStyle {
	UIScrollViewIndicatorStyleDefault,
	UIScrollViewIndicatorStyleBlack,
	UIScrollViewIndicatorStyleWhite
}
declare enum UIScrollViewKeyboardDismissMode {
	UIScrollViewKeyboardDismissModeNone,
	UIScrollViewKeyboardDismissModeOnDrag,
	UIScrollViewKeyboardDismissModeInteractive
}
declare enum UISwipeGestureRecognizerDirection {
	UISwipeGestureRecognizerDirectionRight,
	UISwipeGestureRecognizerDirectionLeft,
	UISwipeGestureRecognizerDirectionUp,
	UISwipeGestureRecognizerDirectionDown
}
declare enum UITableViewCellStyle {
	UITableViewCellStyleDefault,
	UITableViewCellStyleValue1,
	UITableViewCellStyleValue2,
	UITableViewCellStyleSubtitle
}
declare enum UITableViewCellSeparatorStyle {
	UITableViewCellSeparatorStyleNone,
	UITableViewCellSeparatorStyleSingleLine,
	UITableViewCellSeparatorStyleSingleLineEtched
}
declare enum UITableViewCellSelectionStyle {
	UITableViewCellSelectionStyleNone,
	UITableViewCellSelectionStyleBlue,
	UITableViewCellSelectionStyleGray,
	UITableViewCellSelectionStyleDefault
}
declare enum UITableViewCellEditingStyle {
	UITableViewCellEditingStyleNone,
	UITableViewCellEditingStyleDelete,
	UITableViewCellEditingStyleInsert
}
declare enum UITableViewCellAccessoryType {
	UITableViewCellAccessoryNone,
	UITableViewCellAccessoryDisclosureIndicator,
	UITableViewCellAccessoryDetailDisclosureButton,
	UITableViewCellAccessoryCheckmark,
	UITableViewCellAccessoryDetailButton
}
declare enum UITableViewCellStateMask {
	UITableViewCellStateDefaultMask,
	UITableViewCellStateShowingEditControlMask,
	UITableViewCellStateShowingDeleteConfirmationMask
}
declare enum UITableViewStyle {
	UITableViewStylePlain,
	UITableViewStyleGrouped
}
declare enum UITableViewScrollPosition {
	UITableViewScrollPositionNone,
	UITableViewScrollPositionTop,
	UITableViewScrollPositionMiddle,
	UITableViewScrollPositionBottom
}
declare enum UITableViewRowAnimation {
	UITableViewRowAnimationFade,
	UITableViewRowAnimationRight,
	UITableViewRowAnimationLeft,
	UITableViewRowAnimationTop,
	UITableViewRowAnimationBottom,
	UITableViewRowAnimationNone,
	UITableViewRowAnimationMiddle,
	UITableViewRowAnimationAutomatic
}
declare enum UITableViewRowActionStyle {
	UITableViewRowActionStyleDefault,
	UITableViewRowActionStyleDestructive,
	UITableViewRowActionStyleNormal
}
declare enum UIAccessibilityNavigationStyle {
	UIAccessibilityNavigationStyleAutomatic,
	UIAccessibilityNavigationStyleSeparate,
	UIAccessibilityNavigationStyleCombined
}
declare enum UIImageOrientation {
	UIImageOrientationUp,
	UIImageOrientationDown,
	UIImageOrientationLeft,
	UIImageOrientationRight,
	UIImageOrientationUpMirrored,
	UIImageOrientationDownMirrored,
	UIImageOrientationLeftMirrored,
	UIImageOrientationRightMirrored
}
declare enum UIImageResizingMode {
	UIImageResizingModeTile,
	UIImageResizingModeStretch
}
declare enum UIImageRenderingMode {
	UIImageRenderingModeAutomatic,
	UIImageRenderingModeAlwaysOriginal,
	UIImageRenderingModeAlwaysTemplate
}
declare enum UIAccessibilityZoomType {
	UIAccessibilityZoomTypeInsertionPoint
}
declare enum UIGuidedAccessRestrictionState {
	UIGuidedAccessRestrictionStateAllow,
	UIGuidedAccessRestrictionStateDeny
}
declare enum UIAccessibilityScrollDirection {
	UIAccessibilityScrollDirectionRight,
	UIAccessibilityScrollDirectionLeft,
	UIAccessibilityScrollDirectionUp,
	UIAccessibilityScrollDirectionDown,
	UIAccessibilityScrollDirectionNext,
	UIAccessibilityScrollDirectionPrevious
}
declare enum UIActivityIndicatorViewStyle {
	UIActivityIndicatorViewStyleWhiteLarge,
	UIActivityIndicatorViewStyleWhite,
	UIActivityIndicatorViewStyleGray
}
declare enum UIActivityCategory {
	UIActivityCategoryAction,
	UIActivityCategoryShare
}
declare enum UIAlertActionStyle {
	UIAlertActionStyleDefault,
	UIAlertActionStyleCancel,
	UIAlertActionStyleDestructive
}
declare enum UIAlertControllerStyle {
	UIAlertControllerStyleActionSheet,
	UIAlertControllerStyleAlert
}
declare enum UIBarMetrics {
	UIBarMetricsDefault,
	UIBarMetricsCompact,
	UIBarMetricsDefaultPrompt,
	UIBarMetricsCompactPrompt,
	UIBarMetricsLandscapePhone,
	UIBarMetricsLandscapePhonePrompt
}
declare enum UIBarPosition {
	UIBarPositionAny,
	UIBarPositionBottom,
	UIBarPositionTop,
	UIBarPositionTopAttached
}
declare enum UIBarButtonItemStyle {
	UIBarButtonItemStylePlain,
	UIBarButtonItemStyleBordered,
	UIBarButtonItemStyleDone
}
declare enum UIBarButtonSystemItem {
	UIBarButtonSystemItemDone,
	UIBarButtonSystemItemCancel,
	UIBarButtonSystemItemEdit,
	UIBarButtonSystemItemSave,
	UIBarButtonSystemItemAdd,
	UIBarButtonSystemItemFlexibleSpace,
	UIBarButtonSystemItemFixedSpace,
	UIBarButtonSystemItemCompose,
	UIBarButtonSystemItemReply,
	UIBarButtonSystemItemAction,
	UIBarButtonSystemItemOrganize,
	UIBarButtonSystemItemBookmarks,
	UIBarButtonSystemItemSearch,
	UIBarButtonSystemItemRefresh,
	UIBarButtonSystemItemStop,
	UIBarButtonSystemItemCamera,
	UIBarButtonSystemItemTrash,
	UIBarButtonSystemItemPlay,
	UIBarButtonSystemItemPause,
	UIBarButtonSystemItemRewind,
	UIBarButtonSystemItemFastForward,
	UIBarButtonSystemItemUndo,
	UIBarButtonSystemItemRedo,
	UIBarButtonSystemItemPageCurl
}
declare enum UIButtonType {
	UIButtonTypeCustom,
	UIButtonTypeSystem,
	UIButtonTypeDetailDisclosure,
	UIButtonTypeInfoLight,
	UIButtonTypeInfoDark,
	UIButtonTypeContactAdd,
	UIButtonTypeRoundedRect
}
declare enum UICollectionViewScrollPosition {
	UICollectionViewScrollPositionNone,
	UICollectionViewScrollPositionTop,
	UICollectionViewScrollPositionCenteredVertically,
	UICollectionViewScrollPositionBottom,
	UICollectionViewScrollPositionLeft,
	UICollectionViewScrollPositionCenteredHorizontally,
	UICollectionViewScrollPositionRight
}
declare enum UICollectionElementCategory {
	UICollectionElementCategoryCell,
	UICollectionElementCategorySupplementaryView,
	UICollectionElementCategoryDecorationView
}
declare enum UICollectionUpdateAction {
	UICollectionUpdateActionInsert,
	UICollectionUpdateActionDelete,
	UICollectionUpdateActionReload,
	UICollectionUpdateActionMove,
	UICollectionUpdateActionNone
}
declare enum UICollectionViewScrollDirection {
	UICollectionViewScrollDirectionVertical,
	UICollectionViewScrollDirectionHorizontal
}
declare enum UIDataDetectorTypes {
	UIDataDetectorTypePhoneNumber,
	UIDataDetectorTypeLink,
	UIDataDetectorTypeAddress,
	UIDataDetectorTypeCalendarEvent,
	UIDataDetectorTypeNone,
	UIDataDetectorTypeAll
}
declare enum UIDatePickerMode {
	UIDatePickerModeTime,
	UIDatePickerModeDate,
	UIDatePickerModeDateAndTime,
	UIDatePickerModeCountDownTimer
}
declare enum UIDocumentChangeKind {
	UIDocumentChangeDone,
	UIDocumentChangeUndone,
	UIDocumentChangeRedone,
	UIDocumentChangeCleared
}
declare enum UIDocumentSaveOperation {
	UIDocumentSaveForCreating,
	UIDocumentSaveForOverwriting
}
declare enum UIDocumentState {
	UIDocumentStateNormal,
	UIDocumentStateClosed,
	UIDocumentStateInConflict,
	UIDocumentStateSavingError,
	UIDocumentStateEditingDisabled
}
declare enum UIDocumentPickerMode {
	UIDocumentPickerModeImport,
	UIDocumentPickerModeOpen,
	UIDocumentPickerModeExportToService,
	UIDocumentPickerModeMoveToService
}
declare enum UIDocumentMenuOrder {
	UIDocumentMenuOrderFirst,
	UIDocumentMenuOrderLast
}
declare enum UIBlurEffectStyle {
	UIBlurEffectStyleExtraLight,
	UIBlurEffectStyleLight,
	UIBlurEffectStyleDark
}
declare enum UIImagePickerControllerSourceType {
	UIImagePickerControllerSourceTypePhotoLibrary,
	UIImagePickerControllerSourceTypeCamera,
	UIImagePickerControllerSourceTypeSavedPhotosAlbum
}
declare enum UIImagePickerControllerQualityType {
	UIImagePickerControllerQualityTypeHigh,
	UIImagePickerControllerQualityTypeMedium,
	UIImagePickerControllerQualityTypeLow,
	UIImagePickerControllerQualityType640x480,
	UIImagePickerControllerQualityTypeIFrame1280x720,
	UIImagePickerControllerQualityTypeIFrame960x540
}
declare enum UIImagePickerControllerCameraCaptureMode {
	UIImagePickerControllerCameraCaptureModePhoto,
	UIImagePickerControllerCameraCaptureModeVideo
}
declare enum UIImagePickerControllerCameraDevice {
	UIImagePickerControllerCameraDeviceRear,
	UIImagePickerControllerCameraDeviceFront
}
declare enum UIImagePickerControllerCameraFlashMode {
	UIImagePickerControllerCameraFlashModeOff,
	UIImagePickerControllerCameraFlashModeAuto,
	UIImagePickerControllerCameraFlashModeOn
}
declare enum UIInputViewStyle {
	UIInputViewStyleDefault,
	UIInputViewStyleKeyboard
}
declare enum UIUserNotificationType {
	UIUserNotificationTypeNone,
	UIUserNotificationTypeBadge,
	UIUserNotificationTypeSound,
	UIUserNotificationTypeAlert
}
declare enum UIUserNotificationActivationMode {
	UIUserNotificationActivationModeForeground,
	UIUserNotificationActivationModeBackground
}
declare enum UIUserNotificationActionContext {
	UIUserNotificationActionContextDefault,
	UIUserNotificationActionContextMinimal
}
declare enum UIMenuControllerArrowDirection {
	UIMenuControllerArrowDefault,
	UIMenuControllerArrowUp,
	UIMenuControllerArrowDown,
	UIMenuControllerArrowLeft,
	UIMenuControllerArrowRight
}
declare enum UIInterpolatingMotionEffectType {
	UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis,
	UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis
}
declare enum UIPageViewControllerNavigationOrientation {
	UIPageViewControllerNavigationOrientationHorizontal,
	UIPageViewControllerNavigationOrientationVertical
}
declare enum UIPageViewControllerSpineLocation {
	UIPageViewControllerSpineLocationNone,
	UIPageViewControllerSpineLocationMin,
	UIPageViewControllerSpineLocationMid,
	UIPageViewControllerSpineLocationMax
}
declare enum UIPageViewControllerNavigationDirection {
	UIPageViewControllerNavigationDirectionForward,
	UIPageViewControllerNavigationDirectionReverse
}
declare enum UIPageViewControllerTransitionStyle {
	UIPageViewControllerTransitionStylePageCurl,
	UIPageViewControllerTransitionStyleScroll
}
declare enum UIPopoverArrowDirection {
	UIPopoverArrowDirectionUp,
	UIPopoverArrowDirectionDown,
	UIPopoverArrowDirectionLeft,
	UIPopoverArrowDirectionRight,
	UIPopoverArrowDirectionAny,
	UIPopoverArrowDirectionUnknown
}
declare enum UIPrinterJobTypes {
	UIPrinterJobTypeUnknown,
	UIPrinterJobTypeDocument,
	UIPrinterJobTypeEnvelope,
	UIPrinterJobTypeLabel,
	UIPrinterJobTypePhoto,
	UIPrinterJobTypeReceipt,
	UIPrinterJobTypeRoll,
	UIPrinterJobTypeLargeFormat,
	UIPrinterJobTypePostcard
}
declare enum UIPrintInfoOutputType {
	UIPrintInfoOutputGeneral,
	UIPrintInfoOutputPhoto,
	UIPrintInfoOutputGrayscale,
	UIPrintInfoOutputPhotoGrayscale
}
declare enum UIPrintInfoOrientation {
	UIPrintInfoOrientationPortrait,
	UIPrintInfoOrientationLandscape
}
declare enum UIPrintInfoDuplex {
	UIPrintInfoDuplexNone,
	UIPrintInfoDuplexLongEdge,
	UIPrintInfoDuplexShortEdge
}
declare enum UIProgressViewStyle {
	UIProgressViewStyleDefault,
	UIProgressViewStyleBar
}
declare enum UIScreenOverscanCompensation {
	UIScreenOverscanCompensationScale,
	UIScreenOverscanCompensationInsetBounds,
	UIScreenOverscanCompensationInsetApplicationFrame
}
declare enum UISearchBarIcon {
	UISearchBarIconSearch,
	UISearchBarIconClear,
	UISearchBarIconBookmark,
	UISearchBarIconResultsList
}
declare enum UISearchBarStyle {
	UISearchBarStyleDefault,
	UISearchBarStyleProminent,
	UISearchBarStyleMinimal
}
declare enum UISegmentedControlStyle {
	UISegmentedControlStylePlain,
	UISegmentedControlStyleBordered,
	UISegmentedControlStyleBar,
	UISegmentedControlStyleBezeled
}
declare enum UISegmentedControlSegment {
	UISegmentedControlSegmentAny,
	UISegmentedControlSegmentLeft,
	UISegmentedControlSegmentCenter,
	UISegmentedControlSegmentRight,
	UISegmentedControlSegmentAlone
}
declare enum UISplitViewControllerDisplayMode {
	UISplitViewControllerDisplayModeAutomatic,
	UISplitViewControllerDisplayModePrimaryHidden,
	UISplitViewControllerDisplayModeAllVisible,
	UISplitViewControllerDisplayModePrimaryOverlay
}
declare enum UITabBarItemPositioning {
	UITabBarItemPositioningAutomatic,
	UITabBarItemPositioningFill,
	UITabBarItemPositioningCentered
}
declare enum UITabBarSystemItem {
	UITabBarSystemItemMore,
	UITabBarSystemItemFavorites,
	UITabBarSystemItemFeatured,
	UITabBarSystemItemTopRated,
	UITabBarSystemItemRecents,
	UITabBarSystemItemContacts,
	UITabBarSystemItemHistory,
	UITabBarSystemItemBookmarks,
	UITabBarSystemItemSearch,
	UITabBarSystemItemDownloads,
	UITabBarSystemItemMostRecent,
	UITabBarSystemItemMostViewed
}
declare enum UITouchPhase {
	UITouchPhaseBegan,
	UITouchPhaseMoved,
	UITouchPhaseStationary,
	UITouchPhaseEnded,
	UITouchPhaseCancelled
}
declare enum UIWebViewNavigationType {
	UIWebViewNavigationTypeLinkClicked,
	UIWebViewNavigationTypeFormSubmitted,
	UIWebViewNavigationTypeBackForward,
	UIWebViewNavigationTypeReload,
	UIWebViewNavigationTypeFormResubmitted,
	UIWebViewNavigationTypeOther
}
declare enum UIWebPaginationMode {
	UIWebPaginationModeUnpaginated,
	UIWebPaginationModeLeftToRight,
	UIWebPaginationModeTopToBottom,
	UIWebPaginationModeBottomToTop,
	UIWebPaginationModeRightToLeft
}
declare enum UIWebPaginationBreakingMode {
	UIWebPaginationBreakingModePage,
	UIWebPaginationBreakingModeColumn
}
declare enum NSUnderlineStyle {
	NSUnderlineStyleNone,
	NSUnderlineStyleSingle,
	NSUnderlineStyleThick,
	NSUnderlineStyleDouble,
	NSUnderlinePatternSolid,
	NSUnderlinePatternDot,
	NSUnderlinePatternDash,
	NSUnderlinePatternDashDot,
	NSUnderlinePatternDashDotDot,
	NSUnderlineByWord
}
declare enum NSTextWritingDirection {
	NSTextWritingDirectionEmbedding,
	NSTextWritingDirectionOverride
}
declare enum NSTextStorageEditActions {
	NSTextStorageEditedAttributes,
	NSTextStorageEditedCharacters
}
declare enum NSTextLayoutOrientation {
	NSTextLayoutOrientationHorizontal,
	NSTextLayoutOrientationVertical
}
declare enum NSGlyphProperty {
	NSGlyphPropertyNull,
	NSGlyphPropertyControlCharacter,
	NSGlyphPropertyElastic,
	NSGlyphPropertyNonBaseCharacter
}
declare enum NSControlCharacterAction {
	NSControlCharacterZeroAdvancementAction,
	NSControlCharacterWhitespaceAction,
	NSControlCharacterHorizontalTabAction,
	NSControlCharacterLineBreakAction,
	NSControlCharacterParagraphBreakAction,
	NSControlCharacterContainerBreakAction
}
declare enum NSStringDrawingOptions {
	NSStringDrawingTruncatesLastVisibleLine,
	NSStringDrawingUsesLineFragmentOrigin,
	NSStringDrawingUsesFontLeading,
	NSStringDrawingUsesDeviceMetrics
}
declare enum UIPushBehaviorMode {
	UIPushBehaviorModeContinuous,
	UIPushBehaviorModeInstantaneous
}
declare enum UIAttachmentBehaviorType {
	UIAttachmentBehaviorTypeItems,
	UIAttachmentBehaviorTypeAnchor
}
declare enum UICollisionBehaviorMode {
	UICollisionBehaviorModeItems,
	UICollisionBehaviorModeBoundaries,
	UICollisionBehaviorModeEverything
}
declare enum EAGLRenderingAPI {
	kEAGLRenderingAPIOpenGLES1,
	kEAGLRenderingAPIOpenGLES2,
	kEAGLRenderingAPIOpenGLES3
}
declare enum MTLPixelFormat {
	MTLPixelFormatInvalid,
	MTLPixelFormatA8Unorm,
	MTLPixelFormatR8Unorm,
	MTLPixelFormatR8Unorm_sRGB,
	MTLPixelFormatR8Snorm,
	MTLPixelFormatR8Uint,
	MTLPixelFormatR8Sint,
	MTLPixelFormatR16Unorm,
	MTLPixelFormatR16Snorm,
	MTLPixelFormatR16Uint,
	MTLPixelFormatR16Sint,
	MTLPixelFormatR16Float,
	MTLPixelFormatRG8Unorm,
	MTLPixelFormatRG8Unorm_sRGB,
	MTLPixelFormatRG8Snorm,
	MTLPixelFormatRG8Uint,
	MTLPixelFormatRG8Sint,
	MTLPixelFormatB5G6R5Unorm,
	MTLPixelFormatA1BGR5Unorm,
	MTLPixelFormatABGR4Unorm,
	MTLPixelFormatR32Uint,
	MTLPixelFormatR32Sint,
	MTLPixelFormatR32Float,
	MTLPixelFormatRG16Unorm,
	MTLPixelFormatRG16Snorm,
	MTLPixelFormatRG16Uint,
	MTLPixelFormatRG16Sint,
	MTLPixelFormatRG16Float,
	MTLPixelFormatRGBA8Unorm,
	MTLPixelFormatRGBA8Unorm_sRGB,
	MTLPixelFormatRGBA8Snorm,
	MTLPixelFormatRGBA8Uint,
	MTLPixelFormatRGBA8Sint,
	MTLPixelFormatBGRA8Unorm,
	MTLPixelFormatBGRA8Unorm_sRGB,
	MTLPixelFormatRGB10A2Unorm,
	MTLPixelFormatRGB10A2Uint,
	MTLPixelFormatRG11B10Float,
	MTLPixelFormatRGB9E5Float,
	MTLPixelFormatRG32Uint,
	MTLPixelFormatRG32Sint,
	MTLPixelFormatRG32Float,
	MTLPixelFormatRGBA16Unorm,
	MTLPixelFormatRGBA16Snorm,
	MTLPixelFormatRGBA16Uint,
	MTLPixelFormatRGBA16Sint,
	MTLPixelFormatRGBA16Float,
	MTLPixelFormatRGBA32Uint,
	MTLPixelFormatRGBA32Sint,
	MTLPixelFormatRGBA32Float,
	MTLPixelFormatPVRTC_RGB_2BPP,
	MTLPixelFormatPVRTC_RGB_2BPP_sRGB,
	MTLPixelFormatPVRTC_RGB_4BPP,
	MTLPixelFormatPVRTC_RGB_4BPP_sRGB,
	MTLPixelFormatPVRTC_RGBA_2BPP,
	MTLPixelFormatPVRTC_RGBA_2BPP_sRGB,
	MTLPixelFormatPVRTC_RGBA_4BPP,
	MTLPixelFormatPVRTC_RGBA_4BPP_sRGB,
	MTLPixelFormatEAC_R11Unorm,
	MTLPixelFormatEAC_R11Snorm,
	MTLPixelFormatEAC_RG11Unorm,
	MTLPixelFormatEAC_RG11Snorm,
	MTLPixelFormatEAC_RGBA8,
	MTLPixelFormatEAC_RGBA8_sRGB,
	MTLPixelFormatETC2_RGB8,
	MTLPixelFormatETC2_RGB8_sRGB,
	MTLPixelFormatETC2_RGB8A1,
	MTLPixelFormatETC2_RGB8A1_sRGB,
	MTLPixelFormatASTC_4x4_sRGB,
	MTLPixelFormatASTC_5x4_sRGB,
	MTLPixelFormatASTC_5x5_sRGB,
	MTLPixelFormatASTC_6x5_sRGB,
	MTLPixelFormatASTC_6x6_sRGB,
	MTLPixelFormatASTC_8x5_sRGB,
	MTLPixelFormatASTC_8x6_sRGB,
	MTLPixelFormatASTC_8x8_sRGB,
	MTLPixelFormatASTC_10x5_sRGB,
	MTLPixelFormatASTC_10x6_sRGB,
	MTLPixelFormatASTC_10x8_sRGB,
	MTLPixelFormatASTC_10x10_sRGB,
	MTLPixelFormatASTC_12x10_sRGB,
	MTLPixelFormatASTC_12x12_sRGB,
	MTLPixelFormatASTC_4x4_LDR,
	MTLPixelFormatASTC_5x4_LDR,
	MTLPixelFormatASTC_5x5_LDR,
	MTLPixelFormatASTC_6x5_LDR,
	MTLPixelFormatASTC_6x6_LDR,
	MTLPixelFormatASTC_8x5_LDR,
	MTLPixelFormatASTC_8x6_LDR,
	MTLPixelFormatASTC_8x8_LDR,
	MTLPixelFormatASTC_10x5_LDR,
	MTLPixelFormatASTC_10x6_LDR,
	MTLPixelFormatASTC_10x8_LDR,
	MTLPixelFormatASTC_10x10_LDR,
	MTLPixelFormatASTC_12x10_LDR,
	MTLPixelFormatASTC_12x12_LDR,
	MTLPixelFormatGBGR422,
	MTLPixelFormatBGRG422,
	MTLPixelFormatDepth32Float,
	MTLPixelFormatStencil8
}
declare enum MTLPurgeableState {
	MTLPurgeableStateKeepCurrent,
	MTLPurgeableStateNonVolatile,
	MTLPurgeableStateVolatile,
	MTLPurgeableStateEmpty
}
declare enum MTLCPUCacheMode {
	MTLCPUCacheModeDefaultCache,
	MTLCPUCacheModeWriteCombined
}
declare enum MTLResourceOptions {
	MTLResourceOptionCPUCacheModeDefault,
	MTLResourceOptionCPUCacheModeWriteCombined
}
declare enum MTLFunctionType {
	MTLFunctionTypeVertex,
	MTLFunctionTypeFragment,
	MTLFunctionTypeKernel
}
declare enum MTLLibraryError {
	MTLLibraryErrorUnsupported,
	MTLLibraryErrorInternal,
	MTLLibraryErrorCompileFailure,
	MTLLibraryErrorCompileWarning
}
declare enum MTLRenderPipelineError {
	MTLRenderPipelineErrorInternal,
	MTLRenderPipelineErrorUnsupported,
	MTLRenderPipelineErrorInvalidInput
}
declare enum MTLFeatureSet {
	MTLFeatureSet_iOS_GPUFamily1_v1,
	MTLFeatureSet_iOS_GPUFamily2_v1
}
declare enum MTLPipelineOption {
	MTLPipelineOptionNone,
	MTLPipelineOptionArgumentInfo,
	MTLPipelineOptionBufferTypeInfo
}
declare enum MTLTextureType {
	MTLTextureType1D,
	MTLTextureType1DArray,
	MTLTextureType2D,
	MTLTextureType2DArray,
	MTLTextureType2DMultisample,
	MTLTextureTypeCube,
	MTLTextureType3D
}
declare enum MTLCommandBufferStatus {
	MTLCommandBufferStatusNotEnqueued,
	MTLCommandBufferStatusEnqueued,
	MTLCommandBufferStatusCommitted,
	MTLCommandBufferStatusScheduled,
	MTLCommandBufferStatusCompleted,
	MTLCommandBufferStatusError
}
declare enum MTLCommandBufferError {
	MTLCommandBufferErrorNone,
	MTLCommandBufferErrorInternal,
	MTLCommandBufferErrorTimeout,
	MTLCommandBufferErrorPageFault,
	MTLCommandBufferErrorBlacklisted,
	MTLCommandBufferErrorNotPermitted,
	MTLCommandBufferErrorOutOfMemory,
	MTLCommandBufferErrorInvalidResource
}
declare enum MTLCompareFunction {
	MTLCompareFunctionNever,
	MTLCompareFunctionLess,
	MTLCompareFunctionEqual,
	MTLCompareFunctionLessEqual,
	MTLCompareFunctionGreater,
	MTLCompareFunctionNotEqual,
	MTLCompareFunctionGreaterEqual,
	MTLCompareFunctionAlways
}
declare enum MTLStencilOperation {
	MTLStencilOperationKeep,
	MTLStencilOperationZero,
	MTLStencilOperationReplace,
	MTLStencilOperationIncrementClamp,
	MTLStencilOperationDecrementClamp,
	MTLStencilOperationInvert,
	MTLStencilOperationIncrementWrap,
	MTLStencilOperationDecrementWrap
}
declare enum MTLLoadAction {
	MTLLoadActionDontCare,
	MTLLoadActionLoad,
	MTLLoadActionClear
}
declare enum MTLStoreAction {
	MTLStoreActionDontCare,
	MTLStoreActionStore,
	MTLStoreActionMultisampleResolve
}
declare enum MTLDataType {
	MTLDataTypeNone,
	MTLDataTypeStruct,
	MTLDataTypeArray,
	MTLDataTypeFloat,
	MTLDataTypeFloat2,
	MTLDataTypeFloat3,
	MTLDataTypeFloat4,
	MTLDataTypeFloat2x2,
	MTLDataTypeFloat2x3,
	MTLDataTypeFloat2x4,
	MTLDataTypeFloat3x2,
	MTLDataTypeFloat3x3,
	MTLDataTypeFloat3x4,
	MTLDataTypeFloat4x2,
	MTLDataTypeFloat4x3,
	MTLDataTypeFloat4x4,
	MTLDataTypeHalf,
	MTLDataTypeHalf2,
	MTLDataTypeHalf3,
	MTLDataTypeHalf4,
	MTLDataTypeHalf2x2,
	MTLDataTypeHalf2x3,
	MTLDataTypeHalf2x4,
	MTLDataTypeHalf3x2,
	MTLDataTypeHalf3x3,
	MTLDataTypeHalf3x4,
	MTLDataTypeHalf4x2,
	MTLDataTypeHalf4x3,
	MTLDataTypeHalf4x4,
	MTLDataTypeInt,
	MTLDataTypeInt2,
	MTLDataTypeInt3,
	MTLDataTypeInt4,
	MTLDataTypeUInt,
	MTLDataTypeUInt2,
	MTLDataTypeUInt3,
	MTLDataTypeUInt4,
	MTLDataTypeShort,
	MTLDataTypeShort2,
	MTLDataTypeShort3,
	MTLDataTypeShort4,
	MTLDataTypeUShort,
	MTLDataTypeUShort2,
	MTLDataTypeUShort3,
	MTLDataTypeUShort4,
	MTLDataTypeChar,
	MTLDataTypeChar2,
	MTLDataTypeChar3,
	MTLDataTypeChar4,
	MTLDataTypeUChar,
	MTLDataTypeUChar2,
	MTLDataTypeUChar3,
	MTLDataTypeUChar4,
	MTLDataTypeBool,
	MTLDataTypeBool2,
	MTLDataTypeBool3,
	MTLDataTypeBool4
}
declare enum MTLArgumentType {
	MTLArgumentTypeBuffer,
	MTLArgumentTypeThreadgroupMemory,
	MTLArgumentTypeTexture,
	MTLArgumentTypeSampler
}
declare enum MTLArgumentAccess {
	MTLArgumentAccessReadOnly,
	MTLArgumentAccessReadWrite,
	MTLArgumentAccessWriteOnly
}
declare enum MTLBlendFactor {
	MTLBlendFactorZero,
	MTLBlendFactorOne,
	MTLBlendFactorSourceColor,
	MTLBlendFactorOneMinusSourceColor,
	MTLBlendFactorSourceAlpha,
	MTLBlendFactorOneMinusSourceAlpha,
	MTLBlendFactorDestinationColor,
	MTLBlendFactorOneMinusDestinationColor,
	MTLBlendFactorDestinationAlpha,
	MTLBlendFactorOneMinusDestinationAlpha,
	MTLBlendFactorSourceAlphaSaturated,
	MTLBlendFactorBlendColor,
	MTLBlendFactorOneMinusBlendColor,
	MTLBlendFactorBlendAlpha,
	MTLBlendFactorOneMinusBlendAlpha
}
declare enum MTLBlendOperation {
	MTLBlendOperationAdd,
	MTLBlendOperationSubtract,
	MTLBlendOperationReverseSubtract,
	MTLBlendOperationMin,
	MTLBlendOperationMax
}
declare enum MTLColorWriteMask {
	MTLColorWriteMaskNone,
	MTLColorWriteMaskRed,
	MTLColorWriteMaskGreen,
	MTLColorWriteMaskBlue,
	MTLColorWriteMaskAlpha,
	MTLColorWriteMaskAll
}
declare enum MTLVertexFormat {
	MTLVertexFormatInvalid,
	MTLVertexFormatUChar2,
	MTLVertexFormatUChar3,
	MTLVertexFormatUChar4,
	MTLVertexFormatChar2,
	MTLVertexFormatChar3,
	MTLVertexFormatChar4,
	MTLVertexFormatUChar2Normalized,
	MTLVertexFormatUChar3Normalized,
	MTLVertexFormatUChar4Normalized,
	MTLVertexFormatChar2Normalized,
	MTLVertexFormatChar3Normalized,
	MTLVertexFormatChar4Normalized,
	MTLVertexFormatUShort2,
	MTLVertexFormatUShort3,
	MTLVertexFormatUShort4,
	MTLVertexFormatShort2,
	MTLVertexFormatShort3,
	MTLVertexFormatShort4,
	MTLVertexFormatUShort2Normalized,
	MTLVertexFormatUShort3Normalized,
	MTLVertexFormatUShort4Normalized,
	MTLVertexFormatShort2Normalized,
	MTLVertexFormatShort3Normalized,
	MTLVertexFormatShort4Normalized,
	MTLVertexFormatHalf2,
	MTLVertexFormatHalf3,
	MTLVertexFormatHalf4,
	MTLVertexFormatFloat,
	MTLVertexFormatFloat2,
	MTLVertexFormatFloat3,
	MTLVertexFormatFloat4,
	MTLVertexFormatInt,
	MTLVertexFormatInt2,
	MTLVertexFormatInt3,
	MTLVertexFormatInt4,
	MTLVertexFormatUInt,
	MTLVertexFormatUInt2,
	MTLVertexFormatUInt3,
	MTLVertexFormatUInt4,
	MTLVertexFormatInt1010102Normalized,
	MTLVertexFormatUInt1010102Normalized
}
declare enum MTLVertexStepFunction {
	MTLVertexStepFunctionConstant,
	MTLVertexStepFunctionPerVertex,
	MTLVertexStepFunctionPerInstance
}
declare enum MTLPrimitiveType {
	MTLPrimitiveTypePoint,
	MTLPrimitiveTypeLine,
	MTLPrimitiveTypeLineStrip,
	MTLPrimitiveTypeTriangle,
	MTLPrimitiveTypeTriangleStrip
}
declare enum MTLIndexType {
	MTLIndexTypeUInt16,
	MTLIndexTypeUInt32
}
declare enum MTLVisibilityResultMode {
	MTLVisibilityResultModeDisabled,
	MTLVisibilityResultModeBoolean
}
declare enum MTLCullMode {
	MTLCullModeNone,
	MTLCullModeFront,
	MTLCullModeBack
}
declare enum MTLWinding {
	MTLWindingClockwise,
	MTLWindingCounterClockwise
}
declare enum MTLTriangleFillMode {
	MTLTriangleFillModeFill,
	MTLTriangleFillModeLines
}
declare enum MTLSamplerMinMagFilter {
	MTLSamplerMinMagFilterNearest,
	MTLSamplerMinMagFilterLinear
}
declare enum MTLSamplerMipFilter {
	MTLSamplerMipFilterNotMipmapped,
	MTLSamplerMipFilterNearest,
	MTLSamplerMipFilterLinear
}
declare enum MTLSamplerAddressMode {
	MTLSamplerAddressModeClampToEdge,
	MTLSamplerAddressModeRepeat,
	MTLSamplerAddressModeMirrorRepeat,
	MTLSamplerAddressModeClampToZero
}
declare enum CTTextAlignment {
	kCTTextAlignmentLeft,
	kCTTextAlignmentRight,
	kCTTextAlignmentCenter,
	kCTTextAlignmentJustified,
	kCTTextAlignmentNatural,
	kCTLeftTextAlignment,
	kCTRightTextAlignment,
	kCTCenterTextAlignment,
	kCTJustifiedTextAlignment,
	kCTNaturalTextAlignment
}
declare enum CTLineBreakMode {
	kCTLineBreakByWordWrapping,
	kCTLineBreakByCharWrapping,
	kCTLineBreakByClipping,
	kCTLineBreakByTruncatingHead,
	kCTLineBreakByTruncatingTail,
	kCTLineBreakByTruncatingMiddle
}
declare enum CTWritingDirection {
	kCTWritingDirectionNatural,
	kCTWritingDirectionLeftToRight,
	kCTWritingDirectionRightToLeft
}
declare enum CTParagraphStyleSpecifier {
	kCTParagraphStyleSpecifierAlignment,
	kCTParagraphStyleSpecifierFirstLineHeadIndent,
	kCTParagraphStyleSpecifierHeadIndent,
	kCTParagraphStyleSpecifierTailIndent,
	kCTParagraphStyleSpecifierTabStops,
	kCTParagraphStyleSpecifierDefaultTabInterval,
	kCTParagraphStyleSpecifierLineBreakMode,
	kCTParagraphStyleSpecifierLineHeightMultiple,
	kCTParagraphStyleSpecifierMaximumLineHeight,
	kCTParagraphStyleSpecifierMinimumLineHeight,
	kCTParagraphStyleSpecifierLineSpacing,
	kCTParagraphStyleSpecifierParagraphSpacing,
	kCTParagraphStyleSpecifierParagraphSpacingBefore,
	kCTParagraphStyleSpecifierBaseWritingDirection,
	kCTParagraphStyleSpecifierMaximumLineSpacing,
	kCTParagraphStyleSpecifierMinimumLineSpacing,
	kCTParagraphStyleSpecifierLineSpacingAdjustment,
	kCTParagraphStyleSpecifierLineBoundsOptions,
	kCTParagraphStyleSpecifierCount
}
declare enum CTFontSymbolicTraits {
	kCTFontTraitItalic,
	kCTFontTraitBold,
	kCTFontTraitExpanded,
	kCTFontTraitCondensed,
	kCTFontTraitMonoSpace,
	kCTFontTraitVertical,
	kCTFontTraitUIOptimized,
	kCTFontTraitColorGlyphs,
	kCTFontTraitComposite,
	kCTFontTraitClassMask,
	kCTFontItalicTrait,
	kCTFontBoldTrait,
	kCTFontExpandedTrait,
	kCTFontCondensedTrait,
	kCTFontMonoSpaceTrait,
	kCTFontVerticalTrait,
	kCTFontUIOptimizedTrait,
	kCTFontColorGlyphsTrait,
	kCTFontCompositeTrait,
	kCTFontClassMaskTrait
}
declare enum CTFontStylisticClass {
	kCTFontClassUnknown,
	kCTFontClassOldStyleSerifs,
	kCTFontClassTransitionalSerifs,
	kCTFontClassModernSerifs,
	kCTFontClassClarendonSerifs,
	kCTFontClassSlabSerifs,
	kCTFontClassFreeformSerifs,
	kCTFontClassSansSerif,
	kCTFontClassOrnamentals,
	kCTFontClassScripts,
	kCTFontClassSymbolic,
	kCTFontUnknownClass,
	kCTFontOldStyleSerifsClass,
	kCTFontTransitionalSerifsClass,
	kCTFontModernSerifsClass,
	kCTFontClarendonSerifsClass,
	kCTFontSlabSerifsClass,
	kCTFontFreeformSerifsClass,
	kCTFontSansSerifClass,
	kCTFontOrnamentalsClass,
	kCTFontScriptsClass,
	kCTFontSymbolicClass
}
declare enum CTFontOrientation {
	kCTFontOrientationDefault,
	kCTFontOrientationHorizontal,
	kCTFontOrientationVertical,
	kCTFontDefaultOrientation,
	kCTFontHorizontalOrientation,
	kCTFontVerticalOrientation
}
declare enum CTFontFormat {
	kCTFontFormatUnrecognized,
	kCTFontFormatOpenTypePostScript,
	kCTFontFormatOpenTypeTrueType,
	kCTFontFormatTrueType,
	kCTFontFormatPostScript,
	kCTFontFormatBitmap
}
declare enum CTFontDescriptorMatchingState {
	kCTFontDescriptorMatchingDidBegin,
	kCTFontDescriptorMatchingDidFinish,
	kCTFontDescriptorMatchingWillBeginQuerying,
	kCTFontDescriptorMatchingStalled,
	kCTFontDescriptorMatchingWillBeginDownloading,
	kCTFontDescriptorMatchingDownloading,
	kCTFontDescriptorMatchingDidFinishDownloading,
	kCTFontDescriptorMatchingDidMatch,
	kCTFontDescriptorMatchingDidFailWithError
}
declare enum CTFontOptions {
	kCTFontOptionsDefault,
	kCTFontOptionsPreventAutoActivation,
	kCTFontOptionsPreferSystemFont
}
declare enum CTFontUIFontType {
	kCTFontUIFontNone,
	kCTFontUIFontUser,
	kCTFontUIFontUserFixedPitch,
	kCTFontUIFontSystem,
	kCTFontUIFontEmphasizedSystem,
	kCTFontUIFontSmallSystem,
	kCTFontUIFontSmallEmphasizedSystem,
	kCTFontUIFontMiniSystem,
	kCTFontUIFontMiniEmphasizedSystem,
	kCTFontUIFontViews,
	kCTFontUIFontApplication,
	kCTFontUIFontLabel,
	kCTFontUIFontMenuTitle,
	kCTFontUIFontMenuItem,
	kCTFontUIFontMenuItemMark,
	kCTFontUIFontMenuItemCmdKey,
	kCTFontUIFontWindowTitle,
	kCTFontUIFontPushButton,
	kCTFontUIFontUtilityWindowTitle,
	kCTFontUIFontAlertHeader,
	kCTFontUIFontSystemDetail,
	kCTFontUIFontEmphasizedSystemDetail,
	kCTFontUIFontToolbar,
	kCTFontUIFontSmallToolbar,
	kCTFontUIFontMessage,
	kCTFontUIFontPalette,
	kCTFontUIFontToolTip,
	kCTFontUIFontControlContent,
	kCTFontNoFontType,
	kCTFontUserFontType,
	kCTFontUserFixedPitchFontType,
	kCTFontSystemFontType,
	kCTFontEmphasizedSystemFontType,
	kCTFontSmallSystemFontType,
	kCTFontSmallEmphasizedSystemFontType,
	kCTFontMiniSystemFontType,
	kCTFontMiniEmphasizedSystemFontType,
	kCTFontViewsFontType,
	kCTFontApplicationFontType,
	kCTFontLabelFontType,
	kCTFontMenuTitleFontType,
	kCTFontMenuItemFontType,
	kCTFontMenuItemMarkFontType,
	kCTFontMenuItemCmdKeyFontType,
	kCTFontWindowTitleFontType,
	kCTFontPushButtonFontType,
	kCTFontUtilityWindowTitleFontType,
	kCTFontAlertHeaderFontType,
	kCTFontSystemDetailFontType,
	kCTFontEmphasizedSystemDetailFontType,
	kCTFontToolbarFontType,
	kCTFontSmallToolbarFontType,
	kCTFontMessageFontType,
	kCTFontPaletteFontType,
	kCTFontToolTipFontType,
	kCTFontControlContentFontType
}
declare enum CTFontTableOptions {
	kCTFontTableOptionNoOptions,
	kCTFontTableOptionExcludeSynthetic
}
declare enum CTFontManagerError {
	kCTFontManagerErrorFileNotFound,
	kCTFontManagerErrorInsufficientPermissions,
	kCTFontManagerErrorUnrecognizedFormat,
	kCTFontManagerErrorInvalidFontData,
	kCTFontManagerErrorAlreadyRegistered,
	kCTFontManagerErrorNotRegistered,
	kCTFontManagerErrorInUse,
	kCTFontManagerErrorSystemRequired
}
declare enum CTFontManagerScope {
	kCTFontManagerScopeNone,
	kCTFontManagerScopeProcess,
	kCTFontManagerScopeUser,
	kCTFontManagerScopeSession
}
declare enum CTFontManagerAutoActivationSetting {
	kCTFontManagerAutoActivationDefault,
	kCTFontManagerAutoActivationDisabled,
	kCTFontManagerAutoActivationEnabled,
	kCTFontManagerAutoActivationPromptUser
}
declare enum CTFrameProgression {
	kCTFrameProgressionTopToBottom,
	kCTFrameProgressionRightToLeft,
	kCTFrameProgressionLeftToRight
}
declare enum CTFramePathFillRule {
	kCTFramePathFillEvenOdd,
	kCTFramePathFillWindingNumber
}
declare enum CTLineBoundsOptions {
	kCTLineBoundsExcludeTypographicLeading,
	kCTLineBoundsExcludeTypographicShifts,
	kCTLineBoundsUseHangingPunctuation,
	kCTLineBoundsUseGlyphPathBounds,
	kCTLineBoundsUseOpticalBounds,
	kCTLineBoundsIncludeLanguageExtents
}
declare enum CTLineTruncationType {
	kCTLineTruncationStart,
	kCTLineTruncationEnd,
	kCTLineTruncationMiddle
}
declare enum CTCharacterCollection {
	kCTCharacterCollectionIdentityMapping,
	kCTCharacterCollectionAdobeCNS1,
	kCTCharacterCollectionAdobeGB1,
	kCTCharacterCollectionAdobeJapan1,
	kCTCharacterCollectionAdobeJapan2,
	kCTCharacterCollectionAdobeKorea1,
	kCTIdentityMappingCharacterCollection,
	kCTAdobeCNS1CharacterCollection,
	kCTAdobeGB1CharacterCollection,
	kCTAdobeJapan1CharacterCollection,
	kCTAdobeJapan2CharacterCollection,
	kCTAdobeKorea1CharacterCollection
}
declare enum CTRubyAlignment {
	kCTRubyAlignmentInvalid,
	kCTRubyAlignmentAuto,
	kCTRubyAlignmentStart,
	kCTRubyAlignmentCenter,
	kCTRubyAlignmentEnd,
	kCTRubyAlignmentDistributeLetter,
	kCTRubyAlignmentDistributeSpace,
	kCTRubyAlignmentLineEdge
}
declare enum CTRubyOverhang {
	kCTRubyOverhangInvalid,
	kCTRubyOverhangAuto,
	kCTRubyOverhangStart,
	kCTRubyOverhangEnd,
	kCTRubyOverhangNone
}
declare enum CTRubyPosition {
	kCTRubyPositionBefore,
	kCTRubyPositionAfter,
	kCTRubyPositionInterCharacter,
	kCTRubyPositionInline,
	kCTRubyPositionCount
}
declare enum CTRunStatus {
	kCTRunStatusNoStatus,
	kCTRunStatusRightToLeft,
	kCTRunStatusNonMonotonic,
	kCTRunStatusHasNonIdentityMatrix
}
declare enum CTUnderlineStyle {
	kCTUnderlineStyleNone,
	kCTUnderlineStyleSingle,
	kCTUnderlineStyleThick,
	kCTUnderlineStyleDouble
}
declare enum CTUnderlineStyleModifiers {
	kCTUnderlinePatternSolid,
	kCTUnderlinePatternDot,
	kCTUnderlinePatternDash,
	kCTUnderlinePatternDashDot,
	kCTUnderlinePatternDashDotDot
}
declare enum CAEdgeAntialiasingMask {
	kCALayerLeftEdge,
	kCALayerRightEdge,
	kCALayerBottomEdge,
	kCALayerTopEdge
}
declare enum ALAssetOrientation {
	ALAssetOrientationUp,
	ALAssetOrientationDown,
	ALAssetOrientationLeft,
	ALAssetOrientationRight,
	ALAssetOrientationUpMirrored,
	ALAssetOrientationDownMirrored,
	ALAssetOrientationLeftMirrored,
	ALAssetOrientationRightMirrored
}
declare enum ALAuthorizationStatus {
	ALAuthorizationStatusNotDetermined,
	ALAuthorizationStatusRestricted,
	ALAuthorizationStatusDenied,
	ALAuthorizationStatusAuthorized
}
declare enum AVAudioUnitReverbPreset {
	AVAudioUnitReverbPresetSmallRoom,
	AVAudioUnitReverbPresetMediumRoom,
	AVAudioUnitReverbPresetLargeRoom,
	AVAudioUnitReverbPresetMediumHall,
	AVAudioUnitReverbPresetLargeHall,
	AVAudioUnitReverbPresetPlate,
	AVAudioUnitReverbPresetMediumChamber,
	AVAudioUnitReverbPresetLargeChamber,
	AVAudioUnitReverbPresetCathedral,
	AVAudioUnitReverbPresetLargeRoom2,
	AVAudioUnitReverbPresetMediumHall2,
	AVAudioUnitReverbPresetMediumHall3,
	AVAudioUnitReverbPresetLargeHall2
}
declare enum AVAudioUnitEQFilterType {
	AVAudioUnitEQFilterTypeParametric,
	AVAudioUnitEQFilterTypeLowPass,
	AVAudioUnitEQFilterTypeHighPass,
	AVAudioUnitEQFilterTypeResonantLowPass,
	AVAudioUnitEQFilterTypeResonantHighPass,
	AVAudioUnitEQFilterTypeBandPass,
	AVAudioUnitEQFilterTypeBandStop,
	AVAudioUnitEQFilterTypeLowShelf,
	AVAudioUnitEQFilterTypeHighShelf,
	AVAudioUnitEQFilterTypeResonantLowShelf,
	AVAudioUnitEQFilterTypeResonantHighShelf
}
declare enum AVAudio3DMixingRenderingAlgorithm {
	AVAudio3DMixingRenderingAlgorithmEqualPowerPanning,
	AVAudio3DMixingRenderingAlgorithmSphericalHead,
	AVAudio3DMixingRenderingAlgorithmHRTF,
	AVAudio3DMixingRenderingAlgorithmSoundField,
	AVAudio3DMixingRenderingAlgorithmStereoPassThrough
}
declare enum AVAudioEnvironmentDistanceAttenuationModel {
	AVAudioEnvironmentDistanceAttenuationModelExponential,
	AVAudioEnvironmentDistanceAttenuationModelInverse,
	AVAudioEnvironmentDistanceAttenuationModelLinear
}
declare enum AVAudioCommonFormat {
	AVAudioOtherFormat,
	AVAudioPCMFormatFloat32,
	AVAudioPCMFormatFloat64,
	AVAudioPCMFormatInt16,
	AVAudioPCMFormatInt32
}
declare enum AVAudioQuality {
	AVAudioQualityMin,
	AVAudioQualityLow,
	AVAudioQualityMedium,
	AVAudioQualityHigh,
	AVAudioQualityMax
}
declare enum AVAudioPlayerNodeBufferOptions {
	AVAudioPlayerNodeBufferLoops,
	AVAudioPlayerNodeBufferInterrupts,
	AVAudioPlayerNodeBufferInterruptsAtLoop
}
declare enum AVAudioSessionInterruptionOptions {
	AVAudioSessionInterruptionOptionShouldResume
}
declare enum AVAudioSessionSetActiveOptions {
	AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation
}
declare enum AVAudioSessionPortOverride {
	AVAudioSessionPortOverrideNone,
	AVAudioSessionPortOverrideSpeaker
}
declare enum AVAudioSessionRouteChangeReason {
	AVAudioSessionRouteChangeReasonUnknown,
	AVAudioSessionRouteChangeReasonNewDeviceAvailable,
	AVAudioSessionRouteChangeReasonOldDeviceUnavailable,
	AVAudioSessionRouteChangeReasonCategoryChange,
	AVAudioSessionRouteChangeReasonOverride,
	AVAudioSessionRouteChangeReasonWakeFromSleep,
	AVAudioSessionRouteChangeReasonNoSuitableRouteForCategory,
	AVAudioSessionRouteChangeReasonRouteConfigurationChange
}
declare enum AVAudioSessionCategoryOptions {
	AVAudioSessionCategoryOptionMixWithOthers,
	AVAudioSessionCategoryOptionDuckOthers,
	AVAudioSessionCategoryOptionAllowBluetooth,
	AVAudioSessionCategoryOptionDefaultToSpeaker
}
declare enum AVAudioSessionInterruptionType {
	AVAudioSessionInterruptionTypeBegan,
	AVAudioSessionInterruptionTypeEnded
}
declare enum AVAudioSessionSilenceSecondaryAudioHintType {
	AVAudioSessionSilenceSecondaryAudioHintTypeBegin,
	AVAudioSessionSilenceSecondaryAudioHintTypeEnd
}
declare enum AVAudioSessionRecordPermission {
	AVAudioSessionRecordPermissionUndetermined,
	AVAudioSessionRecordPermissionDenied,
	AVAudioSessionRecordPermissionGranted
}
declare enum AVAudioSessionErrorCode {
	AVAudioSessionErrorCodeNone,
	AVAudioSessionErrorCodeMediaServicesFailed,
	AVAudioSessionErrorCodeIsBusy,
	AVAudioSessionErrorCodeIncompatibleCategory,
	AVAudioSessionErrorCodeCannotInterruptOthers,
	AVAudioSessionErrorCodeMissingEntitlement,
	AVAudioSessionErrorCodeSiriIsRecording,
	AVAudioSessionErrorCodeCannotStartPlaying,
	AVAudioSessionErrorCodeCannotStartRecording,
	AVAudioSessionErrorCodeBadParam,
	AVAudioSessionErrorInsufficientPriority,
	AVAudioSessionErrorCodeUnspecified
}
declare enum AVAudioUnitDistortionPreset {
	AVAudioUnitDistortionPresetDrumsBitBrush,
	AVAudioUnitDistortionPresetDrumsBufferBeats,
	AVAudioUnitDistortionPresetDrumsLoFi,
	AVAudioUnitDistortionPresetMultiBrokenSpeaker,
	AVAudioUnitDistortionPresetMultiCellphoneConcert,
	AVAudioUnitDistortionPresetMultiDecimated1,
	AVAudioUnitDistortionPresetMultiDecimated2,
	AVAudioUnitDistortionPresetMultiDecimated3,
	AVAudioUnitDistortionPresetMultiDecimated4,
	AVAudioUnitDistortionPresetMultiDistortedFunk,
	AVAudioUnitDistortionPresetMultiDistortedCubed,
	AVAudioUnitDistortionPresetMultiDistortedSquared,
	AVAudioUnitDistortionPresetMultiEcho1,
	AVAudioUnitDistortionPresetMultiEcho2,
	AVAudioUnitDistortionPresetMultiEchoTight1,
	AVAudioUnitDistortionPresetMultiEchoTight2,
	AVAudioUnitDistortionPresetMultiEverythingIsBroken,
	AVAudioUnitDistortionPresetSpeechAlienChatter,
	AVAudioUnitDistortionPresetSpeechCosmicInterference,
	AVAudioUnitDistortionPresetSpeechGoldenPi,
	AVAudioUnitDistortionPresetSpeechRadioTower,
	AVAudioUnitDistortionPresetSpeechWaves
}
declare enum AVKeyValueStatus {
	AVKeyValueStatusUnknown,
	AVKeyValueStatusLoading,
	AVKeyValueStatusLoaded,
	AVKeyValueStatusFailed,
	AVKeyValueStatusCancelled
}
declare enum AVAssetReferenceRestrictions {
	AVAssetReferenceRestrictionForbidNone,
	AVAssetReferenceRestrictionForbidRemoteReferenceToLocal,
	AVAssetReferenceRestrictionForbidLocalReferenceToRemote,
	AVAssetReferenceRestrictionForbidCrossSiteReference,
	AVAssetReferenceRestrictionForbidLocalReferenceToLocal,
	AVAssetReferenceRestrictionForbidAll
}
declare enum AVAssetExportSessionStatus {
	AVAssetExportSessionStatusUnknown,
	AVAssetExportSessionStatusWaiting,
	AVAssetExportSessionStatusExporting,
	AVAssetExportSessionStatusCompleted,
	AVAssetExportSessionStatusFailed,
	AVAssetExportSessionStatusCancelled
}
declare enum AVAssetImageGeneratorResult {
	AVAssetImageGeneratorSucceeded,
	AVAssetImageGeneratorFailed,
	AVAssetImageGeneratorCancelled
}
declare enum AVAssetReaderStatus {
	AVAssetReaderStatusUnknown,
	AVAssetReaderStatusReading,
	AVAssetReaderStatusCompleted,
	AVAssetReaderStatusFailed,
	AVAssetReaderStatusCancelled
}
declare enum AVAssetWriterStatus {
	AVAssetWriterStatusUnknown,
	AVAssetWriterStatusWriting,
	AVAssetWriterStatusCompleted,
	AVAssetWriterStatusFailed,
	AVAssetWriterStatusCancelled
}
declare enum AVCaptureDevicePosition {
	AVCaptureDevicePositionUnspecified,
	AVCaptureDevicePositionBack,
	AVCaptureDevicePositionFront
}
declare enum AVCaptureFlashMode {
	AVCaptureFlashModeOff,
	AVCaptureFlashModeOn,
	AVCaptureFlashModeAuto
}
declare enum AVCaptureTorchMode {
	AVCaptureTorchModeOff,
	AVCaptureTorchModeOn,
	AVCaptureTorchModeAuto
}
declare enum AVCaptureFocusMode {
	AVCaptureFocusModeLocked,
	AVCaptureFocusModeAutoFocus,
	AVCaptureFocusModeContinuousAutoFocus
}
declare enum AVCaptureAutoFocusRangeRestriction {
	AVCaptureAutoFocusRangeRestrictionNone,
	AVCaptureAutoFocusRangeRestrictionNear,
	AVCaptureAutoFocusRangeRestrictionFar
}
declare enum AVCaptureExposureMode {
	AVCaptureExposureModeLocked,
	AVCaptureExposureModeAutoExpose,
	AVCaptureExposureModeContinuousAutoExposure,
	AVCaptureExposureModeCustom
}
declare enum AVCaptureWhiteBalanceMode {
	AVCaptureWhiteBalanceModeLocked,
	AVCaptureWhiteBalanceModeAutoWhiteBalance,
	AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance
}
declare enum AVAuthorizationStatus {
	AVAuthorizationStatusNotDetermined,
	AVAuthorizationStatusRestricted,
	AVAuthorizationStatusDenied,
	AVAuthorizationStatusAuthorized
}
declare enum AVCaptureVideoStabilizationMode {
	AVCaptureVideoStabilizationModeOff,
	AVCaptureVideoStabilizationModeStandard,
	AVCaptureVideoStabilizationModeCinematic,
	AVCaptureVideoStabilizationModeAuto
}
declare enum AVCaptureAutoFocusSystem {
	AVCaptureAutoFocusSystemNone,
	AVCaptureAutoFocusSystemContrastDetection,
	AVCaptureAutoFocusSystemPhaseDetection
}
declare enum AVCaptureVideoOrientation {
	AVCaptureVideoOrientationPortrait,
	AVCaptureVideoOrientationPortraitUpsideDown,
	AVCaptureVideoOrientationLandscapeRight,
	AVCaptureVideoOrientationLandscapeLeft
}
declare enum AVError {
	AVErrorUnknown,
	AVErrorOutOfMemory,
	AVErrorSessionNotRunning,
	AVErrorDeviceAlreadyUsedByAnotherSession,
	AVErrorNoDataCaptured,
	AVErrorSessionConfigurationChanged,
	AVErrorDiskFull,
	AVErrorDeviceWasDisconnected,
	AVErrorMediaChanged,
	AVErrorMaximumDurationReached,
	AVErrorMaximumFileSizeReached,
	AVErrorMediaDiscontinuity,
	AVErrorMaximumNumberOfSamplesForFileFormatReached,
	AVErrorDeviceNotConnected,
	AVErrorDeviceInUseByAnotherApplication,
	AVErrorDeviceLockedForConfigurationByAnotherProcess,
	AVErrorSessionWasInterrupted,
	AVErrorMediaServicesWereReset,
	AVErrorExportFailed,
	AVErrorDecodeFailed,
	AVErrorInvalidSourceMedia,
	AVErrorFileAlreadyExists,
	AVErrorCompositionTrackSegmentsNotContiguous,
	AVErrorInvalidCompositionTrackSegmentDuration,
	AVErrorInvalidCompositionTrackSegmentSourceStartTime,
	AVErrorInvalidCompositionTrackSegmentSourceDuration,
	AVErrorFileFormatNotRecognized,
	AVErrorFileFailedToParse,
	AVErrorMaximumStillImageCaptureRequestsExceeded,
	AVErrorContentIsProtected,
	AVErrorNoImageAtTime,
	AVErrorDecoderNotFound,
	AVErrorEncoderNotFound,
	AVErrorContentIsNotAuthorized,
	AVErrorApplicationIsNotAuthorized,
	AVErrorDeviceIsNotAvailableInBackground,
	AVErrorOperationNotSupportedForAsset,
	AVErrorDecoderTemporarilyUnavailable,
	AVErrorEncoderTemporarilyUnavailable,
	AVErrorInvalidVideoComposition,
	AVErrorReferenceForbiddenByReferencePolicy,
	AVErrorInvalidOutputURLPathExtension,
	AVErrorScreenCaptureFailed,
	AVErrorDisplayWasDisabled,
	AVErrorTorchLevelUnavailable,
	AVErrorOperationInterrupted,
	AVErrorIncompatibleAsset,
	AVErrorFailedToLoadMediaData,
	AVErrorServerIncorrectlyConfigured,
	AVErrorApplicationIsNotAuthorizedToUseDevice,
	AVErrorFailedToParse,
	AVErrorFileTypeDoesNotSupportSampleReferences,
	AVErrorUndecodableMediaData
}
declare enum AVPlayerStatus {
	AVPlayerStatusUnknown,
	AVPlayerStatusReadyToPlay,
	AVPlayerStatusFailed
}
declare enum AVPlayerActionAtItemEnd {
	AVPlayerActionAtItemEndAdvance,
	AVPlayerActionAtItemEndPause,
	AVPlayerActionAtItemEndNone
}
declare enum AVPlayerItemStatus {
	AVPlayerItemStatusUnknown,
	AVPlayerItemStatusReadyToPlay,
	AVPlayerItemStatusFailed
}
declare enum AVQueuedSampleBufferRenderingStatus {
	AVQueuedSampleBufferRenderingStatusUnknown,
	AVQueuedSampleBufferRenderingStatusRendering,
	AVQueuedSampleBufferRenderingStatusFailed
}
declare enum AVSpeechBoundary {
	AVSpeechBoundaryImmediate,
	AVSpeechBoundaryWord
}
declare enum CMTimeFlags {
	kCMTimeFlags_Valid,
	kCMTimeFlags_HasBeenRounded,
	kCMTimeFlags_PositiveInfinity,
	kCMTimeFlags_NegativeInfinity,
	kCMTimeFlags_Indefinite,
	kCMTimeFlags_ImpliedValueFlagsMask
}
declare enum CMTimeRoundingMethod {
	kCMTimeRoundingMethod_RoundHalfAwayFromZero,
	kCMTimeRoundingMethod_RoundTowardZero,
	kCMTimeRoundingMethod_RoundAwayFromZero,
	kCMTimeRoundingMethod_QuickTime,
	kCMTimeRoundingMethod_RoundTowardPositiveInfinity,
	kCMTimeRoundingMethod_RoundTowardNegativeInfinity,
	kCMTimeRoundingMethod_Default
}
declare enum CKAccountStatus {
	CKAccountStatusCouldNotDetermine,
	CKAccountStatusAvailable,
	CKAccountStatusRestricted,
	CKAccountStatusNoAccount
}
declare enum CKApplicationPermissions {
	CKApplicationPermissionUserDiscoverability
}
declare enum CKApplicationPermissionStatus {
	CKApplicationPermissionStatusInitialState,
	CKApplicationPermissionStatusCouldNotComplete,
	CKApplicationPermissionStatusDenied,
	CKApplicationPermissionStatusGranted
}
declare enum CKErrorCode {
	CKErrorInternalError,
	CKErrorPartialFailure,
	CKErrorNetworkUnavailable,
	CKErrorNetworkFailure,
	CKErrorBadContainer,
	CKErrorServiceUnavailable,
	CKErrorRequestRateLimited,
	CKErrorMissingEntitlement,
	CKErrorNotAuthenticated,
	CKErrorPermissionFailure,
	CKErrorUnknownItem,
	CKErrorInvalidArguments,
	CKErrorResultsTruncated,
	CKErrorServerRecordChanged,
	CKErrorServerRejectedRequest,
	CKErrorAssetFileNotFound,
	CKErrorAssetFileModified,
	CKErrorIncompatibleVersion,
	CKErrorConstraintViolation,
	CKErrorOperationCancelled,
	CKErrorChangeTokenExpired,
	CKErrorBatchRequestFailed,
	CKErrorZoneBusy,
	CKErrorBadDatabase,
	CKErrorQuotaExceeded,
	CKErrorZoneNotFound,
	CKErrorLimitExceeded,
	CKErrorUserDeletedZone
}
declare enum CKNotificationType {
	CKNotificationTypeQuery,
	CKNotificationTypeRecordZone,
	CKNotificationTypeReadNotification
}
declare enum CKQueryNotificationReason {
	CKQueryNotificationReasonRecordCreated,
	CKQueryNotificationReasonRecordUpdated,
	CKQueryNotificationReasonRecordDeleted
}
declare enum CKRecordZoneCapabilities {
	CKRecordZoneCapabilityFetchChanges,
	CKRecordZoneCapabilityAtomic
}
declare enum CKReferenceAction {
	CKReferenceActionNone,
	CKReferenceActionDeleteSelf
}
declare enum CKSubscriptionType {
	CKSubscriptionTypeQuery,
	CKSubscriptionTypeRecordZone
}
declare enum CKSubscriptionOptions {
	CKSubscriptionOptionsFiresOnRecordCreation,
	CKSubscriptionOptionsFiresOnRecordUpdate,
	CKSubscriptionOptionsFiresOnRecordDeletion,
	CKSubscriptionOptionsFiresOnce
}
declare enum CKRecordSavePolicy {
	CKRecordSaveIfServerRecordUnchanged,
	CKRecordSaveChangedKeys,
	CKRecordSaveAllKeys
}
declare enum CLError {
	kCLErrorLocationUnknown,
	kCLErrorDenied,
	kCLErrorNetwork,
	kCLErrorHeadingFailure,
	kCLErrorRegionMonitoringDenied,
	kCLErrorRegionMonitoringFailure,
	kCLErrorRegionMonitoringSetupDelayed,
	kCLErrorRegionMonitoringResponseDelayed,
	kCLErrorGeocodeFoundNoResult,
	kCLErrorGeocodeFoundPartialResult,
	kCLErrorGeocodeCanceled,
	kCLErrorDeferredFailed,
	kCLErrorDeferredNotUpdatingLocation,
	kCLErrorDeferredAccuracyTooLow,
	kCLErrorDeferredDistanceFiltered,
	kCLErrorDeferredCanceled,
	kCLErrorRangingUnavailable,
	kCLErrorRangingFailure
}
declare enum CLRegionState {
	CLRegionStateUnknown,
	CLRegionStateInside,
	CLRegionStateOutside
}
declare enum CLProximity {
	CLProximityUnknown,
	CLProximityImmediate,
	CLProximityNear,
	CLProximityFar
}
declare enum CLDeviceOrientation {
	CLDeviceOrientationUnknown,
	CLDeviceOrientationPortrait,
	CLDeviceOrientationPortraitUpsideDown,
	CLDeviceOrientationLandscapeLeft,
	CLDeviceOrientationLandscapeRight,
	CLDeviceOrientationFaceUp,
	CLDeviceOrientationFaceDown
}
declare enum CLAuthorizationStatus {
	kCLAuthorizationStatusNotDetermined,
	kCLAuthorizationStatusRestricted,
	kCLAuthorizationStatusDenied,
	kCLAuthorizationStatusAuthorized,
	kCLAuthorizationStatusAuthorizedAlways,
	kCLAuthorizationStatusAuthorizedWhenInUse
}
declare enum CLActivityType {
	CLActivityTypeOther,
	CLActivityTypeAutomotiveNavigation,
	CLActivityTypeFitness,
	CLActivityTypeOtherNavigation
}
declare enum CBCentralManagerState {
	CBCentralManagerStateUnknown,
	CBCentralManagerStateResetting,
	CBCentralManagerStateUnsupported,
	CBCentralManagerStateUnauthorized,
	CBCentralManagerStatePoweredOff,
	CBCentralManagerStatePoweredOn
}
declare enum CBError {
	CBErrorUnknown,
	CBErrorInvalidParameters,
	CBErrorInvalidHandle,
	CBErrorNotConnected,
	CBErrorOutOfSpace,
	CBErrorOperationCancelled,
	CBErrorConnectionTimeout,
	CBErrorPeripheralDisconnected,
	CBErrorUUIDNotAllowed,
	CBErrorAlreadyAdvertising,
	CBErrorConnectionFailed
}
declare enum CBATTError {
	CBATTErrorSuccess,
	CBATTErrorInvalidHandle,
	CBATTErrorReadNotPermitted,
	CBATTErrorWriteNotPermitted,
	CBATTErrorInvalidPdu,
	CBATTErrorInsufficientAuthentication,
	CBATTErrorRequestNotSupported,
	CBATTErrorInvalidOffset,
	CBATTErrorInsufficientAuthorization,
	CBATTErrorPrepareQueueFull,
	CBATTErrorAttributeNotFound,
	CBATTErrorAttributeNotLong,
	CBATTErrorInsufficientEncryptionKeySize,
	CBATTErrorInvalidAttributeValueLength,
	CBATTErrorUnlikelyError,
	CBATTErrorInsufficientEncryption,
	CBATTErrorUnsupportedGroupType,
	CBATTErrorInsufficientResources
}
declare enum CBPeripheralManagerAuthorizationStatus {
	CBPeripheralManagerAuthorizationStatusNotDetermined,
	CBPeripheralManagerAuthorizationStatusRestricted,
	CBPeripheralManagerAuthorizationStatusDenied,
	CBPeripheralManagerAuthorizationStatusAuthorized
}
declare enum CBPeripheralManagerState {
	CBPeripheralManagerStateUnknown,
	CBPeripheralManagerStateResetting,
	CBPeripheralManagerStateUnsupported,
	CBPeripheralManagerStateUnauthorized,
	CBPeripheralManagerStatePoweredOff,
	CBPeripheralManagerStatePoweredOn
}
declare enum CBPeripheralManagerConnectionLatency {
	CBPeripheralManagerConnectionLatencyLow,
	CBPeripheralManagerConnectionLatencyMedium,
	CBPeripheralManagerConnectionLatencyHigh
}
declare enum CBPeripheralState {
	CBPeripheralStateDisconnected,
	CBPeripheralStateConnecting,
	CBPeripheralStateConnected
}
declare enum CBCharacteristicWriteType {
	CBCharacteristicWriteWithResponse,
	CBCharacteristicWriteWithoutResponse
}
declare enum CBCharacteristicProperties {
	CBCharacteristicPropertyBroadcast,
	CBCharacteristicPropertyRead,
	CBCharacteristicPropertyWriteWithoutResponse,
	CBCharacteristicPropertyWrite,
	CBCharacteristicPropertyNotify,
	CBCharacteristicPropertyIndicate,
	CBCharacteristicPropertyAuthenticatedSignedWrites,
	CBCharacteristicPropertyExtendedProperties,
	CBCharacteristicPropertyNotifyEncryptionRequired,
	CBCharacteristicPropertyIndicateEncryptionRequired
}
declare enum CBAttributePermissions {
	CBAttributePermissionsReadable,
	CBAttributePermissionsWriteable,
	CBAttributePermissionsReadEncryptionRequired,
	CBAttributePermissionsWriteEncryptionRequired
}
declare enum CMAttitudeReferenceFrame {
	CMAttitudeReferenceFrameXArbitraryZVertical,
	CMAttitudeReferenceFrameXArbitraryCorrectedZVertical,
	CMAttitudeReferenceFrameXMagneticNorthZVertical,
	CMAttitudeReferenceFrameXTrueNorthZVertical
}
declare enum CMMagneticFieldCalibrationAccuracy {
	CMMagneticFieldCalibrationAccuracyUncalibrated,
	CMMagneticFieldCalibrationAccuracyLow,
	CMMagneticFieldCalibrationAccuracyMedium,
	CMMagneticFieldCalibrationAccuracyHigh
}
declare enum CMError {
	CMErrorNULL,
	CMErrorDeviceRequiresMovement,
	CMErrorTrueNorthNotAvailable,
	CMErrorUnknown,
	CMErrorMotionActivityNotAvailable,
	CMErrorMotionActivityNotAuthorized,
	CMErrorMotionActivityNotEntitled,
	CMErrorInvalidParameter
}
declare enum CMMotionActivityConfidence {
	CMMotionActivityConfidenceLow,
	CMMotionActivityConfidenceMedium,
	CMMotionActivityConfidenceHigh
}
declare enum EKAuthorizationStatus {
	EKAuthorizationStatusNotDetermined,
	EKAuthorizationStatusRestricted,
	EKAuthorizationStatusDenied,
	EKAuthorizationStatusAuthorized
}
declare enum EKRecurrenceFrequency {
	EKRecurrenceFrequencyDaily,
	EKRecurrenceFrequencyWeekly,
	EKRecurrenceFrequencyMonthly,
	EKRecurrenceFrequencyYearly
}
declare enum EKParticipantType {
	EKParticipantTypeUnknown,
	EKParticipantTypePerson,
	EKParticipantTypeRoom,
	EKParticipantTypeResource,
	EKParticipantTypeGroup
}
declare enum EKParticipantRole {
	EKParticipantRoleUnknown,
	EKParticipantRoleRequired,
	EKParticipantRoleOptional,
	EKParticipantRoleChair,
	EKParticipantRoleNonParticipant
}
declare enum EKParticipantStatus {
	EKParticipantStatusUnknown,
	EKParticipantStatusPending,
	EKParticipantStatusAccepted,
	EKParticipantStatusDeclined,
	EKParticipantStatusTentative,
	EKParticipantStatusDelegated,
	EKParticipantStatusCompleted,
	EKParticipantStatusInProcess
}
declare enum EKCalendarType {
	EKCalendarTypeLocal,
	EKCalendarTypeCalDAV,
	EKCalendarTypeExchange,
	EKCalendarTypeSubscription,
	EKCalendarTypeBirthday
}
declare enum EKSourceType {
	EKSourceTypeLocal,
	EKSourceTypeExchange,
	EKSourceTypeCalDAV,
	EKSourceTypeMobileMe,
	EKSourceTypeSubscribed,
	EKSourceTypeBirthdays
}
declare enum EKSpan {
	EKSpanThisEvent,
	EKSpanFutureEvents
}
declare enum EKErrorCode {
	EKErrorEventNotMutable,
	EKErrorNoCalendar,
	EKErrorNoStartDate,
	EKErrorNoEndDate,
	EKErrorDatesInverted,
	EKErrorInternalFailure,
	EKErrorCalendarReadOnly,
	EKErrorDurationGreaterThanRecurrence,
	EKErrorAlarmGreaterThanRecurrence,
	EKErrorStartDateTooFarInFuture,
	EKErrorStartDateCollidesWithOtherOccurrence,
	EKErrorObjectBelongsToDifferentStore,
	EKErrorInvitesCannotBeMoved,
	EKErrorInvalidSpan,
	EKErrorCalendarHasNoSource,
	EKErrorCalendarSourceCannotBeModified,
	EKErrorCalendarIsImmutable,
	EKErrorSourceDoesNotAllowCalendarAddDelete,
	EKErrorRecurringReminderRequiresDueDate,
	EKErrorStructuredLocationsNotSupported,
	EKErrorReminderLocationsNotSupported,
	EKErrorAlarmProximityNotSupported,
	EKErrorCalendarDoesNotAllowEvents,
	EKErrorCalendarDoesNotAllowReminders,
	EKErrorSourceDoesNotAllowReminders,
	EKErrorPriorityIsInvalid,
	EKErrorInvalidEntityType,
	EKErrorLast
}
declare enum EKEventAvailability {
	EKEventAvailabilityNotSupported,
	EKEventAvailabilityBusy,
	EKEventAvailabilityFree,
	EKEventAvailabilityTentative,
	EKEventAvailabilityUnavailable
}
declare enum EKEventStatus {
	EKEventStatusNone,
	EKEventStatusConfirmed,
	EKEventStatusTentative,
	EKEventStatusCanceled
}
declare enum EKEventEditViewAction {
	EKEventEditViewActionCanceled,
	EKEventEditViewActionSaved,
	EKEventEditViewActionDeleted,
	EKEventEditViewActionCancelled
}
declare enum EKEventViewAction {
	EKEventViewActionDone,
	EKEventViewActionResponded,
	EKEventViewActionDeleted
}
declare enum EKCalendarChooserSelectionStyle {
	EKCalendarChooserSelectionStyleSingle,
	EKCalendarChooserSelectionStyleMultiple
}
declare enum EKCalendarChooserDisplayStyle {
	EKCalendarChooserDisplayAllCalendars,
	EKCalendarChooserDisplayWritableCalendarsOnly
}
declare enum GKLeaderboardTimeScope {
	GKLeaderboardTimeScopeToday,
	GKLeaderboardTimeScopeWeek,
	GKLeaderboardTimeScopeAllTime
}
declare enum GKLeaderboardPlayerScope {
	GKLeaderboardPlayerScopeGlobal,
	GKLeaderboardPlayerScopeFriendsOnly
}
declare enum GKGameCenterViewControllerState {
	GKGameCenterViewControllerStateDefault,
	GKGameCenterViewControllerStateLeaderboards,
	GKGameCenterViewControllerStateAchievements,
	GKGameCenterViewControllerStateChallenges
}
declare enum GKChallengeState {
	GKChallengeStateInvalid,
	GKChallengeStatePending,
	GKChallengeStateCompleted,
	GKChallengeStateDeclined
}
declare enum GKErrorCode {
	GKErrorUnknown,
	GKErrorCancelled,
	GKErrorCommunicationsFailure,
	GKErrorUserDenied,
	GKErrorInvalidCredentials,
	GKErrorNotAuthenticated,
	GKErrorAuthenticationInProgress,
	GKErrorInvalidPlayer,
	GKErrorScoreNotSet,
	GKErrorParentalControlsBlocked,
	GKErrorPlayerStatusExceedsMaximumLength,
	GKErrorPlayerStatusInvalid,
	GKErrorMatchRequestInvalid,
	GKErrorUnderage,
	GKErrorGameUnrecognized,
	GKErrorNotSupported,
	GKErrorInvalidParameter,
	GKErrorUnexpectedConnection,
	GKErrorChallengeInvalid,
	GKErrorTurnBasedMatchDataTooLarge,
	GKErrorTurnBasedTooManySessions,
	GKErrorTurnBasedInvalidParticipant,
	GKErrorTurnBasedInvalidTurn,
	GKErrorTurnBasedInvalidState,
	GKErrorInvitationsDisabled,
	GKErrorPlayerPhotoFailure,
	GKErrorUbiquityContainerUnavailable
}
declare enum GKTurnBasedMatchStatus {
	GKTurnBasedMatchStatusUnknown,
	GKTurnBasedMatchStatusOpen,
	GKTurnBasedMatchStatusEnded,
	GKTurnBasedMatchStatusMatching
}
declare enum GKTurnBasedParticipantStatus {
	GKTurnBasedParticipantStatusUnknown,
	GKTurnBasedParticipantStatusInvited,
	GKTurnBasedParticipantStatusDeclined,
	GKTurnBasedParticipantStatusMatching,
	GKTurnBasedParticipantStatusActive,
	GKTurnBasedParticipantStatusDone
}
declare enum GKTurnBasedMatchOutcome {
	GKTurnBasedMatchOutcomeNone,
	GKTurnBasedMatchOutcomeQuit,
	GKTurnBasedMatchOutcomeWon,
	GKTurnBasedMatchOutcomeLost,
	GKTurnBasedMatchOutcomeTied,
	GKTurnBasedMatchOutcomeTimeExpired,
	GKTurnBasedMatchOutcomeFirst,
	GKTurnBasedMatchOutcomeSecond,
	GKTurnBasedMatchOutcomeThird,
	GKTurnBasedMatchOutcomeFourth,
	GKTurnBasedMatchOutcomeCustomRange
}
declare enum GKTurnBasedExchangeStatus {
	GKTurnBasedExchangeStatusUnknown,
	GKTurnBasedExchangeStatusActive,
	GKTurnBasedExchangeStatusComplete,
	GKTurnBasedExchangeStatusResolved,
	GKTurnBasedExchangeStatusCanceled
}
declare enum GKInviteRecipientResponse {
	GKInviteRecipientResponseAccepted,
	GKInviteRecipientResponseDeclined,
	GKInviteRecipientResponseFailed,
	GKInviteRecipientResponseIncompatible,
	GKInviteRecipientResponseUnableToConnect,
	GKInviteRecipientResponseNoAnswer,
	GKInviteeResponseAccepted,
	GKInviteeResponseDeclined,
	GKInviteeResponseFailed,
	GKInviteeResponseIncompatible,
	GKInviteeResponseUnableToConnect,
	GKInviteeResponseNoAnswer
}
declare enum GKMatchType {
	GKMatchTypePeerToPeer,
	GKMatchTypeHosted,
	GKMatchTypeTurnBased
}
declare enum GKMatchSendDataMode {
	GKMatchSendDataReliable,
	GKMatchSendDataUnreliable
}
declare enum GKPlayerConnectionState {
	GKPlayerStateUnknown,
	GKPlayerStateConnected,
	GKPlayerStateDisconnected
}
declare enum GKSendDataMode {
	GKSendDataReliable,
	GKSendDataUnreliable
}
declare enum GKSessionMode {
	GKSessionModeServer,
	GKSessionModeClient,
	GKSessionModePeer
}
declare enum GKPeerConnectionState {
	GKPeerStateAvailable,
	GKPeerStateUnavailable,
	GKPeerStateConnected,
	GKPeerStateDisconnected,
	GKPeerStateConnecting
}
declare enum GKVoiceChatServiceError {
	GKVoiceChatServiceInternalError,
	GKVoiceChatServiceNoRemotePacketsError,
	GKVoiceChatServiceUnableToConnectError,
	GKVoiceChatServiceRemoteParticipantHangupError,
	GKVoiceChatServiceInvalidCallIDError,
	GKVoiceChatServiceAudioUnavailableError,
	GKVoiceChatServiceUninitializedClientError,
	GKVoiceChatServiceClientMissingRequiredMethodsError,
	GKVoiceChatServiceRemoteParticipantBusyError,
	GKVoiceChatServiceRemoteParticipantCancelledError,
	GKVoiceChatServiceRemoteParticipantResponseInvalidError,
	GKVoiceChatServiceRemoteParticipantDeclinedInviteError,
	GKVoiceChatServiceMethodCurrentlyInvalidError,
	GKVoiceChatServiceNetworkConfigurationError,
	GKVoiceChatServiceUnsupportedRemoteVersionError,
	GKVoiceChatServiceOutOfMemoryError,
	GKVoiceChatServiceInvalidParameterError
}
declare enum GKSessionError {
	GKSessionInvalidParameterError,
	GKSessionPeerNotFoundError,
	GKSessionDeclinedError,
	GKSessionTimedOutError,
	GKSessionCancelledError,
	GKSessionConnectionFailedError,
	GKSessionConnectionClosedError,
	GKSessionDataTooBigError,
	GKSessionNotConnectedError,
	GKSessionCannotEnableError,
	GKSessionInProgressError,
	GKSessionConnectivityError,
	GKSessionTransportError,
	GKSessionInternalError,
	GKSessionUnknownError,
	GKSessionSystemError
}
declare enum GKVoiceChatPlayerState {
	GKVoiceChatPlayerConnected,
	GKVoiceChatPlayerDisconnected,
	GKVoiceChatPlayerSpeaking,
	GKVoiceChatPlayerSilent,
	GKVoiceChatPlayerConnecting
}
declare enum GLKViewDrawableColorFormat {
	GLKViewDrawableColorFormatRGBA8888,
	GLKViewDrawableColorFormatRGB565,
	GLKViewDrawableColorFormatSRGBA8888
}
declare enum GLKViewDrawableDepthFormat {
	GLKViewDrawableDepthFormatNone,
	GLKViewDrawableDepthFormat16,
	GLKViewDrawableDepthFormat24
}
declare enum GLKViewDrawableStencilFormat {
	GLKViewDrawableStencilFormatNone,
	GLKViewDrawableStencilFormat8
}
declare enum GLKViewDrawableMultisample {
	GLKViewDrawableMultisampleNone,
	GLKViewDrawableMultisample4X
}
declare enum GLKLightingType {
	GLKLightingTypePerVertex,
	GLKLightingTypePerPixel
}
declare enum GLKTextureTarget {
	GLKTextureTarget2D,
	GLKTextureTargetCubeMap,
	GLKTextureTargetCt
}
declare enum GLKTextureEnvMode {
	GLKTextureEnvModeReplace,
	GLKTextureEnvModeModulate,
	GLKTextureEnvModeDecal
}
declare enum GLKFogMode {
	GLKFogModeExp,
	GLKFogModeExp2,
	GLKFogModeLinear
}
declare enum GLKVertexAttrib {
	GLKVertexAttribPosition,
	GLKVertexAttribNormal,
	GLKVertexAttribColor,
	GLKVertexAttribTexCoord0,
	GLKVertexAttribTexCoord1
}
declare enum GLKTextureLoaderError {
	GLKTextureLoaderErrorFileOrURLNotFound,
	GLKTextureLoaderErrorInvalidNSData,
	GLKTextureLoaderErrorInvalidCGImage,
	GLKTextureLoaderErrorUnknownPathType,
	GLKTextureLoaderErrorUnknownFileType,
	GLKTextureLoaderErrorPVRAtlasUnsupported,
	GLKTextureLoaderErrorCubeMapInvalidNumFiles,
	GLKTextureLoaderErrorCompressedTextureUpload,
	GLKTextureLoaderErrorUncompressedTextureUpload,
	GLKTextureLoaderErrorUnsupportedCubeMapDimensions,
	GLKTextureLoaderErrorUnsupportedBitDepth,
	GLKTextureLoaderErrorUnsupportedPVRFormat,
	GLKTextureLoaderErrorDataPreprocessingFailure,
	GLKTextureLoaderErrorMipmapUnsupported,
	GLKTextureLoaderErrorUnsupportedOrientation,
	GLKTextureLoaderErrorReorientationFailure,
	GLKTextureLoaderErrorAlphaPremultiplicationFailure,
	GLKTextureLoaderErrorInvalidEAGLContext,
	GLKTextureLoaderErrorIncompatibleFormatSRGB
}
declare enum GLKTextureInfoAlphaState {
	GLKTextureInfoAlphaStateNone,
	GLKTextureInfoAlphaStateNonPremultiplied,
	GLKTextureInfoAlphaStatePremultiplied
}
declare enum GLKTextureInfoOrigin {
	GLKTextureInfoOriginUnknown,
	GLKTextureInfoOriginTopLeft,
	GLKTextureInfoOriginBottomLeft
}
declare enum HKErrorCode {
	HKNoError,
	HKErrorHealthDataUnavailable,
	HKErrorHealthDataRestricted,
	HKErrorInvalidArgument,
	HKErrorAuthorizationDenied,
	HKErrorAuthorizationNotDetermined,
	HKErrorDatabaseInaccessible,
	HKErrorUserCanceled
}
declare enum HKUpdateFrequency {
	HKUpdateFrequencyImmediate,
	HKUpdateFrequencyHourly,
	HKUpdateFrequencyDaily,
	HKUpdateFrequencyWeekly
}
declare enum HKAuthorizationStatus {
	HKAuthorizationStatusNotDetermined,
	HKAuthorizationStatusSharingDenied,
	HKAuthorizationStatusSharingAuthorized
}
declare enum HKBiologicalSex {
	HKBiologicalSexNotSet,
	HKBiologicalSexFemale,
	HKBiologicalSexMale
}
declare enum HKBloodType {
	HKBloodTypeNotSet,
	HKBloodTypeAPositive,
	HKBloodTypeANegative,
	HKBloodTypeBPositive,
	HKBloodTypeBNegative,
	HKBloodTypeABPositive,
	HKBloodTypeABNegative,
	HKBloodTypeOPositive,
	HKBloodTypeONegative
}
declare enum HKCategoryValueSleepAnalysis {
	HKCategoryValueSleepAnalysisInBed,
	HKCategoryValueSleepAnalysisAsleep
}
declare enum HKWorkoutActivityType {
	HKWorkoutActivityTypeAmericanFootball,
	HKWorkoutActivityTypeArchery,
	HKWorkoutActivityTypeAustralianFootball,
	HKWorkoutActivityTypeBadminton,
	HKWorkoutActivityTypeBaseball,
	HKWorkoutActivityTypeBasketball,
	HKWorkoutActivityTypeBowling,
	HKWorkoutActivityTypeBoxing,
	HKWorkoutActivityTypeClimbing,
	HKWorkoutActivityTypeCricket,
	HKWorkoutActivityTypeCrossTraining,
	HKWorkoutActivityTypeCurling,
	HKWorkoutActivityTypeCycling,
	HKWorkoutActivityTypeDance,
	HKWorkoutActivityTypeDanceInspiredTraining,
	HKWorkoutActivityTypeElliptical,
	HKWorkoutActivityTypeEquestrianSports,
	HKWorkoutActivityTypeFencing,
	HKWorkoutActivityTypeFishing,
	HKWorkoutActivityTypeFunctionalStrengthTraining,
	HKWorkoutActivityTypeGolf,
	HKWorkoutActivityTypeGymnastics,
	HKWorkoutActivityTypeHandball,
	HKWorkoutActivityTypeHiking,
	HKWorkoutActivityTypeHockey,
	HKWorkoutActivityTypeHunting,
	HKWorkoutActivityTypeLacrosse,
	HKWorkoutActivityTypeMartialArts,
	HKWorkoutActivityTypeMindAndBody,
	HKWorkoutActivityTypeMixedMetabolicCardioTraining,
	HKWorkoutActivityTypePaddleSports,
	HKWorkoutActivityTypePlay,
	HKWorkoutActivityTypePreparationAndRecovery,
	HKWorkoutActivityTypeRacquetball,
	HKWorkoutActivityTypeRowing,
	HKWorkoutActivityTypeRugby,
	HKWorkoutActivityTypeRunning,
	HKWorkoutActivityTypeSailing,
	HKWorkoutActivityTypeSkatingSports,
	HKWorkoutActivityTypeSnowSports,
	HKWorkoutActivityTypeSoccer,
	HKWorkoutActivityTypeSoftball,
	HKWorkoutActivityTypeSquash,
	HKWorkoutActivityTypeStairClimbing,
	HKWorkoutActivityTypeSurfingSports,
	HKWorkoutActivityTypeSwimming,
	HKWorkoutActivityTypeTableTennis,
	HKWorkoutActivityTypeTennis,
	HKWorkoutActivityTypeTrackAndField,
	HKWorkoutActivityTypeTraditionalStrengthTraining,
	HKWorkoutActivityTypeVolleyball,
	HKWorkoutActivityTypeWalking,
	HKWorkoutActivityTypeWaterFitness,
	HKWorkoutActivityTypeWaterPolo,
	HKWorkoutActivityTypeWaterSports,
	HKWorkoutActivityTypeWrestling,
	HKWorkoutActivityTypeYoga
}
declare enum HKWorkoutEventType {
	HKWorkoutEventTypePause,
	HKWorkoutEventTypeResume
}
declare enum HKQueryOptions {
	HKQueryOptionNone,
	HKQueryOptionStrictStartDate,
	HKQueryOptionStrictEndDate
}
declare enum HKBodyTemperatureSensorLocation {
	HKBodyTemperatureSensorLocationOther,
	HKBodyTemperatureSensorLocationArmpit,
	HKBodyTemperatureSensorLocationBody,
	HKBodyTemperatureSensorLocationEar,
	HKBodyTemperatureSensorLocationFinger,
	HKBodyTemperatureSensorLocationGastroIntestinal,
	HKBodyTemperatureSensorLocationMouth,
	HKBodyTemperatureSensorLocationRectum,
	HKBodyTemperatureSensorLocationToe,
	HKBodyTemperatureSensorLocationEarDrum,
	HKBodyTemperatureSensorLocationTemporalArtery,
	HKBodyTemperatureSensorLocationForehead
}
declare enum HKHeartRateSensorLocation {
	HKHeartRateSensorLocationOther,
	HKHeartRateSensorLocationChest,
	HKHeartRateSensorLocationWrist,
	HKHeartRateSensorLocationFinger,
	HKHeartRateSensorLocationHand,
	HKHeartRateSensorLocationEarLobe,
	HKHeartRateSensorLocationFoot
}
declare enum HKQuantityAggregationStyle {
	HKQuantityAggregationStyleCumulative,
	HKQuantityAggregationStyleDiscrete
}
declare enum HKStatisticsOptions {
	HKStatisticsOptionNone,
	HKStatisticsOptionSeparateBySource,
	HKStatisticsOptionDiscreteAverage,
	HKStatisticsOptionDiscreteMin,
	HKStatisticsOptionDiscreteMax,
	HKStatisticsOptionCumulativeSum
}
declare enum HKMetricPrefix {
	HKMetricPrefixNone,
	HKMetricPrefixPico,
	HKMetricPrefixNano,
	HKMetricPrefixMicro,
	HKMetricPrefixMilli,
	HKMetricPrefixCenti,
	HKMetricPrefixDeci,
	HKMetricPrefixDeca,
	HKMetricPrefixHecto,
	HKMetricPrefixKilo,
	HKMetricPrefixMega,
	HKMetricPrefixGiga,
	HKMetricPrefixTera
}
declare enum HMCharacteristicValueDoorState {
	HMCharacteristicValueDoorStateOpen,
	HMCharacteristicValueDoorStateClosed,
	HMCharacteristicValueDoorStateOpening,
	HMCharacteristicValueDoorStateClosing,
	HMCharacteristicValueDoorStateStopped
}
declare enum HMCharacteristicValueHeatingCooling {
	HMCharacteristicValueHeatingCoolingOff,
	HMCharacteristicValueHeatingCoolingHeat,
	HMCharacteristicValueHeatingCoolingCool,
	HMCharacteristicValueHeatingCoolingAuto
}
declare enum HMCharacteristicValueRotationDirection {
	HMCharacteristicValueRotationDirectionClockwise,
	HMCharacteristicValueRotationDirectionCounterClockwise
}
declare enum HMCharacteristicValueTemperatureUnit {
	HMCharacteristicValueTemperatureUnitCelsius,
	HMCharacteristicValueTemperatureUnitFahrenheit
}
declare enum HMCharacteristicValueLockMechanismState {
	HMCharacteristicValueLockMechanismStateUnsecured,
	HMCharacteristicValueLockMechanismStateSecured,
	HMCharacteristicValueLockMechanismStateJammed,
	HMCharacteristicValueLockMechanismStateUnknown
}
declare enum HMCharacteristicValueLockMechanism {
	HMCharacteristicValueLockMechanismLastKnownActionSecuredUsingPhysicalMovementInterior,
	HMCharacteristicValueLockMechanismLastKnownActionUnsecuredUsingPhysicalMovementInterior,
	HMCharacteristicValueLockMechanismLastKnownActionSecuredUsingPhysicalMovementExterior,
	HMCharacteristicValueLockMechanismLastKnownActionUnsecuredUsingPhysicalMovementExterior,
	HMCharacteristicValueLockMechanismLastKnownActionSecuredWithKeypad,
	HMCharacteristicValueLockMechanismLastKnownActionUnsecuredWithKeypad,
	HMCharacteristicValueLockMechanismLastKnownActionSecuredRemotely,
	HMCharacteristicValueLockMechanismLastKnownActionUnsecuredRemotely,
	HMCharacteristicValueLockMechanismLastKnownActionSecuredWithAutomaticSecureTimeout
}
declare enum HMErrorCode {
	HMErrorCodeAlreadyExists,
	HMErrorCodeNotFound,
	HMErrorCodeInvalidParameter,
	HMErrorCodeAccessoryNotReachable,
	HMErrorCodeReadOnlyCharacteristic,
	HMErrorCodeWriteOnlyCharacteristic,
	HMErrorCodeNotificationNotSupported,
	HMErrorCodeOperationTimedOut,
	HMErrorCodeAccessoryPoweredOff,
	HMErrorCodeAccessDenied,
	HMErrorCodeObjectAssociatedToAnotherHome,
	HMErrorCodeObjectNotAssociatedToAnyHome,
	HMErrorCodeObjectAlreadyAssociatedToHome,
	HMErrorCodeAccessoryIsBusy,
	HMErrorCodeOperationInProgress,
	HMErrorCodeAccessoryOutOfResources,
	HMErrorCodeInsufficientPrivileges,
	HMErrorCodeAccessoryPairingFailed,
	HMErrorCodeInvalidDataFormatSpecified,
	HMErrorCodeNilParameter,
	HMErrorCodeUnconfiguredParameter,
	HMErrorCodeInvalidClass,
	HMErrorCodeOperationCancelled,
	HMErrorCodeRoomForHomeCannotBeInZone,
	HMErrorCodeNoActionsInActionSet,
	HMErrorCodeNoRegisteredActionSets,
	HMErrorCodeMissingParameter,
	HMErrorCodeFireDateInPast,
	HMErrorCodeRoomForHomeCannotBeUpdated,
	HMErrorCodeActionInAnotherActionSet,
	HMErrorCodeObjectWithSimilarNameExistsInHome,
	HMErrorCodeHomeWithSimilarNameExists,
	HMErrorCodeRenameWithSimilarName,
	HMErrorCodeCannotRemoveNonBridgeAccessory,
	HMErrorCodeNameContainsProhibitedCharacters,
	HMErrorCodeNameDoesNotStartWithValidCharacters,
	HMErrorCodeUserIDNotEmailAddress,
	HMErrorCodeUserDeclinedAddingUser,
	HMErrorCodeUserDeclinedRemovingUser,
	HMErrorCodeUserDeclinedInvite,
	HMErrorCodeUserManagementFailed,
	HMErrorCodeRecurrenceTooSmall,
	HMErrorCodeInvalidValueType,
	HMErrorCodeValueLowerThanMinimum,
	HMErrorCodeValueHigherThanMaximum,
	HMErrorCodeStringLongerThanMaximum,
	HMErrorCodeHomeAccessNotAuthorized,
	HMErrorCodeOperationNotSupported,
	HMErrorCodeMaximumObjectLimitReached,
	HMErrorCodeAccessorySentInvalidResponse,
	HMErrorCodeStringShorterThanMinimum,
	HMErrorCodeGenericError,
	HMErrorCodeSecurityFailure,
	HMErrorCodeCommunicationFailure,
	HMErrorCodeMessageAuthenticationFailed,
	HMErrorCodeInvalidMessageSize,
	HMErrorCodeAccessoryDiscoveryFailed,
	HMErrorCodeClientRequestError,
	HMErrorCodeAccessoryResponseError,
	HMErrorCodeNameDoesNotEndWithValidCharacters,
	HMErrorCodeAccessoryIsBlocked,
	HMErrorCodeInvalidAssociatedServiceType,
	HMErrorCodeActionSetExecutionFailed,
	HMErrorCodeActionSetExecutionPartialSuccess,
	HMErrorCodeActionSetExecutionInProgress,
	HMErrorCodeAccessoryOutOfCompliance,
	HMErrorCodeDataResetFailure,
	HMErrorCodeNotificationAlreadyEnabled,
	HMErrorCodeRecurrenceMustBeOnSpecifiedBoundaries,
	HMErrorCodeDateMustBeOnSpecifiedBoundaries,
	HMErrorCodeCannotActivateTriggerTooFarInFuture,
	HMErrorCodeRecurrenceTooLarge,
	HMErrorCodeReadWritePartialSuccess,
	HMErrorCodeReadWriteFailure,
	HMErrorCodeNotSignedIntoiCloud,
	HMErrorCodeKeychainSyncNotEnabled,
	HMErrorCodeCloudDataSyncInProgress,
	HMErrorCodeNetworkUnavailable,
	HMErrorCodeAddAccessoryFailed,
	HMErrorCodeMissingEntitlement
}
declare enum MPMediaType {
	MPMediaTypeMusic,
	MPMediaTypePodcast,
	MPMediaTypeAudioBook,
	MPMediaTypeAudioITunesU,
	MPMediaTypeAnyAudio,
	MPMediaTypeMovie,
	MPMediaTypeTVShow,
	MPMediaTypeVideoPodcast,
	MPMediaTypeMusicVideo,
	MPMediaTypeVideoITunesU,
	MPMediaTypeHomeVideo,
	MPMediaTypeAnyVideo,
	MPMediaTypeAny
}
declare enum MPMediaPlaylistAttribute {
	MPMediaPlaylistAttributeNone,
	MPMediaPlaylistAttributeOnTheGo,
	MPMediaPlaylistAttributeSmart,
	MPMediaPlaylistAttributeGenius
}
declare enum MPMediaGrouping {
	MPMediaGroupingTitle,
	MPMediaGroupingAlbum,
	MPMediaGroupingArtist,
	MPMediaGroupingAlbumArtist,
	MPMediaGroupingComposer,
	MPMediaGroupingGenre,
	MPMediaGroupingPlaylist,
	MPMediaGroupingPodcastTitle
}
declare enum MPMediaPredicateComparison {
	MPMediaPredicateComparisonEqualTo,
	MPMediaPredicateComparisonContains
}
declare enum MPMovieScalingMode {
	MPMovieScalingModeNone,
	MPMovieScalingModeAspectFit,
	MPMovieScalingModeAspectFill,
	MPMovieScalingModeFill
}
declare enum MPMoviePlaybackState {
	MPMoviePlaybackStateStopped,
	MPMoviePlaybackStatePlaying,
	MPMoviePlaybackStatePaused,
	MPMoviePlaybackStateInterrupted,
	MPMoviePlaybackStateSeekingForward,
	MPMoviePlaybackStateSeekingBackward
}
declare enum MPMovieLoadState {
	MPMovieLoadStateUnknown,
	MPMovieLoadStatePlayable,
	MPMovieLoadStatePlaythroughOK,
	MPMovieLoadStateStalled
}
declare enum MPMovieRepeatMode {
	MPMovieRepeatModeNone,
	MPMovieRepeatModeOne
}
declare enum MPMovieControlStyle {
	MPMovieControlStyleNone,
	MPMovieControlStyleEmbedded,
	MPMovieControlStyleFullscreen,
	MPMovieControlStyleDefault
}
declare enum MPMovieFinishReason {
	MPMovieFinishReasonPlaybackEnded,
	MPMovieFinishReasonPlaybackError,
	MPMovieFinishReasonUserExited
}
declare enum MPMovieMediaTypeMask {
	MPMovieMediaTypeMaskNone,
	MPMovieMediaTypeMaskVideo,
	MPMovieMediaTypeMaskAudio
}
declare enum MPMovieSourceType {
	MPMovieSourceTypeUnknown,
	MPMovieSourceTypeFile,
	MPMovieSourceTypeStreaming
}
declare enum MPMovieTimeOption {
	MPMovieTimeOptionNearestKeyFrame,
	MPMovieTimeOptionExact
}
declare enum MPMusicPlaybackState {
	MPMusicPlaybackStateStopped,
	MPMusicPlaybackStatePlaying,
	MPMusicPlaybackStatePaused,
	MPMusicPlaybackStateInterrupted,
	MPMusicPlaybackStateSeekingForward,
	MPMusicPlaybackStateSeekingBackward
}
declare enum MPMusicRepeatMode {
	MPMusicRepeatModeDefault,
	MPMusicRepeatModeNone,
	MPMusicRepeatModeOne,
	MPMusicRepeatModeAll
}
declare enum MPMusicShuffleMode {
	MPMusicShuffleModeDefault,
	MPMusicShuffleModeOff,
	MPMusicShuffleModeSongs,
	MPMusicShuffleModeAlbums
}
declare enum MPRemoteCommandHandlerStatus {
	MPRemoteCommandHandlerStatusSuccess,
	MPRemoteCommandHandlerStatusNoSuchContent,
	MPRemoteCommandHandlerStatusCommandFailed
}
declare enum MPSeekCommandEventType {
	MPSeekCommandEventTypeBeginSeeking,
	MPSeekCommandEventTypeEndSeeking
}
declare enum CGImageMetadataType {
	kCGImageMetadataTypeInvalid,
	kCGImageMetadataTypeDefault,
	kCGImageMetadataTypeString,
	kCGImageMetadataTypeArrayUnordered,
	kCGImageMetadataTypeArrayOrdered,
	kCGImageMetadataTypeAlternateArray,
	kCGImageMetadataTypeAlternateText,
	kCGImageMetadataTypeStructure
}
declare enum CGImageMetadataErrors {
	kCGImageMetadataErrorUnknown,
	kCGImageMetadataErrorUnsupportedFormat,
	kCGImageMetadataErrorBadArgument,
	kCGImageMetadataErrorConflictingArguments,
	kCGImageMetadataErrorPrefixConflict
}
declare enum CGImageSourceStatus {
	kCGImageStatusUnexpectedEOF,
	kCGImageStatusInvalidData,
	kCGImageStatusUnknownType,
	kCGImageStatusReadingHeader,
	kCGImageStatusIncomplete,
	kCGImageStatusComplete
}
declare enum CGImagePropertyOrientation {
	kCGImagePropertyOrientationUp,
	kCGImagePropertyOrientationUpMirrored,
	kCGImagePropertyOrientationDown,
	kCGImagePropertyOrientationDownMirrored,
	kCGImagePropertyOrientationLeftMirrored,
	kCGImagePropertyOrientationRight,
	kCGImagePropertyOrientationRightMirrored,
	kCGImagePropertyOrientationLeft
}
declare enum JSType {
	kJSTypeUndefined,
	kJSTypeNull,
	kJSTypeBoolean,
	kJSTypeNumber,
	kJSTypeString,
	kJSTypeObject
}
declare enum LAPolicy {
	LAPolicyDeviceOwnerAuthenticationWithBiometrics
}
declare enum LAError {
	LAErrorAuthenticationFailed,
	LAErrorUserCancel,
	LAErrorUserFallback,
	LAErrorSystemCancel,
	LAErrorPasscodeNotSet,
	LAErrorTouchIDNotAvailable,
	LAErrorTouchIDNotEnrolled
}
declare enum MKAnnotationViewDragState {
	MKAnnotationViewDragStateNone,
	MKAnnotationViewDragStateStarting,
	MKAnnotationViewDragStateDragging,
	MKAnnotationViewDragStateCanceling,
	MKAnnotationViewDragStateEnding
}
declare enum MKDistanceFormatterUnits {
	MKDistanceFormatterUnitsDefault,
	MKDistanceFormatterUnitsMetric,
	MKDistanceFormatterUnitsImperial,
	MKDistanceFormatterUnitsImperialWithYards
}
declare enum MKDistanceFormatterUnitStyle {
	MKDistanceFormatterUnitStyleDefault,
	MKDistanceFormatterUnitStyleAbbreviated,
	MKDistanceFormatterUnitStyleFull
}
declare enum MKMapType {
	MKMapTypeStandard,
	MKMapTypeSatellite,
	MKMapTypeHybrid
}
declare enum MKErrorCode {
	MKErrorUnknown,
	MKErrorServerFailure,
	MKErrorLoadingThrottled,
	MKErrorPlacemarkNotFound,
	MKErrorDirectionsNotFound
}
declare enum MKUserTrackingMode {
	MKUserTrackingModeNone,
	MKUserTrackingModeFollow,
	MKUserTrackingModeFollowWithHeading
}
declare enum MKOverlayLevel {
	MKOverlayLevelAboveRoads,
	MKOverlayLevelAboveLabels
}
declare enum MKPinAnnotationColor {
	MKPinAnnotationColorRed,
	MKPinAnnotationColorGreen,
	MKPinAnnotationColorPurple
}
declare enum MKDirectionsTransportType {
	MKDirectionsTransportTypeAutomobile,
	MKDirectionsTransportTypeWalking,
	MKDirectionsTransportTypeAny
}
declare enum MACaptionAppearanceDomain {
	kMACaptionAppearanceDomainDefault,
	kMACaptionAppearanceDomainUser
}
declare enum MACaptionAppearanceDisplayType {
	kMACaptionAppearanceDisplayTypeForcedOnly,
	kMACaptionAppearanceDisplayTypeAutomatic,
	kMACaptionAppearanceDisplayTypeAlwaysOn
}
declare enum MACaptionAppearanceBehavior {
	kMACaptionAppearanceBehaviorUseValue,
	kMACaptionAppearanceBehaviorUseContentIfAvailable
}
declare enum MACaptionAppearanceFontStyle {
	kMACaptionAppearanceFontStyleDefault,
	kMACaptionAppearanceFontStyleMonospacedWithSerif,
	kMACaptionAppearanceFontStyleProportionalWithSerif,
	kMACaptionAppearanceFontStyleMonospacedWithoutSerif,
	kMACaptionAppearanceFontStyleProportionalWithoutSerif,
	kMACaptionAppearanceFontStyleCasual,
	kMACaptionAppearanceFontStyleCursive,
	kMACaptionAppearanceFontStyleSmallCapital
}
declare enum MACaptionAppearanceTextEdgeStyle {
	kMACaptionAppearanceTextEdgeStyleUndefined,
	kMACaptionAppearanceTextEdgeStyleNone,
	kMACaptionAppearanceTextEdgeStyleRaised,
	kMACaptionAppearanceTextEdgeStyleDepressed,
	kMACaptionAppearanceTextEdgeStyleUniform,
	kMACaptionAppearanceTextEdgeStyleDropShadow
}
declare enum MFMailComposeResult {
	MFMailComposeResultCancelled,
	MFMailComposeResultSaved,
	MFMailComposeResultSent,
	MFMailComposeResultFailed
}
declare enum MFMailComposeErrorCode {
	MFMailComposeErrorCodeSaveFailed,
	MFMailComposeErrorCodeSendFailed
}
declare enum MessageComposeResult {
	MessageComposeResultCancelled,
	MessageComposeResultSent,
	MessageComposeResultFailed
}
declare enum MCErrorCode {
	MCErrorUnknown,
	MCErrorNotConnected,
	MCErrorInvalidParameter,
	MCErrorUnsupported,
	MCErrorTimedOut,
	MCErrorCancelled,
	MCErrorUnavailable
}
declare enum MCSessionSendDataMode {
	MCSessionSendDataReliable,
	MCSessionSendDataUnreliable
}
declare enum MCSessionState {
	MCSessionStateNotConnected,
	MCSessionStateConnecting,
	MCSessionStateConnected
}
declare enum MCEncryptionPreference {
	MCEncryptionOptional,
	MCEncryptionRequired,
	MCEncryptionNone
}
declare enum NEVPNError {
	NEVPNErrorConfigurationInvalid,
	NEVPNErrorConfigurationDisabled,
	NEVPNErrorConnectionFailed,
	NEVPNErrorConfigurationStale
}
declare enum NEVPNStatus {
	NEVPNStatusInvalid,
	NEVPNStatusDisconnected,
	NEVPNStatusConnecting,
	NEVPNStatusConnected,
	NEVPNStatusReasserting,
	NEVPNStatusDisconnecting
}
declare enum NEVPNIKEAuthenticationMethod {
	NEVPNIKEAuthenticationMethodNone,
	NEVPNIKEAuthenticationMethodCertificate,
	NEVPNIKEAuthenticationMethodSharedSecret
}
declare enum NEVPNIKEv2EncryptionAlgorithm {
	NEVPNIKEv2EncryptionAlgorithmDES,
	NEVPNIKEv2EncryptionAlgorithm3DES,
	NEVPNIKEv2EncryptionAlgorithmAES128,
	NEVPNIKEv2EncryptionAlgorithmAES256
}
declare enum NEVPNIKEv2IntegrityAlgorithm {
	NEVPNIKEv2IntegrityAlgorithmSHA96,
	NEVPNIKEv2IntegrityAlgorithmSHA160,
	NEVPNIKEv2IntegrityAlgorithmSHA256,
	NEVPNIKEv2IntegrityAlgorithmSHA384,
	NEVPNIKEv2IntegrityAlgorithmSHA512
}
declare enum NEVPNIKEv2DeadPeerDetectionRate {
	NEVPNIKEv2DeadPeerDetectionRateNone,
	NEVPNIKEv2DeadPeerDetectionRateLow,
	NEVPNIKEv2DeadPeerDetectionRateMedium,
	NEVPNIKEv2DeadPeerDetectionRateHigh
}
declare enum NEVPNIKEv2DiffieHellmanGroup {
	NEVPNIKEv2DiffieHellmanGroup0,
	NEVPNIKEv2DiffieHellmanGroup1,
	NEVPNIKEv2DiffieHellmanGroup2,
	NEVPNIKEv2DiffieHellmanGroup5,
	NEVPNIKEv2DiffieHellmanGroup14,
	NEVPNIKEv2DiffieHellmanGroup15,
	NEVPNIKEv2DiffieHellmanGroup16,
	NEVPNIKEv2DiffieHellmanGroup17,
	NEVPNIKEv2DiffieHellmanGroup18
}
declare enum NEOnDemandRuleAction {
	NEOnDemandRuleActionConnect,
	NEOnDemandRuleActionDisconnect,
	NEOnDemandRuleActionEvaluateConnection,
	NEOnDemandRuleActionIgnore
}
declare enum NEOnDemandRuleInterfaceType {
	NEOnDemandRuleInterfaceTypeWiFi,
	NEOnDemandRuleInterfaceTypeCellular
}
declare enum NEEvaluateConnectionRuleAction {
	NEEvaluateConnectionRuleActionConnectIfNeeded,
	NEEvaluateConnectionRuleActionNeverConnect
}
declare enum NCUpdateResult {
	NCUpdateResultNewData,
	NCUpdateResultNoData,
	NCUpdateResultFailed
}
declare enum PHAuthorizationStatus {
	PHAuthorizationStatusNotDetermined,
	PHAuthorizationStatusRestricted,
	PHAuthorizationStatusDenied,
	PHAuthorizationStatusAuthorized
}
declare enum PHCollectionListType {
	PHCollectionListTypeMomentList,
	PHCollectionListTypeFolder,
	PHCollectionListTypeSmartFolder
}
declare enum PHCollectionListSubtype {
	PHCollectionListSubtypeMomentListCluster,
	PHCollectionListSubtypeMomentListYear,
	PHCollectionListSubtypeRegularFolder,
	PHCollectionListSubtypeSmartFolderEvents,
	PHCollectionListSubtypeSmartFolderFaces,
	PHCollectionListSubtypeAny
}
declare enum PHCollectionEditOperation {
	PHCollectionEditOperationDeleteContent,
	PHCollectionEditOperationRemoveContent,
	PHCollectionEditOperationAddContent,
	PHCollectionEditOperationCreateContent,
	PHCollectionEditOperationRearrangeContent,
	PHCollectionEditOperationDelete,
	PHCollectionEditOperationRename
}
declare enum PHAssetCollectionType {
	PHAssetCollectionTypeAlbum,
	PHAssetCollectionTypeSmartAlbum,
	PHAssetCollectionTypeMoment
}
declare enum PHAssetCollectionSubtype {
	PHAssetCollectionSubtypeAlbumRegular,
	PHAssetCollectionSubtypeAlbumSyncedEvent,
	PHAssetCollectionSubtypeAlbumSyncedFaces,
	PHAssetCollectionSubtypeAlbumSyncedAlbum,
	PHAssetCollectionSubtypeAlbumImported,
	PHAssetCollectionSubtypeAlbumCloudShared,
	PHAssetCollectionSubtypeSmartAlbumGeneric,
	PHAssetCollectionSubtypeSmartAlbumPanoramas,
	PHAssetCollectionSubtypeSmartAlbumVideos,
	PHAssetCollectionSubtypeSmartAlbumFavorites,
	PHAssetCollectionSubtypeSmartAlbumTimelapses,
	PHAssetCollectionSubtypeSmartAlbumAllHidden,
	PHAssetCollectionSubtypeSmartAlbumRecentlyAdded,
	PHAssetCollectionSubtypeSmartAlbumBursts,
	PHAssetCollectionSubtypeSmartAlbumSlomoVideos,
	PHAssetCollectionSubtypeAny
}
declare enum PHAssetEditOperation {
	PHAssetEditOperationDelete,
	PHAssetEditOperationContent,
	PHAssetEditOperationProperties
}
declare enum PHAssetMediaType {
	PHAssetMediaTypeUnknown,
	PHAssetMediaTypeImage,
	PHAssetMediaTypeVideo,
	PHAssetMediaTypeAudio
}
declare enum PHAssetMediaSubtype {
	PHAssetMediaSubtypeNone,
	PHAssetMediaSubtypePhotoPanorama,
	PHAssetMediaSubtypePhotoHDR,
	PHAssetMediaSubtypeVideoStreamed,
	PHAssetMediaSubtypeVideoHighFrameRate,
	PHAssetMediaSubtypeVideoTimelapse
}
declare enum PHAssetBurstSelectionType {
	PHAssetBurstSelectionTypeNone,
	PHAssetBurstSelectionTypeAutoPick,
	PHAssetBurstSelectionTypeUserPick
}
declare enum PHImageContentMode {
	PHImageContentModeAspectFit,
	PHImageContentModeAspectFill,
	PHImageContentModeDefault
}
declare enum PHImageRequestOptionsVersion {
	PHImageRequestOptionsVersionCurrent,
	PHImageRequestOptionsVersionUnadjusted,
	PHImageRequestOptionsVersionOriginal
}
declare enum PHImageRequestOptionsDeliveryMode {
	PHImageRequestOptionsDeliveryModeOpportunistic,
	PHImageRequestOptionsDeliveryModeHighQualityFormat,
	PHImageRequestOptionsDeliveryModeFastFormat
}
declare enum PHImageRequestOptionsResizeMode {
	PHImageRequestOptionsResizeModeNone,
	PHImageRequestOptionsResizeModeFast,
	PHImageRequestOptionsResizeModeExact
}
declare enum PHVideoRequestOptionsVersion {
	PHVideoRequestOptionsVersionCurrent,
	PHVideoRequestOptionsVersionOriginal
}
declare enum PHVideoRequestOptionsDeliveryMode {
	PHVideoRequestOptionsDeliveryModeAutomatic,
	PHVideoRequestOptionsDeliveryModeHighQualityFormat,
	PHVideoRequestOptionsDeliveryModeMediumQualityFormat,
	PHVideoRequestOptionsDeliveryModeFastFormat
}
declare enum SSReadingListErrorCode {
	SSReadingListErrorURLSchemeNotAllowed
}
declare enum SLRequestMethod {
	SLRequestMethodGET,
	SLRequestMethodPOST,
	SLRequestMethodDELETE,
	SLRequestMethodPUT
}
declare enum SLComposeViewControllerResult {
	SLComposeViewControllerResultCancelled,
	SLComposeViewControllerResultDone
}
declare enum SKBlendMode {
	SKBlendModeAlpha,
	SKBlendModeAdd,
	SKBlendModeSubtract,
	SKBlendModeMultiply,
	SKBlendModeMultiplyX2,
	SKBlendModeScreen,
	SKBlendModeReplace
}
declare enum SKTextureFilteringMode {
	SKTextureFilteringNearest,
	SKTextureFilteringLinear
}
declare enum SKUniformType {
	SKUniformTypeNone,
	SKUniformTypeFloat,
	SKUniformTypeFloatVector2,
	SKUniformTypeFloatVector3,
	SKUniformTypeFloatVector4,
	SKUniformTypeFloatMatrix2,
	SKUniformTypeFloatMatrix3,
	SKUniformTypeFloatMatrix4,
	SKUniformTypeTexture
}
declare enum SKSceneScaleMode {
	SKSceneScaleModeFill,
	SKSceneScaleModeAspectFill,
	SKSceneScaleModeAspectFit,
	SKSceneScaleModeResizeFill
}
declare enum SKInterpolationMode {
	SKInterpolationModeLinear,
	SKInterpolationModeSpline,
	SKInterpolationModeStep
}
declare enum SKRepeatMode {
	SKRepeatModeClamp,
	SKRepeatModeLoop
}
declare enum SKActionTimingMode {
	SKActionTimingLinear,
	SKActionTimingEaseIn,
	SKActionTimingEaseOut,
	SKActionTimingEaseInEaseOut
}
declare enum SKLabelVerticalAlignmentMode {
	SKLabelVerticalAlignmentModeBaseline,
	SKLabelVerticalAlignmentModeCenter,
	SKLabelVerticalAlignmentModeTop,
	SKLabelVerticalAlignmentModeBottom
}
declare enum SKLabelHorizontalAlignmentMode {
	SKLabelHorizontalAlignmentModeCenter,
	SKLabelHorizontalAlignmentModeLeft,
	SKLabelHorizontalAlignmentModeRight
}
declare enum SKTransitionDirection {
	SKTransitionDirectionUp,
	SKTransitionDirectionDown,
	SKTransitionDirectionRight,
	SKTransitionDirectionLeft
}
declare enum SKDownloadState {
	SKDownloadStateWaiting,
	SKDownloadStateActive,
	SKDownloadStatePaused,
	SKDownloadStateFinished,
	SKDownloadStateFailed,
	SKDownloadStateCancelled
}
declare enum SKPaymentTransactionState {
	SKPaymentTransactionStatePurchasing,
	SKPaymentTransactionStatePurchased,
	SKPaymentTransactionStateFailed,
	SKPaymentTransactionStateRestored,
	SKPaymentTransactionStateDeferred
}
declare enum VTCompressionSessionOptionFlags {
	kVTCompressionSessionBeginFinalPass
}
declare enum WKErrorCode {
	WKErrorUnknown,
	WKErrorWebContentProcessTerminated,
	WKErrorWebViewInvalidated,
	WKErrorJavaScriptExceptionOccurred
}
declare enum WKNavigationType {
	WKNavigationTypeLinkActivated,
	WKNavigationTypeFormSubmitted,
	WKNavigationTypeBackForward,
	WKNavigationTypeReload,
	WKNavigationTypeFormResubmitted,
	WKNavigationTypeOther
}
declare enum WKNavigationActionPolicy {
	WKNavigationActionPolicyCancel,
	WKNavigationActionPolicyAllow
}
declare enum WKNavigationResponsePolicy {
	WKNavigationResponsePolicyCancel,
	WKNavigationResponsePolicyAllow
}
declare enum WKUserScriptInjectionTime {
	WKUserScriptInjectionTimeAtDocumentStart,
	WKUserScriptInjectionTimeAtDocumentEnd
}
declare enum WKSelectionGranularity {
	WKSelectionGranularityDynamic,
	WKSelectionGranularityCharacter
}
declare var noErr: number;
declare var kNilOptions: number;
declare var kVariableLengthArray: number;
declare var kUnknownType: number;
declare var normal: number;
declare var developStage: number;
declare var OSUnknownByteOrder: number;
declare var eNoteReapDeprecated: number;
declare var eNoteExitReparentedDeprecated: number;
declare var kCGFontIndexMax: number;
declare var CGGlyphMin: number;
declare var kCGGradientDrawsBeforeStartLocation: number;
declare var kCFNotFound: number;
declare var kCFCalendarComponentsWrap: number;
declare var kCFRunLoopRunFinished: number;
declare var kCFSocketAutomaticallyReenableReadCallBack: number;
declare var kCFPropertyListReadCorruptError: number;
declare var kCFBundleExecutableArchitectureI386: number;
declare var kCFMessagePortSuccess: number;
declare var kCFNotificationDeliverImmediately: number;
declare var kCFStringTokenizerUnitWord: number;
declare var kCFFileDescriptorReadCallBack: number;
declare var kCVSMPTETimeType24: number;
declare var kCVSMPTETimeValid: number;
declare var kCVTimeIsIndefinite: number;
declare var kCVTimeStampVideoTimeValid: number;
declare var kCVTimeStampVideoHostTimeValid: number;
declare var kCVAttachmentMode_ShouldNotPropagate: number;
declare var kCVPixelFormatType_1Monochrome: number;
declare var NSNotFound: number;
declare var NSBundleExecutableArchitectureI386: number;
declare var NS_UnknownByteOrder: number;
declare var NSWrapCalendarComponents: number;
declare var NSDateComponentUndefined: number;
declare var NSASCIIStringEncoding: number;
declare var NSProprietaryStringEncoding: number;
declare var NSOpenStepUnicodeReservedBase: number;
declare var NSPointerFunctionsStrongMemory: number;
declare var NSHashTableStrongMemory: number;
declare var NSMapTableStrongMemory: number;
declare var NSOperationQueueDefaultMaxConcurrentOperationCount: number;
declare var NSMachPortDeallocateNone: number;
declare var NSWindowsNTOperatingSystem: number;
declare var NSTextCheckingAllSystemTypes: number;
declare var NSURLErrorCancelledReasonUserForceQuitApplication: number;
declare var NSURLErrorUnknown: number;
declare var NSFileNoSuchFileError: number;
declare var NSUbiquitousKeyValueStoreServerChange: number;
declare var NSUndoCloseGroupingRunLoopOrdering: number;
declare var errSecSuccess: number;
declare var kSecPaddingNone: number;
declare var kSecRevocationOCSPMethod: number;
declare var kSecTrustResultInvalid: number;
declare var SSL_NULL_WITH_NULL_NULL: number;
declare var errSSLProtocol: number;
declare var kCFStreamErrorSOCKSSubDomainNone: number;
declare var kCFStreamErrorSOCKS5BadResponseAddr: number;
declare var kCFStreamErrorSOCKS4RequestFailed: number;
declare var kSOCKS5NoAcceptableMethod: number;
declare var kABPersonType: number;
declare var kABInvalidPropertyType: number;
declare var kABOperationNotPermittedByStoreError: number;
declare var kABSourceTypeLocal: number;
declare var kABPersonSortByFirstName: number;
declare var kABPersonCompositeNameFormatFirstNameFirst: number;
declare var UIPrintingNotAvailableError: number;
declare var UISegmentedControlNoSegment: number;
declare var NSAttachmentCharacter: number;
declare var kCTFontClassMaskShift: number;
declare var kCTFontPrioritySystem: number;
declare var kCTFontTableBASE: number;
declare var kCTFontCollectionCopyDefaultOptions: number;
declare var kCTRunDelegateVersion1: number;
declare var kCTWritingDirectionEmbedding: number;
declare var kAllTypographicFeaturesType: number;
declare var kAllTypeFeaturesOnSelector: number;
declare var kRequiredLigaturesOnSelector: number;
declare var kUnconnectedSelector: number;
declare var kUpperAndLowerCaseSelector: number;
declare var kSubstituteVerticalFormsOnSelector: number;
declare var kLinguisticRearrangementOnSelector: number;
declare var kMonospacedNumbersSelector: number;
declare var kWordInitialSwashesOnSelector: number;
declare var kShowDiacriticsSelector: number;
declare var kNormalPositionSelector: number;
declare var kNoFractionsSelector: number;
declare var kPreventOverlapOnSelector: number;
declare var kHyphensToEmDashOnSelector: number;
declare var kHyphenToMinusOnSelector: number;
declare var kNoOrnamentsSelector: number;
declare var kNoAlternatesSelector: number;
declare var kDesignLevel1Selector: number;
declare var kNoStyleOptionsSelector: number;
declare var kTraditionalCharactersSelector: number;
declare var kLowerCaseNumbersSelector: number;
declare var kProportionalTextSelector: number;
declare var kNoTransliterationSelector: number;
declare var kNoAnnotationSelector: number;
declare var kFullWidthKanaSelector: number;
declare var kFullWidthIdeographsSelector: number;
declare var kCanonicalCompositionOnSelector: number;
declare var kNoRubyKanaSelector: number;
declare var kNoCJKSymbolAlternativesSelector: number;
declare var kNoIdeographicAlternativesSelector: number;
declare var kCJKVerticalRomanCenteredSelector: number;
declare var kNoCJKItalicRomanSelector: number;
declare var kCaseSensitiveLayoutOnSelector: number;
declare var kAlternateHorizKanaOnSelector: number;
declare var kNoStylisticAlternatesSelector: number;
declare var kContextualAlternatesOnSelector: number;
declare var kDefaultLowerCaseSelector: number;
declare var kDefaultUpperCaseSelector: number;
declare var kHalfWidthCJKRomanSelector: number;
declare var kSFNTLookupSimpleArray: number;
declare var kSTClassEndOfText: number;
declare var kSTXHasLigAction: number;
declare var kSTKCrossStreamReset: number;
declare var kLCARTag: number;
declare var kJUSTTag: number;
declare var kJUSTKashidaPriority: number;
declare var kJUSTOverridePriority: number;
declare var kOPBDTag: number;
declare var kMORTTag: number;
declare var kMORXTag: number;
declare var kPROPTag: number;
declare var kPROPLDirectionClass: number;
declare var kTRAKTag: number;
declare var kKERNTag: number;
declare var kKERNOrderedList: number;
declare var kKERNLineStart: number;
declare var kKERXTag: number;
declare var kKERXOrderedList: number;
declare var kKERXLineStart: number;
declare var kKERXActionTypeMask: number;
declare var kBSLNTag: number;
declare var kBSLNRomanBaseline: number;
declare var kANKRCurrentVersion: number;
declare var kLTAGCurrentVersion: number;
declare var sizeof_sfntDirectory: number;
declare var cmapFontTableTag: number;
declare var kFontUnicodePlatform: number;
declare var kFontUnicodeDefaultSemantics: number;
declare var kFontRomanScript: number;
declare var kFontMicrosoftSymbolScript: number;
declare var kFontCustom8BitScript: number;
declare var kFontEnglishLanguage: number;
declare var kFontNoPlatformCode: number;
declare var sizeof_sfntCMapSubHeader: number;
declare var sizeof_sfntCMapExtendedSubHeader: number;
declare var sizeof_sfntCMapEncoding: number;
declare var sizeof_sfntCMapHeader: number;
declare var nameFontTableTag: number;
declare var kFontCopyrightName: number;
declare var kFontNoNameCode: number;
declare var sizeof_sfntNameRecord: number;
declare var sizeof_sfntNameHeader: number;
declare var variationFontTableTag: number;
declare var sizeof_sfntVariationAxis: number;
declare var sizeof_sfntInstance: number;
declare var sizeof_sfntVariationHeader: number;
declare var descriptorFontTableTag: number;
declare var sizeof_sfntDescriptorHeader: number;
declare var featureFontTableTag: number;
declare var os2FontTableTag: number;
declare var nonGlyphID: number;
declare var ALAssetsGroupLibrary: number;
declare var ALAssetsLibraryUnknownError: number;
declare var kAudio_UnimplementedError: number;
declare var kAudioStreamAnyRate: number;
declare var kAudioFormatLinearPCM: number;
declare var kAudioFormatFlagIsFloat: number;
declare var kAudioFormatFlagsNativeEndian: number;
declare var kSMPTETimeType24: number;
declare var kSMPTETimeValid: number;
declare var kAudioTimeStampSampleTimeValid: number;
declare var kAudioTimeStampSampleHostTimeValid: number;
declare var kAudioChannelLabel_Unknown: number;
declare var kAudioChannelBit_Left: number;
declare var kAudioChannelFlags_AllOff: number;
declare var kAudioChannelCoordinates_LeftRight: number;
declare var kAudioChannelLayoutTag_UseChannelDescriptions: number;
declare var kMPEG4Object_AAC_Main: number;
declare var kAudioFileAIFFType: number;
declare var kAudioFileUnspecifiedError: number;
declare var kAudioFileFlags_EraseFile: number;
declare var kAudioFileReadPermission: number;
declare var kAudioFileLoopDirection_NoLooping: number;
declare var kAudioFileMarkerType_Generic: number;
declare var kAudioFileRegionFlag_LoopEnable: number;
declare var kBytePacketTranslationFlag_IsEstimate: number;
declare var kAudioFilePropertyFileFormat: number;
declare var kAudioFileGlobalInfo_ReadableTypes: number;
declare var kAudioFileStreamPropertyFlag_PropertyIsCached: number;
declare var kAudioFileStreamError_UnsupportedFileType: number;
declare var kAudioFileStreamProperty_ReadyToProducePackets: number;
declare var kPanningMode_SoundField: number;
declare var kAudioBalanceFadeType_MaxUnityGain: number;
declare var kAudioFormatProperty_FormatInfo: number;
declare var kAudioFormatProperty_HardwareCodecCapabilities: number;
declare var kAudioDecoderComponentType: number;
declare var kAppleSoftwareAudioCodecManufacturer: number;
declare var kAudioFormatUnspecifiedError: number;
declare var kAudioQueueErr_InvalidBuffer: number;
declare var kAudioQueueProperty_IsRunning: number;
declare var kAudioQueueTimePitchAlgorithm_Spectral: number;
declare var kAudioQueueProperty_HardwareCodecPolicy: number;
declare var kAudioQueueHardwareCodecPolicy_Default: number;
declare var kAudioQueueProperty_ChannelAssignments: number;
declare var kAudioQueueParam_Volume: number;
declare var kAudioQueueProcessingTap_PreEffects: number;
declare var kAudioSessionNoError: number;
declare var kAudioSessionBeginInterruption: number;
declare var kAudioSessionCategory_AmbientSound: number;
declare var kAudioSessionOverrideAudioRoute_None: number;
declare var kAudioSessionRouteChangeReason_Unknown: number;
declare var kAudioSessionInterruptionType_ShouldResume: number;
declare var kAudioSessionMode_Default: number;
declare var kAudioSessionProperty_PreferredHardwareSampleRate: number;
declare var kAudioSessionSetActiveFlag_NotifyOthersOnDeactivation: number;
declare var kAudioSessionCategory_UserInterfaceSoundEffects: number;
declare var kAudioSessionProperty_AudioRoute: number;
declare var kAudioServicesNoError: number;
declare var kSystemSoundID_Vibrate: number;
declare var kAudioServicesPropertyIsUISound: number;
declare var kAUGraphErr_NodeNotFound: number;
declare var kAUNodeInteraction_Connection: number;
declare var kAudioConverterPropertyMinimumInputBufferSize: number;
declare var kAudioConverterPropertyCanResumeFromInterruption: number;
declare var kAudioConverterQuality_Max: number;
declare var kAudioConverterSampleRateConverterComplexity_Linear: number;
declare var kConverterPrimeMethod_Pre: number;
declare var kAudioConverterErr_FormatNotSupported: number;
declare var kAudioConverterErr_HardwareInUse: number;
declare var kExtAudioFileProperty_FileDataFormat: number;
declare var kExtAudioFileError_CodecUnavailableInputConsumed: number;
declare var kMusicEventType_NULL: number;
declare var kMusicSequenceLoadSMF_ChannelsToTracks: number;
declare var kMusicSequenceType_Beats: number;
declare var kMusicSequenceFile_MIDIType: number;
declare var kMusicSequenceFileFlags_EraseFile: number;
declare var kAudioToolboxErr_InvalidSequenceType: number;
declare var kSequenceTrackProperty_LoopInfo: number;
declare var kCAF_FileType: number;
declare var kCAF_StreamDescriptionChunkID: number;
declare var kCAFLinearPCMFormatFlagIsFloat: number;
declare var kCAFMarkerType_Generic: number;
declare var kCAF_SMPTE_TimeTypeNone: number;
declare var kCAFRegionFlag_LoopEnable: number;
declare var kAudioComponentFlag_Unsearchable: number;
declare var kAudioUnitType_Output: number;
declare var kAudioUnitType_RemoteEffect: number;
declare var kAudioUnitManufacturer_Apple: number;
declare var kAudioUnitSubType_GenericOutput: number;
declare var kAudioUnitSubType_Sampler: number;
declare var kAudioUnitSubType_AUConverter: number;
declare var kAudioUnitSubType_PeakLimiter: number;
declare var kAudioUnitSubType_MultiChannelMixer: number;
declare var kAudioUnitSubType_ScheduledSoundPlayer: number;
declare var kAudioUnitRenderAction_PreRender: number;
declare var kAudioUnitErr_InvalidProperty: number;
declare var kAudioComponentErr_DuplicateDescription: number;
declare var kParameterEvent_Immediate: number;
declare var kAudioUnitRange: number;
declare var kAudioUnitErr_IllegalInstrument: number;
declare var kAudioOutputUnitRange: number;
declare var kAudioUnitScope_Global: number;
declare var kAudioUnitProperty_ClassInfo: number;
declare var kAudioUnitProperty_RemoteControlEventListener: number;
declare var kRenderQuality_Max: number;
declare var kNumberOfResponseFrequencies: number;
declare var kAudioUnitParameterUnit_Generic: number;
declare var kAudioUnitParameterFlag_CFNameRelease: number;
declare var kAudioUnitClumpID_System: number;
declare var kAudioUnitParameterName_Full: number;
declare var kAudioUnitRemoteControlEvent_TogglePlayPause: number;
declare var kAudioOutputUnitProperty_IsRunning: number;
declare var kAudioUnitProperty_SampleRateConverterComplexity: number;
declare var kAudioUnitSampleRateConverterComplexity_Linear: number;
declare var kAudioOutputUnitProperty_CurrentDevice: number;
declare var kAudioOutputUnitProperty_MIDICallbacks: number;
declare var kAUVoiceIOProperty_BypassVoiceProcessing: number;
declare var kAUVoiceIOProperty_DuckNonVoiceAudio: number;
declare var kAUNBandEQProperty_NumberOfBands: number;
declare var kAudioUnitProperty_MeteringMode: number;
declare var kAudioUnitProperty_ReverbRoomType: number;
declare var kSpatializationAlgorithm_EqualPowerPanning: number;
declare var kReverbRoomType_SmallRoom: number;
declare var kSpatialMixerAttenuationCurve_Power: number;
declare var kSpatialMixerRenderingFlags_InterAuralDelay: number;
declare var kAudioUnitProperty_3DMixerDistanceParams: number;
declare var k3DMixerRenderingFlags_InterAuralDelay: number;
declare var k3DMixerAttenuationCurve_Power: number;
declare var kAudioUnitProperty_ScheduleAudioSlice: number;
declare var kScheduledAudioSliceFlag_Complete: number;
declare var kAudioUnitProperty_ScheduledFileIDs: number;
declare var kMusicDeviceProperty_InstrumentName: number;
declare var kMusicDeviceProperty_InstrumentCount: number;
declare var kAUMIDISynthProperty_EnablePreload: number;
declare var kAUSamplerProperty_LoadInstrument: number;
declare var kInstrumentType_DLSPreset: number;
declare var kAUSampler_DefaultPercussionBankMSB: number;
declare var kAudioUnitProperty_DeferredRendererPullSize: number;
declare var kAUSamplerProperty_LoadPresetFromBank: number;
declare var kAUGroupParameterID_Volume: number;
declare var kSpatialMixerParam_Azimuth: number;
declare var kReverbParam_FilterFrequency: number;
declare var k3DMixerParam_Azimuth: number;
declare var kMultiChannelMixerParam_Volume: number;
declare var kMatrixMixerParam_Volume: number;
declare var kHALOutputParam_Volume: number;
declare var kTimePitchParam_Rate: number;
declare var kNewTimePitchParam_Rate: number;
declare var kAUSamplerParam_Gain: number;
declare var kBandpassParam_CenterFrequency: number;
declare var kHipassParam_CutoffFrequency: number;
declare var kLowPassParam_CutoffFrequency: number;
declare var kHighShelfParam_CutOffFrequency: number;
declare var kAULowShelfParam_CutoffFrequency: number;
declare var kParametricEQParam_CenterFreq: number;
declare var kLimiterParam_AttackTime: number;
declare var kDynamicsProcessorParam_Threshold: number;
declare var kVarispeedParam_PlaybackRate: number;
declare var kDistortionParam_Delay: number;
declare var kDelayParam_WetDryMix: number;
declare var kAUNBandEQParam_GlobalGain: number;
declare var kAUNBandEQFilterType_Parametric: number;
declare var kRoundTripAACParam_Format: number;
declare var kRandomParam_BoundA: number;
declare var kReverb2Param_DryWetMix: number;
declare var kMusicNoteEvent_UseGroupInstrument: number;
declare var kMusicDeviceRange: number;
declare var AVAudioSessionInterruptionFlags_ShouldResume: number;
declare var AVAudioSessionSetActiveFlags_NotifyOthersOnDeactivation: number;
declare var kCMPersistentTrackID_Invalid: number;
declare var kCMAttachmentMode_ShouldNotPropagate: number;
declare var kCMBlockBufferNoErr: number;
declare var kCMBlockBufferAssureMemoryNowFlag: number;
declare var kCMBlockBufferCustomBlockSourceVersion: number;
declare var kCMFormatDescriptionError_InvalidParameter: number;
declare var kCMMediaType_Video: number;
declare var kCMAudioCodecType_AAC_LCProtected: number;
declare var kCMAudioFormatDescriptionMask_StreamBasicDescription: number;
declare var kCMPixelFormat_32ARGB: number;
declare var kCMVideoCodecType_422YpCbCr8: number;
declare var kCMMPEG2VideoProfile_HDV_720p30: number;
declare var kCMMuxedStreamType_MPEG1System: number;
declare var kCMClosedCaptionFormatType_CEA608: number;
declare var kCMTextFormatType_QTText: number;
declare var kCMTextDisplayFlag_scrollIn: number;
declare var kCMTextJustification_left_top: number;
declare var kCMSubtitleFormatType_3GText: number;
declare var kCMTimeCodeFormatType_TimeCode32: number;
declare var kCMTimeCodeFlag_DropFrame: number;
declare var kCMMetadataFormatType_ICY: number;
declare var kCMSampleBufferError_AllocationFailed: number;
declare var kCMSampleBufferFlag_AudioBufferList_Assure16ByteAlignment: number;
declare var kCMClockError_MissingRequiredParameter: number;
declare var kCMTimebaseError_MissingRequiredParameter: number;
declare var kCMSyncError_MissingRequiredParameter: number;
declare var kCMFormatDescriptionBridgeError_InvalidParameter: number;
declare var kCMBufferQueueError_AllocationFailed: number;
declare var kCMBufferQueueTrigger_WhenDurationBecomesLessThan: number;
declare var kCMSimpleQueueError_AllocationFailed: number;
declare var kCMMetadataIdentifierError_AllocationFailed: number;
declare var kCMMetadataDataTypeRegistryError_AllocationFailed: number;
declare var kMTAudioProcessingTapCreationFlag_PreEffects: number;
declare var kMTAudioProcessingTapFlag_StartOfStream: number;
declare var kMTAudioProcessingTapCallbacksVersion_0: number;
declare var kCTErrorDomainNoError: number;
declare var EKSunday: number;
declare var EKCalendarEventAvailabilityNone: number;
declare var EKEntityTypeEvent: number;
declare var EKEntityMaskEvent: number;
declare var EKAlarmProximityNone: number;
declare var GKPhotoSizeSmall: number;
declare var GKPeerPickerConnectionTypeOnline: number;
declare var kJSPropertyAttributeNone: number;
declare var kJSClassAttributeNone: number;
declare var SKErrorUnknown: number;
declare var kSCStatusOK: number;
declare var kSCPreferencesNotificationCommit: number;
declare var kSCBondStatusOK: number;
declare var kSCNetworkFlagsTransientConnection: number;
declare var kSCNetworkReachabilityFlagsTransientConnection: number;
declare var kSCNetworkConnectionInvalid: number;
declare var kSCNetworkConnectionPPPDisconnected: number;
declare var TWRequestMethodGET: number;
declare var TWTweetComposeViewControllerResultCancelled: number;
declare var kVTUnlimitedFrameDelayCount: number;
declare var kVTPropertyNotSupportedErr: number;
declare var kVTDecodeFrame_EnableAsynchronousDecompression: number;
declare var kVTDecodeInfo_Asynchronous: number;
declare var kVTEncodeInfo_Asynchronous: number;
declare var signgam: number;
declare var optarg: string;
declare var optind: number;
declare var opterr: number;
declare var optopt: number;
declare var suboptarg: string;
declare var optreset: number;
declare var _NSConcreteGlobalBlock: any[];
declare var _NSConcreteStackBlock: any[];
declare var _DefaultRuneLocale: _RuneLocale;
declare var _CurrentRuneLocale: any;
declare var sys_signame: string[];
declare var sys_siglist: string[];
declare var __stdinp: any;
declare var __stdoutp: any;
declare var __stderrp: any;
declare var sys_nerr: number;
declare var sys_errlist: any;
declare var __mb_cur_max: number;
declare var tzname: any;
declare var getdate_err: number;
declare var timezoneVar: number;
declare var daylight: number;
declare var _dispatch_main_q: void;
declare var _dispatch_queue_attr_concurrent: void;
declare var KERNEL_SECURITY_TOKEN: security_token_t;
declare var KERNEL_AUDIT_TOKEN: audit_token_t;
declare var _dispatch_source_type_data_add: void;
declare var _dispatch_source_type_data_or: void;
declare var _dispatch_source_type_mach_send: void;
declare var _dispatch_source_type_mach_recv: void;
declare var _dispatch_source_type_memorypressure: void;
declare var _dispatch_source_type_proc: void;
declare var _dispatch_source_type_read: void;
declare var _dispatch_source_type_signal: void;
declare var _dispatch_source_type_timer: void;
declare var _dispatch_source_type_vnode: void;
declare var _dispatch_source_type_write: void;
declare var _dispatch_data_empty: void;
declare var _dispatch_data_destructor_free: () => void;
declare var _dispatch_data_destructor_munmap: () => void;
declare var averunnable: loadavg;
declare var CGPointZero: CGPoint;
declare var CGSizeZero: CGSize;
declare var CGRectZero: CGRect;
declare var CGRectNull: CGRect;
declare var CGRectInfinite: CGRect;
declare var CGAffineTransformIdentity: CGAffineTransform;
declare var kCGFontVariationAxisName: string;
declare var kCGFontVariationAxisMinValue: string;
declare var kCGFontVariationAxisMaxValue: string;
declare var kCGFontVariationAxisDefaultValue: string;
declare var kCGPDFContextMediaBox: string;
declare var kCGPDFContextCropBox: string;
declare var kCGPDFContextBleedBox: string;
declare var kCGPDFContextTrimBox: string;
declare var kCGPDFContextArtBox: string;
declare var kCGPDFContextTitle: string;
declare var kCGPDFContextAuthor: string;
declare var kCGPDFContextSubject: string;
declare var kCGPDFContextKeywords: string;
declare var kCGPDFContextCreator: string;
declare var kCGPDFContextOwnerPassword: string;
declare var kCGPDFContextUserPassword: string;
declare var kCGPDFContextEncryptionKeyLength: string;
declare var kCGPDFContextAllowsPrinting: string;
declare var kCGPDFContextAllowsCopying: string;
declare var kCFCoreFoundationVersionNumber: number;
declare var kCFNull: any;
declare var kCFAllocatorDefault: any;
declare var kCFAllocatorSystemDefault: any;
declare var kCFAllocatorMalloc: any;
declare var kCFAllocatorMallocZone: any;
declare var kCFAllocatorNull: any;
declare var kCFAllocatorUseContext: any;
declare var kCFTypeDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
declare var kCFCopyStringDictionaryKeyCallBacks: CFDictionaryKeyCallBacks;
declare var kCFTypeDictionaryValueCallBacks: CFDictionaryValueCallBacks;
declare var kCFTypeArrayCallBacks: CFArrayCallBacks;
declare var kCFLocaleCurrentLocaleDidChangeNotification: string;
declare var kCFLocaleIdentifier: string;
declare var kCFLocaleLanguageCode: string;
declare var kCFLocaleCountryCode: string;
declare var kCFLocaleScriptCode: string;
declare var kCFLocaleVariantCode: string;
declare var kCFLocaleExemplarCharacterSet: string;
declare var kCFLocaleCalendarIdentifier: string;
declare var kCFLocaleCalendar: string;
declare var kCFLocaleCollationIdentifier: string;
declare var kCFLocaleUsesMetricSystem: string;
declare var kCFLocaleMeasurementSystem: string;
declare var kCFLocaleDecimalSeparator: string;
declare var kCFLocaleGroupingSeparator: string;
declare var kCFLocaleCurrencySymbol: string;
declare var kCFLocaleCurrencyCode: string;
declare var kCFLocaleCollatorIdentifier: string;
declare var kCFLocaleQuotationBeginDelimiterKey: string;
declare var kCFLocaleQuotationEndDelimiterKey: string;
declare var kCFLocaleAlternateQuotationBeginDelimiterKey: string;
declare var kCFLocaleAlternateQuotationEndDelimiterKey: string;
declare var kCFGregorianCalendar: string;
declare var kCFBuddhistCalendar: string;
declare var kCFChineseCalendar: string;
declare var kCFHebrewCalendar: string;
declare var kCFIslamicCalendar: string;
declare var kCFIslamicCivilCalendar: string;
declare var kCFJapaneseCalendar: string;
declare var kCFRepublicOfChinaCalendar: string;
declare var kCFPersianCalendar: string;
declare var kCFIndianCalendar: string;
declare var kCFISO8601Calendar: string;
declare var kCFIslamicTabularCalendar: string;
declare var kCFIslamicUmmAlQuraCalendar: string;
declare var kCFStringTransformStripCombiningMarks: string;
declare var kCFStringTransformToLatin: string;
declare var kCFStringTransformFullwidthHalfwidth: string;
declare var kCFStringTransformLatinKatakana: string;
declare var kCFStringTransformLatinHiragana: string;
declare var kCFStringTransformHiraganaKatakana: string;
declare var kCFStringTransformMandarinLatin: string;
declare var kCFStringTransformLatinHangul: string;
declare var kCFStringTransformLatinArabic: string;
declare var kCFStringTransformLatinHebrew: string;
declare var kCFStringTransformLatinThai: string;
declare var kCFStringTransformLatinCyrillic: string;
declare var kCFStringTransformLatinGreek: string;
declare var kCFStringTransformToXMLHex: string;
declare var kCFStringTransformToUnicodeName: string;
declare var kCFStringTransformStripDiacritics: string;
declare var kCFErrorDomainPOSIX: string;
declare var kCFErrorDomainOSStatus: string;
declare var kCFErrorDomainMach: string;
declare var kCFErrorDomainCocoa: string;
declare var kCFErrorLocalizedDescriptionKey: string;
declare var kCFErrorLocalizedFailureReasonKey: string;
declare var kCFErrorLocalizedRecoverySuggestionKey: string;
declare var kCFErrorDescriptionKey: string;
declare var kCFErrorUnderlyingErrorKey: string;
declare var kCFErrorURLKey: string;
declare var kCFErrorFilePathKey: string;
declare var kCFURLKeysOfUnsetValuesKey: string;
declare var kCFURLNameKey: string;
declare var kCFURLLocalizedNameKey: string;
declare var kCFURLIsRegularFileKey: string;
declare var kCFURLIsDirectoryKey: string;
declare var kCFURLIsSymbolicLinkKey: string;
declare var kCFURLIsVolumeKey: string;
declare var kCFURLIsPackageKey: string;
declare var kCFURLIsSystemImmutableKey: string;
declare var kCFURLIsUserImmutableKey: string;
declare var kCFURLIsHiddenKey: string;
declare var kCFURLHasHiddenExtensionKey: string;
declare var kCFURLCreationDateKey: string;
declare var kCFURLContentAccessDateKey: string;
declare var kCFURLContentModificationDateKey: string;
declare var kCFURLAttributeModificationDateKey: string;
declare var kCFURLLinkCountKey: string;
declare var kCFURLParentDirectoryURLKey: string;
declare var kCFURLVolumeURLKey: string;
declare var kCFURLTypeIdentifierKey: string;
declare var kCFURLLocalizedTypeDescriptionKey: string;
declare var kCFURLLabelNumberKey: string;
declare var kCFURLLabelColorKey: string;
declare var kCFURLLocalizedLabelKey: string;
declare var kCFURLEffectiveIconKey: string;
declare var kCFURLCustomIconKey: string;
declare var kCFURLFileResourceIdentifierKey: string;
declare var kCFURLVolumeIdentifierKey: string;
declare var kCFURLPreferredIOBlockSizeKey: string;
declare var kCFURLIsReadableKey: string;
declare var kCFURLIsWritableKey: string;
declare var kCFURLIsExecutableKey: string;
declare var kCFURLFileSecurityKey: string;
declare var kCFURLIsExcludedFromBackupKey: string;
declare var kCFURLPathKey: string;
declare var kCFURLIsMountTriggerKey: string;
declare var kCFURLGenerationIdentifierKey: string;
declare var kCFURLDocumentIdentifierKey: string;
declare var kCFURLAddedToDirectoryDateKey: string;
declare var kCFURLFileResourceTypeKey: string;
declare var kCFURLFileResourceTypeNamedPipe: string;
declare var kCFURLFileResourceTypeCharacterSpecial: string;
declare var kCFURLFileResourceTypeDirectory: string;
declare var kCFURLFileResourceTypeBlockSpecial: string;
declare var kCFURLFileResourceTypeRegular: string;
declare var kCFURLFileResourceTypeSymbolicLink: string;
declare var kCFURLFileResourceTypeSocket: string;
declare var kCFURLFileResourceTypeUnknown: string;
declare var kCFURLFileSizeKey: string;
declare var kCFURLFileAllocatedSizeKey: string;
declare var kCFURLTotalFileSizeKey: string;
declare var kCFURLTotalFileAllocatedSizeKey: string;
declare var kCFURLIsAliasFileKey: string;
declare var kCFURLVolumeLocalizedFormatDescriptionKey: string;
declare var kCFURLVolumeTotalCapacityKey: string;
declare var kCFURLVolumeAvailableCapacityKey: string;
declare var kCFURLVolumeResourceCountKey: string;
declare var kCFURLVolumeSupportsPersistentIDsKey: string;
declare var kCFURLVolumeSupportsSymbolicLinksKey: string;
declare var kCFURLVolumeSupportsHardLinksKey: string;
declare var kCFURLVolumeSupportsJournalingKey: string;
declare var kCFURLVolumeIsJournalingKey: string;
declare var kCFURLVolumeSupportsSparseFilesKey: string;
declare var kCFURLVolumeSupportsZeroRunsKey: string;
declare var kCFURLVolumeSupportsCaseSensitiveNamesKey: string;
declare var kCFURLVolumeSupportsCasePreservedNamesKey: string;
declare var kCFURLVolumeSupportsRootDirectoryDatesKey: string;
declare var kCFURLVolumeSupportsVolumeSizesKey: string;
declare var kCFURLVolumeSupportsRenamingKey: string;
declare var kCFURLVolumeSupportsAdvisoryFileLockingKey: string;
declare var kCFURLVolumeSupportsExtendedSecurityKey: string;
declare var kCFURLVolumeIsBrowsableKey: string;
declare var kCFURLVolumeMaximumFileSizeKey: string;
declare var kCFURLVolumeIsEjectableKey: string;
declare var kCFURLVolumeIsRemovableKey: string;
declare var kCFURLVolumeIsInternalKey: string;
declare var kCFURLVolumeIsAutomountedKey: string;
declare var kCFURLVolumeIsLocalKey: string;
declare var kCFURLVolumeIsReadOnlyKey: string;
declare var kCFURLVolumeCreationDateKey: string;
declare var kCFURLVolumeURLForRemountingKey: string;
declare var kCFURLVolumeUUIDStringKey: string;
declare var kCFURLVolumeNameKey: string;
declare var kCFURLVolumeLocalizedNameKey: string;
declare var kCFURLIsUbiquitousItemKey: string;
declare var kCFURLUbiquitousItemHasUnresolvedConflictsKey: string;
declare var kCFURLUbiquitousItemIsDownloadedKey: string;
declare var kCFURLUbiquitousItemIsDownloadingKey: string;
declare var kCFURLUbiquitousItemIsUploadedKey: string;
declare var kCFURLUbiquitousItemIsUploadingKey: string;
declare var kCFURLUbiquitousItemPercentDownloadedKey: string;
declare var kCFURLUbiquitousItemPercentUploadedKey: string;
declare var kCFURLUbiquitousItemDownloadingStatusKey: string;
declare var kCFURLUbiquitousItemDownloadingErrorKey: string;
declare var kCFURLUbiquitousItemUploadingErrorKey: string;
declare var kCFURLUbiquitousItemDownloadingStatusNotDownloaded: string;
declare var kCFURLUbiquitousItemDownloadingStatusDownloaded: string;
declare var kCFURLUbiquitousItemDownloadingStatusCurrent: string;
declare var kCFAbsoluteTimeIntervalSince1970: number;
declare var kCFAbsoluteTimeIntervalSince1904: number;
declare var kCFTypeBagCallBacks: CFBagCallBacks;
declare var kCFCopyStringBagCallBacks: CFBagCallBacks;
declare var kCFStringBinaryHeapCallBacks: CFBinaryHeapCallBacks;
declare var kCFTimeZoneSystemTimeZoneDidChangeNotification: string;
declare var kCFDateFormatterIsLenient: string;
declare var kCFDateFormatterTimeZone: string;
declare var kCFDateFormatterCalendarName: string;
declare var kCFDateFormatterDefaultFormat: string;
declare var kCFDateFormatterTwoDigitStartDate: string;
declare var kCFDateFormatterDefaultDate: string;
declare var kCFDateFormatterCalendar: string;
declare var kCFDateFormatterEraSymbols: string;
declare var kCFDateFormatterMonthSymbols: string;
declare var kCFDateFormatterShortMonthSymbols: string;
declare var kCFDateFormatterWeekdaySymbols: string;
declare var kCFDateFormatterShortWeekdaySymbols: string;
declare var kCFDateFormatterAMSymbol: string;
declare var kCFDateFormatterPMSymbol: string;
declare var kCFDateFormatterLongEraSymbols: string;
declare var kCFDateFormatterVeryShortMonthSymbols: string;
declare var kCFDateFormatterStandaloneMonthSymbols: string;
declare var kCFDateFormatterShortStandaloneMonthSymbols: string;
declare var kCFDateFormatterVeryShortStandaloneMonthSymbols: string;
declare var kCFDateFormatterVeryShortWeekdaySymbols: string;
declare var kCFDateFormatterStandaloneWeekdaySymbols: string;
declare var kCFDateFormatterShortStandaloneWeekdaySymbols: string;
declare var kCFDateFormatterVeryShortStandaloneWeekdaySymbols: string;
declare var kCFDateFormatterQuarterSymbols: string;
declare var kCFDateFormatterShortQuarterSymbols: string;
declare var kCFDateFormatterStandaloneQuarterSymbols: string;
declare var kCFDateFormatterShortStandaloneQuarterSymbols: string;
declare var kCFDateFormatterGregorianStartDate: string;
declare var kCFDateFormatterDoesRelativeDateFormattingKey: string;
declare var kCFBooleanTrue: any;
declare var kCFBooleanFalse: any;
declare var kCFNumberPositiveInfinity: NSNumber;
declare var kCFNumberNegativeInfinity: NSNumber;
declare var kCFNumberNaN: NSNumber;
declare var kCFNumberFormatterCurrencyCode: string;
declare var kCFNumberFormatterDecimalSeparator: string;
declare var kCFNumberFormatterCurrencyDecimalSeparator: string;
declare var kCFNumberFormatterAlwaysShowDecimalSeparator: string;
declare var kCFNumberFormatterGroupingSeparator: string;
declare var kCFNumberFormatterUseGroupingSeparator: string;
declare var kCFNumberFormatterPercentSymbol: string;
declare var kCFNumberFormatterZeroSymbol: string;
declare var kCFNumberFormatterNaNSymbol: string;
declare var kCFNumberFormatterInfinitySymbol: string;
declare var kCFNumberFormatterMinusSign: string;
declare var kCFNumberFormatterPlusSign: string;
declare var kCFNumberFormatterCurrencySymbol: string;
declare var kCFNumberFormatterExponentSymbol: string;
declare var kCFNumberFormatterMinIntegerDigits: string;
declare var kCFNumberFormatterMaxIntegerDigits: string;
declare var kCFNumberFormatterMinFractionDigits: string;
declare var kCFNumberFormatterMaxFractionDigits: string;
declare var kCFNumberFormatterGroupingSize: string;
declare var kCFNumberFormatterSecondaryGroupingSize: string;
declare var kCFNumberFormatterRoundingMode: string;
declare var kCFNumberFormatterRoundingIncrement: string;
declare var kCFNumberFormatterFormatWidth: string;
declare var kCFNumberFormatterPaddingPosition: string;
declare var kCFNumberFormatterPaddingCharacter: string;
declare var kCFNumberFormatterDefaultFormat: string;
declare var kCFNumberFormatterMultiplier: string;
declare var kCFNumberFormatterPositivePrefix: string;
declare var kCFNumberFormatterPositiveSuffix: string;
declare var kCFNumberFormatterNegativePrefix: string;
declare var kCFNumberFormatterNegativeSuffix: string;
declare var kCFNumberFormatterPerMillSymbol: string;
declare var kCFNumberFormatterInternationalCurrencySymbol: string;
declare var kCFNumberFormatterCurrencyGroupingSeparator: string;
declare var kCFNumberFormatterIsLenient: string;
declare var kCFNumberFormatterUseSignificantDigits: string;
declare var kCFNumberFormatterMinSignificantDigits: string;
declare var kCFNumberFormatterMaxSignificantDigits: string;
declare var kCFPreferencesAnyApplication: string;
declare var kCFPreferencesCurrentApplication: string;
declare var kCFPreferencesAnyHost: string;
declare var kCFPreferencesCurrentHost: string;
declare var kCFPreferencesAnyUser: string;
declare var kCFPreferencesCurrentUser: string;
declare var kCFRunLoopDefaultMode: string;
declare var kCFRunLoopCommonModes: string;
declare var kCFSocketCommandKey: string;
declare var kCFSocketNameKey: string;
declare var kCFSocketValueKey: string;
declare var kCFSocketResultKey: string;
declare var kCFSocketErrorKey: string;
declare var kCFSocketRegisterCommand: string;
declare var kCFSocketRetrieveCommand: string;
declare var kCFStreamPropertyDataWritten: string;
declare var kCFStreamPropertyAppendToFile: string;
declare var kCFStreamPropertyFileCurrentOffset: string;
declare var kCFStreamPropertySocketNativeHandle: string;
declare var kCFStreamPropertySocketRemoteHostName: string;
declare var kCFStreamPropertySocketRemotePortNumber: string;
declare var kCFTypeSetCallBacks: CFSetCallBacks;
declare var kCFCopyStringSetCallBacks: CFSetCallBacks;
declare var kCFURLFileExists: string;
declare var kCFURLFileDirectoryContents: string;
declare var kCFURLFileLength: string;
declare var kCFURLFileLastModificationTime: string;
declare var kCFURLFilePOSIXMode: string;
declare var kCFURLFileOwnerID: string;
declare var kCFURLHTTPStatusCode: string;
declare var kCFURLHTTPStatusLine: string;
declare var kCFBundleInfoDictionaryVersionKey: string;
declare var kCFBundleExecutableKey: string;
declare var kCFBundleIdentifierKey: string;
declare var kCFBundleVersionKey: string;
declare var kCFBundleDevelopmentRegionKey: string;
declare var kCFBundleNameKey: string;
declare var kCFBundleLocalizationsKey: string;
declare var kCFPlugInDynamicRegistrationKey: string;
declare var kCFPlugInDynamicRegisterFunctionKey: string;
declare var kCFPlugInUnloadFunctionKey: string;
declare var kCFPlugInFactoriesKey: string;
declare var kCFPlugInTypesKey: string;
declare var kCVZeroTime: CVTime;
declare var kCVIndefiniteTime: CVTime;
declare var kCVBufferPropagatedAttachmentsKey: string;
declare var kCVBufferNonPropagatedAttachmentsKey: string;
declare var kCVBufferMovieTimeKey: string;
declare var kCVBufferTimeValueKey: string;
declare var kCVBufferTimeScaleKey: string;
declare var kCVImageBufferCGColorSpaceKey: string;
declare var kCVImageBufferCleanApertureKey: string;
declare var kCVImageBufferCleanApertureWidthKey: string;
declare var kCVImageBufferCleanApertureHeightKey: string;
declare var kCVImageBufferCleanApertureHorizontalOffsetKey: string;
declare var kCVImageBufferCleanApertureVerticalOffsetKey: string;
declare var kCVImageBufferPreferredCleanApertureKey: string;
declare var kCVImageBufferFieldCountKey: string;
declare var kCVImageBufferFieldDetailKey: string;
declare var kCVImageBufferFieldDetailTemporalTopFirst: string;
declare var kCVImageBufferFieldDetailTemporalBottomFirst: string;
declare var kCVImageBufferFieldDetailSpatialFirstLineEarly: string;
declare var kCVImageBufferFieldDetailSpatialFirstLineLate: string;
declare var kCVImageBufferPixelAspectRatioKey: string;
declare var kCVImageBufferPixelAspectRatioHorizontalSpacingKey: string;
declare var kCVImageBufferPixelAspectRatioVerticalSpacingKey: string;
declare var kCVImageBufferDisplayDimensionsKey: string;
declare var kCVImageBufferDisplayWidthKey: string;
declare var kCVImageBufferDisplayHeightKey: string;
declare var kCVImageBufferGammaLevelKey: string;
declare var kCVImageBufferICCProfileKey: string;
declare var kCVImageBufferYCbCrMatrixKey: string;
declare var kCVImageBufferYCbCrMatrix_ITU_R_709_2: string;
declare var kCVImageBufferYCbCrMatrix_ITU_R_601_4: string;
declare var kCVImageBufferYCbCrMatrix_SMPTE_240M_1995: string;
declare var kCVImageBufferColorPrimariesKey: string;
declare var kCVImageBufferColorPrimaries_ITU_R_709_2: string;
declare var kCVImageBufferColorPrimaries_EBU_3213: string;
declare var kCVImageBufferColorPrimaries_SMPTE_C: string;
declare var kCVImageBufferColorPrimaries_P22: string;
declare var kCVImageBufferTransferFunctionKey: string;
declare var kCVImageBufferTransferFunction_ITU_R_709_2: string;
declare var kCVImageBufferTransferFunction_SMPTE_240M_1995: string;
declare var kCVImageBufferTransferFunction_UseGamma: string;
declare var kCVImageBufferChromaLocationTopFieldKey: string;
declare var kCVImageBufferChromaLocationBottomFieldKey: string;
declare var kCVImageBufferChromaLocation_Left: string;
declare var kCVImageBufferChromaLocation_Center: string;
declare var kCVImageBufferChromaLocation_TopLeft: string;
declare var kCVImageBufferChromaLocation_Top: string;
declare var kCVImageBufferChromaLocation_BottomLeft: string;
declare var kCVImageBufferChromaLocation_Bottom: string;
declare var kCVImageBufferChromaLocation_DV420: string;
declare var kCVImageBufferChromaSubsamplingKey: string;
declare var kCVImageBufferChromaSubsampling_420: string;
declare var kCVImageBufferChromaSubsampling_422: string;
declare var kCVImageBufferChromaSubsampling_411: string;
declare var kCVImageBufferAlphaChannelIsOpaque: string;
declare var kCVPixelBufferPixelFormatTypeKey: string;
declare var kCVPixelBufferMemoryAllocatorKey: string;
declare var kCVPixelBufferWidthKey: string;
declare var kCVPixelBufferHeightKey: string;
declare var kCVPixelBufferExtendedPixelsLeftKey: string;
declare var kCVPixelBufferExtendedPixelsTopKey: string;
declare var kCVPixelBufferExtendedPixelsRightKey: string;
declare var kCVPixelBufferExtendedPixelsBottomKey: string;
declare var kCVPixelBufferBytesPerRowAlignmentKey: string;
declare var kCVPixelBufferCGBitmapContextCompatibilityKey: string;
declare var kCVPixelBufferCGImageCompatibilityKey: string;
declare var kCVPixelBufferOpenGLCompatibilityKey: string;
declare var kCVPixelBufferPlaneAlignmentKey: string;
declare var kCVPixelBufferIOSurfacePropertiesKey: string;
declare var kCVPixelBufferOpenGLESCompatibilityKey: string;
declare var kCVPixelBufferMetalCompatibilityKey: string;
declare var kCVPixelBufferPoolMinimumBufferCountKey: string;
declare var kCVPixelBufferPoolMaximumBufferAgeKey: string;
declare var kCVPixelBufferPoolAllocationThresholdKey: string;
declare var kCVPixelBufferPoolFreeBufferNotification: string;
declare var kCVOpenGLESTextureCacheMaximumTextureAgeKey: string;
declare var kCVPixelFormatName: string;
declare var kCVPixelFormatConstant: string;
declare var kCVPixelFormatCodecType: string;
declare var kCVPixelFormatFourCC: string;
declare var kCVPixelFormatContainsAlpha: string;
declare var kCVPixelFormatContainsYCbCr: string;
declare var kCVPixelFormatContainsRGB: string;
declare var kCVPixelFormatPlanes: string;
declare var kCVPixelFormatBlockWidth: string;
declare var kCVPixelFormatBlockHeight: string;
declare var kCVPixelFormatBitsPerBlock: string;
declare var kCVPixelFormatBlockHorizontalAlignment: string;
declare var kCVPixelFormatBlockVerticalAlignment: string;
declare var kCVPixelFormatBlackBlock: string;
declare var kCVPixelFormatHorizontalSubsampling: string;
declare var kCVPixelFormatVerticalSubsampling: string;
declare var kCVPixelFormatOpenGLFormat: string;
declare var kCVPixelFormatOpenGLType: string;
declare var kCVPixelFormatOpenGLInternalFormat: string;
declare var kCVPixelFormatCGBitmapInfo: string;
declare var kCVPixelFormatQDCompatibility: string;
declare var kCVPixelFormatCGBitmapContextCompatibility: string;
declare var kCVPixelFormatCGImageCompatibility: string;
declare var kCVPixelFormatOpenGLCompatibility: string;
declare var kCVPixelFormatOpenGLESCompatibility: string;
declare var kCVPixelFormatFillExtendedPixelsCallback: string;
declare var kCVMetalTextureCacheMaximumTextureAgeKey: string;
declare var NSFoundationVersionNumber: number;
declare var NSBundleDidLoadNotification: string;
declare var NSLoadedClasses: string;
declare var NSSystemClockDidChangeNotification: string;
declare var NSCalendarIdentifierGregorian: string;
declare var NSCalendarIdentifierBuddhist: string;
declare var NSCalendarIdentifierChinese: string;
declare var NSCalendarIdentifierCoptic: string;
declare var NSCalendarIdentifierEthiopicAmeteMihret: string;
declare var NSCalendarIdentifierEthiopicAmeteAlem: string;
declare var NSCalendarIdentifierHebrew: string;
declare var NSCalendarIdentifierISO8601: string;
declare var NSCalendarIdentifierIndian: string;
declare var NSCalendarIdentifierIslamic: string;
declare var NSCalendarIdentifierIslamicCivil: string;
declare var NSCalendarIdentifierJapanese: string;
declare var NSCalendarIdentifierPersian: string;
declare var NSCalendarIdentifierRepublicOfChina: string;
declare var NSCalendarIdentifierIslamicTabular: string;
declare var NSCalendarIdentifierIslamicUmmAlQura: string;
declare var NSCalendarDayChangedNotification: string;
declare var NSParseErrorException: string;
declare var NSCharacterConversionException: string;
declare var NSStringEncodingDetectionSuggestedEncodingsKey: string;
declare var NSStringEncodingDetectionDisallowedEncodingsKey: string;
declare var NSStringEncodingDetectionUseOnlySuggestedEncodingsKey: string;
declare var NSStringEncodingDetectionAllowLossyKey: string;
declare var NSStringEncodingDetectionFromWindowsKey: string;
declare var NSStringEncodingDetectionLossySubstitutionKey: string;
declare var NSStringEncodingDetectionLikelyLanguageKey: string;
declare var _NSConstantStringClassReference: any;
declare var NSDecimalNumberExactnessException: string;
declare var NSDecimalNumberOverflowException: string;
declare var NSDecimalNumberUnderflowException: string;
declare var NSDecimalNumberDivideByZeroException: string;
declare var NSCocoaErrorDomain: string;
declare var NSPOSIXErrorDomain: string;
declare var NSOSStatusErrorDomain: string;
declare var NSMachErrorDomain: string;
declare var NSUnderlyingErrorKey: string;
declare var NSLocalizedDescriptionKey: string;
declare var NSLocalizedFailureReasonErrorKey: string;
declare var NSLocalizedRecoverySuggestionErrorKey: string;
declare var NSLocalizedRecoveryOptionsErrorKey: string;
declare var NSRecoveryAttempterErrorKey: string;
declare var NSHelpAnchorErrorKey: string;
declare var NSStringEncodingErrorKey: string;
declare var NSURLErrorKey: string;
declare var NSFilePathErrorKey: string;
declare var NSGenericException: string;
declare var NSRangeException: string;
declare var NSInvalidArgumentException: string;
declare var NSInternalInconsistencyException: string;
declare var NSMallocException: string;
declare var NSObjectInaccessibleException: string;
declare var NSObjectNotAvailableException: string;
declare var NSDestinationInvalidException: string;
declare var NSPortTimeoutException: string;
declare var NSInvalidSendPortException: string;
declare var NSInvalidReceivePortException: string;
declare var NSPortSendException: string;
declare var NSPortReceiveException: string;
declare var NSOldStyleException: string;
declare var NSAssertionHandlerKey: string;
declare var NSFileHandleOperationException: string;
declare var NSFileHandleReadCompletionNotification: string;
declare var NSFileHandleReadToEndOfFileCompletionNotification: string;
declare var NSFileHandleConnectionAcceptedNotification: string;
declare var NSFileHandleDataAvailableNotification: string;
declare var NSFileHandleNotificationDataItem: string;
declare var NSFileHandleNotificationFileHandleItem: string;
declare var NSFileHandleNotificationMonitorModes: string;
declare var NSUbiquityIdentityDidChangeNotification: string;
declare var NSFileType: string;
declare var NSFileTypeDirectory: string;
declare var NSFileTypeRegular: string;
declare var NSFileTypeSymbolicLink: string;
declare var NSFileTypeSocket: string;
declare var NSFileTypeCharacterSpecial: string;
declare var NSFileTypeBlockSpecial: string;
declare var NSFileTypeUnknown: string;
declare var NSFileSize: string;
declare var NSFileModificationDate: string;
declare var NSFileReferenceCount: string;
declare var NSFileDeviceIdentifier: string;
declare var NSFileOwnerAccountName: string;
declare var NSFileGroupOwnerAccountName: string;
declare var NSFilePosixPermissions: string;
declare var NSFileSystemNumber: string;
declare var NSFileSystemFileNumber: string;
declare var NSFileExtensionHidden: string;
declare var NSFileHFSCreatorCode: string;
declare var NSFileHFSTypeCode: string;
declare var NSFileImmutable: string;
declare var NSFileAppendOnly: string;
declare var NSFileCreationDate: string;
declare var NSFileOwnerAccountID: string;
declare var NSFileGroupOwnerAccountID: string;
declare var NSFileBusy: string;
declare var NSFileProtectionKey: string;
declare var NSFileProtectionNone: string;
declare var NSFileProtectionComplete: string;
declare var NSFileProtectionCompleteUnlessOpen: string;
declare var NSFileProtectionCompleteUntilFirstUserAuthentication: string;
declare var NSFileSystemSize: string;
declare var NSFileSystemFreeSize: string;
declare var NSFileSystemNodes: string;
declare var NSFileSystemFreeNodes: string;
declare var NSHTTPCookieName: string;
declare var NSHTTPCookieValue: string;
declare var NSHTTPCookieOriginURL: string;
declare var NSHTTPCookieVersion: string;
declare var NSHTTPCookieDomain: string;
declare var NSHTTPCookiePath: string;
declare var NSHTTPCookieSecure: string;
declare var NSHTTPCookieExpires: string;
declare var NSHTTPCookieComment: string;
declare var NSHTTPCookieCommentURL: string;
declare var NSHTTPCookieDiscard: string;
declare var NSHTTPCookieMaximumAge: string;
declare var NSHTTPCookiePort: string;
declare var NSHTTPCookieManagerAcceptPolicyChangedNotification: string;
declare var NSHTTPCookieManagerCookiesChangedNotification: string;
declare var NSUndefinedKeyException: string;
declare var NSAverageKeyValueOperator: string;
declare var NSCountKeyValueOperator: string;
declare var NSDistinctUnionOfArraysKeyValueOperator: string;
declare var NSDistinctUnionOfObjectsKeyValueOperator: string;
declare var NSDistinctUnionOfSetsKeyValueOperator: string;
declare var NSMaximumKeyValueOperator: string;
declare var NSMinimumKeyValueOperator: string;
declare var NSSumKeyValueOperator: string;
declare var NSUnionOfArraysKeyValueOperator: string;
declare var NSUnionOfObjectsKeyValueOperator: string;
declare var NSUnionOfSetsKeyValueOperator: string;
declare var NSKeyValueChangeKindKey: string;
declare var NSKeyValueChangeNewKey: string;
declare var NSKeyValueChangeOldKey: string;
declare var NSKeyValueChangeIndexesKey: string;
declare var NSKeyValueChangeNotificationIsPriorKey: string;
declare var NSInvalidArchiveOperationException: string;
declare var NSInvalidUnarchiveOperationException: string;
declare var NSKeyedArchiveRootObjectKey: string;
declare var NSCurrentLocaleDidChangeNotification: string;
declare var NSLocaleIdentifier: string;
declare var NSLocaleLanguageCode: string;
declare var NSLocaleCountryCode: string;
declare var NSLocaleScriptCode: string;
declare var NSLocaleVariantCode: string;
declare var NSLocaleExemplarCharacterSet: string;
declare var NSLocaleCalendar: string;
declare var NSLocaleCollationIdentifier: string;
declare var NSLocaleUsesMetricSystem: string;
declare var NSLocaleMeasurementSystem: string;
declare var NSLocaleDecimalSeparator: string;
declare var NSLocaleGroupingSeparator: string;
declare var NSLocaleCurrencySymbol: string;
declare var NSLocaleCurrencyCode: string;
declare var NSLocaleCollatorIdentifier: string;
declare var NSLocaleQuotationBeginDelimiterKey: string;
declare var NSLocaleQuotationEndDelimiterKey: string;
declare var NSLocaleAlternateQuotationBeginDelimiterKey: string;
declare var NSLocaleAlternateQuotationEndDelimiterKey: string;
declare var NSGregorianCalendar: string;
declare var NSBuddhistCalendar: string;
declare var NSChineseCalendar: string;
declare var NSHebrewCalendar: string;
declare var NSIslamicCalendar: string;
declare var NSIslamicCivilCalendar: string;
declare var NSJapaneseCalendar: string;
declare var NSRepublicOfChinaCalendar: string;
declare var NSPersianCalendar: string;
declare var NSIndianCalendar: string;
declare var NSISO8601Calendar: string;
declare var NSInvocationOperationVoidResultException: string;
declare var NSInvocationOperationCancelledException: string;
declare var NSPortDidBecomeInvalidNotification: string;
declare var NSTextCheckingNameKey: string;
declare var NSTextCheckingJobTitleKey: string;
declare var NSTextCheckingOrganizationKey: string;
declare var NSTextCheckingStreetKey: string;
declare var NSTextCheckingCityKey: string;
declare var NSTextCheckingStateKey: string;
declare var NSTextCheckingZIPKey: string;
declare var NSTextCheckingCountryKey: string;
declare var NSTextCheckingPhoneKey: string;
declare var NSTextCheckingAirlineKey: string;
declare var NSTextCheckingFlightKey: string;
declare var NSDefaultRunLoopMode: string;
declare var NSRunLoopCommonModes: string;
declare var NSStreamSocketSecurityLevelKey: string;
declare var NSStreamSocketSecurityLevelNone: string;
declare var NSStreamSocketSecurityLevelSSLv2: string;
declare var NSStreamSocketSecurityLevelSSLv3: string;
declare var NSStreamSocketSecurityLevelTLSv1: string;
declare var NSStreamSocketSecurityLevelNegotiatedSSL: string;
declare var NSStreamSOCKSProxyConfigurationKey: string;
declare var NSStreamSOCKSProxyHostKey: string;
declare var NSStreamSOCKSProxyPortKey: string;
declare var NSStreamSOCKSProxyVersionKey: string;
declare var NSStreamSOCKSProxyUserKey: string;
declare var NSStreamSOCKSProxyPasswordKey: string;
declare var NSStreamSOCKSProxyVersion4: string;
declare var NSStreamSOCKSProxyVersion5: string;
declare var NSStreamDataWrittenToMemoryStreamKey: string;
declare var NSStreamFileCurrentOffsetKey: string;
declare var NSStreamSocketSSLErrorDomain: string;
declare var NSStreamSOCKSErrorDomain: string;
declare var NSStreamNetworkServiceType: string;
declare var NSStreamNetworkServiceTypeVoIP: string;
declare var NSStreamNetworkServiceTypeVideo: string;
declare var NSStreamNetworkServiceTypeBackground: string;
declare var NSStreamNetworkServiceTypeVoice: string;
declare var NSWillBecomeMultiThreadedNotification: string;
declare var NSDidBecomeSingleThreadedNotification: string;
declare var NSThreadWillExitNotification: string;
declare var NSSystemTimeZoneDidChangeNotification: string;
declare var NSURLFileScheme: string;
declare var NSURLKeysOfUnsetValuesKey: string;
declare var NSURLNameKey: string;
declare var NSURLLocalizedNameKey: string;
declare var NSURLIsRegularFileKey: string;
declare var NSURLIsDirectoryKey: string;
declare var NSURLIsSymbolicLinkKey: string;
declare var NSURLIsVolumeKey: string;
declare var NSURLIsPackageKey: string;
declare var NSURLIsSystemImmutableKey: string;
declare var NSURLIsUserImmutableKey: string;
declare var NSURLIsHiddenKey: string;
declare var NSURLHasHiddenExtensionKey: string;
declare var NSURLCreationDateKey: string;
declare var NSURLContentAccessDateKey: string;
declare var NSURLContentModificationDateKey: string;
declare var NSURLAttributeModificationDateKey: string;
declare var NSURLLinkCountKey: string;
declare var NSURLParentDirectoryURLKey: string;
declare var NSURLVolumeURLKey: string;
declare var NSURLTypeIdentifierKey: string;
declare var NSURLLocalizedTypeDescriptionKey: string;
declare var NSURLLabelNumberKey: string;
declare var NSURLLabelColorKey: string;
declare var NSURLLocalizedLabelKey: string;
declare var NSURLEffectiveIconKey: string;
declare var NSURLCustomIconKey: string;
declare var NSURLFileResourceIdentifierKey: string;
declare var NSURLVolumeIdentifierKey: string;
declare var NSURLPreferredIOBlockSizeKey: string;
declare var NSURLIsReadableKey: string;
declare var NSURLIsWritableKey: string;
declare var NSURLIsExecutableKey: string;
declare var NSURLFileSecurityKey: string;
declare var NSURLIsExcludedFromBackupKey: string;
declare var NSURLPathKey: string;
declare var NSURLIsMountTriggerKey: string;
declare var NSURLGenerationIdentifierKey: string;
declare var NSURLDocumentIdentifierKey: string;
declare var NSURLAddedToDirectoryDateKey: string;
declare var NSURLFileResourceTypeKey: string;
declare var NSURLFileResourceTypeNamedPipe: string;
declare var NSURLFileResourceTypeCharacterSpecial: string;
declare var NSURLFileResourceTypeDirectory: string;
declare var NSURLFileResourceTypeBlockSpecial: string;
declare var NSURLFileResourceTypeRegular: string;
declare var NSURLFileResourceTypeSymbolicLink: string;
declare var NSURLFileResourceTypeSocket: string;
declare var NSURLFileResourceTypeUnknown: string;
declare var NSURLThumbnailDictionaryKey: string;
declare var NSThumbnail1024x1024SizeKey: string;
declare var NSURLFileSizeKey: string;
declare var NSURLFileAllocatedSizeKey: string;
declare var NSURLTotalFileSizeKey: string;
declare var NSURLTotalFileAllocatedSizeKey: string;
declare var NSURLIsAliasFileKey: string;
declare var NSURLVolumeLocalizedFormatDescriptionKey: string;
declare var NSURLVolumeTotalCapacityKey: string;
declare var NSURLVolumeAvailableCapacityKey: string;
declare var NSURLVolumeResourceCountKey: string;
declare var NSURLVolumeSupportsPersistentIDsKey: string;
declare var NSURLVolumeSupportsSymbolicLinksKey: string;
declare var NSURLVolumeSupportsHardLinksKey: string;
declare var NSURLVolumeSupportsJournalingKey: string;
declare var NSURLVolumeIsJournalingKey: string;
declare var NSURLVolumeSupportsSparseFilesKey: string;
declare var NSURLVolumeSupportsZeroRunsKey: string;
declare var NSURLVolumeSupportsCaseSensitiveNamesKey: string;
declare var NSURLVolumeSupportsCasePreservedNamesKey: string;
declare var NSURLVolumeSupportsRootDirectoryDatesKey: string;
declare var NSURLVolumeSupportsVolumeSizesKey: string;
declare var NSURLVolumeSupportsRenamingKey: string;
declare var NSURLVolumeSupportsAdvisoryFileLockingKey: string;
declare var NSURLVolumeSupportsExtendedSecurityKey: string;
declare var NSURLVolumeIsBrowsableKey: string;
declare var NSURLVolumeMaximumFileSizeKey: string;
declare var NSURLVolumeIsEjectableKey: string;
declare var NSURLVolumeIsRemovableKey: string;
declare var NSURLVolumeIsInternalKey: string;
declare var NSURLVolumeIsAutomountedKey: string;
declare var NSURLVolumeIsLocalKey: string;
declare var NSURLVolumeIsReadOnlyKey: string;
declare var NSURLVolumeCreationDateKey: string;
declare var NSURLVolumeURLForRemountingKey: string;
declare var NSURLVolumeUUIDStringKey: string;
declare var NSURLVolumeNameKey: string;
declare var NSURLVolumeLocalizedNameKey: string;
declare var NSURLIsUbiquitousItemKey: string;
declare var NSURLUbiquitousItemHasUnresolvedConflictsKey: string;
declare var NSURLUbiquitousItemIsDownloadedKey: string;
declare var NSURLUbiquitousItemIsDownloadingKey: string;
declare var NSURLUbiquitousItemIsUploadedKey: string;
declare var NSURLUbiquitousItemIsUploadingKey: string;
declare var NSURLUbiquitousItemPercentDownloadedKey: string;
declare var NSURLUbiquitousItemPercentUploadedKey: string;
declare var NSURLUbiquitousItemDownloadingStatusKey: string;
declare var NSURLUbiquitousItemDownloadingErrorKey: string;
declare var NSURLUbiquitousItemUploadingErrorKey: string;
declare var NSURLUbiquitousItemDownloadRequestedKey: string;
declare var NSURLUbiquitousItemContainerDisplayNameKey: string;
declare var NSURLUbiquitousItemDownloadingStatusNotDownloaded: string;
declare var NSURLUbiquitousItemDownloadingStatusDownloaded: string;
declare var NSURLUbiquitousItemDownloadingStatusCurrent: string;
declare var NSURLCredentialStorageChangedNotification: string;
declare var NSURLCredentialStorageRemoveSynchronizableCredentials: string;
declare var NSURLErrorDomain: string;
declare var NSURLErrorFailingURLErrorKey: string;
declare var NSURLErrorFailingURLStringErrorKey: string;
declare var NSErrorFailingURLStringKey: string;
declare var NSURLErrorFailingURLPeerTrustErrorKey: string;
declare var NSURLErrorBackgroundTaskCancelledReasonKey: string;
declare var NSURLProtectionSpaceHTTP: string;
declare var NSURLProtectionSpaceHTTPS: string;
declare var NSURLProtectionSpaceFTP: string;
declare var NSURLProtectionSpaceHTTPProxy: string;
declare var NSURLProtectionSpaceHTTPSProxy: string;
declare var NSURLProtectionSpaceFTPProxy: string;
declare var NSURLProtectionSpaceSOCKSProxy: string;
declare var NSURLAuthenticationMethodDefault: string;
declare var NSURLAuthenticationMethodHTTPBasic: string;
declare var NSURLAuthenticationMethodHTTPDigest: string;
declare var NSURLAuthenticationMethodHTMLForm: string;
declare var NSURLAuthenticationMethodNTLM: string;
declare var NSURLAuthenticationMethodNegotiate: string;
declare var NSURLAuthenticationMethodClientCertificate: string;
declare var NSURLAuthenticationMethodServerTrust: string;
declare var NSGlobalDomain: string;
declare var NSArgumentDomain: string;
declare var NSRegistrationDomain: string;
declare var NSUserDefaultsDidChangeNotification: string;
declare var NSNegateBooleanTransformerName: string;
declare var NSIsNilTransformerName: string;
declare var NSIsNotNilTransformerName: string;
declare var NSUnarchiveFromDataTransformerName: string;
declare var NSKeyedUnarchiveFromDataTransformerName: string;
declare var NSXMLParserErrorDomain: string;
declare var NSExtensionItemsAndErrorsKey: string;
declare var NSItemProviderPreferredImageSizeKey: string;
declare var NSExtensionJavaScriptPreprocessingResultsKey: string;
declare var NSExtensionJavaScriptFinalizeArgumentKey: string;
declare var NSItemProviderErrorDomain: string;
declare var NSExtensionItemAttributedTitleKey: string;
declare var NSExtensionItemAttributedContentTextKey: string;
declare var NSExtensionItemAttachmentsKey: string;
declare var NSLinguisticTagSchemeTokenType: string;
declare var NSLinguisticTagSchemeLexicalClass: string;
declare var NSLinguisticTagSchemeNameType: string;
declare var NSLinguisticTagSchemeNameTypeOrLexicalClass: string;
declare var NSLinguisticTagSchemeLemma: string;
declare var NSLinguisticTagSchemeLanguage: string;
declare var NSLinguisticTagSchemeScript: string;
declare var NSLinguisticTagWord: string;
declare var NSLinguisticTagPunctuation: string;
declare var NSLinguisticTagWhitespace: string;
declare var NSLinguisticTagOther: string;
declare var NSLinguisticTagNoun: string;
declare var NSLinguisticTagVerb: string;
declare var NSLinguisticTagAdjective: string;
declare var NSLinguisticTagAdverb: string;
declare var NSLinguisticTagPronoun: string;
declare var NSLinguisticTagDeterminer: string;
declare var NSLinguisticTagParticle: string;
declare var NSLinguisticTagPreposition: string;
declare var NSLinguisticTagNumber: string;
declare var NSLinguisticTagConjunction: string;
declare var NSLinguisticTagInterjection: string;
declare var NSLinguisticTagClassifier: string;
declare var NSLinguisticTagIdiom: string;
declare var NSLinguisticTagOtherWord: string;
declare var NSLinguisticTagSentenceTerminator: string;
declare var NSLinguisticTagOpenQuote: string;
declare var NSLinguisticTagCloseQuote: string;
declare var NSLinguisticTagOpenParenthesis: string;
declare var NSLinguisticTagCloseParenthesis: string;
declare var NSLinguisticTagWordJoiner: string;
declare var NSLinguisticTagDash: string;
declare var NSLinguisticTagOtherPunctuation: string;
declare var NSLinguisticTagParagraphBreak: string;
declare var NSLinguisticTagOtherWhitespace: string;
declare var NSLinguisticTagPersonalName: string;
declare var NSLinguisticTagPlaceName: string;
declare var NSLinguisticTagOrganizationName: string;
declare var NSMetadataItemFSNameKey: string;
declare var NSMetadataItemDisplayNameKey: string;
declare var NSMetadataItemURLKey: string;
declare var NSMetadataItemPathKey: string;
declare var NSMetadataItemFSSizeKey: string;
declare var NSMetadataItemFSCreationDateKey: string;
declare var NSMetadataItemFSContentChangeDateKey: string;
declare var NSMetadataItemContentTypeKey: string;
declare var NSMetadataItemContentTypeTreeKey: string;
declare var NSMetadataItemIsUbiquitousKey: string;
declare var NSMetadataUbiquitousItemHasUnresolvedConflictsKey: string;
declare var NSMetadataUbiquitousItemIsDownloadedKey: string;
declare var NSMetadataUbiquitousItemDownloadingStatusKey: string;
declare var NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: string;
declare var NSMetadataUbiquitousItemDownloadingStatusDownloaded: string;
declare var NSMetadataUbiquitousItemDownloadingStatusCurrent: string;
declare var NSMetadataUbiquitousItemIsDownloadingKey: string;
declare var NSMetadataUbiquitousItemIsUploadedKey: string;
declare var NSMetadataUbiquitousItemIsUploadingKey: string;
declare var NSMetadataUbiquitousItemPercentDownloadedKey: string;
declare var NSMetadataUbiquitousItemPercentUploadedKey: string;
declare var NSMetadataUbiquitousItemDownloadingErrorKey: string;
declare var NSMetadataUbiquitousItemUploadingErrorKey: string;
declare var NSMetadataUbiquitousItemDownloadRequestedKey: string;
declare var NSMetadataUbiquitousItemIsExternalDocumentKey: string;
declare var NSMetadataUbiquitousItemContainerDisplayNameKey: string;
declare var NSMetadataUbiquitousItemURLInLocalContainerKey: string;
declare var NSMetadataQueryDidStartGatheringNotification: string;
declare var NSMetadataQueryGatheringProgressNotification: string;
declare var NSMetadataQueryDidFinishGatheringNotification: string;
declare var NSMetadataQueryDidUpdateNotification: string;
declare var NSMetadataQueryUpdateAddedItemsKey: string;
declare var NSMetadataQueryUpdateChangedItemsKey: string;
declare var NSMetadataQueryUpdateRemovedItemsKey: string;
declare var NSMetadataQueryResultContentRelevanceAttribute: string;
declare var NSMetadataQueryUbiquitousDocumentsScope: string;
declare var NSMetadataQueryUbiquitousDataScope: string;
declare var NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: string;
declare var NSNetServicesErrorCode: string;
declare var NSNetServicesErrorDomain: string;
declare var NSProgressEstimatedTimeRemainingKey: string;
declare var NSProgressThroughputKey: string;
declare var NSProgressKindFile: string;
declare var NSProgressFileOperationKindKey: string;
declare var NSProgressFileOperationKindDownloading: string;
declare var NSProgressFileOperationKindDecompressingAfterDownloading: string;
declare var NSProgressFileOperationKindReceiving: string;
declare var NSProgressFileOperationKindCopying: string;
declare var NSProgressFileURLKey: string;
declare var NSProgressFileTotalCountKey: string;
declare var NSProgressFileCompletedCountKey: string;
declare var NSUbiquitousKeyValueStoreDidChangeExternallyNotification: string;
declare var NSUbiquitousKeyValueStoreChangeReasonKey: string;
declare var NSUbiquitousKeyValueStoreChangedKeysKey: string;
declare var NSUndoManagerGroupIsDiscardableKey: string;
declare var NSUndoManagerCheckpointNotification: string;
declare var NSUndoManagerWillUndoChangeNotification: string;
declare var NSUndoManagerWillRedoChangeNotification: string;
declare var NSUndoManagerDidUndoChangeNotification: string;
declare var NSUndoManagerDidRedoChangeNotification: string;
declare var NSUndoManagerDidOpenUndoGroupNotification: string;
declare var NSUndoManagerWillCloseUndoGroupNotification: string;
declare var NSUndoManagerDidCloseUndoGroupNotification: string;
declare var NSURLSessionTransferSizeUnknown: number;
declare var NSURLSessionTaskPriorityDefault: number;
declare var NSURLSessionTaskPriorityLow: number;
declare var NSURLSessionTaskPriorityHigh: number;
declare var NSURLSessionDownloadTaskResumeData: string;
declare var NSUserActivityTypeBrowsingWeb: string;
declare var kSecImportExportPassphrase: string;
declare var kSecImportItemLabel: string;
declare var kSecImportItemKeyID: string;
declare var kSecImportItemTrust: string;
declare var kSecImportItemCertChain: string;
declare var kSecImportItemIdentity: string;
declare var kSecClass: any;
declare var kSecClassGenericPassword: any;
declare var kSecClassInternetPassword: any;
declare var kSecClassCertificate: any;
declare var kSecClassKey: any;
declare var kSecClassIdentity: any;
declare var kSecAttrAccessible: any;
declare var kSecAttrAccessControl: any;
declare var kSecAttrAccessGroup: any;
declare var kSecAttrSynchronizable: any;
declare var kSecAttrSynchronizableAny: any;
declare var kSecAttrCreationDate: any;
declare var kSecAttrModificationDate: any;
declare var kSecAttrDescription: any;
declare var kSecAttrComment: any;
declare var kSecAttrCreator: any;
declare var kSecAttrType: any;
declare var kSecAttrLabel: any;
declare var kSecAttrIsInvisible: any;
declare var kSecAttrIsNegative: any;
declare var kSecAttrAccount: any;
declare var kSecAttrService: any;
declare var kSecAttrGeneric: any;
declare var kSecAttrSecurityDomain: any;
declare var kSecAttrServer: any;
declare var kSecAttrProtocol: any;
declare var kSecAttrAuthenticationType: any;
declare var kSecAttrPort: any;
declare var kSecAttrPath: any;
declare var kSecAttrSubject: any;
declare var kSecAttrIssuer: any;
declare var kSecAttrSerialNumber: any;
declare var kSecAttrSubjectKeyID: any;
declare var kSecAttrPublicKeyHash: any;
declare var kSecAttrCertificateType: any;
declare var kSecAttrCertificateEncoding: any;
declare var kSecAttrKeyClass: any;
declare var kSecAttrApplicationLabel: any;
declare var kSecAttrIsPermanent: any;
declare var kSecAttrApplicationTag: any;
declare var kSecAttrKeyType: any;
declare var kSecAttrKeySizeInBits: any;
declare var kSecAttrEffectiveKeySize: any;
declare var kSecAttrCanEncrypt: any;
declare var kSecAttrCanDecrypt: any;
declare var kSecAttrCanDerive: any;
declare var kSecAttrCanSign: any;
declare var kSecAttrCanVerify: any;
declare var kSecAttrCanWrap: any;
declare var kSecAttrCanUnwrap: any;
declare var kSecAttrAccessibleWhenUnlocked: any;
declare var kSecAttrAccessibleAfterFirstUnlock: any;
declare var kSecAttrAccessibleAlways: any;
declare var kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly: any;
declare var kSecAttrAccessibleWhenUnlockedThisDeviceOnly: any;
declare var kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly: any;
declare var kSecAttrAccessibleAlwaysThisDeviceOnly: any;
declare var kSecAttrProtocolFTP: any;
declare var kSecAttrProtocolFTPAccount: any;
declare var kSecAttrProtocolHTTP: any;
declare var kSecAttrProtocolIRC: any;
declare var kSecAttrProtocolNNTP: any;
declare var kSecAttrProtocolPOP3: any;
declare var kSecAttrProtocolSMTP: any;
declare var kSecAttrProtocolSOCKS: any;
declare var kSecAttrProtocolIMAP: any;
declare var kSecAttrProtocolLDAP: any;
declare var kSecAttrProtocolAppleTalk: any;
declare var kSecAttrProtocolAFP: any;
declare var kSecAttrProtocolTelnet: any;
declare var kSecAttrProtocolSSH: any;
declare var kSecAttrProtocolFTPS: any;
declare var kSecAttrProtocolHTTPS: any;
declare var kSecAttrProtocolHTTPProxy: any;
declare var kSecAttrProtocolHTTPSProxy: any;
declare var kSecAttrProtocolFTPProxy: any;
declare var kSecAttrProtocolSMB: any;
declare var kSecAttrProtocolRTSP: any;
declare var kSecAttrProtocolRTSPProxy: any;
declare var kSecAttrProtocolDAAP: any;
declare var kSecAttrProtocolEPPC: any;
declare var kSecAttrProtocolIPP: any;
declare var kSecAttrProtocolNNTPS: any;
declare var kSecAttrProtocolLDAPS: any;
declare var kSecAttrProtocolTelnetS: any;
declare var kSecAttrProtocolIMAPS: any;
declare var kSecAttrProtocolIRCS: any;
declare var kSecAttrProtocolPOP3S: any;
declare var kSecAttrAuthenticationTypeNTLM: any;
declare var kSecAttrAuthenticationTypeMSN: any;
declare var kSecAttrAuthenticationTypeDPA: any;
declare var kSecAttrAuthenticationTypeRPA: any;
declare var kSecAttrAuthenticationTypeHTTPBasic: any;
declare var kSecAttrAuthenticationTypeHTTPDigest: any;
declare var kSecAttrAuthenticationTypeHTMLForm: any;
declare var kSecAttrAuthenticationTypeDefault: any;
declare var kSecAttrKeyClassPublic: any;
declare var kSecAttrKeyClassPrivate: any;
declare var kSecAttrKeyClassSymmetric: any;
declare var kSecAttrKeyTypeRSA: any;
declare var kSecAttrKeyTypeEC: any;
declare var kSecMatchPolicy: any;
declare var kSecMatchItemList: any;
declare var kSecMatchSearchList: any;
declare var kSecMatchIssuers: any;
declare var kSecMatchEmailAddressIfPresent: any;
declare var kSecMatchSubjectContains: any;
declare var kSecMatchCaseInsensitive: any;
declare var kSecMatchTrustedOnly: any;
declare var kSecMatchValidOnDate: any;
declare var kSecMatchLimit: any;
declare var kSecMatchLimitOne: any;
declare var kSecMatchLimitAll: any;
declare var kSecReturnData: any;
declare var kSecReturnAttributes: any;
declare var kSecReturnRef: any;
declare var kSecReturnPersistentRef: any;
declare var kSecValueData: any;
declare var kSecValueRef: any;
declare var kSecValuePersistentRef: any;
declare var kSecUseItemList: any;
declare var kSecUseOperationPrompt: any;
declare var kSecUseNoAuthenticationUI: any;
declare var kSecPrivateKeyAttrs: any;
declare var kSecPublicKeyAttrs: any;
declare var kSecPolicyAppleX509Basic: any;
declare var kSecPolicyAppleSSL: any;
declare var kSecPolicyAppleSMIME: any;
declare var kSecPolicyAppleEAP: any;
declare var kSecPolicyAppleIPsec: any;
declare var kSecPolicyAppleCodeSigning: any;
declare var kSecPolicyAppleIDValidation: any;
declare var kSecPolicyAppleTimeStamping: any;
declare var kSecPolicyAppleRevocation: any;
declare var kSecPolicyOid: any;
declare var kSecPolicyName: any;
declare var kSecPolicyClient: any;
declare var kSecPolicyRevocationFlags: any;
declare var kSecRandomDefault: any;
declare var kSecSharedPassword: any;
declare var kSecPropertyTypeTitle: any;
declare var kSecPropertyTypeError: any;
declare var kSecTrustEvaluationDate: any;
declare var kSecTrustExtendedValidation: any;
declare var kSecTrustOrganizationName: any;
declare var kSecTrustResultValue: any;
declare var kSecTrustRevocationChecked: any;
declare var kSecTrustRevocationValidUntilDate: any;
declare var kCFErrorDomainCFNetwork: string;
declare var kCFErrorDomainWinSock: string;
declare var kCFURLErrorFailingURLErrorKey: string;
declare var kCFURLErrorFailingURLStringErrorKey: string;
declare var kCFGetAddrInfoFailureKey: string;
declare var kCFSOCKSStatusCodeKey: string;
declare var kCFSOCKSVersionKey: string;
declare var kCFSOCKSNegotiationMethodKey: string;
declare var kCFDNSServiceFailureKey: string;
declare var kCFFTPStatusCodeKey: string;
declare var kCFStreamErrorDomainNetDB: number;
declare var kCFStreamErrorDomainSystemConfiguration: number;
declare var kCFStreamErrorDomainMach: number;
declare var kCFStreamErrorDomainNetServices: number;
declare var kCFStreamPropertySSLContext: string;
declare var kCFStreamPropertySSLPeerTrust: string;
declare var kCFStreamSSLValidatesCertificateChain: string;
declare var kCFStreamPropertySSLSettings: string;
declare var kCFStreamSSLLevel: string;
declare var kCFStreamSSLPeerName: string;
declare var kCFStreamSSLCertificates: string;
declare var kCFStreamSSLIsServer: string;
declare var kCFStreamNetworkServiceType: string;
declare var kCFStreamNetworkServiceTypeVoIP: string;
declare var kCFStreamNetworkServiceTypeVideo: string;
declare var kCFStreamNetworkServiceTypeVoice: string;
declare var kCFStreamNetworkServiceTypeBackground: string;
declare var kCFStreamPropertyNoCellular: string;
declare var kCFStreamPropertyConnectionIsCellular: string;
declare var kCFStreamErrorDomainWinSock: number;
declare var kCFStreamErrorDomainSOCKS: number;
declare var kCFStreamPropertySOCKSProxy: string;
declare var kCFStreamPropertySOCKSProxyHost: string;
declare var kCFStreamPropertySOCKSProxyPort: string;
declare var kCFStreamPropertySOCKSVersion: string;
declare var kCFStreamSocketSOCKSVersion4: string;
declare var kCFStreamSocketSOCKSVersion5: string;
declare var kCFStreamPropertySOCKSUser: string;
declare var kCFStreamPropertySOCKSPassword: string;
declare var kCFStreamPropertyProxyLocalBypass: string;
declare var kCFStreamErrorDomainSSL: number;
declare var kCFStreamPropertySocketSecurityLevel: string;
declare var kCFStreamSocketSecurityLevelNone: string;
declare var kCFStreamSocketSecurityLevelSSLv2: string;
declare var kCFStreamSocketSecurityLevelSSLv3: string;
declare var kCFStreamSocketSecurityLevelTLSv1: string;
declare var kCFStreamSocketSecurityLevelNegotiatedSSL: string;
declare var kCFStreamPropertyShouldCloseNativeSocket: string;
declare var kCFStreamPropertySocketRemoteHost: string;
declare var kCFStreamPropertySocketRemoteNetService: string;
declare var kCFStreamPropertySSLPeerCertificates: string;
declare var kCFStreamSSLAllowsExpiredCertificates: string;
declare var kCFStreamSSLAllowsExpiredRoots: string;
declare var kCFStreamSSLAllowsAnyRoot: string;
declare var kCFStreamErrorDomainFTP: number;
declare var kCFStreamPropertyFTPUserName: string;
declare var kCFStreamPropertyFTPPassword: string;
declare var kCFStreamPropertyFTPUsePassiveMode: string;
declare var kCFStreamPropertyFTPResourceSize: string;
declare var kCFStreamPropertyFTPFetchResourceInfo: string;
declare var kCFStreamPropertyFTPFileTransferOffset: string;
declare var kCFStreamPropertyFTPAttemptPersistentConnection: string;
declare var kCFStreamPropertyFTPProxy: string;
declare var kCFStreamPropertyFTPProxyHost: string;
declare var kCFStreamPropertyFTPProxyPort: string;
declare var kCFStreamPropertyFTPProxyUser: string;
declare var kCFStreamPropertyFTPProxyPassword: string;
declare var kCFFTPResourceMode: string;
declare var kCFFTPResourceName: string;
declare var kCFFTPResourceOwner: string;
declare var kCFFTPResourceGroup: string;
declare var kCFFTPResourceLink: string;
declare var kCFFTPResourceSize: string;
declare var kCFFTPResourceType: string;
declare var kCFFTPResourceModDate: string;
declare var kCFHTTPVersion1_0: string;
declare var kCFHTTPVersion1_1: string;
declare var kCFHTTPAuthenticationSchemeBasic: string;
declare var kCFHTTPAuthenticationSchemeDigest: string;
declare var kCFHTTPAuthenticationSchemeNTLM: string;
declare var kCFHTTPAuthenticationSchemeKerberos: string;
declare var kCFHTTPAuthenticationSchemeNegotiate: string;
declare var kCFHTTPAuthenticationSchemeNegotiate2: string;
declare var kCFHTTPAuthenticationSchemeXMobileMeAuthToken: string;
declare var kCFHTTPAuthenticationSchemeOAuth1: string;
declare var kCFStreamErrorDomainHTTP: number;
declare var kCFStreamPropertyHTTPResponseHeader: string;
declare var kCFStreamPropertyHTTPFinalURL: string;
declare var kCFStreamPropertyHTTPFinalRequest: string;
declare var kCFStreamPropertyHTTPProxy: string;
declare var kCFStreamPropertyHTTPProxyHost: string;
declare var kCFStreamPropertyHTTPProxyPort: string;
declare var kCFStreamPropertyHTTPSProxyHost: string;
declare var kCFStreamPropertyHTTPSProxyPort: string;
declare var kCFStreamPropertyHTTPShouldAutoredirect: string;
declare var kCFStreamPropertyHTTPAttemptPersistentConnection: string;
declare var kCFStreamPropertyHTTPRequestBytesWrittenCount: string;
declare var kCFHTTPAuthenticationUsername: string;
declare var kCFHTTPAuthenticationPassword: string;
declare var kCFHTTPAuthenticationAccountDomain: string;
declare var kCFProxyTypeKey: string;
declare var kCFProxyHostNameKey: string;
declare var kCFProxyPortNumberKey: string;
declare var kCFProxyAutoConfigurationURLKey: string;
declare var kCFProxyAutoConfigurationJavaScriptKey: string;
declare var kCFProxyUsernameKey: string;
declare var kCFProxyPasswordKey: string;
declare var kCFProxyTypeNone: string;
declare var kCFProxyTypeHTTP: string;
declare var kCFProxyTypeHTTPS: string;
declare var kCFProxyTypeSOCKS: string;
declare var kCFProxyTypeFTP: string;
declare var kCFProxyTypeAutoConfigurationURL: string;
declare var kCFProxyTypeAutoConfigurationJavaScript: string;
declare var kCFProxyAutoConfigurationHTTPResponseKey: string;
declare var kCFNetworkProxiesHTTPEnable: string;
declare var kCFNetworkProxiesHTTPPort: string;
declare var kCFNetworkProxiesHTTPProxy: string;
declare var kCFNetworkProxiesProxyAutoConfigEnable: string;
declare var kCFNetworkProxiesProxyAutoConfigURLString: string;
declare var kCFNetworkProxiesProxyAutoConfigJavaScript: string;
declare var ACAccountTypeIdentifierTwitter: string;
declare var ACAccountTypeIdentifierFacebook: string;
declare var ACAccountTypeIdentifierSinaWeibo: string;
declare var ACAccountTypeIdentifierTencentWeibo: string;
declare var ACFacebookAppIdKey: string;
declare var ACFacebookPermissionsKey: string;
declare var ACFacebookAudienceKey: string;
declare var ACFacebookAudienceEveryone: string;
declare var ACFacebookAudienceFriends: string;
declare var ACFacebookAudienceOnlyMe: string;
declare var ACTencentWeiboAppIdKey: string;
declare var ACAccountStoreDidChangeNotification: string;
declare var ACErrorDomain: string;
declare var ABAddressBookErrorDomain: string;
declare var kABSourceNameProperty: number;
declare var kABSourceTypeProperty: number;
declare var kABWorkLabel: string;
declare var kABHomeLabel: string;
declare var kABOtherLabel: string;
declare var kABPersonFirstNameProperty: number;
declare var kABPersonLastNameProperty: number;
declare var kABPersonMiddleNameProperty: number;
declare var kABPersonPrefixProperty: number;
declare var kABPersonSuffixProperty: number;
declare var kABPersonNicknameProperty: number;
declare var kABPersonFirstNamePhoneticProperty: number;
declare var kABPersonLastNamePhoneticProperty: number;
declare var kABPersonMiddleNamePhoneticProperty: number;
declare var kABPersonOrganizationProperty: number;
declare var kABPersonJobTitleProperty: number;
declare var kABPersonDepartmentProperty: number;
declare var kABPersonEmailProperty: number;
declare var kABPersonBirthdayProperty: number;
declare var kABPersonNoteProperty: number;
declare var kABPersonCreationDateProperty: number;
declare var kABPersonModificationDateProperty: number;
declare var kABPersonAddressProperty: number;
declare var kABPersonAddressStreetKey: string;
declare var kABPersonAddressCityKey: string;
declare var kABPersonAddressStateKey: string;
declare var kABPersonAddressZIPKey: string;
declare var kABPersonAddressCountryKey: string;
declare var kABPersonAddressCountryCodeKey: string;
declare var kABPersonDateProperty: number;
declare var kABPersonAnniversaryLabel: string;
declare var kABPersonKindProperty: number;
declare var kABPersonKindPerson: NSNumber;
declare var kABPersonKindOrganization: NSNumber;
declare var kABPersonPhoneProperty: number;
declare var kABPersonPhoneMobileLabel: string;
declare var kABPersonPhoneIPhoneLabel: string;
declare var kABPersonPhoneMainLabel: string;
declare var kABPersonPhoneHomeFAXLabel: string;
declare var kABPersonPhoneWorkFAXLabel: string;
declare var kABPersonPhoneOtherFAXLabel: string;
declare var kABPersonPhonePagerLabel: string;
declare var kABPersonInstantMessageProperty: number;
declare var kABPersonInstantMessageServiceKey: string;
declare var kABPersonInstantMessageServiceYahoo: string;
declare var kABPersonInstantMessageServiceJabber: string;
declare var kABPersonInstantMessageServiceMSN: string;
declare var kABPersonInstantMessageServiceICQ: string;
declare var kABPersonInstantMessageServiceAIM: string;
declare var kABPersonInstantMessageServiceQQ: string;
declare var kABPersonInstantMessageServiceGoogleTalk: string;
declare var kABPersonInstantMessageServiceSkype: string;
declare var kABPersonInstantMessageServiceFacebook: string;
declare var kABPersonInstantMessageServiceGaduGadu: string;
declare var kABPersonInstantMessageUsernameKey: string;
declare var kABPersonURLProperty: number;
declare var kABPersonHomePageLabel: string;
declare var kABPersonRelatedNamesProperty: number;
declare var kABPersonFatherLabel: string;
declare var kABPersonMotherLabel: string;
declare var kABPersonParentLabel: string;
declare var kABPersonBrotherLabel: string;
declare var kABPersonSisterLabel: string;
declare var kABPersonChildLabel: string;
declare var kABPersonFriendLabel: string;
declare var kABPersonSpouseLabel: string;
declare var kABPersonPartnerLabel: string;
declare var kABPersonAssistantLabel: string;
declare var kABPersonManagerLabel: string;
declare var kABPersonSocialProfileProperty: number;
declare var kABPersonSocialProfileURLKey: string;
declare var kABPersonSocialProfileServiceKey: string;
declare var kABPersonSocialProfileUsernameKey: string;
declare var kABPersonSocialProfileUserIdentifierKey: string;
declare var kABPersonSocialProfileServiceTwitter: string;
declare var kABPersonSocialProfileServiceSinaWeibo: string;
declare var kABPersonSocialProfileServiceGameCenter: string;
declare var kABPersonSocialProfileServiceFacebook: string;
declare var kABPersonSocialProfileServiceMyspace: string;
declare var kABPersonSocialProfileServiceLinkedIn: string;
declare var kABPersonSocialProfileServiceFlickr: string;
declare var kABPersonAlternateBirthdayProperty: number;
declare var kABPersonAlternateBirthdayCalendarIdentifierKey: string;
declare var kABPersonAlternateBirthdayEraKey: string;
declare var kABPersonAlternateBirthdayYearKey: string;
declare var kABPersonAlternateBirthdayMonthKey: string;
declare var kABPersonAlternateBirthdayIsLeapMonthKey: string;
declare var kABPersonAlternateBirthdayDayKey: string;
declare var kABGroupNameProperty: number;
declare var UIKeyInputUpArrow: string;
declare var UIKeyInputDownArrow: string;
declare var UIKeyInputLeftArrow: string;
declare var UIKeyInputRightArrow: string;
declare var UIKeyInputEscape: string;
declare var UIFontDescriptorFamilyAttribute: string;
declare var UIFontDescriptorNameAttribute: string;
declare var UIFontDescriptorFaceAttribute: string;
declare var UIFontDescriptorSizeAttribute: string;
declare var UIFontDescriptorVisibleNameAttribute: string;
declare var UIFontDescriptorMatrixAttribute: string;
declare var UIFontDescriptorCharacterSetAttribute: string;
declare var UIFontDescriptorCascadeListAttribute: string;
declare var UIFontDescriptorTraitsAttribute: string;
declare var UIFontDescriptorFixedAdvanceAttribute: string;
declare var UIFontDescriptorFeatureSettingsAttribute: string;
declare var UIFontDescriptorTextStyleAttribute: string;
declare var UIFontSymbolicTrait: string;
declare var UIFontWeightTrait: string;
declare var UIFontWidthTrait: string;
declare var UIFontSlantTrait: string;
declare var UIFontFeatureTypeIdentifierKey: string;
declare var UIFontFeatureSelectorIdentifierKey: string;
declare var UIFontTextStyleHeadline: string;
declare var UIFontTextStyleBody: string;
declare var UIFontTextStyleSubheadline: string;
declare var UIFontTextStyleFootnote: string;
declare var UIFontTextStyleCaption1: string;
declare var UIFontTextStyleCaption2: string;
declare var UIDeviceOrientationDidChangeNotification: string;
declare var UIDeviceBatteryStateDidChangeNotification: string;
declare var UIDeviceBatteryLevelDidChangeNotification: string;
declare var UIDeviceProximityStateDidChangeNotification: string;
declare var UIEdgeInsetsZero: UIEdgeInsets;
declare var UIOffsetZero: UIOffset;
declare var UILayoutPriorityRequired: number;
declare var UILayoutPriorityDefaultHigh: number;
declare var UILayoutPriorityDefaultLow: number;
declare var UILayoutPriorityFittingSizeLevel: number;
declare var UIViewNoIntrinsicMetric: number;
declare var UILayoutFittingCompressedSize: CGSize;
declare var UILayoutFittingExpandedSize: CGSize;
declare var NSTabColumnTerminatorsAttributeName: string;
declare var UITextAttributeFont: string;
declare var UITextAttributeTextColor: string;
declare var UITextAttributeTextShadowColor: string;
declare var UITextAttributeTextShadowOffset: string;
declare var UITextInputTextBackgroundColorKey: string;
declare var UITextInputTextColorKey: string;
declare var UITextInputTextFontKey: string;
declare var UITextInputCurrentInputModeDidChangeNotification: string;
declare var UITextFieldTextDidBeginEditingNotification: string;
declare var UITextFieldTextDidEndEditingNotification: string;
declare var UITextFieldTextDidChangeNotification: string;
declare var UIApplicationInvalidInterfaceOrientationException: string;
declare var UIBackgroundTaskInvalid: number;
declare var UIMinimumKeepAliveTimeout: number;
declare var UIApplicationBackgroundFetchIntervalMinimum: number;
declare var UIApplicationBackgroundFetchIntervalNever: number;
declare var UITrackingRunLoopMode: string;
declare var UIApplicationDidEnterBackgroundNotification: string;
declare var UIApplicationWillEnterForegroundNotification: string;
declare var UIApplicationDidFinishLaunchingNotification: string;
declare var UIApplicationDidBecomeActiveNotification: string;
declare var UIApplicationWillResignActiveNotification: string;
declare var UIApplicationDidReceiveMemoryWarningNotification: string;
declare var UIApplicationWillTerminateNotification: string;
declare var UIApplicationSignificantTimeChangeNotification: string;
declare var UIApplicationWillChangeStatusBarOrientationNotification: string;
declare var UIApplicationDidChangeStatusBarOrientationNotification: string;
declare var UIApplicationStatusBarOrientationUserInfoKey: string;
declare var UIApplicationWillChangeStatusBarFrameNotification: string;
declare var UIApplicationDidChangeStatusBarFrameNotification: string;
declare var UIApplicationStatusBarFrameUserInfoKey: string;
declare var UIApplicationBackgroundRefreshStatusDidChangeNotification: string;
declare var UIApplicationLaunchOptionsURLKey: string;
declare var UIApplicationLaunchOptionsSourceApplicationKey: string;
declare var UIApplicationLaunchOptionsRemoteNotificationKey: string;
declare var UIApplicationLaunchOptionsLocalNotificationKey: string;
declare var UIApplicationLaunchOptionsAnnotationKey: string;
declare var UIApplicationProtectedDataWillBecomeUnavailable: string;
declare var UIApplicationProtectedDataDidBecomeAvailable: string;
declare var UIApplicationLaunchOptionsLocationKey: string;
declare var UIApplicationLaunchOptionsNewsstandDownloadsKey: string;
declare var UIApplicationLaunchOptionsBluetoothCentralsKey: string;
declare var UIApplicationLaunchOptionsBluetoothPeripheralsKey: string;
declare var UIApplicationLaunchOptionsUserActivityDictionaryKey: string;
declare var UIApplicationLaunchOptionsUserActivityTypeKey: string;
declare var UIApplicationOpenSettingsURLString: string;
declare var UIContentSizeCategoryExtraSmall: string;
declare var UIContentSizeCategorySmall: string;
declare var UIContentSizeCategoryMedium: string;
declare var UIContentSizeCategoryLarge: string;
declare var UIContentSizeCategoryExtraLarge: string;
declare var UIContentSizeCategoryExtraExtraLarge: string;
declare var UIContentSizeCategoryExtraExtraExtraLarge: string;
declare var UIContentSizeCategoryAccessibilityMedium: string;
declare var UIContentSizeCategoryAccessibilityLarge: string;
declare var UIContentSizeCategoryAccessibilityExtraLarge: string;
declare var UIContentSizeCategoryAccessibilityExtraExtraLarge: string;
declare var UIContentSizeCategoryAccessibilityExtraExtraExtraLarge: string;
declare var UIContentSizeCategoryDidChangeNotification: string;
declare var UIContentSizeCategoryNewValueKey: string;
declare var UIApplicationUserDidTakeScreenshotNotification: string;
declare var UIApplicationKeyboardExtensionPointIdentifier: string;
declare var UIStateRestorationViewControllerStoryboardKey: string;
declare var UIApplicationStateRestorationBundleVersionKey: string;
declare var UIApplicationStateRestorationUserInterfaceIdiomKey: string;
declare var UIApplicationStateRestorationTimestampKey: string;
declare var UIApplicationStateRestorationSystemVersionKey: string;
declare var UIViewControllerShowDetailTargetDidChangeNotification: string;
declare var UIViewControllerHierarchyInconsistencyException: string;
declare var UINavigationControllerHideShowBarDuration: number;
declare var UIScrollViewDecelerationRateNormal: number;
declare var UIScrollViewDecelerationRateFast: number;
declare var UITableViewIndexSearch: string;
declare var UITableViewAutomaticDimension: number;
declare var UITableViewSelectionDidChangeNotification: string;
declare var UIAccessibilityTraitNone: number;
declare var UIAccessibilityTraitButton: number;
declare var UIAccessibilityTraitLink: number;
declare var UIAccessibilityTraitHeader: number;
declare var UIAccessibilityTraitSearchField: number;
declare var UIAccessibilityTraitImage: number;
declare var UIAccessibilityTraitSelected: number;
declare var UIAccessibilityTraitPlaysSound: number;
declare var UIAccessibilityTraitKeyboardKey: number;
declare var UIAccessibilityTraitStaticText: number;
declare var UIAccessibilityTraitSummaryElement: number;
declare var UIAccessibilityTraitNotEnabled: number;
declare var UIAccessibilityTraitUpdatesFrequently: number;
declare var UIAccessibilityTraitStartsMediaSession: number;
declare var UIAccessibilityTraitAdjustable: number;
declare var UIAccessibilityTraitAllowsDirectInteraction: number;
declare var UIAccessibilityTraitCausesPageTurn: number;
declare var UIAccessibilityScreenChangedNotification: number;
declare var UIAccessibilityLayoutChangedNotification: number;
declare var UIAccessibilityAnnouncementNotification: number;
declare var UIAccessibilityAnnouncementDidFinishNotification: string;
declare var UIAccessibilityAnnouncementKeyStringValue: string;
declare var UIAccessibilityAnnouncementKeyWasSuccessful: string;
declare var UIAccessibilityPageScrolledNotification: number;
declare var UIAccessibilityPauseAssistiveTechnologyNotification: number;
declare var UIAccessibilityResumeAssistiveTechnologyNotification: number;
declare var UIAccessibilityNotificationSwitchControlIdentifier: string;
declare var UIAccessibilitySpeechAttributePunctuation: string;
declare var UIAccessibilitySpeechAttributeLanguage: string;
declare var UIAccessibilitySpeechAttributePitch: string;
declare var UIAccessibilityVoiceOverStatusChanged: string;
declare var UIAccessibilityMonoAudioStatusDidChangeNotification: string;
declare var UIAccessibilityClosedCaptioningStatusDidChangeNotification: string;
declare var UIAccessibilityInvertColorsStatusDidChangeNotification: string;
declare var UIAccessibilityGuidedAccessStatusDidChangeNotification: string;
declare var UIAccessibilityBoldTextStatusDidChangeNotification: string;
declare var UIAccessibilityGrayscaleStatusDidChangeNotification: string;
declare var UIAccessibilityReduceTransparencyStatusDidChangeNotification: string;
declare var UIAccessibilityReduceMotionStatusDidChangeNotification: string;
declare var UIAccessibilityDarkerSystemColorsStatusDidChangeNotification: string;
declare var UIAccessibilitySwitchControlStatusDidChangeNotification: string;
declare var UIAccessibilitySpeakSelectionStatusDidChangeNotification: string;
declare var UIAccessibilitySpeakScreenStatusDidChangeNotification: string;
declare var UIActivityTypePostToFacebook: string;
declare var UIActivityTypePostToTwitter: string;
declare var UIActivityTypePostToWeibo: string;
declare var UIActivityTypeMessage: string;
declare var UIActivityTypeMail: string;
declare var UIActivityTypePrint: string;
declare var UIActivityTypeCopyToPasteboard: string;
declare var UIActivityTypeAssignToContact: string;
declare var UIActivityTypeSaveToCameraRoll: string;
declare var UIActivityTypeAddToReadingList: string;
declare var UIActivityTypePostToFlickr: string;
declare var UIActivityTypePostToVimeo: string;
declare var UIActivityTypePostToTencentWeibo: string;
declare var UIActivityTypeAirDrop: string;
declare var UICollectionElementKindSectionHeader: string;
declare var UICollectionElementKindSectionFooter: string;
declare var UIDocumentStateChangedNotification: string;
declare var NSUserActivityDocumentURLKey: string;
declare var UIImagePickerControllerMediaType: string;
declare var UIImagePickerControllerOriginalImage: string;
declare var UIImagePickerControllerEditedImage: string;
declare var UIImagePickerControllerCropRect: string;
declare var UIImagePickerControllerMediaURL: string;
declare var UIImagePickerControllerReferenceURL: string;
declare var UIImagePickerControllerMediaMetadata: string;
declare var UILocalNotificationDefaultSoundName: string;
declare var UIMenuControllerWillShowMenuNotification: string;
declare var UIMenuControllerDidShowMenuNotification: string;
declare var UIMenuControllerWillHideMenuNotification: string;
declare var UIMenuControllerDidHideMenuNotification: string;
declare var UIMenuControllerMenuFrameDidChangeNotification: string;
declare var UINibExternalObjects: string;
declare var UINibProxiedObjectsKey: string;
declare var UIPageViewControllerOptionSpineLocationKey: string;
declare var UIPageViewControllerOptionInterPageSpacingKey: string;
declare var UIPasteboardNameGeneral: string;
declare var UIPasteboardNameFind: string;
declare var UIPasteboardChangedNotification: string;
declare var UIPasteboardChangedTypesAddedKey: string;
declare var UIPasteboardChangedTypesRemovedKey: string;
declare var UIPasteboardRemovedNotification: string;
declare var UIPasteboardTypeListString: NSArray;
declare var UIPasteboardTypeListURL: NSArray;
declare var UIPasteboardTypeListImage: NSArray;
declare var UIPasteboardTypeListColor: NSArray;
declare var UIPrintErrorDomain: string;
declare var UIScreenDidConnectNotification: string;
declare var UIScreenDidDisconnectNotification: string;
declare var UIScreenModeDidChangeNotification: string;
declare var UIScreenBrightnessDidChangeNotification: string;
declare var UITransitionContextFromViewControllerKey: string;
declare var UITransitionContextToViewControllerKey: string;
declare var UITransitionContextFromViewKey: string;
declare var UITransitionContextToViewKey: string;
declare var UISplitViewControllerAutomaticDimension: number;
declare var UITextViewTextDidBeginEditingNotification: string;
declare var UITextViewTextDidChangeNotification: string;
declare var UITextViewTextDidEndEditingNotification: string;
declare var UIWindowLevelNormal: number;
declare var UIWindowLevelAlert: number;
declare var UIWindowLevelStatusBar: number;
declare var UIWindowDidBecomeVisibleNotification: string;
declare var UIWindowDidBecomeHiddenNotification: string;
declare var UIWindowDidBecomeKeyNotification: string;
declare var UIWindowDidResignKeyNotification: string;
declare var UIKeyboardWillShowNotification: string;
declare var UIKeyboardDidShowNotification: string;
declare var UIKeyboardWillHideNotification: string;
declare var UIKeyboardDidHideNotification: string;
declare var UIKeyboardFrameBeginUserInfoKey: string;
declare var UIKeyboardFrameEndUserInfoKey: string;
declare var UIKeyboardAnimationDurationUserInfoKey: string;
declare var UIKeyboardAnimationCurveUserInfoKey: string;
declare var UIKeyboardWillChangeFrameNotification: string;
declare var UIKeyboardDidChangeFrameNotification: string;
declare var UIKeyboardCenterBeginUserInfoKey: string;
declare var UIKeyboardCenterEndUserInfoKey: string;
declare var UIKeyboardBoundsUserInfoKey: string;
declare var NSFontAttributeName: string;
declare var NSParagraphStyleAttributeName: string;
declare var NSForegroundColorAttributeName: string;
declare var NSBackgroundColorAttributeName: string;
declare var NSLigatureAttributeName: string;
declare var NSKernAttributeName: string;
declare var NSStrikethroughStyleAttributeName: string;
declare var NSUnderlineStyleAttributeName: string;
declare var NSStrokeColorAttributeName: string;
declare var NSStrokeWidthAttributeName: string;
declare var NSShadowAttributeName: string;
declare var NSTextEffectAttributeName: string;
declare var NSAttachmentAttributeName: string;
declare var NSLinkAttributeName: string;
declare var NSBaselineOffsetAttributeName: string;
declare var NSUnderlineColorAttributeName: string;
declare var NSStrikethroughColorAttributeName: string;
declare var NSObliquenessAttributeName: string;
declare var NSExpansionAttributeName: string;
declare var NSWritingDirectionAttributeName: string;
declare var NSVerticalGlyphFormAttributeName: string;
declare var NSTextEffectLetterpressStyle: string;
declare var NSPlainTextDocumentType: string;
declare var NSRTFTextDocumentType: string;
declare var NSRTFDTextDocumentType: string;
declare var NSHTMLTextDocumentType: string;
declare var NSTextLayoutSectionOrientation: string;
declare var NSTextLayoutSectionRange: string;
declare var NSDocumentTypeDocumentAttribute: string;
declare var NSCharacterEncodingDocumentAttribute: string;
declare var NSDefaultAttributesDocumentAttribute: string;
declare var NSPaperSizeDocumentAttribute: string;
declare var NSPaperMarginDocumentAttribute: string;
declare var NSViewSizeDocumentAttribute: string;
declare var NSViewZoomDocumentAttribute: string;
declare var NSViewModeDocumentAttribute: string;
declare var NSReadOnlyDocumentAttribute: string;
declare var NSBackgroundColorDocumentAttribute: string;
declare var NSHyphenationFactorDocumentAttribute: string;
declare var NSDefaultTabIntervalDocumentAttribute: string;
declare var NSTextLayoutSectionsAttribute: string;
declare var NSTextStorageWillProcessEditingNotification: string;
declare var NSTextStorageDidProcessEditingNotification: string;
declare var kCIFormatARGB8: number;
declare var kCIFormatBGRA8: number;
declare var kCIFormatRGBA8: number;
declare var kCIFormatRGBAf: number;
declare var kCIFormatRGBAh: number;
declare var kCIImageColorSpace: string;
declare var kCIImageProperties: string;
declare var kCIImageAutoAdjustEnhance: string;
declare var kCIImageAutoAdjustRedEye: string;
declare var kCIImageAutoAdjustFeatures: string;
declare var kCIImageAutoAdjustCrop: string;
declare var kCIImageAutoAdjustLevel: string;
declare var kCIContextOutputColorSpace: string;
declare var kCIContextWorkingColorSpace: string;
declare var kCIContextWorkingFormat: string;
declare var kCIContextUseSoftwareRenderer: string;
declare var kCIContextPriorityRequestLow: string;
declare var kCIAttributeFilterName: string;
declare var kCIAttributeFilterDisplayName: string;
declare var kCIAttributeFilterCategories: string;
declare var kCIAttributeClass: string;
declare var kCIAttributeType: string;
declare var kCIAttributeMin: string;
declare var kCIAttributeMax: string;
declare var kCIAttributeSliderMin: string;
declare var kCIAttributeSliderMax: string;
declare var kCIAttributeDefault: string;
declare var kCIAttributeIdentity: string;
declare var kCIAttributeName: string;
declare var kCIAttributeDisplayName: string;
declare var kCIAttributeTypeTime: string;
declare var kCIAttributeTypeScalar: string;
declare var kCIAttributeTypeDistance: string;
declare var kCIAttributeTypeAngle: string;
declare var kCIAttributeTypeBoolean: string;
declare var kCIAttributeTypeInteger: string;
declare var kCIAttributeTypeCount: string;
declare var kCIAttributeTypePosition: string;
declare var kCIAttributeTypeOffset: string;
declare var kCIAttributeTypePosition3: string;
declare var kCIAttributeTypeRectangle: string;
declare var kCIAttributeTypeColor: string;
declare var kCIAttributeTypeImage: string;
declare var kCIAttributeTypeTransform: string;
declare var kCICategoryDistortionEffect: string;
declare var kCICategoryGeometryAdjustment: string;
declare var kCICategoryCompositeOperation: string;
declare var kCICategoryHalftoneEffect: string;
declare var kCICategoryColorAdjustment: string;
declare var kCICategoryColorEffect: string;
declare var kCICategoryTransition: string;
declare var kCICategoryTileEffect: string;
declare var kCICategoryGenerator: string;
declare var kCICategoryReduction: string;
declare var kCICategoryGradient: string;
declare var kCICategoryStylize: string;
declare var kCICategorySharpen: string;
declare var kCICategoryBlur: string;
declare var kCICategoryVideo: string;
declare var kCICategoryStillImage: string;
declare var kCICategoryInterlaced: string;
declare var kCICategoryNonSquarePixels: string;
declare var kCICategoryHighDynamicRange: string;
declare var kCICategoryBuiltIn: string;
declare var kCIOutputImageKey: string;
declare var kCIInputBackgroundImageKey: string;
declare var kCIInputImageKey: string;
declare var kCIInputTimeKey: string;
declare var kCIInputTransformKey: string;
declare var kCIInputScaleKey: string;
declare var kCIInputAspectRatioKey: string;
declare var kCIInputCenterKey: string;
declare var kCIInputRadiusKey: string;
declare var kCIInputAngleKey: string;
declare var kCIInputWidthKey: string;
declare var kCIInputSharpnessKey: string;
declare var kCIInputIntensityKey: string;
declare var kCIInputEVKey: string;
declare var kCIInputSaturationKey: string;
declare var kCIInputColorKey: string;
declare var kCIInputBrightnessKey: string;
declare var kCIInputContrastKey: string;
declare var kCIInputMaskImageKey: string;
declare var kCIInputTargetImageKey: string;
declare var kCIInputExtentKey: string;
declare var kCIInputVersionKey: string;
declare var CIDetectorTypeFace: string;
declare var CIDetectorTypeRectangle: string;
declare var CIDetectorTypeQRCode: string;
declare var CIDetectorAccuracy: string;
declare var CIDetectorAccuracyLow: string;
declare var CIDetectorAccuracyHigh: string;
declare var CIDetectorTracking: string;
declare var CIDetectorMinFeatureSize: string;
declare var CIDetectorImageOrientation: string;
declare var CIDetectorEyeBlink: string;
declare var CIDetectorSmile: string;
declare var CIDetectorFocalLength: string;
declare var CIDetectorAspectRatio: string;
declare var CIFeatureTypeFace: string;
declare var kEAGLDrawablePropertyRetainedBacking: string;
declare var kEAGLDrawablePropertyColorFormat: string;
declare var kEAGLColorFormatRGBA8: string;
declare var kEAGLColorFormatRGB565: string;
declare var kEAGLColorFormatSRGBA8: string;
declare var MTLLibraryErrorDomain: string;
declare var MTLRenderPipelineErrorDomain: string;
declare var MTLCommandBufferErrorDomain: string;
declare var kCTFontSymbolicTrait: string;
declare var kCTFontWeightTrait: string;
declare var kCTFontWidthTrait: string;
declare var kCTFontSlantTrait: string;
declare var kCTFontURLAttribute: string;
declare var kCTFontNameAttribute: string;
declare var kCTFontDisplayNameAttribute: string;
declare var kCTFontFamilyNameAttribute: string;
declare var kCTFontStyleNameAttribute: string;
declare var kCTFontTraitsAttribute: string;
declare var kCTFontVariationAttribute: string;
declare var kCTFontSizeAttribute: string;
declare var kCTFontMatrixAttribute: string;
declare var kCTFontCascadeListAttribute: string;
declare var kCTFontCharacterSetAttribute: string;
declare var kCTFontLanguagesAttribute: string;
declare var kCTFontBaselineAdjustAttribute: string;
declare var kCTFontMacintoshEncodingsAttribute: string;
declare var kCTFontFeaturesAttribute: string;
declare var kCTFontFeatureSettingsAttribute: string;
declare var kCTFontFixedAdvanceAttribute: string;
declare var kCTFontOrientationAttribute: string;
declare var kCTFontFormatAttribute: string;
declare var kCTFontRegistrationScopeAttribute: string;
declare var kCTFontPriorityAttribute: string;
declare var kCTFontEnabledAttribute: string;
declare var kCTFontDownloadableAttribute: string;
declare var kCTFontDownloadedAttribute: string;
declare var kCTFontDescriptorMatchingSourceDescriptor: string;
declare var kCTFontDescriptorMatchingDescriptors: string;
declare var kCTFontDescriptorMatchingResult: string;
declare var kCTFontDescriptorMatchingPercentage: string;
declare var kCTFontDescriptorMatchingCurrentAssetSize: string;
declare var kCTFontDescriptorMatchingTotalDownloadedSize: string;
declare var kCTFontDescriptorMatchingTotalAssetSize: string;
declare var kCTFontDescriptorMatchingError: string;
declare var kCTFontCopyrightNameKey: string;
declare var kCTFontFamilyNameKey: string;
declare var kCTFontSubFamilyNameKey: string;
declare var kCTFontStyleNameKey: string;
declare var kCTFontUniqueNameKey: string;
declare var kCTFontFullNameKey: string;
declare var kCTFontVersionNameKey: string;
declare var kCTFontPostScriptNameKey: string;
declare var kCTFontTrademarkNameKey: string;
declare var kCTFontManufacturerNameKey: string;
declare var kCTFontDesignerNameKey: string;
declare var kCTFontDescriptionNameKey: string;
declare var kCTFontVendorURLNameKey: string;
declare var kCTFontDesignerURLNameKey: string;
declare var kCTFontLicenseNameKey: string;
declare var kCTFontLicenseURLNameKey: string;
declare var kCTFontSampleTextNameKey: string;
declare var kCTFontPostScriptCIDNameKey: string;
declare var kCTFontVariationAxisIdentifierKey: string;
declare var kCTFontVariationAxisMinimumValueKey: string;
declare var kCTFontVariationAxisMaximumValueKey: string;
declare var kCTFontVariationAxisDefaultValueKey: string;
declare var kCTFontVariationAxisNameKey: string;
declare var kCTFontOpenTypeFeatureTag: string;
declare var kCTFontOpenTypeFeatureValue: string;
declare var kCTFontFeatureTypeIdentifierKey: string;
declare var kCTFontFeatureTypeNameKey: string;
declare var kCTFontFeatureTypeExclusiveKey: string;
declare var kCTFontFeatureTypeSelectorsKey: string;
declare var kCTFontFeatureSelectorIdentifierKey: string;
declare var kCTFontFeatureSelectorNameKey: string;
declare var kCTFontFeatureSelectorDefaultKey: string;
declare var kCTFontFeatureSelectorSettingKey: string;
declare var kCTBaselineClassRoman: string;
declare var kCTBaselineClassIdeographicCentered: string;
declare var kCTBaselineClassIdeographicLow: string;
declare var kCTBaselineClassIdeographicHigh: string;
declare var kCTBaselineClassHanging: string;
declare var kCTBaselineClassMath: string;
declare var kCTBaselineReferenceFont: string;
declare var kCTBaselineOriginalFont: string;
declare var kCTFontCollectionRemoveDuplicatesOption: string;
declare var kCTFontManagerErrorDomain: string;
declare var kCTFontManagerErrorFontURLsKey: string;
declare var kCTFontManagerRegisteredFontsChangedNotification: string;
declare var kCTFrameProgressionAttributeName: string;
declare var kCTFramePathFillRuleAttributeName: string;
declare var kCTFramePathWidthAttributeName: string;
declare var kCTFrameClippingPathsAttributeName: string;
declare var kCTFramePathClippingPathAttributeName: string;
declare var kCTTypesetterOptionDisableBidiProcessing: string;
declare var kCTTypesetterOptionForcedEmbeddingLevel: string;
declare var kCTFontAttributeName: string;
declare var kCTForegroundColorFromContextAttributeName: string;
declare var kCTKernAttributeName: string;
declare var kCTLigatureAttributeName: string;
declare var kCTForegroundColorAttributeName: string;
declare var kCTParagraphStyleAttributeName: string;
declare var kCTStrokeWidthAttributeName: string;
declare var kCTStrokeColorAttributeName: string;
declare var kCTUnderlineStyleAttributeName: string;
declare var kCTSuperscriptAttributeName: string;
declare var kCTUnderlineColorAttributeName: string;
declare var kCTVerticalFormsAttributeName: string;
declare var kCTGlyphInfoAttributeName: string;
declare var kCTCharacterShapeAttributeName: string;
declare var kCTLanguageAttributeName: string;
declare var kCTRunDelegateAttributeName: string;
declare var kCTBaselineClassAttributeName: string;
declare var kCTBaselineInfoAttributeName: string;
declare var kCTBaselineReferenceInfoAttributeName: string;
declare var kCTWritingDirectionAttributeName: string;
declare var kCTRubyAnnotationAttributeName: string;
declare var kCTTabColumnTerminatorsAttributeName: string;
declare var ABPersonNamePrefixProperty: string;
declare var ABPersonGivenNameProperty: string;
declare var ABPersonMiddleNameProperty: string;
declare var ABPersonFamilyNameProperty: string;
declare var ABPersonNameSuffixProperty: string;
declare var ABPersonPreviousFamilyNameProperty: string;
declare var ABPersonNicknameProperty: string;
declare var ABPersonPhoneticGivenNameProperty: string;
declare var ABPersonPhoneticMiddleNameProperty: string;
declare var ABPersonPhoneticFamilyNameProperty: string;
declare var ABPersonOrganizationNameProperty: string;
declare var ABPersonDepartmentNameProperty: string;
declare var ABPersonJobTitleProperty: string;
declare var ABPersonBirthdayProperty: string;
declare var ABPersonNoteProperty: string;
declare var ABPersonPhoneNumbersProperty: string;
declare var ABPersonEmailAddressesProperty: string;
declare var ABPersonUrlAddressesProperty: string;
declare var ABPersonDatesProperty: string;
declare var ABPersonInstantMessageAddressesProperty: string;
declare var ABPersonRelatedNamesProperty: string;
declare var ABPersonSocialProfilesProperty: string;
declare var ABPersonPostalAddressesProperty: string;
declare var CATransform3DIdentity: CATransform3D;
declare var kCAFillModeForwards: string;
declare var kCAFillModeBackwards: string;
declare var kCAFillModeBoth: string;
declare var kCAFillModeRemoved: string;
declare var kCAFillModeFrozen: string;
declare var kCAGravityCenter: string;
declare var kCAGravityTop: string;
declare var kCAGravityBottom: string;
declare var kCAGravityLeft: string;
declare var kCAGravityRight: string;
declare var kCAGravityTopLeft: string;
declare var kCAGravityTopRight: string;
declare var kCAGravityBottomLeft: string;
declare var kCAGravityBottomRight: string;
declare var kCAGravityResize: string;
declare var kCAGravityResizeAspect: string;
declare var kCAGravityResizeAspectFill: string;
declare var kCAFilterNearest: string;
declare var kCAFilterLinear: string;
declare var kCAFilterTrilinear: string;
declare var kCAOnOrderIn: string;
declare var kCAOnOrderOut: string;
declare var kCATransition: string;
declare var kCAAnimationLinear: string;
declare var kCAAnimationDiscrete: string;
declare var kCAAnimationPaced: string;
declare var kCAAnimationCubic: string;
declare var kCAAnimationCubicPaced: string;
declare var kCAAnimationRotateAuto: string;
declare var kCAAnimationRotateAutoReverse: string;
declare var kCATransitionFade: string;
declare var kCATransitionMoveIn: string;
declare var kCATransitionPush: string;
declare var kCATransitionReveal: string;
declare var kCATransitionFromRight: string;
declare var kCATransitionFromLeft: string;
declare var kCATransitionFromTop: string;
declare var kCATransitionFromBottom: string;
declare var kCAEmitterLayerPoint: string;
declare var kCAEmitterLayerLine: string;
declare var kCAEmitterLayerRectangle: string;
declare var kCAEmitterLayerCuboid: string;
declare var kCAEmitterLayerCircle: string;
declare var kCAEmitterLayerSphere: string;
declare var kCAEmitterLayerPoints: string;
declare var kCAEmitterLayerOutline: string;
declare var kCAEmitterLayerSurface: string;
declare var kCAEmitterLayerVolume: string;
declare var kCAEmitterLayerUnordered: string;
declare var kCAEmitterLayerOldestFirst: string;
declare var kCAEmitterLayerOldestLast: string;
declare var kCAEmitterLayerBackToFront: string;
declare var kCAEmitterLayerAdditive: string;
declare var kCAGradientLayerAxial: string;
declare var kCAMediaTimingFunctionLinear: string;
declare var kCAMediaTimingFunctionEaseIn: string;
declare var kCAMediaTimingFunctionEaseOut: string;
declare var kCAMediaTimingFunctionEaseInEaseOut: string;
declare var kCAMediaTimingFunctionDefault: string;
declare var kCAScrollNone: string;
declare var kCAScrollVertically: string;
declare var kCAScrollHorizontally: string;
declare var kCAScrollBoth: string;
declare var kCAFillRuleNonZero: string;
declare var kCAFillRuleEvenOdd: string;
declare var kCALineJoinMiter: string;
declare var kCALineJoinRound: string;
declare var kCALineJoinBevel: string;
declare var kCALineCapButt: string;
declare var kCALineCapRound: string;
declare var kCALineCapSquare: string;
declare var kCATruncationNone: string;
declare var kCATruncationStart: string;
declare var kCATruncationEnd: string;
declare var kCATruncationMiddle: string;
declare var kCAAlignmentNatural: string;
declare var kCAAlignmentLeft: string;
declare var kCAAlignmentRight: string;
declare var kCAAlignmentCenter: string;
declare var kCAAlignmentJustified: string;
declare var kCATransactionAnimationDuration: string;
declare var kCATransactionDisableActions: string;
declare var kCATransactionAnimationTimingFunction: string;
declare var kCATransactionCompletionBlock: string;
declare var kCAValueFunctionRotateX: string;
declare var kCAValueFunctionRotateY: string;
declare var kCAValueFunctionRotateZ: string;
declare var kCAValueFunctionScale: string;
declare var kCAValueFunctionScaleX: string;
declare var kCAValueFunctionScaleY: string;
declare var kCAValueFunctionScaleZ: string;
declare var kCAValueFunctionTranslate: string;
declare var kCAValueFunctionTranslateX: string;
declare var kCAValueFunctionTranslateY: string;
declare var kCAValueFunctionTranslateZ: string;
declare var ALAssetsLibraryChangedNotification: string;
declare var ALAssetLibraryUpdatedAssetsKey: string;
declare var ALAssetLibraryInsertedAssetGroupsKey: string;
declare var ALAssetLibraryUpdatedAssetGroupsKey: string;
declare var ALAssetLibraryDeletedAssetGroupsKey: string;
declare var ALAssetsLibraryErrorDomain: string;
declare var ALErrorInvalidProperty: string;
declare var ALAssetPropertyType: string;
declare var ALAssetPropertyLocation: string;
declare var ALAssetPropertyDuration: string;
declare var ALAssetPropertyOrientation: string;
declare var ALAssetPropertyDate: string;
declare var ALAssetPropertyRepresentations: string;
declare var ALAssetPropertyURLs: string;
declare var ALAssetPropertyAssetURL: string;
declare var ALAssetTypePhoto: string;
declare var ALAssetTypeVideo: string;
declare var ALAssetTypeUnknown: string;
declare var ALAssetsGroupPropertyName: string;
declare var ALAssetsGroupPropertyType: string;
declare var ALAssetsGroupPropertyPersistentID: string;
declare var ALAssetsGroupPropertyURL: string;
declare var kAudioSession_RouteChangeKey_Reason: string;
declare var kAudioSession_AudioRouteChangeKey_PreviousRouteDescription: string;
declare var kAudioSession_AudioRouteChangeKey_CurrentRouteDescription: string;
declare var kAudioSession_AudioRouteKey_Inputs: string;
declare var kAudioSession_AudioRouteKey_Outputs: string;
declare var kAudioSession_AudioRouteKey_Type: string;
declare var kAudioSessionInputRoute_LineIn: string;
declare var kAudioSessionInputRoute_BuiltInMic: string;
declare var kAudioSessionInputRoute_HeadsetMic: string;
declare var kAudioSessionInputRoute_BluetoothHFP: string;
declare var kAudioSessionInputRoute_USBAudio: string;
declare var kAudioSessionOutputRoute_LineOut: string;
declare var kAudioSessionOutputRoute_Headphones: string;
declare var kAudioSessionOutputRoute_BluetoothHFP: string;
declare var kAudioSessionOutputRoute_BluetoothA2DP: string;
declare var kAudioSessionOutputRoute_BuiltInReceiver: string;
declare var kAudioSessionOutputRoute_BuiltInSpeaker: string;
declare var kAudioSessionOutputRoute_USBAudio: string;
declare var kAudioSessionOutputRoute_HDMI: string;
declare var kAudioSessionOutputRoute_AirPlay: string;
declare var kAudioSession_InputSourceKey_ID: string;
declare var kAudioSession_InputSourceKey_Description: string;
declare var kAudioSession_OutputDestinationKey_ID: string;
declare var kAudioSession_OutputDestinationKey_Description: string;
declare var kAudioComponentRegistrationsChangedNotification: string;
declare var AVAudioEngineConfigurationChangeNotification: string;
declare var AVFormatIDKey: string;
declare var AVSampleRateKey: string;
declare var AVNumberOfChannelsKey: string;
declare var AVLinearPCMBitDepthKey: string;
declare var AVLinearPCMIsBigEndianKey: string;
declare var AVLinearPCMIsFloatKey: string;
declare var AVLinearPCMIsNonInterleaved: string;
declare var AVEncoderAudioQualityKey: string;
declare var AVEncoderAudioQualityForVBRKey: string;
declare var AVEncoderBitRateKey: string;
declare var AVEncoderBitRatePerChannelKey: string;
declare var AVEncoderBitRateStrategyKey: string;
declare var AVEncoderBitDepthHintKey: string;
declare var AVSampleRateConverterAlgorithmKey: string;
declare var AVSampleRateConverterAudioQualityKey: string;
declare var AVChannelLayoutKey: string;
declare var AVAudioBitRateStrategy_Constant: string;
declare var AVAudioBitRateStrategy_LongTermAverage: string;
declare var AVAudioBitRateStrategy_VariableConstrained: string;
declare var AVAudioBitRateStrategy_Variable: string;
declare var AVSampleRateConverterAlgorithm_Normal: string;
declare var AVSampleRateConverterAlgorithm_Mastering: string;
declare var AVAudioSessionInterruptionNotification: string;
declare var AVAudioSessionRouteChangeNotification: string;
declare var AVAudioSessionMediaServicesWereLostNotification: string;
declare var AVAudioSessionMediaServicesWereResetNotification: string;
declare var AVAudioSessionSilenceSecondaryAudioHintNotification: string;
declare var AVAudioSessionInterruptionTypeKey: string;
declare var AVAudioSessionInterruptionOptionKey: string;
declare var AVAudioSessionRouteChangeReasonKey: string;
declare var AVAudioSessionRouteChangePreviousRouteKey: string;
declare var AVAudioSessionSilenceSecondaryAudioHintTypeKey: string;
declare var AVAudioSessionCategoryAmbient: string;
declare var AVAudioSessionCategorySoloAmbient: string;
declare var AVAudioSessionCategoryPlayback: string;
declare var AVAudioSessionCategoryRecord: string;
declare var AVAudioSessionCategoryPlayAndRecord: string;
declare var AVAudioSessionCategoryAudioProcessing: string;
declare var AVAudioSessionCategoryMultiRoute: string;
declare var AVAudioSessionModeDefault: string;
declare var AVAudioSessionModeVoiceChat: string;
declare var AVAudioSessionModeGameChat: string;
declare var AVAudioSessionModeVideoRecording: string;
declare var AVAudioSessionModeMeasurement: string;
declare var AVAudioSessionModeMoviePlayback: string;
declare var AVAudioSessionModeVideoChat: string;
declare var AVAudioSessionPortLineIn: string;
declare var AVAudioSessionPortBuiltInMic: string;
declare var AVAudioSessionPortHeadsetMic: string;
declare var AVAudioSessionPortLineOut: string;
declare var AVAudioSessionPortHeadphones: string;
declare var AVAudioSessionPortBluetoothA2DP: string;
declare var AVAudioSessionPortBuiltInReceiver: string;
declare var AVAudioSessionPortBuiltInSpeaker: string;
declare var AVAudioSessionPortHDMI: string;
declare var AVAudioSessionPortAirPlay: string;
declare var AVAudioSessionPortBluetoothLE: string;
declare var AVAudioSessionPortBluetoothHFP: string;
declare var AVAudioSessionPortUSBAudio: string;
declare var AVAudioSessionPortCarAudio: string;
declare var AVAudioSessionLocationUpper: string;
declare var AVAudioSessionLocationLower: string;
declare var AVAudioSessionOrientationTop: string;
declare var AVAudioSessionOrientationBottom: string;
declare var AVAudioSessionOrientationFront: string;
declare var AVAudioSessionOrientationBack: string;
declare var AVAudioSessionPolarPatternOmnidirectional: string;
declare var AVAudioSessionPolarPatternCardioid: string;
declare var AVAudioSessionPolarPatternSubcardioid: string;
declare var AVCoreAnimationBeginTimeAtZero: number;
declare var AVLayerVideoGravityResizeAspect: string;
declare var AVLayerVideoGravityResizeAspectFill: string;
declare var AVLayerVideoGravityResize: string;
declare var AVURLAssetPreferPreciseDurationAndTimingKey: string;
declare var AVURLAssetReferenceRestrictionsKey: string;
declare var AVURLAssetHTTPCookiesKey: string;
declare var AVAssetExportPresetLowQuality: string;
declare var AVAssetExportPresetMediumQuality: string;
declare var AVAssetExportPresetHighestQuality: string;
declare var AVAssetExportPreset640x480: string;
declare var AVAssetExportPreset960x540: string;
declare var AVAssetExportPreset1280x720: string;
declare var AVAssetExportPreset1920x1080: string;
declare var AVAssetExportPresetAppleM4A: string;
declare var AVAssetExportPresetPassthrough: string;
declare var AVAssetImageGeneratorApertureModeCleanAperture: string;
declare var AVAssetImageGeneratorApertureModeProductionAperture: string;
declare var AVAssetImageGeneratorApertureModeEncodedPixels: string;
declare var AVTrackAssociationTypeAudioFallback: string;
declare var AVTrackAssociationTypeChapterList: string;
declare var AVTrackAssociationTypeForcedSubtitlesOnly: string;
declare var AVTrackAssociationTypeSelectionFollower: string;
declare var AVTrackAssociationTypeTimecode: string;
declare var AVTrackAssociationTypeMetadataReferent: string;
declare var AVAudioTimePitchAlgorithmLowQualityZeroLatency: string;
declare var AVAudioTimePitchAlgorithmTimeDomain: string;
declare var AVAudioTimePitchAlgorithmSpectral: string;
declare var AVAudioTimePitchAlgorithmVarispeed: string;
declare var AVCaptureDeviceWasConnectedNotification: string;
declare var AVCaptureDeviceWasDisconnectedNotification: string;
declare var AVCaptureDeviceSubjectAreaDidChangeNotification: string;
declare var AVCaptureMaxAvailableTorchLevel: number;
declare var AVCaptureLensPositionCurrent: number;
declare var AVCaptureExposureDurationCurrent: CMTime;
declare var AVCaptureISOCurrent: number;
declare var AVCaptureExposureTargetBiasCurrent: number;
declare var AVCaptureWhiteBalanceGainsCurrent: AVCaptureWhiteBalanceGains;
declare var AVCaptureInputPortFormatDescriptionDidChangeNotification: string;
declare var AVCaptureSessionRuntimeErrorNotification: string;
declare var AVCaptureSessionErrorKey: string;
declare var AVCaptureSessionDidStartRunningNotification: string;
declare var AVCaptureSessionDidStopRunningNotification: string;
declare var AVCaptureSessionWasInterruptedNotification: string;
declare var AVCaptureSessionInterruptionEndedNotification: string;
declare var AVCaptureSessionPresetPhoto: string;
declare var AVCaptureSessionPresetHigh: string;
declare var AVCaptureSessionPresetMedium: string;
declare var AVCaptureSessionPresetLow: string;
declare var AVCaptureSessionPreset352x288: string;
declare var AVCaptureSessionPreset640x480: string;
declare var AVCaptureSessionPreset1280x720: string;
declare var AVCaptureSessionPreset1920x1080: string;
declare var AVCaptureSessionPresetiFrame960x540: string;
declare var AVCaptureSessionPresetiFrame1280x720: string;
declare var AVCaptureSessionPresetInputPriority: string;
declare var AVFoundationErrorDomain: string;
declare var AVErrorDeviceKey: string;
declare var AVErrorTimeKey: string;
declare var AVErrorFileSizeKey: string;
declare var AVErrorPIDKey: string;
declare var AVErrorRecordingSuccessfullyFinishedKey: string;
declare var AVErrorMediaTypeKey: string;
declare var AVErrorMediaSubTypeKey: string;
declare var AVErrorPresentationTimeStampKey: string;
declare var AVErrorPersistentTrackIDKey: string;
declare var AVErrorFileTypeKey: string;
declare var AVMediaTypeVideo: string;
declare var AVMediaTypeAudio: string;
declare var AVMediaTypeText: string;
declare var AVMediaTypeClosedCaption: string;
declare var AVMediaTypeSubtitle: string;
declare var AVMediaTypeTimecode: string;
declare var AVMediaTypeMetadata: string;
declare var AVMediaTypeMuxed: string;
declare var AVMediaCharacteristicVisual: string;
declare var AVMediaCharacteristicAudible: string;
declare var AVMediaCharacteristicLegible: string;
declare var AVMediaCharacteristicFrameBased: string;
declare var AVMediaCharacteristicIsMainProgramContent: string;
declare var AVMediaCharacteristicIsAuxiliaryContent: string;
declare var AVMediaCharacteristicContainsOnlyForcedSubtitles: string;
declare var AVMediaCharacteristicTranscribesSpokenDialogForAccessibility: string;
declare var AVMediaCharacteristicDescribesMusicAndSoundForAccessibility: string;
declare var AVMediaCharacteristicEasyToRead: string;
declare var AVMediaCharacteristicDescribesVideoForAccessibility: string;
declare var AVFileTypeQuickTimeMovie: string;
declare var AVFileTypeMPEG4: string;
declare var AVFileTypeAppleM4V: string;
declare var AVFileTypeAppleM4A: string;
declare var AVFileType3GPP: string;
declare var AVFileType3GPP2: string;
declare var AVFileTypeCoreAudioFormat: string;
declare var AVFileTypeWAVE: string;
declare var AVFileTypeAIFF: string;
declare var AVFileTypeAIFC: string;
declare var AVFileTypeAMR: string;
declare var AVFileTypeMPEGLayer3: string;
declare var AVFileTypeSunAU: string;
declare var AVFileTypeAC3: string;
declare var AVMetadataKeySpaceCommon: string;
declare var AVMetadataCommonKeyTitle: string;
declare var AVMetadataCommonKeyCreator: string;
declare var AVMetadataCommonKeySubject: string;
declare var AVMetadataCommonKeyDescription: string;
declare var AVMetadataCommonKeyPublisher: string;
declare var AVMetadataCommonKeyContributor: string;
declare var AVMetadataCommonKeyCreationDate: string;
declare var AVMetadataCommonKeyLastModifiedDate: string;
declare var AVMetadataCommonKeyType: string;
declare var AVMetadataCommonKeyFormat: string;
declare var AVMetadataCommonKeyIdentifier: string;
declare var AVMetadataCommonKeySource: string;
declare var AVMetadataCommonKeyLanguage: string;
declare var AVMetadataCommonKeyRelation: string;
declare var AVMetadataCommonKeyLocation: string;
declare var AVMetadataCommonKeyCopyrights: string;
declare var AVMetadataCommonKeyAlbumName: string;
declare var AVMetadataCommonKeyAuthor: string;
declare var AVMetadataCommonKeyArtist: string;
declare var AVMetadataCommonKeyArtwork: string;
declare var AVMetadataCommonKeyMake: string;
declare var AVMetadataCommonKeyModel: string;
declare var AVMetadataCommonKeySoftware: string;
declare var AVMetadataFormatQuickTimeUserData: string;
declare var AVMetadataKeySpaceQuickTimeUserData: string;
declare var AVMetadataQuickTimeUserDataKeyAlbum: string;
declare var AVMetadataQuickTimeUserDataKeyArranger: string;
declare var AVMetadataQuickTimeUserDataKeyArtist: string;
declare var AVMetadataQuickTimeUserDataKeyAuthor: string;
declare var AVMetadataQuickTimeUserDataKeyChapter: string;
declare var AVMetadataQuickTimeUserDataKeyComment: string;
declare var AVMetadataQuickTimeUserDataKeyComposer: string;
declare var AVMetadataQuickTimeUserDataKeyCopyright: string;
declare var AVMetadataQuickTimeUserDataKeyCreationDate: string;
declare var AVMetadataQuickTimeUserDataKeyDescription: string;
declare var AVMetadataQuickTimeUserDataKeyDirector: string;
declare var AVMetadataQuickTimeUserDataKeyDisclaimer: string;
declare var AVMetadataQuickTimeUserDataKeyEncodedBy: string;
declare var AVMetadataQuickTimeUserDataKeyFullName: string;
declare var AVMetadataQuickTimeUserDataKeyGenre: string;
declare var AVMetadataQuickTimeUserDataKeyHostComputer: string;
declare var AVMetadataQuickTimeUserDataKeyInformation: string;
declare var AVMetadataQuickTimeUserDataKeyKeywords: string;
declare var AVMetadataQuickTimeUserDataKeyMake: string;
declare var AVMetadataQuickTimeUserDataKeyModel: string;
declare var AVMetadataQuickTimeUserDataKeyOriginalArtist: string;
declare var AVMetadataQuickTimeUserDataKeyOriginalFormat: string;
declare var AVMetadataQuickTimeUserDataKeyOriginalSource: string;
declare var AVMetadataQuickTimeUserDataKeyPerformers: string;
declare var AVMetadataQuickTimeUserDataKeyProducer: string;
declare var AVMetadataQuickTimeUserDataKeyPublisher: string;
declare var AVMetadataQuickTimeUserDataKeyProduct: string;
declare var AVMetadataQuickTimeUserDataKeySoftware: string;
declare var AVMetadataQuickTimeUserDataKeySpecialPlaybackRequirements: string;
declare var AVMetadataQuickTimeUserDataKeyTrack: string;
declare var AVMetadataQuickTimeUserDataKeyWarning: string;
declare var AVMetadataQuickTimeUserDataKeyWriter: string;
declare var AVMetadataQuickTimeUserDataKeyURLLink: string;
declare var AVMetadataQuickTimeUserDataKeyLocationISO6709: string;
declare var AVMetadataQuickTimeUserDataKeyTrackName: string;
declare var AVMetadataQuickTimeUserDataKeyCredits: string;
declare var AVMetadataQuickTimeUserDataKeyPhonogramRights: string;
declare var AVMetadataQuickTimeUserDataKeyTaggedCharacteristic: string;
declare var AVMetadataFormatISOUserData: string;
declare var AVMetadataKeySpaceISOUserData: string;
declare var AVMetadataISOUserDataKeyCopyright: string;
declare var AVMetadataISOUserDataKeyTaggedCharacteristic: string;
declare var AVMetadata3GPUserDataKeyCopyright: string;
declare var AVMetadata3GPUserDataKeyAuthor: string;
declare var AVMetadata3GPUserDataKeyPerformer: string;
declare var AVMetadata3GPUserDataKeyGenre: string;
declare var AVMetadata3GPUserDataKeyRecordingYear: string;
declare var AVMetadata3GPUserDataKeyLocation: string;
declare var AVMetadata3GPUserDataKeyTitle: string;
declare var AVMetadata3GPUserDataKeyDescription: string;
declare var AVMetadata3GPUserDataKeyCollection: string;
declare var AVMetadata3GPUserDataKeyUserRating: string;
declare var AVMetadata3GPUserDataKeyThumbnail: string;
declare var AVMetadata3GPUserDataKeyAlbumAndTrack: string;
declare var AVMetadata3GPUserDataKeyKeywordList: string;
declare var AVMetadata3GPUserDataKeyMediaClassification: string;
declare var AVMetadata3GPUserDataKeyMediaRating: string;
declare var AVMetadataFormatQuickTimeMetadata: string;
declare var AVMetadataKeySpaceQuickTimeMetadata: string;
declare var AVMetadataQuickTimeMetadataKeyAuthor: string;
declare var AVMetadataQuickTimeMetadataKeyComment: string;
declare var AVMetadataQuickTimeMetadataKeyCopyright: string;
declare var AVMetadataQuickTimeMetadataKeyCreationDate: string;
declare var AVMetadataQuickTimeMetadataKeyDirector: string;
declare var AVMetadataQuickTimeMetadataKeyDisplayName: string;
declare var AVMetadataQuickTimeMetadataKeyInformation: string;
declare var AVMetadataQuickTimeMetadataKeyKeywords: string;
declare var AVMetadataQuickTimeMetadataKeyProducer: string;
declare var AVMetadataQuickTimeMetadataKeyPublisher: string;
declare var AVMetadataQuickTimeMetadataKeyAlbum: string;
declare var AVMetadataQuickTimeMetadataKeyArtist: string;
declare var AVMetadataQuickTimeMetadataKeyArtwork: string;
declare var AVMetadataQuickTimeMetadataKeyDescription: string;
declare var AVMetadataQuickTimeMetadataKeySoftware: string;
declare var AVMetadataQuickTimeMetadataKeyYear: string;
declare var AVMetadataQuickTimeMetadataKeyGenre: string;
declare var AVMetadataQuickTimeMetadataKeyiXML: string;
declare var AVMetadataQuickTimeMetadataKeyLocationISO6709: string;
declare var AVMetadataQuickTimeMetadataKeyMake: string;
declare var AVMetadataQuickTimeMetadataKeyModel: string;
declare var AVMetadataQuickTimeMetadataKeyArranger: string;
declare var AVMetadataQuickTimeMetadataKeyEncodedBy: string;
declare var AVMetadataQuickTimeMetadataKeyOriginalArtist: string;
declare var AVMetadataQuickTimeMetadataKeyPerformer: string;
declare var AVMetadataQuickTimeMetadataKeyComposer: string;
declare var AVMetadataQuickTimeMetadataKeyCredits: string;
declare var AVMetadataQuickTimeMetadataKeyPhonogramRights: string;
declare var AVMetadataQuickTimeMetadataKeyCameraIdentifier: string;
declare var AVMetadataQuickTimeMetadataKeyCameraFrameReadoutTime: string;
declare var AVMetadataQuickTimeMetadataKeyTitle: string;
declare var AVMetadataQuickTimeMetadataKeyCollectionUser: string;
declare var AVMetadataQuickTimeMetadataKeyRatingUser: string;
declare var AVMetadataQuickTimeMetadataKeyLocationName: string;
declare var AVMetadataQuickTimeMetadataKeyLocationBody: string;
declare var AVMetadataQuickTimeMetadataKeyLocationNote: string;
declare var AVMetadataQuickTimeMetadataKeyLocationRole: string;
declare var AVMetadataQuickTimeMetadataKeyLocationDate: string;
declare var AVMetadataQuickTimeMetadataKeyDirectionFacing: string;
declare var AVMetadataQuickTimeMetadataKeyDirectionMotion: string;
declare var AVMetadataFormatiTunesMetadata: string;
declare var AVMetadataKeySpaceiTunes: string;
declare var AVMetadataiTunesMetadataKeyAlbum: string;
declare var AVMetadataiTunesMetadataKeyArtist: string;
declare var AVMetadataiTunesMetadataKeyUserComment: string;
declare var AVMetadataiTunesMetadataKeyCoverArt: string;
declare var AVMetadataiTunesMetadataKeyCopyright: string;
declare var AVMetadataiTunesMetadataKeyReleaseDate: string;
declare var AVMetadataiTunesMetadataKeyEncodedBy: string;
declare var AVMetadataiTunesMetadataKeyPredefinedGenre: string;
declare var AVMetadataiTunesMetadataKeyUserGenre: string;
declare var AVMetadataiTunesMetadataKeySongName: string;
declare var AVMetadataiTunesMetadataKeyTrackSubTitle: string;
declare var AVMetadataiTunesMetadataKeyEncodingTool: string;
declare var AVMetadataiTunesMetadataKeyComposer: string;
declare var AVMetadataiTunesMetadataKeyAlbumArtist: string;
declare var AVMetadataiTunesMetadataKeyAccountKind: string;
declare var AVMetadataiTunesMetadataKeyAppleID: string;
declare var AVMetadataiTunesMetadataKeyArtistID: string;
declare var AVMetadataiTunesMetadataKeySongID: string;
declare var AVMetadataiTunesMetadataKeyDiscCompilation: string;
declare var AVMetadataiTunesMetadataKeyDiscNumber: string;
declare var AVMetadataiTunesMetadataKeyGenreID: string;
declare var AVMetadataiTunesMetadataKeyGrouping: string;
declare var AVMetadataiTunesMetadataKeyPlaylistID: string;
declare var AVMetadataiTunesMetadataKeyContentRating: string;
declare var AVMetadataiTunesMetadataKeyBeatsPerMin: string;
declare var AVMetadataiTunesMetadataKeyTrackNumber: string;
declare var AVMetadataiTunesMetadataKeyArtDirector: string;
declare var AVMetadataiTunesMetadataKeyArranger: string;
declare var AVMetadataiTunesMetadataKeyAuthor: string;
declare var AVMetadataiTunesMetadataKeyLyrics: string;
declare var AVMetadataiTunesMetadataKeyAcknowledgement: string;
declare var AVMetadataiTunesMetadataKeyConductor: string;
declare var AVMetadataiTunesMetadataKeyDescription: string;
declare var AVMetadataiTunesMetadataKeyDirector: string;
declare var AVMetadataiTunesMetadataKeyEQ: string;
declare var AVMetadataiTunesMetadataKeyLinerNotes: string;
declare var AVMetadataiTunesMetadataKeyRecordCompany: string;
declare var AVMetadataiTunesMetadataKeyOriginalArtist: string;
declare var AVMetadataiTunesMetadataKeyPhonogramRights: string;
declare var AVMetadataiTunesMetadataKeyProducer: string;
declare var AVMetadataiTunesMetadataKeyPerformer: string;
declare var AVMetadataiTunesMetadataKeyPublisher: string;
declare var AVMetadataiTunesMetadataKeySoundEngineer: string;
declare var AVMetadataiTunesMetadataKeySoloist: string;
declare var AVMetadataiTunesMetadataKeyCredits: string;
declare var AVMetadataiTunesMetadataKeyThanks: string;
declare var AVMetadataiTunesMetadataKeyOnlineExtras: string;
declare var AVMetadataiTunesMetadataKeyExecProducer: string;
declare var AVMetadataFormatID3Metadata: string;
declare var AVMetadataKeySpaceID3: string;
declare var AVMetadataID3MetadataKeyAudioEncryption: string;
declare var AVMetadataID3MetadataKeyAttachedPicture: string;
declare var AVMetadataID3MetadataKeyAudioSeekPointIndex: string;
declare var AVMetadataID3MetadataKeyComments: string;
declare var AVMetadataID3MetadataKeyCommerical: string;
declare var AVMetadataID3MetadataKeyEncryption: string;
declare var AVMetadataID3MetadataKeyEqualization: string;
declare var AVMetadataID3MetadataKeyEqualization2: string;
declare var AVMetadataID3MetadataKeyEventTimingCodes: string;
declare var AVMetadataID3MetadataKeyGeneralEncapsulatedObject: string;
declare var AVMetadataID3MetadataKeyGroupIdentifier: string;
declare var AVMetadataID3MetadataKeyInvolvedPeopleList_v23: string;
declare var AVMetadataID3MetadataKeyLink: string;
declare var AVMetadataID3MetadataKeyMusicCDIdentifier: string;
declare var AVMetadataID3MetadataKeyMPEGLocationLookupTable: string;
declare var AVMetadataID3MetadataKeyOwnership: string;
declare var AVMetadataID3MetadataKeyPrivate: string;
declare var AVMetadataID3MetadataKeyPlayCounter: string;
declare var AVMetadataID3MetadataKeyPopularimeter: string;
declare var AVMetadataID3MetadataKeyPositionSynchronization: string;
declare var AVMetadataID3MetadataKeyRecommendedBufferSize: string;
declare var AVMetadataID3MetadataKeyRelativeVolumeAdjustment: string;
declare var AVMetadataID3MetadataKeyRelativeVolumeAdjustment2: string;
declare var AVMetadataID3MetadataKeyReverb: string;
declare var AVMetadataID3MetadataKeySeek: string;
declare var AVMetadataID3MetadataKeySignature: string;
declare var AVMetadataID3MetadataKeySynchronizedLyric: string;
declare var AVMetadataID3MetadataKeySynchronizedTempoCodes: string;
declare var AVMetadataID3MetadataKeyAlbumTitle: string;
declare var AVMetadataID3MetadataKeyBeatsPerMinute: string;
declare var AVMetadataID3MetadataKeyComposer: string;
declare var AVMetadataID3MetadataKeyContentType: string;
declare var AVMetadataID3MetadataKeyCopyright: string;
declare var AVMetadataID3MetadataKeyDate: string;
declare var AVMetadataID3MetadataKeyEncodingTime: string;
declare var AVMetadataID3MetadataKeyPlaylistDelay: string;
declare var AVMetadataID3MetadataKeyOriginalReleaseTime: string;
declare var AVMetadataID3MetadataKeyRecordingTime: string;
declare var AVMetadataID3MetadataKeyReleaseTime: string;
declare var AVMetadataID3MetadataKeyTaggingTime: string;
declare var AVMetadataID3MetadataKeyEncodedBy: string;
declare var AVMetadataID3MetadataKeyLyricist: string;
declare var AVMetadataID3MetadataKeyFileType: string;
declare var AVMetadataID3MetadataKeyTime: string;
declare var AVMetadataID3MetadataKeyInvolvedPeopleList_v24: string;
declare var AVMetadataID3MetadataKeyContentGroupDescription: string;
declare var AVMetadataID3MetadataKeyTitleDescription: string;
declare var AVMetadataID3MetadataKeySubTitle: string;
declare var AVMetadataID3MetadataKeyInitialKey: string;
declare var AVMetadataID3MetadataKeyLanguage: string;
declare var AVMetadataID3MetadataKeyLength: string;
declare var AVMetadataID3MetadataKeyMusicianCreditsList: string;
declare var AVMetadataID3MetadataKeyMediaType: string;
declare var AVMetadataID3MetadataKeyMood: string;
declare var AVMetadataID3MetadataKeyOriginalAlbumTitle: string;
declare var AVMetadataID3MetadataKeyOriginalFilename: string;
declare var AVMetadataID3MetadataKeyOriginalLyricist: string;
declare var AVMetadataID3MetadataKeyOriginalArtist: string;
declare var AVMetadataID3MetadataKeyOriginalReleaseYear: string;
declare var AVMetadataID3MetadataKeyFileOwner: string;
declare var AVMetadataID3MetadataKeyLeadPerformer: string;
declare var AVMetadataID3MetadataKeyBand: string;
declare var AVMetadataID3MetadataKeyConductor: string;
declare var AVMetadataID3MetadataKeyModifiedBy: string;
declare var AVMetadataID3MetadataKeyPartOfASet: string;
declare var AVMetadataID3MetadataKeyProducedNotice: string;
declare var AVMetadataID3MetadataKeyPublisher: string;
declare var AVMetadataID3MetadataKeyTrackNumber: string;
declare var AVMetadataID3MetadataKeyRecordingDates: string;
declare var AVMetadataID3MetadataKeyInternetRadioStationName: string;
declare var AVMetadataID3MetadataKeyInternetRadioStationOwner: string;
declare var AVMetadataID3MetadataKeySize: string;
declare var AVMetadataID3MetadataKeyAlbumSortOrder: string;
declare var AVMetadataID3MetadataKeyPerformerSortOrder: string;
declare var AVMetadataID3MetadataKeyTitleSortOrder: string;
declare var AVMetadataID3MetadataKeyInternationalStandardRecordingCode: string;
declare var AVMetadataID3MetadataKeyEncodedWith: string;
declare var AVMetadataID3MetadataKeySetSubtitle: string;
declare var AVMetadataID3MetadataKeyYear: string;
declare var AVMetadataID3MetadataKeyUserText: string;
declare var AVMetadataID3MetadataKeyUniqueFileIdentifier: string;
declare var AVMetadataID3MetadataKeyTermsOfUse: string;
declare var AVMetadataID3MetadataKeyUnsynchronizedLyric: string;
declare var AVMetadataID3MetadataKeyCommercialInformation: string;
declare var AVMetadataID3MetadataKeyCopyrightInformation: string;
declare var AVMetadataID3MetadataKeyOfficialAudioFileWebpage: string;
declare var AVMetadataID3MetadataKeyOfficialArtistWebpage: string;
declare var AVMetadataID3MetadataKeyOfficialAudioSourceWebpage: string;
declare var AVMetadataID3MetadataKeyOfficialInternetRadioStationHomepage: string;
declare var AVMetadataID3MetadataKeyPayment: string;
declare var AVMetadataID3MetadataKeyOfficialPublisherWebpage: string;
declare var AVMetadataID3MetadataKeyUserURL: string;
declare var AVMetadataKeySpaceIcy: string;
declare var AVMetadataIcyMetadataKeyStreamTitle: string;
declare var AVMetadataIcyMetadataKeyStreamURL: string;
declare var AVMetadataFormatHLSMetadata: string;
declare var AVMetadataExtraAttributeValueURIKey: string;
declare var AVMetadataExtraAttributeBaseURIKey: string;
declare var AVMetadataCommonIdentifierTitle: string;
declare var AVMetadataCommonIdentifierCreator: string;
declare var AVMetadataCommonIdentifierSubject: string;
declare var AVMetadataCommonIdentifierDescription: string;
declare var AVMetadataCommonIdentifierPublisher: string;
declare var AVMetadataCommonIdentifierContributor: string;
declare var AVMetadataCommonIdentifierCreationDate: string;
declare var AVMetadataCommonIdentifierLastModifiedDate: string;
declare var AVMetadataCommonIdentifierType: string;
declare var AVMetadataCommonIdentifierFormat: string;
declare var AVMetadataCommonIdentifierAssetIdentifier: string;
declare var AVMetadataCommonIdentifierSource: string;
declare var AVMetadataCommonIdentifierLanguage: string;
declare var AVMetadataCommonIdentifierRelation: string;
declare var AVMetadataCommonIdentifierLocation: string;
declare var AVMetadataCommonIdentifierCopyrights: string;
declare var AVMetadataCommonIdentifierAlbumName: string;
declare var AVMetadataCommonIdentifierAuthor: string;
declare var AVMetadataCommonIdentifierArtist: string;
declare var AVMetadataCommonIdentifierArtwork: string;
declare var AVMetadataCommonIdentifierMake: string;
declare var AVMetadataCommonIdentifierModel: string;
declare var AVMetadataCommonIdentifierSoftware: string;
declare var AVMetadataIdentifierQuickTimeUserDataAlbum: string;
declare var AVMetadataIdentifierQuickTimeUserDataArranger: string;
declare var AVMetadataIdentifierQuickTimeUserDataArtist: string;
declare var AVMetadataIdentifierQuickTimeUserDataAuthor: string;
declare var AVMetadataIdentifierQuickTimeUserDataChapter: string;
declare var AVMetadataIdentifierQuickTimeUserDataComment: string;
declare var AVMetadataIdentifierQuickTimeUserDataComposer: string;
declare var AVMetadataIdentifierQuickTimeUserDataCopyright: string;
declare var AVMetadataIdentifierQuickTimeUserDataCreationDate: string;
declare var AVMetadataIdentifierQuickTimeUserDataDescription: string;
declare var AVMetadataIdentifierQuickTimeUserDataDirector: string;
declare var AVMetadataIdentifierQuickTimeUserDataDisclaimer: string;
declare var AVMetadataIdentifierQuickTimeUserDataEncodedBy: string;
declare var AVMetadataIdentifierQuickTimeUserDataFullName: string;
declare var AVMetadataIdentifierQuickTimeUserDataGenre: string;
declare var AVMetadataIdentifierQuickTimeUserDataHostComputer: string;
declare var AVMetadataIdentifierQuickTimeUserDataInformation: string;
declare var AVMetadataIdentifierQuickTimeUserDataKeywords: string;
declare var AVMetadataIdentifierQuickTimeUserDataMake: string;
declare var AVMetadataIdentifierQuickTimeUserDataModel: string;
declare var AVMetadataIdentifierQuickTimeUserDataOriginalArtist: string;
declare var AVMetadataIdentifierQuickTimeUserDataOriginalFormat: string;
declare var AVMetadataIdentifierQuickTimeUserDataOriginalSource: string;
declare var AVMetadataIdentifierQuickTimeUserDataPerformers: string;
declare var AVMetadataIdentifierQuickTimeUserDataProducer: string;
declare var AVMetadataIdentifierQuickTimeUserDataPublisher: string;
declare var AVMetadataIdentifierQuickTimeUserDataProduct: string;
declare var AVMetadataIdentifierQuickTimeUserDataSoftware: string;
declare var AVMetadataIdentifierQuickTimeUserDataSpecialPlaybackRequirements: string;
declare var AVMetadataIdentifierQuickTimeUserDataTrack: string;
declare var AVMetadataIdentifierQuickTimeUserDataWarning: string;
declare var AVMetadataIdentifierQuickTimeUserDataWriter: string;
declare var AVMetadataIdentifierQuickTimeUserDataURLLink: string;
declare var AVMetadataIdentifierQuickTimeUserDataLocationISO6709: string;
declare var AVMetadataIdentifierQuickTimeUserDataTrackName: string;
declare var AVMetadataIdentifierQuickTimeUserDataCredits: string;
declare var AVMetadataIdentifierQuickTimeUserDataPhonogramRights: string;
declare var AVMetadataIdentifierQuickTimeUserDataTaggedCharacteristic: string;
declare var AVMetadataIdentifierISOUserDataCopyright: string;
declare var AVMetadataIdentifierISOUserDataTaggedCharacteristic: string;
declare var AVMetadataIdentifier3GPUserDataCopyright: string;
declare var AVMetadataIdentifier3GPUserDataAuthor: string;
declare var AVMetadataIdentifier3GPUserDataPerformer: string;
declare var AVMetadataIdentifier3GPUserDataGenre: string;
declare var AVMetadataIdentifier3GPUserDataRecordingYear: string;
declare var AVMetadataIdentifier3GPUserDataLocation: string;
declare var AVMetadataIdentifier3GPUserDataTitle: string;
declare var AVMetadataIdentifier3GPUserDataDescription: string;
declare var AVMetadataIdentifier3GPUserDataCollection: string;
declare var AVMetadataIdentifier3GPUserDataUserRating: string;
declare var AVMetadataIdentifier3GPUserDataThumbnail: string;
declare var AVMetadataIdentifier3GPUserDataAlbumAndTrack: string;
declare var AVMetadataIdentifier3GPUserDataKeywordList: string;
declare var AVMetadataIdentifier3GPUserDataMediaClassification: string;
declare var AVMetadataIdentifier3GPUserDataMediaRating: string;
declare var AVMetadataIdentifierQuickTimeMetadataAuthor: string;
declare var AVMetadataIdentifierQuickTimeMetadataComment: string;
declare var AVMetadataIdentifierQuickTimeMetadataCopyright: string;
declare var AVMetadataIdentifierQuickTimeMetadataCreationDate: string;
declare var AVMetadataIdentifierQuickTimeMetadataDirector: string;
declare var AVMetadataIdentifierQuickTimeMetadataDisplayName: string;
declare var AVMetadataIdentifierQuickTimeMetadataInformation: string;
declare var AVMetadataIdentifierQuickTimeMetadataKeywords: string;
declare var AVMetadataIdentifierQuickTimeMetadataProducer: string;
declare var AVMetadataIdentifierQuickTimeMetadataPublisher: string;
declare var AVMetadataIdentifierQuickTimeMetadataAlbum: string;
declare var AVMetadataIdentifierQuickTimeMetadataArtist: string;
declare var AVMetadataIdentifierQuickTimeMetadataArtwork: string;
declare var AVMetadataIdentifierQuickTimeMetadataDescription: string;
declare var AVMetadataIdentifierQuickTimeMetadataSoftware: string;
declare var AVMetadataIdentifierQuickTimeMetadataYear: string;
declare var AVMetadataIdentifierQuickTimeMetadataGenre: string;
declare var AVMetadataIdentifierQuickTimeMetadataiXML: string;
declare var AVMetadataIdentifierQuickTimeMetadataLocationISO6709: string;
declare var AVMetadataIdentifierQuickTimeMetadataMake: string;
declare var AVMetadataIdentifierQuickTimeMetadataModel: string;
declare var AVMetadataIdentifierQuickTimeMetadataArranger: string;
declare var AVMetadataIdentifierQuickTimeMetadataEncodedBy: string;
declare var AVMetadataIdentifierQuickTimeMetadataOriginalArtist: string;
declare var AVMetadataIdentifierQuickTimeMetadataPerformer: string;
declare var AVMetadataIdentifierQuickTimeMetadataComposer: string;
declare var AVMetadataIdentifierQuickTimeMetadataCredits: string;
declare var AVMetadataIdentifierQuickTimeMetadataPhonogramRights: string;
declare var AVMetadataIdentifierQuickTimeMetadataCameraIdentifier: string;
declare var AVMetadataIdentifierQuickTimeMetadataCameraFrameReadoutTime: string;
declare var AVMetadataIdentifierQuickTimeMetadataTitle: string;
declare var AVMetadataIdentifierQuickTimeMetadataCollectionUser: string;
declare var AVMetadataIdentifierQuickTimeMetadataRatingUser: string;
declare var AVMetadataIdentifierQuickTimeMetadataLocationName: string;
declare var AVMetadataIdentifierQuickTimeMetadataLocationBody: string;
declare var AVMetadataIdentifierQuickTimeMetadataLocationNote: string;
declare var AVMetadataIdentifierQuickTimeMetadataLocationRole: string;
declare var AVMetadataIdentifierQuickTimeMetadataLocationDate: string;
declare var AVMetadataIdentifierQuickTimeMetadataDirectionFacing: string;
declare var AVMetadataIdentifierQuickTimeMetadataDirectionMotion: string;
declare var AVMetadataIdentifierQuickTimeMetadataPreferredAffineTransform: string;
declare var AVMetadataIdentifieriTunesMetadataAlbum: string;
declare var AVMetadataIdentifieriTunesMetadataArtist: string;
declare var AVMetadataIdentifieriTunesMetadataUserComment: string;
declare var AVMetadataIdentifieriTunesMetadataCoverArt: string;
declare var AVMetadataIdentifieriTunesMetadataCopyright: string;
declare var AVMetadataIdentifieriTunesMetadataReleaseDate: string;
declare var AVMetadataIdentifieriTunesMetadataEncodedBy: string;
declare var AVMetadataIdentifieriTunesMetadataPredefinedGenre: string;
declare var AVMetadataIdentifieriTunesMetadataUserGenre: string;
declare var AVMetadataIdentifieriTunesMetadataSongName: string;
declare var AVMetadataIdentifieriTunesMetadataTrackSubTitle: string;
declare var AVMetadataIdentifieriTunesMetadataEncodingTool: string;
declare var AVMetadataIdentifieriTunesMetadataComposer: string;
declare var AVMetadataIdentifieriTunesMetadataAlbumArtist: string;
declare var AVMetadataIdentifieriTunesMetadataAccountKind: string;
declare var AVMetadataIdentifieriTunesMetadataAppleID: string;
declare var AVMetadataIdentifieriTunesMetadataArtistID: string;
declare var AVMetadataIdentifieriTunesMetadataSongID: string;
declare var AVMetadataIdentifieriTunesMetadataDiscCompilation: string;
declare var AVMetadataIdentifieriTunesMetadataDiscNumber: string;
declare var AVMetadataIdentifieriTunesMetadataGenreID: string;
declare var AVMetadataIdentifieriTunesMetadataGrouping: string;
declare var AVMetadataIdentifieriTunesMetadataPlaylistID: string;
declare var AVMetadataIdentifieriTunesMetadataContentRating: string;
declare var AVMetadataIdentifieriTunesMetadataBeatsPerMin: string;
declare var AVMetadataIdentifieriTunesMetadataTrackNumber: string;
declare var AVMetadataIdentifieriTunesMetadataArtDirector: string;
declare var AVMetadataIdentifieriTunesMetadataArranger: string;
declare var AVMetadataIdentifieriTunesMetadataAuthor: string;
declare var AVMetadataIdentifieriTunesMetadataLyrics: string;
declare var AVMetadataIdentifieriTunesMetadataAcknowledgement: string;
declare var AVMetadataIdentifieriTunesMetadataConductor: string;
declare var AVMetadataIdentifieriTunesMetadataDescription: string;
declare var AVMetadataIdentifieriTunesMetadataDirector: string;
declare var AVMetadataIdentifieriTunesMetadataEQ: string;
declare var AVMetadataIdentifieriTunesMetadataLinerNotes: string;
declare var AVMetadataIdentifieriTunesMetadataRecordCompany: string;
declare var AVMetadataIdentifieriTunesMetadataOriginalArtist: string;
declare var AVMetadataIdentifieriTunesMetadataPhonogramRights: string;
declare var AVMetadataIdentifieriTunesMetadataProducer: string;
declare var AVMetadataIdentifieriTunesMetadataPerformer: string;
declare var AVMetadataIdentifieriTunesMetadataPublisher: string;
declare var AVMetadataIdentifieriTunesMetadataSoundEngineer: string;
declare var AVMetadataIdentifieriTunesMetadataSoloist: string;
declare var AVMetadataIdentifieriTunesMetadataCredits: string;
declare var AVMetadataIdentifieriTunesMetadataThanks: string;
declare var AVMetadataIdentifieriTunesMetadataOnlineExtras: string;
declare var AVMetadataIdentifieriTunesMetadataExecProducer: string;
declare var AVMetadataIdentifierID3MetadataAudioEncryption: string;
declare var AVMetadataIdentifierID3MetadataAttachedPicture: string;
declare var AVMetadataIdentifierID3MetadataAudioSeekPointIndex: string;
declare var AVMetadataIdentifierID3MetadataComments: string;
declare var AVMetadataIdentifierID3MetadataCommerical: string;
declare var AVMetadataIdentifierID3MetadataEncryption: string;
declare var AVMetadataIdentifierID3MetadataEqualization: string;
declare var AVMetadataIdentifierID3MetadataEqualization2: string;
declare var AVMetadataIdentifierID3MetadataEventTimingCodes: string;
declare var AVMetadataIdentifierID3MetadataGeneralEncapsulatedObject: string;
declare var AVMetadataIdentifierID3MetadataGroupIdentifier: string;
declare var AVMetadataIdentifierID3MetadataInvolvedPeopleList_v23: string;
declare var AVMetadataIdentifierID3MetadataLink: string;
declare var AVMetadataIdentifierID3MetadataMusicCDIdentifier: string;
declare var AVMetadataIdentifierID3MetadataMPEGLocationLookupTable: string;
declare var AVMetadataIdentifierID3MetadataOwnership: string;
declare var AVMetadataIdentifierID3MetadataPrivate: string;
declare var AVMetadataIdentifierID3MetadataPlayCounter: string;
declare var AVMetadataIdentifierID3MetadataPopularimeter: string;
declare var AVMetadataIdentifierID3MetadataPositionSynchronization: string;
declare var AVMetadataIdentifierID3MetadataRecommendedBufferSize: string;
declare var AVMetadataIdentifierID3MetadataRelativeVolumeAdjustment: string;
declare var AVMetadataIdentifierID3MetadataRelativeVolumeAdjustment2: string;
declare var AVMetadataIdentifierID3MetadataReverb: string;
declare var AVMetadataIdentifierID3MetadataSeek: string;
declare var AVMetadataIdentifierID3MetadataSignature: string;
declare var AVMetadataIdentifierID3MetadataSynchronizedLyric: string;
declare var AVMetadataIdentifierID3MetadataSynchronizedTempoCodes: string;
declare var AVMetadataIdentifierID3MetadataAlbumTitle: string;
declare var AVMetadataIdentifierID3MetadataBeatsPerMinute: string;
declare var AVMetadataIdentifierID3MetadataComposer: string;
declare var AVMetadataIdentifierID3MetadataContentType: string;
declare var AVMetadataIdentifierID3MetadataCopyright: string;
declare var AVMetadataIdentifierID3MetadataDate: string;
declare var AVMetadataIdentifierID3MetadataEncodingTime: string;
declare var AVMetadataIdentifierID3MetadataPlaylistDelay: string;
declare var AVMetadataIdentifierID3MetadataOriginalReleaseTime: string;
declare var AVMetadataIdentifierID3MetadataRecordingTime: string;
declare var AVMetadataIdentifierID3MetadataReleaseTime: string;
declare var AVMetadataIdentifierID3MetadataTaggingTime: string;
declare var AVMetadataIdentifierID3MetadataEncodedBy: string;
declare var AVMetadataIdentifierID3MetadataLyricist: string;
declare var AVMetadataIdentifierID3MetadataFileType: string;
declare var AVMetadataIdentifierID3MetadataTime: string;
declare var AVMetadataIdentifierID3MetadataInvolvedPeopleList_v24: string;
declare var AVMetadataIdentifierID3MetadataContentGroupDescription: string;
declare var AVMetadataIdentifierID3MetadataTitleDescription: string;
declare var AVMetadataIdentifierID3MetadataSubTitle: string;
declare var AVMetadataIdentifierID3MetadataInitialKey: string;
declare var AVMetadataIdentifierID3MetadataLanguage: string;
declare var AVMetadataIdentifierID3MetadataLength: string;
declare var AVMetadataIdentifierID3MetadataMusicianCreditsList: string;
declare var AVMetadataIdentifierID3MetadataMediaType: string;
declare var AVMetadataIdentifierID3MetadataMood: string;
declare var AVMetadataIdentifierID3MetadataOriginalAlbumTitle: string;
declare var AVMetadataIdentifierID3MetadataOriginalFilename: string;
declare var AVMetadataIdentifierID3MetadataOriginalLyricist: string;
declare var AVMetadataIdentifierID3MetadataOriginalArtist: string;
declare var AVMetadataIdentifierID3MetadataOriginalReleaseYear: string;
declare var AVMetadataIdentifierID3MetadataFileOwner: string;
declare var AVMetadataIdentifierID3MetadataLeadPerformer: string;
declare var AVMetadataIdentifierID3MetadataBand: string;
declare var AVMetadataIdentifierID3MetadataConductor: string;
declare var AVMetadataIdentifierID3MetadataModifiedBy: string;
declare var AVMetadataIdentifierID3MetadataPartOfASet: string;
declare var AVMetadataIdentifierID3MetadataProducedNotice: string;
declare var AVMetadataIdentifierID3MetadataPublisher: string;
declare var AVMetadataIdentifierID3MetadataTrackNumber: string;
declare var AVMetadataIdentifierID3MetadataRecordingDates: string;
declare var AVMetadataIdentifierID3MetadataInternetRadioStationName: string;
declare var AVMetadataIdentifierID3MetadataInternetRadioStationOwner: string;
declare var AVMetadataIdentifierID3MetadataSize: string;
declare var AVMetadataIdentifierID3MetadataAlbumSortOrder: string;
declare var AVMetadataIdentifierID3MetadataPerformerSortOrder: string;
declare var AVMetadataIdentifierID3MetadataTitleSortOrder: string;
declare var AVMetadataIdentifierID3MetadataInternationalStandardRecordingCode: string;
declare var AVMetadataIdentifierID3MetadataEncodedWith: string;
declare var AVMetadataIdentifierID3MetadataSetSubtitle: string;
declare var AVMetadataIdentifierID3MetadataYear: string;
declare var AVMetadataIdentifierID3MetadataUserText: string;
declare var AVMetadataIdentifierID3MetadataUniqueFileIdentifier: string;
declare var AVMetadataIdentifierID3MetadataTermsOfUse: string;
declare var AVMetadataIdentifierID3MetadataUnsynchronizedLyric: string;
declare var AVMetadataIdentifierID3MetadataCommercialInformation: string;
declare var AVMetadataIdentifierID3MetadataCopyrightInformation: string;
declare var AVMetadataIdentifierID3MetadataOfficialAudioFileWebpage: string;
declare var AVMetadataIdentifierID3MetadataOfficialArtistWebpage: string;
declare var AVMetadataIdentifierID3MetadataOfficialAudioSourceWebpage: string;
declare var AVMetadataIdentifierID3MetadataOfficialInternetRadioStationHomepage: string;
declare var AVMetadataIdentifierID3MetadataPayment: string;
declare var AVMetadataIdentifierID3MetadataOfficialPublisherWebpage: string;
declare var AVMetadataIdentifierID3MetadataUserURL: string;
declare var AVMetadataIdentifierIcyMetadataStreamTitle: string;
declare var AVMetadataIdentifierIcyMetadataStreamURL: string;
declare var AVMetadataObjectTypeFace: string;
declare var AVMetadataObjectTypeUPCECode: string;
declare var AVMetadataObjectTypeCode39Code: string;
declare var AVMetadataObjectTypeCode39Mod43Code: string;
declare var AVMetadataObjectTypeEAN13Code: string;
declare var AVMetadataObjectTypeEAN8Code: string;
declare var AVMetadataObjectTypeCode93Code: string;
declare var AVMetadataObjectTypeCode128Code: string;
declare var AVMetadataObjectTypePDF417Code: string;
declare var AVMetadataObjectTypeQRCode: string;
declare var AVMetadataObjectTypeAztecCode: string;
declare var AVMetadataObjectTypeInterleaved2of5Code: string;
declare var AVMetadataObjectTypeITF14Code: string;
declare var AVMetadataObjectTypeDataMatrixCode: string;
declare var AVOutputSettingsPreset640x480: string;
declare var AVOutputSettingsPreset960x540: string;
declare var AVOutputSettingsPreset1280x720: string;
declare var AVOutputSettingsPreset1920x1080: string;
declare var AVPlayerItemTimeJumpedNotification: string;
declare var AVPlayerItemDidPlayToEndTimeNotification: string;
declare var AVPlayerItemFailedToPlayToEndTimeNotification: string;
declare var AVPlayerItemPlaybackStalledNotification: string;
declare var AVPlayerItemNewAccessLogEntryNotification: string;
declare var AVPlayerItemNewErrorLogEntryNotification: string;
declare var AVPlayerItemFailedToPlayToEndTimeErrorKey: string;
declare var AVPlayerItemLegibleOutputTextStylingResolutionDefault: string;
declare var AVPlayerItemLegibleOutputTextStylingResolutionSourceAndRulesOnly: string;
declare var AVSampleBufferDisplayLayerFailedToDecodeNotification: string;
declare var AVSampleBufferDisplayLayerFailedToDecodeNotificationErrorKey: string;
declare var AVSpeechUtteranceMinimumSpeechRate: number;
declare var AVSpeechUtteranceMaximumSpeechRate: number;
declare var AVSpeechUtteranceDefaultSpeechRate: number;
declare var AVVideoCodecKey: string;
declare var AVVideoCodecH264: string;
declare var AVVideoCodecJPEG: string;
declare var AVVideoWidthKey: string;
declare var AVVideoHeightKey: string;
declare var AVVideoPixelAspectRatioKey: string;
declare var AVVideoPixelAspectRatioHorizontalSpacingKey: string;
declare var AVVideoPixelAspectRatioVerticalSpacingKey: string;
declare var AVVideoCleanApertureKey: string;
declare var AVVideoCleanApertureWidthKey: string;
declare var AVVideoCleanApertureHeightKey: string;
declare var AVVideoCleanApertureHorizontalOffsetKey: string;
declare var AVVideoCleanApertureVerticalOffsetKey: string;
declare var AVVideoScalingModeKey: string;
declare var AVVideoScalingModeFit: string;
declare var AVVideoScalingModeResize: string;
declare var AVVideoScalingModeResizeAspect: string;
declare var AVVideoScalingModeResizeAspectFill: string;
declare var AVVideoCompressionPropertiesKey: string;
declare var AVVideoAverageBitRateKey: string;
declare var AVVideoQualityKey: string;
declare var AVVideoMaxKeyFrameIntervalKey: string;
declare var AVVideoMaxKeyFrameIntervalDurationKey: string;
declare var AVVideoAllowFrameReorderingKey: string;
declare var AVVideoProfileLevelKey: string;
declare var AVVideoProfileLevelH264Baseline30: string;
declare var AVVideoProfileLevelH264Baseline31: string;
declare var AVVideoProfileLevelH264Baseline41: string;
declare var AVVideoProfileLevelH264BaselineAutoLevel: string;
declare var AVVideoProfileLevelH264Main30: string;
declare var AVVideoProfileLevelH264Main31: string;
declare var AVVideoProfileLevelH264Main32: string;
declare var AVVideoProfileLevelH264Main41: string;
declare var AVVideoProfileLevelH264MainAutoLevel: string;
declare var AVVideoProfileLevelH264High40: string;
declare var AVVideoProfileLevelH264High41: string;
declare var AVVideoProfileLevelH264HighAutoLevel: string;
declare var AVVideoH264EntropyModeKey: string;
declare var AVVideoH264EntropyModeCAVLC: string;
declare var AVVideoH264EntropyModeCABAC: string;
declare var AVVideoExpectedSourceFrameRateKey: string;
declare var AVVideoAverageNonDroppableFrameRateKey: string;
declare var kCMTimeInvalid: CMTime;
declare var kCMTimeIndefinite: CMTime;
declare var kCMTimePositiveInfinity: CMTime;
declare var kCMTimeNegativeInfinity: CMTime;
declare var kCMTimeZero: CMTime;
declare var kCMTimeValueKey: string;
declare var kCMTimeScaleKey: string;
declare var kCMTimeEpochKey: string;
declare var kCMTimeFlagsKey: string;
declare var kCMTimeRangeZero: CMTimeRange;
declare var kCMTimeRangeInvalid: CMTimeRange;
declare var kCMTimeRangeStartKey: string;
declare var kCMTimeRangeDurationKey: string;
declare var kCMFormatDescriptionExtension_OriginalCompressionSettings: string;
declare var kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms: string;
declare var kCMFormatDescriptionExtension_VerbatimSampleDescription: string;
declare var kCMFormatDescriptionExtension_VerbatimISOSampleEntry: string;
declare var kCMFormatDescriptionExtension_FormatName: string;
declare var kCMFormatDescriptionExtension_Depth: string;
declare var kCMFormatDescriptionKey_CleanApertureWidthRational: string;
declare var kCMFormatDescriptionKey_CleanApertureHeightRational: string;
declare var kCMFormatDescriptionKey_CleanApertureHorizontalOffsetRational: string;
declare var kCMFormatDescriptionKey_CleanApertureVerticalOffsetRational: string;
declare var kCMFormatDescriptionColorPrimaries_P22: string;
declare var kCMFormatDescriptionExtension_FullRangeVideo: string;
declare var kCMFormatDescriptionExtension_ICCProfile: string;
declare var kCMFormatDescriptionExtension_BytesPerRow: string;
declare var kCMFormatDescriptionConformsToMPEG2VideoProfile: string;
declare var kCMFormatDescriptionExtension_TemporalQuality: string;
declare var kCMFormatDescriptionExtension_SpatialQuality: string;
declare var kCMFormatDescriptionExtension_Version: string;
declare var kCMFormatDescriptionExtension_RevisionLevel: string;
declare var kCMFormatDescriptionExtension_Vendor: string;
declare var kCMFormatDescriptionVendor_Apple: string;
declare var kCMTextFormatDescriptionExtension_DisplayFlags: string;
declare var kCMTextFormatDescriptionExtension_BackgroundColor: string;
declare var kCMTextFormatDescriptionColor_Red: string;
declare var kCMTextFormatDescriptionColor_Green: string;
declare var kCMTextFormatDescriptionColor_Blue: string;
declare var kCMTextFormatDescriptionColor_Alpha: string;
declare var kCMTextFormatDescriptionExtension_DefaultTextBox: string;
declare var kCMTextFormatDescriptionRect_Top: string;
declare var kCMTextFormatDescriptionRect_Left: string;
declare var kCMTextFormatDescriptionRect_Bottom: string;
declare var kCMTextFormatDescriptionRect_Right: string;
declare var kCMTextFormatDescriptionExtension_DefaultStyle: string;
declare var kCMTextFormatDescriptionStyle_StartChar: string;
declare var kCMTextFormatDescriptionStyle_Font: string;
declare var kCMTextFormatDescriptionStyle_FontFace: string;
declare var kCMTextFormatDescriptionStyle_ForegroundColor: string;
declare var kCMTextFormatDescriptionStyle_FontSize: string;
declare var kCMTextFormatDescriptionExtension_HorizontalJustification: string;
declare var kCMTextFormatDescriptionExtension_VerticalJustification: string;
declare var kCMTextFormatDescriptionStyle_EndChar: string;
declare var kCMTextFormatDescriptionExtension_FontTable: string;
declare var kCMTextFormatDescriptionExtension_TextJustification: string;
declare var kCMTextFormatDescriptionStyle_Height: string;
declare var kCMTextFormatDescriptionStyle_Ascent: string;
declare var kCMTextFormatDescriptionExtension_DefaultFontName: string;
declare var kCMTimeCodeFormatDescriptionExtension_SourceReferenceName: string;
declare var kCMTimeCodeFormatDescriptionKey_Value: string;
declare var kCMTimeCodeFormatDescriptionKey_LangCode: string;
declare var kCMFormatDescriptionExtensionKey_MetadataKeyTable: string;
declare var kCMMetadataFormatDescriptionKey_Namespace: string;
declare var kCMMetadataFormatDescriptionKey_Value: string;
declare var kCMMetadataFormatDescriptionKey_LocalID: string;
declare var kCMMetadataFormatDescriptionKey_DataType: string;
declare var kCMMetadataFormatDescriptionKey_DataTypeNamespace: string;
declare var kCMMetadataFormatDescriptionKey_ConformingDataTypes: string;
declare var kCMMetadataFormatDescriptionKey_LanguageTag: string;
declare var kCMMetadataFormatDescriptionMetadataSpecificationKey_Identifier: string;
declare var kCMMetadataFormatDescriptionMetadataSpecificationKey_DataType: string;
declare var kCMMetadataFormatDescriptionMetadataSpecificationKey_ExtendedLanguageTag: string;
declare var kCMTimingInfoInvalid: CMSampleTimingInfo;
declare var kCMSampleBufferNotification_DataBecameReady: string;
declare var kCMSampleBufferNotification_DataFailed: string;
declare var kCMSampleBufferNotificationParameter_OSStatus: string;
declare var kCMSampleBufferConduitNotification_InhibitOutputUntil: string;
declare var kCMSampleBufferConduitNotificationParameter_ResumeTag: string;
declare var kCMSampleBufferConduitNotification_ResetOutput: string;
declare var kCMSampleBufferConduitNotification_UpcomingOutputPTSRangeChanged: string;
declare var kCMSampleBufferConduitNotificationParameter_UpcomingOutputPTSRangeMayOverlapQueuedOutputPTSRange: string;
declare var kCMSampleBufferConduitNotificationParameter_MinUpcomingOutputPTS: string;
declare var kCMSampleBufferConduitNotificationParameter_MaxUpcomingOutputPTS: string;
declare var kCMSampleBufferConsumerNotification_BufferConsumed: string;
declare var kCMSampleAttachmentKey_NotSync: string;
declare var kCMSampleAttachmentKey_PartialSync: string;
declare var kCMSampleAttachmentKey_HasRedundantCoding: string;
declare var kCMSampleAttachmentKey_IsDependedOnByOthers: string;
declare var kCMSampleAttachmentKey_DependsOnOthers: string;
declare var kCMSampleAttachmentKey_EarlierDisplayTimesAllowed: string;
declare var kCMSampleAttachmentKey_DisplayImmediately: string;
declare var kCMSampleAttachmentKey_DoNotDisplay: string;
declare var kCMSampleBufferAttachmentKey_ResetDecoderBeforeDecoding: string;
declare var kCMSampleBufferAttachmentKey_DrainAfterDecoding: string;
declare var kCMSampleBufferAttachmentKey_PostNotificationWhenConsumed: string;
declare var kCMSampleBufferAttachmentKey_ResumeOutput: string;
declare var kCMSampleBufferAttachmentKey_TransitionID: string;
declare var kCMSampleBufferAttachmentKey_TrimDurationAtStart: string;
declare var kCMSampleBufferAttachmentKey_TrimDurationAtEnd: string;
declare var kCMSampleBufferAttachmentKey_SpeedMultiplier: string;
declare var kCMSampleBufferAttachmentKey_Reverse: string;
declare var kCMSampleBufferAttachmentKey_FillDiscontinuitiesWithSilence: string;
declare var kCMSampleBufferAttachmentKey_EmptyMedia: string;
declare var kCMSampleBufferAttachmentKey_PermanentEmptyMedia: string;
declare var kCMSampleBufferAttachmentKey_DisplayEmptyMediaImmediately: string;
declare var kCMSampleBufferAttachmentKey_EndsPreviousSampleDuration: string;
declare var kCMSampleBufferAttachmentKey_SampleReferenceURL: string;
declare var kCMSampleBufferAttachmentKey_SampleReferenceByteOffset: string;
declare var kCMSampleBufferAttachmentKey_GradualDecoderRefresh: string;
declare var kCMSampleBufferAttachmentKey_DroppedFrameReason: string;
declare var kCMSampleBufferDroppedFrameReason_FrameWasLate: string;
declare var kCMSampleBufferDroppedFrameReason_OutOfBuffers: string;
declare var kCMSampleBufferDroppedFrameReason_Discontinuity: string;
declare var kCMSampleBufferAttachmentKey_DroppedFrameReasonInfo: string;
declare var kCMSampleBufferDroppedFrameReasonInfo_CameraModeSwitch: string;
declare var kCMSampleBufferAttachmentKey_ForceKeyFrame: string;
declare var kCMTimebaseNotification_EffectiveRateChanged: string;
declare var kCMTimebaseNotification_TimeJumped: string;
declare var kCMTimebaseNotificationKey_EventTime: string;
declare var kCMImageDescriptionFlavor_QuickTimeMovie: string;
declare var kCMImageDescriptionFlavor_ISOFamily: string;
declare var kCMImageDescriptionFlavor_3GPFamily: string;
declare var kCMSoundDescriptionFlavor_QuickTimeMovie: string;
declare var kCMSoundDescriptionFlavor_QuickTimeMovieV2: string;
declare var kCMSoundDescriptionFlavor_ISOFamily: string;
declare var kCMSoundDescriptionFlavor_3GPFamily: string;
declare var kCMMemoryPoolOption_AgeOutPeriod: string;
declare var kCMTextMarkupAttribute_ForegroundColorARGB: string;
declare var kCMTextMarkupAttribute_BackgroundColorARGB: string;
declare var kCMTextMarkupAttribute_CharacterBackgroundColorARGB: string;
declare var kCMTextMarkupAttribute_BoldStyle: string;
declare var kCMTextMarkupAttribute_ItalicStyle: string;
declare var kCMTextMarkupAttribute_UnderlineStyle: string;
declare var kCMTextMarkupAttribute_FontFamilyName: string;
declare var kCMTextMarkupAttribute_GenericFontFamilyName: string;
declare var kCMTextMarkupGenericFontName_Default: string;
declare var kCMTextMarkupGenericFontName_Serif: string;
declare var kCMTextMarkupGenericFontName_SansSerif: string;
declare var kCMTextMarkupGenericFontName_Monospace: string;
declare var kCMTextMarkupGenericFontName_ProportionalSerif: string;
declare var kCMTextMarkupGenericFontName_ProportionalSansSerif: string;
declare var kCMTextMarkupGenericFontName_MonospaceSerif: string;
declare var kCMTextMarkupGenericFontName_MonospaceSansSerif: string;
declare var kCMTextMarkupGenericFontName_Casual: string;
declare var kCMTextMarkupGenericFontName_Cursive: string;
declare var kCMTextMarkupGenericFontName_Fantasy: string;
declare var kCMTextMarkupGenericFontName_SmallCapital: string;
declare var kCMTextMarkupAttribute_BaseFontSizePercentageRelativeToVideoHeight: string;
declare var kCMTextMarkupAttribute_RelativeFontSize: string;
declare var kCMTextMarkupAttribute_VerticalLayout: string;
declare var kCMTextVerticalLayout_LeftToRight: string;
declare var kCMTextVerticalLayout_RightToLeft: string;
declare var kCMTextMarkupAttribute_Alignment: string;
declare var kCMTextMarkupAlignmentType_Start: string;
declare var kCMTextMarkupAlignmentType_Middle: string;
declare var kCMTextMarkupAlignmentType_End: string;
declare var kCMTextMarkupAlignmentType_Left: string;
declare var kCMTextMarkupAlignmentType_Right: string;
declare var kCMTextMarkupAttribute_TextPositionPercentageRelativeToWritingDirection: string;
declare var kCMTextMarkupAttribute_OrthogonalLinePositionPercentageRelativeToWritingDirection: string;
declare var kCMTextMarkupAttribute_WritingDirectionSizePercentage: string;
declare var kCMTextMarkupAttribute_CharacterEdgeStyle: string;
declare var kCMTextMarkupCharacterEdgeStyle_None: string;
declare var kCMTextMarkupCharacterEdgeStyle_Raised: string;
declare var kCMTextMarkupCharacterEdgeStyle_Depressed: string;
declare var kCMTextMarkupCharacterEdgeStyle_Uniform: string;
declare var kCMTextMarkupCharacterEdgeStyle_DropShadow: string;
declare var kCMMetadataKeySpace_QuickTimeUserData: string;
declare var kCMMetadataKeySpace_ISOUserData: string;
declare var kCMMetadataKeySpace_QuickTimeMetadata: string;
declare var kCMMetadataKeySpace_iTunes: string;
declare var kCMMetadataKeySpace_ID3: string;
declare var kCMMetadataKeySpace_Icy: string;
declare var kCMMetadataIdentifier_QuickTimeMetadataLocation_ISO6709: string;
declare var kCMMetadataIdentifier_QuickTimeMetadataDirection_Facing: string;
declare var kCMMetadataIdentifier_QuickTimeMetadataPreferredAffineTransform: string;
declare var kCMMetadataBaseDataType_RawData: string;
declare var kCMMetadataBaseDataType_UTF8: string;
declare var kCMMetadataBaseDataType_UTF16: string;
declare var kCMMetadataBaseDataType_GIF: string;
declare var kCMMetadataBaseDataType_JPEG: string;
declare var kCMMetadataBaseDataType_PNG: string;
declare var kCMMetadataBaseDataType_BMP: string;
declare var kCMMetadataBaseDataType_Float32: string;
declare var kCMMetadataBaseDataType_Float64: string;
declare var kCMMetadataBaseDataType_SInt8: string;
declare var kCMMetadataBaseDataType_SInt16: string;
declare var kCMMetadataBaseDataType_SInt32: string;
declare var kCMMetadataBaseDataType_SInt64: string;
declare var kCMMetadataBaseDataType_UInt8: string;
declare var kCMMetadataBaseDataType_UInt16: string;
declare var kCMMetadataBaseDataType_UInt32: string;
declare var kCMMetadataBaseDataType_UInt64: string;
declare var kCMMetadataBaseDataType_PointF32: string;
declare var kCMMetadataBaseDataType_DimensionsF32: string;
declare var kCMMetadataBaseDataType_RectF32: string;
declare var kCMMetadataBaseDataType_AffineTransformF64: string;
declare var kCMMetadataDataType_QuickTimeMetadataLocation_ISO6709: string;
declare var kCMMetadataDataType_QuickTimeMetadataDirection: string;
declare var CKOwnerDefaultName: string;
declare var CKErrorDomain: string;
declare var CKPartialErrorsByItemIDKey: string;
declare var CKRecordChangedErrorAncestorRecordKey: string;
declare var CKRecordChangedErrorServerRecordKey: string;
declare var CKRecordChangedErrorClientRecordKey: string;
declare var CKErrorRetryAfterKey: string;
declare var CKRecordZoneDefaultName: string;
declare var CKRecordTypeUserRecord: string;
declare var CKQueryOperationMaximumResults: number;
declare var kCLDistanceFilterNone: number;
declare var kCLLocationAccuracyBestForNavigation: number;
declare var kCLLocationAccuracyBest: number;
declare var kCLLocationAccuracyNearestTenMeters: number;
declare var kCLLocationAccuracyHundredMeters: number;
declare var kCLLocationAccuracyKilometer: number;
declare var kCLLocationAccuracyThreeKilometers: number;
declare var CLLocationDistanceMax: number;
declare var CLTimeIntervalMax: number;
declare var kCLLocationCoordinate2DInvalid: CLLocationCoordinate2D;
declare var kCLErrorDomain: string;
declare var kCLErrorUserInfoAlternateRegionKey: string;
declare var kCLHeadingFilterNone: number;
declare var CBAdvertisementDataLocalNameKey: string;
declare var CBAdvertisementDataTxPowerLevelKey: string;
declare var CBAdvertisementDataServiceUUIDsKey: string;
declare var CBAdvertisementDataServiceDataKey: string;
declare var CBAdvertisementDataManufacturerDataKey: string;
declare var CBAdvertisementDataOverflowServiceUUIDsKey: string;
declare var CBAdvertisementDataIsConnectable: string;
declare var CBAdvertisementDataSolicitedServiceUUIDsKey: string;
declare var CBCentralManagerOptionShowPowerAlertKey: string;
declare var CBCentralManagerOptionRestoreIdentifierKey: string;
declare var CBCentralManagerScanOptionAllowDuplicatesKey: string;
declare var CBCentralManagerScanOptionSolicitedServiceUUIDsKey: string;
declare var CBConnectPeripheralOptionNotifyOnConnectionKey: string;
declare var CBConnectPeripheralOptionNotifyOnDisconnectionKey: string;
declare var CBConnectPeripheralOptionNotifyOnNotificationKey: string;
declare var CBCentralManagerRestoredStatePeripheralsKey: string;
declare var CBCentralManagerRestoredStateScanServicesKey: string;
declare var CBCentralManagerRestoredStateScanOptionsKey: string;
declare var CBErrorDomain: string;
declare var CBATTErrorDomain: string;
declare var CBPeripheralManagerOptionShowPowerAlertKey: string;
declare var CBPeripheralManagerOptionRestoreIdentifierKey: string;
declare var CBPeripheralManagerRestoredStateServicesKey: string;
declare var CBPeripheralManagerRestoredStateAdvertisementDataKey: string;
declare var CBUUIDCharacteristicExtendedPropertiesString: string;
declare var CBUUIDCharacteristicUserDescriptionString: string;
declare var CBUUIDClientCharacteristicConfigurationString: string;
declare var CBUUIDServerCharacteristicConfigurationString: string;
declare var CBUUIDCharacteristicFormatString: string;
declare var CBUUIDCharacteristicAggregateFormatString: string;
declare var CBUUIDGenericAccessProfileString: string;
declare var CBUUIDGenericAttributeProfileString: string;
declare var CBUUIDDeviceNameString: string;
declare var CBUUIDAppearanceString: string;
declare var CBUUIDPeripheralPrivacyFlagString: string;
declare var CBUUIDReconnectionAddressString: string;
declare var CBUUIDPeripheralPreferredConnectionParametersString: string;
declare var CBUUIDServiceChangedString: string;
declare var CMErrorDomain: string;
declare var CTCallStateDialing: string;
declare var CTCallStateIncoming: string;
declare var CTCallStateConnected: string;
declare var CTCallStateDisconnected: string;
declare var CTSubscriberTokenRefreshed: string;
declare var CTRadioAccessTechnologyDidChangeNotification: string;
declare var CTRadioAccessTechnologyGPRS: string;
declare var CTRadioAccessTechnologyEdge: string;
declare var CTRadioAccessTechnologyWCDMA: string;
declare var CTRadioAccessTechnologyHSDPA: string;
declare var CTRadioAccessTechnologyHSUPA: string;
declare var CTRadioAccessTechnologyCDMA1x: string;
declare var CTRadioAccessTechnologyCDMAEVDORev0: string;
declare var CTRadioAccessTechnologyCDMAEVDORevA: string;
declare var CTRadioAccessTechnologyCDMAEVDORevB: string;
declare var CTRadioAccessTechnologyeHRPD: string;
declare var CTRadioAccessTechnologyLTE: string;
declare var EKEventStoreChangedNotification: string;
declare var EKErrorDomain: string;
declare var GKErrorDomain: string;
declare var GKPlayerDidChangeNotificationName: string;
declare var GKTurnTimeoutDefault: number;
declare var GKTurnTimeoutNone: number;
declare var GKExchangeTimeoutDefault: number;
declare var GKExchangeTimeoutNone: number;
declare var GKPlayerAuthenticationDidChangeNotificationName: string;
declare var GKSessionErrorDomain: string;
declare var GKVoiceChatServiceErrorDomain: string;
declare var GLKTextureLoaderApplyPremultiplication: string;
declare var GLKTextureLoaderGenerateMipmaps: string;
declare var GLKTextureLoaderOriginBottomLeft: string;
declare var GLKTextureLoaderGrayscaleAsAlpha: string;
declare var GLKTextureLoaderSRGB: string;
declare var GLKTextureLoaderErrorDomain: string;
declare var GLKTextureLoaderErrorKey: string;
declare var GLKTextureLoaderGLErrorKey: string;
declare var HKErrorDomain: string;
declare var HKPredicateKeyPathUUID: string;
declare var HKPredicateKeyPathSource: string;
declare var HKPredicateKeyPathMetadata: string;
declare var HKPredicateKeyPathCorrelation: string;
declare var HKPredicateKeyPathWorkout: string;
declare var HKSampleSortIdentifierStartDate: string;
declare var HKSampleSortIdentifierEndDate: string;
declare var HKPredicateKeyPathStartDate: string;
declare var HKPredicateKeyPathEndDate: string;
declare var HKPredicateKeyPathWorkoutDuration: string;
declare var HKPredicateKeyPathWorkoutTotalDistance: string;
declare var HKPredicateKeyPathWorkoutTotalEnergyBurned: string;
declare var HKPredicateKeyPathWorkoutType: string;
declare var HKWorkoutSortIdentifierDuration: string;
declare var HKWorkoutSortIdentifierTotalDistance: string;
declare var HKWorkoutSortIdentifierTotalEnergyBurned: string;
declare var HKPredicateKeyPathCategoryValue: string;
declare var HKMetadataKeyDeviceSerialNumber: string;
declare var HKMetadataKeyBodyTemperatureSensorLocation: string;
declare var HKMetadataKeyHeartRateSensorLocation: string;
declare var HKMetadataKeyFoodType: string;
declare var HKMetadataKeyUDIDeviceIdentifier: string;
declare var HKMetadataKeyUDIProductionIdentifier: string;
declare var HKMetadataKeyDigitalSignature: string;
declare var HKMetadataKeyExternalUUID: string;
declare var HKMetadataKeyTimeZone: string;
declare var HKMetadataKeyDeviceName: string;
declare var HKMetadataKeyDeviceManufacturerName: string;
declare var HKMetadataKeyWasTakenInLab: string;
declare var HKMetadataKeyReferenceRangeLowerLimit: string;
declare var HKMetadataKeyReferenceRangeUpperLimit: string;
declare var HKMetadataKeyWasUserEntered: string;
declare var HKMetadataKeyWorkoutBrandName: string;
declare var HKMetadataKeyGroupFitness: string;
declare var HKMetadataKeyIndoorWorkout: string;
declare var HKMetadataKeyCoachedWorkout: string;
declare var HKQuantityTypeIdentifierBodyMassIndex: string;
declare var HKQuantityTypeIdentifierBodyFatPercentage: string;
declare var HKQuantityTypeIdentifierHeight: string;
declare var HKQuantityTypeIdentifierBodyMass: string;
declare var HKQuantityTypeIdentifierLeanBodyMass: string;
declare var HKQuantityTypeIdentifierStepCount: string;
declare var HKQuantityTypeIdentifierDistanceWalkingRunning: string;
declare var HKQuantityTypeIdentifierDistanceCycling: string;
declare var HKQuantityTypeIdentifierBasalEnergyBurned: string;
declare var HKQuantityTypeIdentifierActiveEnergyBurned: string;
declare var HKQuantityTypeIdentifierFlightsClimbed: string;
declare var HKQuantityTypeIdentifierNikeFuel: string;
declare var HKQuantityTypeIdentifierHeartRate: string;
declare var HKQuantityTypeIdentifierBodyTemperature: string;
declare var HKQuantityTypeIdentifierBloodPressureSystolic: string;
declare var HKQuantityTypeIdentifierBloodPressureDiastolic: string;
declare var HKQuantityTypeIdentifierRespiratoryRate: string;
declare var HKQuantityTypeIdentifierOxygenSaturation: string;
declare var HKQuantityTypeIdentifierPeripheralPerfusionIndex: string;
declare var HKQuantityTypeIdentifierBloodGlucose: string;
declare var HKQuantityTypeIdentifierNumberOfTimesFallen: string;
declare var HKQuantityTypeIdentifierElectrodermalActivity: string;
declare var HKQuantityTypeIdentifierInhalerUsage: string;
declare var HKQuantityTypeIdentifierBloodAlcoholContent: string;
declare var HKQuantityTypeIdentifierForcedVitalCapacity: string;
declare var HKQuantityTypeIdentifierForcedExpiratoryVolume1: string;
declare var HKQuantityTypeIdentifierPeakExpiratoryFlowRate: string;
declare var HKQuantityTypeIdentifierDietaryFatTotal: string;
declare var HKQuantityTypeIdentifierDietaryFatPolyunsaturated: string;
declare var HKQuantityTypeIdentifierDietaryFatMonounsaturated: string;
declare var HKQuantityTypeIdentifierDietaryFatSaturated: string;
declare var HKQuantityTypeIdentifierDietaryCholesterol: string;
declare var HKQuantityTypeIdentifierDietarySodium: string;
declare var HKQuantityTypeIdentifierDietaryCarbohydrates: string;
declare var HKQuantityTypeIdentifierDietaryFiber: string;
declare var HKQuantityTypeIdentifierDietarySugar: string;
declare var HKQuantityTypeIdentifierDietaryEnergyConsumed: string;
declare var HKQuantityTypeIdentifierDietaryProtein: string;
declare var HKQuantityTypeIdentifierDietaryVitaminA: string;
declare var HKQuantityTypeIdentifierDietaryVitaminB6: string;
declare var HKQuantityTypeIdentifierDietaryVitaminB12: string;
declare var HKQuantityTypeIdentifierDietaryVitaminC: string;
declare var HKQuantityTypeIdentifierDietaryVitaminD: string;
declare var HKQuantityTypeIdentifierDietaryVitaminE: string;
declare var HKQuantityTypeIdentifierDietaryVitaminK: string;
declare var HKQuantityTypeIdentifierDietaryCalcium: string;
declare var HKQuantityTypeIdentifierDietaryIron: string;
declare var HKQuantityTypeIdentifierDietaryThiamin: string;
declare var HKQuantityTypeIdentifierDietaryRiboflavin: string;
declare var HKQuantityTypeIdentifierDietaryNiacin: string;
declare var HKQuantityTypeIdentifierDietaryFolate: string;
declare var HKQuantityTypeIdentifierDietaryBiotin: string;
declare var HKQuantityTypeIdentifierDietaryPantothenicAcid: string;
declare var HKQuantityTypeIdentifierDietaryPhosphorus: string;
declare var HKQuantityTypeIdentifierDietaryIodine: string;
declare var HKQuantityTypeIdentifierDietaryMagnesium: string;
declare var HKQuantityTypeIdentifierDietaryZinc: string;
declare var HKQuantityTypeIdentifierDietarySelenium: string;
declare var HKQuantityTypeIdentifierDietaryCopper: string;
declare var HKQuantityTypeIdentifierDietaryManganese: string;
declare var HKQuantityTypeIdentifierDietaryChromium: string;
declare var HKQuantityTypeIdentifierDietaryMolybdenum: string;
declare var HKQuantityTypeIdentifierDietaryChloride: string;
declare var HKQuantityTypeIdentifierDietaryPotassium: string;
declare var HKQuantityTypeIdentifierDietaryCaffeine: string;
declare var HKCategoryTypeIdentifierSleepAnalysis: string;
declare var HKCharacteristicTypeIdentifierBiologicalSex: string;
declare var HKCharacteristicTypeIdentifierBloodType: string;
declare var HKCharacteristicTypeIdentifierDateOfBirth: string;
declare var HKCorrelationTypeIdentifierBloodPressure: string;
declare var HKCorrelationTypeIdentifierFood: string;
declare var HKWorkoutTypeIdentifier: string;
declare var HKPredicateKeyPathQuantity: string;
declare var HMUserFailedAccessoriesKey: string;
declare var HMServiceTypeLightbulb: string;
declare var HMServiceTypeSwitch: string;
declare var HMServiceTypeThermostat: string;
declare var HMServiceTypeGarageDoorOpener: string;
declare var HMServiceTypeAccessoryInformation: string;
declare var HMServiceTypeFan: string;
declare var HMServiceTypeOutlet: string;
declare var HMServiceTypeLockMechanism: string;
declare var HMServiceTypeLockManagement: string;
declare var HMCharacteristicPropertySupportsEventNotification: string;
declare var HMCharacteristicPropertyReadable: string;
declare var HMCharacteristicPropertyWritable: string;
declare var HMCharacteristicTypePowerState: string;
declare var HMCharacteristicTypeHue: string;
declare var HMCharacteristicTypeSaturation: string;
declare var HMCharacteristicTypeBrightness: string;
declare var HMCharacteristicTypeTemperatureUnits: string;
declare var HMCharacteristicTypeCurrentTemperature: string;
declare var HMCharacteristicTypeTargetTemperature: string;
declare var HMCharacteristicTypeCurrentHeatingCooling: string;
declare var HMCharacteristicTypeTargetHeatingCooling: string;
declare var HMCharacteristicTypeCoolingThreshold: string;
declare var HMCharacteristicTypeHeatingThreshold: string;
declare var HMCharacteristicTypeCurrentRelativeHumidity: string;
declare var HMCharacteristicTypeTargetRelativeHumidity: string;
declare var HMCharacteristicTypeCurrentDoorState: string;
declare var HMCharacteristicTypeTargetDoorState: string;
declare var HMCharacteristicTypeObstructionDetected: string;
declare var HMCharacteristicTypeName: string;
declare var HMCharacteristicTypeManufacturer: string;
declare var HMCharacteristicTypeModel: string;
declare var HMCharacteristicTypeSerialNumber: string;
declare var HMCharacteristicTypeIdentify: string;
declare var HMCharacteristicTypeRotationDirection: string;
declare var HMCharacteristicTypeRotationSpeed: string;
declare var HMCharacteristicTypeOutletInUse: string;
declare var HMCharacteristicTypeVersion: string;
declare var HMCharacteristicTypeLogs: string;
declare var HMCharacteristicTypeAudioFeedback: string;
declare var HMCharacteristicTypeAdminOnlyAccess: string;
declare var HMCharacteristicTypeMotionDetected: string;
declare var HMCharacteristicTypeCurrentLockMechanismState: string;
declare var HMCharacteristicTypeTargetLockMechanismState: string;
declare var HMCharacteristicTypeLockMechanismLastKnownAction: string;
declare var HMCharacteristicTypeLockManagementControlPoint: string;
declare var HMCharacteristicTypeLockManagementAutoSecureTimeout: string;
declare var HMCharacteristicMetadataFormatBool: string;
declare var HMCharacteristicMetadataFormatInt: string;
declare var HMCharacteristicMetadataFormatFloat: string;
declare var HMCharacteristicMetadataFormatString: string;
declare var HMCharacteristicMetadataFormatArray: string;
declare var HMCharacteristicMetadataFormatDictionary: string;
declare var HMCharacteristicMetadataFormatUInt8: string;
declare var HMCharacteristicMetadataFormatUInt16: string;
declare var HMCharacteristicMetadataFormatUInt32: string;
declare var HMCharacteristicMetadataFormatUInt64: string;
declare var HMCharacteristicMetadataFormatData: string;
declare var HMCharacteristicMetadataFormatTLV8: string;
declare var HMCharacteristicMetadataUnitsCelsius: string;
declare var HMCharacteristicMetadataUnitsFahrenheit: string;
declare var HMCharacteristicMetadataUnitsPercentage: string;
declare var HMCharacteristicMetadataUnitsArcDegree: string;
declare var HMErrorDomain: string;
declare var MPMediaEntityPropertyPersistentID: string;
declare var MPMediaItemPropertyPersistentID: string;
declare var MPMediaItemPropertyMediaType: string;
declare var MPMediaItemPropertyTitle: string;
declare var MPMediaItemPropertyAlbumTitle: string;
declare var MPMediaItemPropertyAlbumPersistentID: string;
declare var MPMediaItemPropertyArtist: string;
declare var MPMediaItemPropertyArtistPersistentID: string;
declare var MPMediaItemPropertyAlbumArtist: string;
declare var MPMediaItemPropertyAlbumArtistPersistentID: string;
declare var MPMediaItemPropertyGenre: string;
declare var MPMediaItemPropertyGenrePersistentID: string;
declare var MPMediaItemPropertyComposer: string;
declare var MPMediaItemPropertyComposerPersistentID: string;
declare var MPMediaItemPropertyPlaybackDuration: string;
declare var MPMediaItemPropertyAlbumTrackNumber: string;
declare var MPMediaItemPropertyAlbumTrackCount: string;
declare var MPMediaItemPropertyDiscNumber: string;
declare var MPMediaItemPropertyDiscCount: string;
declare var MPMediaItemPropertyArtwork: string;
declare var MPMediaItemPropertyLyrics: string;
declare var MPMediaItemPropertyIsCompilation: string;
declare var MPMediaItemPropertyReleaseDate: string;
declare var MPMediaItemPropertyBeatsPerMinute: string;
declare var MPMediaItemPropertyComments: string;
declare var MPMediaItemPropertyAssetURL: string;
declare var MPMediaItemPropertyIsCloudItem: string;
declare var MPMediaItemPropertyPodcastTitle: string;
declare var MPMediaItemPropertyPodcastPersistentID: string;
declare var MPMediaItemPropertyPlayCount: string;
declare var MPMediaItemPropertySkipCount: string;
declare var MPMediaItemPropertyRating: string;
declare var MPMediaItemPropertyLastPlayedDate: string;
declare var MPMediaItemPropertyUserGrouping: string;
declare var MPMediaItemPropertyBookmarkTime: string;
declare var MPMediaLibraryDidChangeNotification: string;
declare var MPMediaPlaylistPropertyPersistentID: string;
declare var MPMediaPlaylistPropertyName: string;
declare var MPMediaPlaylistPropertyPlaylistAttributes: string;
declare var MPMediaPlaylistPropertySeedItems: string;
declare var MPMediaPlaybackIsPreparedToPlayDidChangeNotification: string;
declare var MPMoviePlayerScalingModeDidChangeNotification: string;
declare var MPMoviePlayerPlaybackDidFinishNotification: string;
declare var MPMoviePlayerPlaybackDidFinishReasonUserInfoKey: string;
declare var MPMoviePlayerPlaybackStateDidChangeNotification: string;
declare var MPMoviePlayerLoadStateDidChangeNotification: string;
declare var MPMoviePlayerNowPlayingMovieDidChangeNotification: string;
declare var MPMoviePlayerWillEnterFullscreenNotification: string;
declare var MPMoviePlayerDidEnterFullscreenNotification: string;
declare var MPMoviePlayerWillExitFullscreenNotification: string;
declare var MPMoviePlayerDidExitFullscreenNotification: string;
declare var MPMoviePlayerFullscreenAnimationDurationUserInfoKey: string;
declare var MPMoviePlayerFullscreenAnimationCurveUserInfoKey: string;
declare var MPMoviePlayerIsAirPlayVideoActiveDidChangeNotification: string;
declare var MPMoviePlayerReadyForDisplayDidChangeNotification: string;
declare var MPMovieMediaTypesAvailableNotification: string;
declare var MPMovieSourceTypeAvailableNotification: string;
declare var MPMovieDurationAvailableNotification: string;
declare var MPMovieNaturalSizeAvailableNotification: string;
declare var MPMoviePlayerThumbnailImageRequestDidFinishNotification: string;
declare var MPMoviePlayerThumbnailImageKey: string;
declare var MPMoviePlayerThumbnailTimeKey: string;
declare var MPMoviePlayerThumbnailErrorKey: string;
declare var MPMoviePlayerTimedMetadataUpdatedNotification: string;
declare var MPMoviePlayerTimedMetadataUserInfoKey: string;
declare var MPMoviePlayerTimedMetadataKeyName: string;
declare var MPMoviePlayerTimedMetadataKeyInfo: string;
declare var MPMoviePlayerTimedMetadataKeyMIMEType: string;
declare var MPMoviePlayerTimedMetadataKeyDataType: string;
declare var MPMoviePlayerTimedMetadataKeyLanguageCode: string;
declare var MPMusicPlayerControllerPlaybackStateDidChangeNotification: string;
declare var MPMusicPlayerControllerNowPlayingItemDidChangeNotification: string;
declare var MPMusicPlayerControllerVolumeDidChangeNotification: string;
declare var MPNowPlayingInfoPropertyElapsedPlaybackTime: string;
declare var MPNowPlayingInfoPropertyPlaybackRate: string;
declare var MPNowPlayingInfoPropertyDefaultPlaybackRate: string;
declare var MPNowPlayingInfoPropertyPlaybackQueueIndex: string;
declare var MPNowPlayingInfoPropertyPlaybackQueueCount: string;
declare var MPNowPlayingInfoPropertyChapterNumber: string;
declare var MPNowPlayingInfoPropertyChapterCount: string;
declare var MPVolumeViewWirelessRoutesAvailableDidChangeNotification: string;
declare var MPVolumeViewWirelessRouteActiveDidChangeNotification: string;
declare var kCGImageMetadataNamespaceExif: string;
declare var kCGImageMetadataNamespaceExifAux: string;
declare var kCGImageMetadataNamespaceExifEX: string;
declare var kCGImageMetadataNamespaceDublinCore: string;
declare var kCGImageMetadataNamespaceIPTCCore: string;
declare var kCGImageMetadataNamespacePhotoshop: string;
declare var kCGImageMetadataNamespaceTIFF: string;
declare var kCGImageMetadataNamespaceXMPBasic: string;
declare var kCGImageMetadataNamespaceXMPRights: string;
declare var kCGImageMetadataPrefixExif: string;
declare var kCGImageMetadataPrefixExifAux: string;
declare var kCGImageMetadataPrefixExifEX: string;
declare var kCGImageMetadataPrefixDublinCore: string;
declare var kCGImageMetadataPrefixIPTCCore: string;
declare var kCGImageMetadataPrefixPhotoshop: string;
declare var kCGImageMetadataPrefixTIFF: string;
declare var kCGImageMetadataPrefixXMPBasic: string;
declare var kCGImageMetadataPrefixXMPRights: string;
declare var kCGImageMetadataEnumerateRecursively: string;
declare var kCFErrorDomainCGImageMetadata: string;
declare var kCGImageSourceTypeIdentifierHint: string;
declare var kCGImageSourceShouldCache: string;
declare var kCGImageSourceShouldCacheImmediately: string;
declare var kCGImageSourceShouldAllowFloat: string;
declare var kCGImageSourceCreateThumbnailFromImageIfAbsent: string;
declare var kCGImageSourceCreateThumbnailFromImageAlways: string;
declare var kCGImageSourceThumbnailMaxPixelSize: string;
declare var kCGImageSourceCreateThumbnailWithTransform: string;
declare var kCGImageDestinationLossyCompressionQuality: string;
declare var kCGImageDestinationBackgroundColor: string;
declare var kCGImageDestinationImageMaxPixelSize: string;
declare var kCGImageDestinationEmbedThumbnail: string;
declare var kCGImageDestinationMetadata: string;
declare var kCGImageDestinationMergeMetadata: string;
declare var kCGImageMetadataShouldExcludeXMP: string;
declare var kCGImageMetadataShouldExcludeGPS: string;
declare var kCGImageDestinationDateTime: string;
declare var kCGImageDestinationOrientation: string;
declare var kCGImagePropertyTIFFDictionary: string;
declare var kCGImagePropertyGIFDictionary: string;
declare var kCGImagePropertyJFIFDictionary: string;
declare var kCGImagePropertyExifDictionary: string;
declare var kCGImagePropertyPNGDictionary: string;
declare var kCGImagePropertyIPTCDictionary: string;
declare var kCGImagePropertyGPSDictionary: string;
declare var kCGImagePropertyRawDictionary: string;
declare var kCGImagePropertyCIFFDictionary: string;
declare var kCGImagePropertyMakerCanonDictionary: string;
declare var kCGImagePropertyMakerNikonDictionary: string;
declare var kCGImagePropertyMakerMinoltaDictionary: string;
declare var kCGImagePropertyMakerFujiDictionary: string;
declare var kCGImagePropertyMakerOlympusDictionary: string;
declare var kCGImagePropertyMakerPentaxDictionary: string;
declare var kCGImageProperty8BIMDictionary: string;
declare var kCGImagePropertyDNGDictionary: string;
declare var kCGImagePropertyExifAuxDictionary: string;
declare var kCGImagePropertyMakerAppleDictionary: string;
declare var kCGImagePropertyFileSize: string;
declare var kCGImagePropertyPixelHeight: string;
declare var kCGImagePropertyPixelWidth: string;
declare var kCGImagePropertyDPIHeight: string;
declare var kCGImagePropertyDPIWidth: string;
declare var kCGImagePropertyDepth: string;
declare var kCGImagePropertyOrientation: string;
declare var kCGImagePropertyIsFloat: string;
declare var kCGImagePropertyIsIndexed: string;
declare var kCGImagePropertyHasAlpha: string;
declare var kCGImagePropertyColorModel: string;
declare var kCGImagePropertyProfileName: string;
declare var kCGImagePropertyColorModelRGB: string;
declare var kCGImagePropertyColorModelGray: string;
declare var kCGImagePropertyColorModelCMYK: string;
declare var kCGImagePropertyColorModelLab: string;
declare var kCGImagePropertyTIFFCompression: string;
declare var kCGImagePropertyTIFFPhotometricInterpretation: string;
declare var kCGImagePropertyTIFFDocumentName: string;
declare var kCGImagePropertyTIFFImageDescription: string;
declare var kCGImagePropertyTIFFMake: string;
declare var kCGImagePropertyTIFFModel: string;
declare var kCGImagePropertyTIFFOrientation: string;
declare var kCGImagePropertyTIFFXResolution: string;
declare var kCGImagePropertyTIFFYResolution: string;
declare var kCGImagePropertyTIFFResolutionUnit: string;
declare var kCGImagePropertyTIFFSoftware: string;
declare var kCGImagePropertyTIFFTransferFunction: string;
declare var kCGImagePropertyTIFFDateTime: string;
declare var kCGImagePropertyTIFFArtist: string;
declare var kCGImagePropertyTIFFHostComputer: string;
declare var kCGImagePropertyTIFFCopyright: string;
declare var kCGImagePropertyTIFFWhitePoint: string;
declare var kCGImagePropertyTIFFPrimaryChromaticities: string;
declare var kCGImagePropertyJFIFVersion: string;
declare var kCGImagePropertyJFIFXDensity: string;
declare var kCGImagePropertyJFIFYDensity: string;
declare var kCGImagePropertyJFIFDensityUnit: string;
declare var kCGImagePropertyJFIFIsProgressive: string;
declare var kCGImagePropertyExifExposureTime: string;
declare var kCGImagePropertyExifFNumber: string;
declare var kCGImagePropertyExifExposureProgram: string;
declare var kCGImagePropertyExifSpectralSensitivity: string;
declare var kCGImagePropertyExifISOSpeedRatings: string;
declare var kCGImagePropertyExifOECF: string;
declare var kCGImagePropertyExifSensitivityType: string;
declare var kCGImagePropertyExifStandardOutputSensitivity: string;
declare var kCGImagePropertyExifRecommendedExposureIndex: string;
declare var kCGImagePropertyExifISOSpeed: string;
declare var kCGImagePropertyExifISOSpeedLatitudeyyy: string;
declare var kCGImagePropertyExifISOSpeedLatitudezzz: string;
declare var kCGImagePropertyExifVersion: string;
declare var kCGImagePropertyExifDateTimeOriginal: string;
declare var kCGImagePropertyExifDateTimeDigitized: string;
declare var kCGImagePropertyExifComponentsConfiguration: string;
declare var kCGImagePropertyExifCompressedBitsPerPixel: string;
declare var kCGImagePropertyExifShutterSpeedValue: string;
declare var kCGImagePropertyExifApertureValue: string;
declare var kCGImagePropertyExifBrightnessValue: string;
declare var kCGImagePropertyExifExposureBiasValue: string;
declare var kCGImagePropertyExifMaxApertureValue: string;
declare var kCGImagePropertyExifSubjectDistance: string;
declare var kCGImagePropertyExifMeteringMode: string;
declare var kCGImagePropertyExifLightSource: string;
declare var kCGImagePropertyExifFlash: string;
declare var kCGImagePropertyExifFocalLength: string;
declare var kCGImagePropertyExifSubjectArea: string;
declare var kCGImagePropertyExifMakerNote: string;
declare var kCGImagePropertyExifUserComment: string;
declare var kCGImagePropertyExifSubsecTime: string;
declare var kCGImagePropertyExifSubsecTimeOrginal: string;
declare var kCGImagePropertyExifSubsecTimeDigitized: string;
declare var kCGImagePropertyExifFlashPixVersion: string;
declare var kCGImagePropertyExifColorSpace: string;
declare var kCGImagePropertyExifPixelXDimension: string;
declare var kCGImagePropertyExifPixelYDimension: string;
declare var kCGImagePropertyExifRelatedSoundFile: string;
declare var kCGImagePropertyExifFlashEnergy: string;
declare var kCGImagePropertyExifSpatialFrequencyResponse: string;
declare var kCGImagePropertyExifFocalPlaneXResolution: string;
declare var kCGImagePropertyExifFocalPlaneYResolution: string;
declare var kCGImagePropertyExifFocalPlaneResolutionUnit: string;
declare var kCGImagePropertyExifSubjectLocation: string;
declare var kCGImagePropertyExifExposureIndex: string;
declare var kCGImagePropertyExifSensingMethod: string;
declare var kCGImagePropertyExifFileSource: string;
declare var kCGImagePropertyExifSceneType: string;
declare var kCGImagePropertyExifCFAPattern: string;
declare var kCGImagePropertyExifCustomRendered: string;
declare var kCGImagePropertyExifExposureMode: string;
declare var kCGImagePropertyExifWhiteBalance: string;
declare var kCGImagePropertyExifDigitalZoomRatio: string;
declare var kCGImagePropertyExifFocalLenIn35mmFilm: string;
declare var kCGImagePropertyExifSceneCaptureType: string;
declare var kCGImagePropertyExifGainControl: string;
declare var kCGImagePropertyExifContrast: string;
declare var kCGImagePropertyExifSaturation: string;
declare var kCGImagePropertyExifSharpness: string;
declare var kCGImagePropertyExifDeviceSettingDescription: string;
declare var kCGImagePropertyExifSubjectDistRange: string;
declare var kCGImagePropertyExifImageUniqueID: string;
declare var kCGImagePropertyExifCameraOwnerName: string;
declare var kCGImagePropertyExifBodySerialNumber: string;
declare var kCGImagePropertyExifLensSpecification: string;
declare var kCGImagePropertyExifLensMake: string;
declare var kCGImagePropertyExifLensModel: string;
declare var kCGImagePropertyExifLensSerialNumber: string;
declare var kCGImagePropertyExifGamma: string;
declare var kCGImagePropertyExifAuxLensInfo: string;
declare var kCGImagePropertyExifAuxLensModel: string;
declare var kCGImagePropertyExifAuxSerialNumber: string;
declare var kCGImagePropertyExifAuxLensID: string;
declare var kCGImagePropertyExifAuxLensSerialNumber: string;
declare var kCGImagePropertyExifAuxImageNumber: string;
declare var kCGImagePropertyExifAuxFlashCompensation: string;
declare var kCGImagePropertyExifAuxOwnerName: string;
declare var kCGImagePropertyExifAuxFirmware: string;
declare var kCGImagePropertyGIFLoopCount: string;
declare var kCGImagePropertyGIFDelayTime: string;
declare var kCGImagePropertyGIFImageColorMap: string;
declare var kCGImagePropertyGIFHasGlobalColorMap: string;
declare var kCGImagePropertyGIFUnclampedDelayTime: string;
declare var kCGImagePropertyPNGGamma: string;
declare var kCGImagePropertyPNGInterlaceType: string;
declare var kCGImagePropertyPNGXPixelsPerMeter: string;
declare var kCGImagePropertyPNGYPixelsPerMeter: string;
declare var kCGImagePropertyPNGsRGBIntent: string;
declare var kCGImagePropertyPNGChromaticities: string;
declare var kCGImagePropertyPNGAuthor: string;
declare var kCGImagePropertyPNGCopyright: string;
declare var kCGImagePropertyPNGCreationTime: string;
declare var kCGImagePropertyPNGDescription: string;
declare var kCGImagePropertyPNGModificationTime: string;
declare var kCGImagePropertyPNGSoftware: string;
declare var kCGImagePropertyPNGTitle: string;
declare var kCGImagePropertyAPNGLoopCount: string;
declare var kCGImagePropertyAPNGDelayTime: string;
declare var kCGImagePropertyAPNGUnclampedDelayTime: string;
declare var kCGImagePropertyGPSVersion: string;
declare var kCGImagePropertyGPSLatitudeRef: string;
declare var kCGImagePropertyGPSLatitude: string;
declare var kCGImagePropertyGPSLongitudeRef: string;
declare var kCGImagePropertyGPSLongitude: string;
declare var kCGImagePropertyGPSAltitudeRef: string;
declare var kCGImagePropertyGPSAltitude: string;
declare var kCGImagePropertyGPSTimeStamp: string;
declare var kCGImagePropertyGPSSatellites: string;
declare var kCGImagePropertyGPSStatus: string;
declare var kCGImagePropertyGPSMeasureMode: string;
declare var kCGImagePropertyGPSDOP: string;
declare var kCGImagePropertyGPSSpeedRef: string;
declare var kCGImagePropertyGPSSpeed: string;
declare var kCGImagePropertyGPSTrackRef: string;
declare var kCGImagePropertyGPSTrack: string;
declare var kCGImagePropertyGPSImgDirectionRef: string;
declare var kCGImagePropertyGPSImgDirection: string;
declare var kCGImagePropertyGPSMapDatum: string;
declare var kCGImagePropertyGPSDestLatitudeRef: string;
declare var kCGImagePropertyGPSDestLatitude: string;
declare var kCGImagePropertyGPSDestLongitudeRef: string;
declare var kCGImagePropertyGPSDestLongitude: string;
declare var kCGImagePropertyGPSDestBearingRef: string;
declare var kCGImagePropertyGPSDestBearing: string;
declare var kCGImagePropertyGPSDestDistanceRef: string;
declare var kCGImagePropertyGPSDestDistance: string;
declare var kCGImagePropertyGPSProcessingMethod: string;
declare var kCGImagePropertyGPSAreaInformation: string;
declare var kCGImagePropertyGPSDateStamp: string;
declare var kCGImagePropertyGPSDifferental: string;
declare var kCGImagePropertyGPSHPositioningError: string;
declare var kCGImagePropertyIPTCObjectTypeReference: string;
declare var kCGImagePropertyIPTCObjectAttributeReference: string;
declare var kCGImagePropertyIPTCObjectName: string;
declare var kCGImagePropertyIPTCEditStatus: string;
declare var kCGImagePropertyIPTCEditorialUpdate: string;
declare var kCGImagePropertyIPTCUrgency: string;
declare var kCGImagePropertyIPTCSubjectReference: string;
declare var kCGImagePropertyIPTCCategory: string;
declare var kCGImagePropertyIPTCSupplementalCategory: string;
declare var kCGImagePropertyIPTCFixtureIdentifier: string;
declare var kCGImagePropertyIPTCKeywords: string;
declare var kCGImagePropertyIPTCContentLocationCode: string;
declare var kCGImagePropertyIPTCContentLocationName: string;
declare var kCGImagePropertyIPTCReleaseDate: string;
declare var kCGImagePropertyIPTCReleaseTime: string;
declare var kCGImagePropertyIPTCExpirationDate: string;
declare var kCGImagePropertyIPTCExpirationTime: string;
declare var kCGImagePropertyIPTCSpecialInstructions: string;
declare var kCGImagePropertyIPTCActionAdvised: string;
declare var kCGImagePropertyIPTCReferenceService: string;
declare var kCGImagePropertyIPTCReferenceDate: string;
declare var kCGImagePropertyIPTCReferenceNumber: string;
declare var kCGImagePropertyIPTCDateCreated: string;
declare var kCGImagePropertyIPTCTimeCreated: string;
declare var kCGImagePropertyIPTCDigitalCreationDate: string;
declare var kCGImagePropertyIPTCDigitalCreationTime: string;
declare var kCGImagePropertyIPTCOriginatingProgram: string;
declare var kCGImagePropertyIPTCProgramVersion: string;
declare var kCGImagePropertyIPTCObjectCycle: string;
declare var kCGImagePropertyIPTCByline: string;
declare var kCGImagePropertyIPTCBylineTitle: string;
declare var kCGImagePropertyIPTCCity: string;
declare var kCGImagePropertyIPTCSubLocation: string;
declare var kCGImagePropertyIPTCProvinceState: string;
declare var kCGImagePropertyIPTCCountryPrimaryLocationCode: string;
declare var kCGImagePropertyIPTCCountryPrimaryLocationName: string;
declare var kCGImagePropertyIPTCOriginalTransmissionReference: string;
declare var kCGImagePropertyIPTCHeadline: string;
declare var kCGImagePropertyIPTCCredit: string;
declare var kCGImagePropertyIPTCSource: string;
declare var kCGImagePropertyIPTCCopyrightNotice: string;
declare var kCGImagePropertyIPTCContact: string;
declare var kCGImagePropertyIPTCCaptionAbstract: string;
declare var kCGImagePropertyIPTCWriterEditor: string;
declare var kCGImagePropertyIPTCImageType: string;
declare var kCGImagePropertyIPTCImageOrientation: string;
declare var kCGImagePropertyIPTCLanguageIdentifier: string;
declare var kCGImagePropertyIPTCStarRating: string;
declare var kCGImagePropertyIPTCCreatorContactInfo: string;
declare var kCGImagePropertyIPTCRightsUsageTerms: string;
declare var kCGImagePropertyIPTCScene: string;
declare var kCGImagePropertyIPTCContactInfoCity: string;
declare var kCGImagePropertyIPTCContactInfoCountry: string;
declare var kCGImagePropertyIPTCContactInfoAddress: string;
declare var kCGImagePropertyIPTCContactInfoPostalCode: string;
declare var kCGImagePropertyIPTCContactInfoStateProvince: string;
declare var kCGImagePropertyIPTCContactInfoEmails: string;
declare var kCGImagePropertyIPTCContactInfoPhones: string;
declare var kCGImagePropertyIPTCContactInfoWebURLs: string;
declare var kCGImageProperty8BIMLayerNames: string;
declare var kCGImageProperty8BIMVersion: string;
declare var kCGImagePropertyDNGVersion: string;
declare var kCGImagePropertyDNGBackwardVersion: string;
declare var kCGImagePropertyDNGUniqueCameraModel: string;
declare var kCGImagePropertyDNGLocalizedCameraModel: string;
declare var kCGImagePropertyDNGCameraSerialNumber: string;
declare var kCGImagePropertyDNGLensInfo: string;
declare var kCGImagePropertyCIFFDescription: string;
declare var kCGImagePropertyCIFFFirmware: string;
declare var kCGImagePropertyCIFFOwnerName: string;
declare var kCGImagePropertyCIFFImageName: string;
declare var kCGImagePropertyCIFFImageFileName: string;
declare var kCGImagePropertyCIFFReleaseMethod: string;
declare var kCGImagePropertyCIFFReleaseTiming: string;
declare var kCGImagePropertyCIFFRecordID: string;
declare var kCGImagePropertyCIFFSelfTimingTime: string;
declare var kCGImagePropertyCIFFCameraSerialNumber: string;
declare var kCGImagePropertyCIFFImageSerialNumber: string;
declare var kCGImagePropertyCIFFContinuousDrive: string;
declare var kCGImagePropertyCIFFFocusMode: string;
declare var kCGImagePropertyCIFFMeteringMode: string;
declare var kCGImagePropertyCIFFShootingMode: string;
declare var kCGImagePropertyCIFFLensModel: string;
declare var kCGImagePropertyCIFFLensMaxMM: string;
declare var kCGImagePropertyCIFFLensMinMM: string;
declare var kCGImagePropertyCIFFWhiteBalanceIndex: string;
declare var kCGImagePropertyCIFFFlashExposureComp: string;
declare var kCGImagePropertyCIFFMeasuredEV: string;
declare var kCGImagePropertyMakerNikonISOSetting: string;
declare var kCGImagePropertyMakerNikonColorMode: string;
declare var kCGImagePropertyMakerNikonQuality: string;
declare var kCGImagePropertyMakerNikonWhiteBalanceMode: string;
declare var kCGImagePropertyMakerNikonSharpenMode: string;
declare var kCGImagePropertyMakerNikonFocusMode: string;
declare var kCGImagePropertyMakerNikonFlashSetting: string;
declare var kCGImagePropertyMakerNikonISOSelection: string;
declare var kCGImagePropertyMakerNikonFlashExposureComp: string;
declare var kCGImagePropertyMakerNikonImageAdjustment: string;
declare var kCGImagePropertyMakerNikonLensAdapter: string;
declare var kCGImagePropertyMakerNikonLensType: string;
declare var kCGImagePropertyMakerNikonLensInfo: string;
declare var kCGImagePropertyMakerNikonFocusDistance: string;
declare var kCGImagePropertyMakerNikonDigitalZoom: string;
declare var kCGImagePropertyMakerNikonShootingMode: string;
declare var kCGImagePropertyMakerNikonCameraSerialNumber: string;
declare var kCGImagePropertyMakerNikonShutterCount: string;
declare var kCGImagePropertyMakerCanonOwnerName: string;
declare var kCGImagePropertyMakerCanonCameraSerialNumber: string;
declare var kCGImagePropertyMakerCanonImageSerialNumber: string;
declare var kCGImagePropertyMakerCanonFlashExposureComp: string;
declare var kCGImagePropertyMakerCanonContinuousDrive: string;
declare var kCGImagePropertyMakerCanonLensModel: string;
declare var kCGImagePropertyMakerCanonFirmware: string;
declare var kCGImagePropertyMakerCanonAspectRatioInfo: string;
declare var kJSClassDefinitionEmpty: JSClassDefinition;
declare var JSPropertyDescriptorWritableKey: string;
declare var JSPropertyDescriptorEnumerableKey: string;
declare var JSPropertyDescriptorConfigurableKey: string;
declare var JSPropertyDescriptorValueKey: string;
declare var JSPropertyDescriptorGetKey: string;
declare var JSPropertyDescriptorSetKey: string;
declare var LAErrorDomain: string;
declare var MKAnnotationCalloutInfoDidChangeNotification: string;
declare var MKMapSizeWorld: MKMapSize;
declare var MKMapRectWorld: MKMapRect;
declare var MKMapRectNull: MKMapRect;
declare var MKLaunchOptionsDirectionsModeKey: string;
declare var MKLaunchOptionsMapTypeKey: string;
declare var MKLaunchOptionsShowsTrafficKey: string;
declare var MKLaunchOptionsDirectionsModeDriving: string;
declare var MKLaunchOptionsDirectionsModeWalking: string;
declare var MKLaunchOptionsMapCenterKey: string;
declare var MKLaunchOptionsMapSpanKey: string;
declare var MKLaunchOptionsCameraKey: string;
declare var MKErrorDomain: string;
declare var kMACaptionAppearanceSettingsChangedNotification: string;
declare var MAMediaCharacteristicDescribesMusicAndSoundForAccessibility: string;
declare var MAMediaCharacteristicTranscribesSpokenDialogForAccessibility: string;
declare var kMAAudibleMediaSettingsChangedNotification: string;
declare var MAMediaCharacteristicDescribesVideoForAccessibility: string;
declare var MFMailComposeErrorDomain: string;
declare var MFMessageComposeViewControllerAttachmentURL: string;
declare var MFMessageComposeViewControllerAttachmentAlternateFilename: string;
declare var MFMessageComposeViewControllerTextMessageAvailabilityDidChangeNotification: string;
declare var MFMessageComposeViewControllerTextMessageAvailabilityKey: string;
declare var kUTTypeItem: string;
declare var kUTTypeContent: string;
declare var kUTTypeCompositeContent: string;
declare var kUTTypeMessage: string;
declare var kUTTypeContact: string;
declare var kUTTypeArchive: string;
declare var kUTTypeDiskImage: string;
declare var kUTTypeData: string;
declare var kUTTypeDirectory: string;
declare var kUTTypeResolvable: string;
declare var kUTTypeSymLink: string;
declare var kUTTypeExecutable: string;
declare var kUTTypeMountPoint: string;
declare var kUTTypeAliasFile: string;
declare var kUTTypeAliasRecord: string;
declare var kUTTypeURLBookmarkData: string;
declare var kUTTypeURL: string;
declare var kUTTypeFileURL: string;
declare var kUTTypeText: string;
declare var kUTTypePlainText: string;
declare var kUTTypeUTF8PlainText: string;
declare var kUTTypeUTF16ExternalPlainText: string;
declare var kUTTypeUTF16PlainText: string;
declare var kUTTypeDelimitedText: string;
declare var kUTTypeCommaSeparatedText: string;
declare var kUTTypeTabSeparatedText: string;
declare var kUTTypeUTF8TabSeparatedText: string;
declare var kUTTypeRTF: string;
declare var kUTTypeHTML: string;
declare var kUTTypeXML: string;
declare var kUTTypeSourceCode: string;
declare var kUTTypeAssemblyLanguageSource: string;
declare var kUTTypeCSource: string;
declare var kUTTypeObjectiveCSource: string;
declare var kUTTypeCPlusPlusSource: string;
declare var kUTTypeObjectiveCPlusPlusSource: string;
declare var kUTTypeCHeader: string;
declare var kUTTypeCPlusPlusHeader: string;
declare var kUTTypeJavaSource: string;
declare var kUTTypeScript: string;
declare var kUTTypeAppleScript: string;
declare var kUTTypeOSAScript: string;
declare var kUTTypeOSAScriptBundle: string;
declare var kUTTypeJavaScript: string;
declare var kUTTypeShellScript: string;
declare var kUTTypePerlScript: string;
declare var kUTTypePythonScript: string;
declare var kUTTypeRubyScript: string;
declare var kUTTypePHPScript: string;
declare var kUTTypeJSON: string;
declare var kUTTypePropertyList: string;
declare var kUTTypeXMLPropertyList: string;
declare var kUTTypeBinaryPropertyList: string;
declare var kUTTypePDF: string;
declare var kUTTypeRTFD: string;
declare var kUTTypeFlatRTFD: string;
declare var kUTTypeTXNTextAndMultimediaData: string;
declare var kUTTypeWebArchive: string;
declare var kUTTypeImage: string;
declare var kUTTypeJPEG: string;
declare var kUTTypeJPEG2000: string;
declare var kUTTypeTIFF: string;
declare var kUTTypePICT: string;
declare var kUTTypeGIF: string;
declare var kUTTypePNG: string;
declare var kUTTypeQuickTimeImage: string;
declare var kUTTypeAppleICNS: string;
declare var kUTTypeBMP: string;
declare var kUTTypeICO: string;
declare var kUTTypeRawImage: string;
declare var kUTTypeScalableVectorGraphics: string;
declare var kUTTypeAudiovisualContent: string;
declare var kUTTypeMovie: string;
declare var kUTTypeVideo: string;
declare var kUTTypeAudio: string;
declare var kUTTypeQuickTimeMovie: string;
declare var kUTTypeMPEG: string;
declare var kUTTypeMPEG2Video: string;
declare var kUTTypeMPEG2TransportStream: string;
declare var kUTTypeMP3: string;
declare var kUTTypeMPEG4: string;
declare var kUTTypeMPEG4Audio: string;
declare var kUTTypeAppleProtectedMPEG4Audio: string;
declare var kUTTypeAppleProtectedMPEG4Video: string;
declare var kUTTypeAVIMovie: string;
declare var kUTTypeAudioInterchangeFileFormat: string;
declare var kUTTypeWaveformAudio: string;
declare var kUTTypeMIDIAudio: string;
declare var kUTTypePlaylist: string;
declare var kUTTypeM3UPlaylist: string;
declare var kUTTypeFolder: string;
declare var kUTTypeVolume: string;
declare var kUTTypePackage: string;
declare var kUTTypeBundle: string;
declare var kUTTypePluginBundle: string;
declare var kUTTypeSpotlightImporter: string;
declare var kUTTypeQuickLookGenerator: string;
declare var kUTTypeXPCService: string;
declare var kUTTypeFramework: string;
declare var kUTTypeApplication: string;
declare var kUTTypeApplicationBundle: string;
declare var kUTTypeApplicationFile: string;
declare var kUTTypeUnixExecutable: string;
declare var kUTTypeWindowsExecutable: string;
declare var kUTTypeJavaClass: string;
declare var kUTTypeJavaArchive: string;
declare var kUTTypeSystemPreferencesPane: string;
declare var kUTTypeGNUZipArchive: string;
declare var kUTTypeBzip2Archive: string;
declare var kUTTypeZipArchive: string;
declare var kUTTypeSpreadsheet: string;
declare var kUTTypePresentation: string;
declare var kUTTypeDatabase: string;
declare var kUTTypeVCard: string;
declare var kUTTypeToDoItem: string;
declare var kUTTypeCalendarEvent: string;
declare var kUTTypeEmailMessage: string;
declare var kUTTypeInternetLocation: string;
declare var kUTTypeInkText: string;
declare var kUTTypeFont: string;
declare var kUTTypeBookmark: string;
declare var kUTType3DContent: string;
declare var kUTTypePKCS12: string;
declare var kUTTypeX509Certificate: string;
declare var kUTTypeElectronicPublication: string;
declare var kUTTypeLog: string;
declare var kUTExportedTypeDeclarationsKey: string;
declare var kUTImportedTypeDeclarationsKey: string;
declare var kUTTypeIdentifierKey: string;
declare var kUTTypeTagSpecificationKey: string;
declare var kUTTypeConformsToKey: string;
declare var kUTTypeDescriptionKey: string;
declare var kUTTypeIconFileKey: string;
declare var kUTTypeReferenceURLKey: string;
declare var kUTTypeVersionKey: string;
declare var kUTTagClassFilenameExtension: string;
declare var kUTTagClassMIMEType: string;
declare var MCErrorDomain: string;
declare var kMCSessionMinimumNumberOfPeers: number;
declare var kMCSessionMaximumNumberOfPeers: number;
declare var NEVPNErrorDomain: string;
declare var NEVPNConfigurationChangeNotification: string;
declare var NEVPNStatusDidChangeNotification: string;
declare var PHContentEditingInputResultIsInCloudKey: string;
declare var PHContentEditingInputCancelledKey: string;
declare var PHContentEditingInputErrorKey: string;
declare var PHImageManagerMaximumSize: CGSize;
declare var PHImageResultIsInCloudKey: string;
declare var PHImageResultIsDegradedKey: string;
declare var PHImageResultRequestIDKey: string;
declare var PHImageCancelledKey: string;
declare var PHImageErrorKey: string;
declare var PKPushTypeVoIP: string;
declare var SSReadingListErrorDomain: string;
declare var SLServiceTypeTwitter: string;
declare var SLServiceTypeFacebook: string;
declare var SLServiceTypeSinaWeibo: string;
declare var SLServiceTypeTencentWeibo: string;
declare var SKDownloadTimeRemainingUnknown: number;
declare var SKErrorDomain: string;
declare var SKReceiptPropertyIsExpired: string;
declare var SKReceiptPropertyIsRevoked: string;
declare var SKReceiptPropertyIsVolumePurchase: string;
declare var SKStoreProductParameterITunesItemIdentifier: string;
declare var SKStoreProductParameterAffiliateToken: string;
declare var SKStoreProductParameterCampaignToken: string;
declare var kCFErrorDomainSystemConfiguration: string;
declare var kVTCompressionPropertyKey_NumberOfPendingFrames: string;
declare var kVTCompressionPropertyKey_PixelBufferPoolIsShared: string;
declare var kVTCompressionPropertyKey_VideoEncoderPixelBufferAttributes: string;
declare var kVTCompressionPropertyKey_MaxKeyFrameInterval: string;
declare var kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration: string;
declare var kVTCompressionPropertyKey_AllowTemporalCompression: string;
declare var kVTCompressionPropertyKey_AllowFrameReordering: string;
declare var kVTCompressionPropertyKey_AverageBitRate: string;
declare var kVTCompressionPropertyKey_DataRateLimits: string;
declare var kVTCompressionPropertyKey_Quality: string;
declare var kVTCompressionPropertyKey_MoreFramesBeforeStart: string;
declare var kVTCompressionPropertyKey_MoreFramesAfterEnd: string;
declare var kVTCompressionPropertyKey_ProfileLevel: string;
declare var kVTProfileLevel_H264_Baseline_1_3: string;
declare var kVTProfileLevel_H264_Baseline_3_0: string;
declare var kVTProfileLevel_H264_Baseline_3_1: string;
declare var kVTProfileLevel_H264_Baseline_3_2: string;
declare var kVTProfileLevel_H264_Baseline_4_0: string;
declare var kVTProfileLevel_H264_Baseline_4_1: string;
declare var kVTProfileLevel_H264_Baseline_4_2: string;
declare var kVTProfileLevel_H264_Baseline_5_0: string;
declare var kVTProfileLevel_H264_Baseline_5_1: string;
declare var kVTProfileLevel_H264_Baseline_5_2: string;
declare var kVTProfileLevel_H264_Baseline_AutoLevel: string;
declare var kVTProfileLevel_H264_Main_3_0: string;
declare var kVTProfileLevel_H264_Main_3_1: string;
declare var kVTProfileLevel_H264_Main_3_2: string;
declare var kVTProfileLevel_H264_Main_4_0: string;
declare var kVTProfileLevel_H264_Main_4_1: string;
declare var kVTProfileLevel_H264_Main_4_2: string;
declare var kVTProfileLevel_H264_Main_5_0: string;
declare var kVTProfileLevel_H264_Main_5_1: string;
declare var kVTProfileLevel_H264_Main_5_2: string;
declare var kVTProfileLevel_H264_Main_AutoLevel: string;
declare var kVTProfileLevel_H264_Extended_5_0: string;
declare var kVTProfileLevel_H264_Extended_AutoLevel: string;
declare var kVTProfileLevel_H264_High_3_0: string;
declare var kVTProfileLevel_H264_High_3_1: string;
declare var kVTProfileLevel_H264_High_3_2: string;
declare var kVTProfileLevel_H264_High_4_0: string;
declare var kVTProfileLevel_H264_High_4_1: string;
declare var kVTProfileLevel_H264_High_4_2: string;
declare var kVTProfileLevel_H264_High_5_0: string;
declare var kVTProfileLevel_H264_High_5_1: string;
declare var kVTProfileLevel_H264_High_5_2: string;
declare var kVTProfileLevel_H264_High_AutoLevel: string;
declare var kVTProfileLevel_MP4V_Simple_L0: string;
declare var kVTProfileLevel_MP4V_Simple_L1: string;
declare var kVTProfileLevel_MP4V_Simple_L2: string;
declare var kVTProfileLevel_MP4V_Simple_L3: string;
declare var kVTProfileLevel_MP4V_Main_L2: string;
declare var kVTProfileLevel_MP4V_Main_L3: string;
declare var kVTProfileLevel_MP4V_Main_L4: string;
declare var kVTProfileLevel_MP4V_AdvancedSimple_L0: string;
declare var kVTProfileLevel_MP4V_AdvancedSimple_L1: string;
declare var kVTProfileLevel_MP4V_AdvancedSimple_L2: string;
declare var kVTProfileLevel_MP4V_AdvancedSimple_L3: string;
declare var kVTProfileLevel_MP4V_AdvancedSimple_L4: string;
declare var kVTProfileLevel_H263_Profile0_Level10: string;
declare var kVTProfileLevel_H263_Profile0_Level45: string;
declare var kVTProfileLevel_H263_Profile3_Level45: string;
declare var kVTCompressionPropertyKey_H264EntropyMode: string;
declare var kVTH264EntropyMode_CAVLC: string;
declare var kVTH264EntropyMode_CABAC: string;
declare var kVTCompressionPropertyKey_Depth: string;
declare var kVTCompressionPropertyKey_MaxFrameDelayCount: string;
declare var kVTCompressionPropertyKey_MaxH264SliceBytes: string;
declare var kVTCompressionPropertyKey_RealTime: string;
declare var kVTCompressionPropertyKey_SourceFrameCount: string;
declare var kVTCompressionPropertyKey_ExpectedFrameRate: string;
declare var kVTCompressionPropertyKey_ExpectedDuration: string;
declare var kVTEncodeFrameOptionKey_ForceKeyFrame: string;
declare var kVTCompressionPropertyKey_CleanAperture: string;
declare var kVTCompressionPropertyKey_PixelAspectRatio: string;
declare var kVTCompressionPropertyKey_FieldCount: string;
declare var kVTCompressionPropertyKey_FieldDetail: string;
declare var kVTCompressionPropertyKey_AspectRatio16x9: string;
declare var kVTCompressionPropertyKey_ProgressiveScan: string;
declare var kVTCompressionPropertyKey_ColorPrimaries: string;
declare var kVTCompressionPropertyKey_TransferFunction: string;
declare var kVTCompressionPropertyKey_YCbCrMatrix: string;
declare var kVTCompressionPropertyKey_ICCProfile: string;
declare var kVTCompressionPropertyKey_PixelTransferProperties: string;
declare var kVTCompressionPropertyKey_MultiPassStorage: string;
declare var kVTPropertyTypeKey: string;
declare var kVTPropertyType_Enumeration: string;
declare var kVTPropertyType_Boolean: string;
declare var kVTPropertyType_Number: string;
declare var kVTPropertyReadWriteStatusKey: string;
declare var kVTPropertyReadWriteStatus_ReadOnly: string;
declare var kVTPropertyReadWriteStatus_ReadWrite: string;
declare var kVTPropertyShouldBeSerializedKey: string;
declare var kVTPropertySupportedValueMinimumKey: string;
declare var kVTPropertySupportedValueMaximumKey: string;
declare var kVTPropertySupportedValueListKey: string;
declare var kVTPropertyDocumentationKey: string;
declare var kVTVideoEncoderSpecification_EncoderID: string;
declare var kVTDecompressionPropertyKey_PixelBufferPool: string;
declare var kVTDecompressionPropertyKey_PixelBufferPoolIsShared: string;
declare var kVTDecompressionPropertyKey_OutputPoolRequestedMinimumBufferCount: string;
declare var kVTDecompressionPropertyKey_NumberOfFramesBeingDecoded: string;
declare var kVTDecompressionPropertyKey_MinOutputPresentationTimeStampOfFramesBeingDecoded: string;
declare var kVTDecompressionPropertyKey_MaxOutputPresentationTimeStampOfFramesBeingDecoded: string;
declare var kVTDecompressionPropertyKey_ContentHasInterframeDependencies: string;
declare var kVTDecompressionPropertyKey_RealTime: string;
declare var kVTDecompressionPropertyKey_ThreadCount: string;
declare var kVTDecompressionPropertyKey_FieldMode: string;
declare var kVTDecompressionProperty_FieldMode_BothFields: string;
declare var kVTDecompressionProperty_FieldMode_TopFieldOnly: string;
declare var kVTDecompressionProperty_FieldMode_BottomFieldOnly: string;
declare var kVTDecompressionProperty_FieldMode_SingleField: string;
declare var kVTDecompressionProperty_FieldMode_DeinterlaceFields: string;
declare var kVTDecompressionPropertyKey_DeinterlaceMode: string;
declare var kVTDecompressionProperty_DeinterlaceMode_VerticalFilter: string;
declare var kVTDecompressionProperty_DeinterlaceMode_Temporal: string;
declare var kVTDecompressionPropertyKey_ReducedResolutionDecode: string;
declare var kVTDecompressionResolutionKey_Width: string;
declare var kVTDecompressionResolutionKey_Height: string;
declare var kVTDecompressionPropertyKey_ReducedCoefficientDecode: string;
declare var kVTDecompressionPropertyKey_ReducedFrameDelivery: string;
declare var kVTDecompressionPropertyKey_OnlyTheseFrames: string;
declare var kVTDecompressionProperty_OnlyTheseFrames_AllFrames: string;
declare var kVTDecompressionProperty_OnlyTheseFrames_NonDroppableFrames: string;
declare var kVTDecompressionProperty_OnlyTheseFrames_IFrames: string;
declare var kVTDecompressionProperty_OnlyTheseFrames_KeyFrames: string;
declare var kVTDecompressionPropertyKey_SuggestedQualityOfServiceTiers: string;
declare var kVTDecompressionPropertyKey_SupportedPixelFormatsOrderedByQuality: string;
declare var kVTDecompressionPropertyKey_SupportedPixelFormatsOrderedByPerformance: string;
declare var kVTDecompressionPropertyKey_PixelFormatsWithReducedResolutionSupport: string;
declare var kVTDecompressionPropertyKey_PixelTransferProperties: string;
declare var kVTMultiPassStorageCreationOption_DoNotDelete: string;
declare var kVTVideoEncoderList_CodecType: string;
declare var kVTVideoEncoderList_EncoderID: string;
declare var kVTVideoEncoderList_CodecName: string;
declare var kVTVideoEncoderList_EncoderName: string;
declare var kVTVideoEncoderList_DisplayName: string;
declare var WKErrorDomain: string;
declare var sqlite3_version: any;
declare var sqlite3_temp_directory: string;
declare var sqlite3_data_directory: string;
declare var bold: number;
declare var italic: number;
declare var underline: number;
declare var outline: number;
declare var shadow: number;
declare var condense: number;
declare var extend: number;
declare var alphaStage: number;
declare var betaStage: number;
declare var finalStage: number;
declare var OSLittleEndian: number;
declare var OSBigEndian: number;
declare var kCGFontIndexInvalid: number;
declare var kCGGlyphMax: number;
declare var CGGlyphMax: number;
declare var kCGGradientDrawsAfterEndLocation: number;
declare var kCFRunLoopRunStopped: number;
declare var kCFRunLoopRunTimedOut: number;
declare var kCFRunLoopRunHandledSource: number;
declare var kCFSocketAutomaticallyReenableAcceptCallBack: number;
declare var kCFSocketAutomaticallyReenableDataCallBack: number;
declare var kCFSocketAutomaticallyReenableWriteCallBack: number;
declare var kCFSocketLeaveErrors: number;
declare var kCFSocketCloseOnInvalidate: number;
declare var kCFPropertyListReadUnknownVersionError: number;
declare var kCFPropertyListReadStreamError: number;
declare var kCFPropertyListWriteStreamError: number;
declare var kCFBundleExecutableArchitecturePPC: number;
declare var kCFBundleExecutableArchitectureX86_64: number;
declare var kCFBundleExecutableArchitecturePPC64: number;
declare var kCFMessagePortSendTimeout: number;
declare var kCFMessagePortReceiveTimeout: number;
declare var kCFMessagePortIsInvalid: number;
declare var kCFMessagePortTransportError: number;
declare var kCFMessagePortBecameInvalidError: number;
declare var kCFNotificationPostToAllSessions: number;
declare var kCFStringTokenizerUnitSentence: number;
declare var kCFStringTokenizerUnitParagraph: number;
declare var kCFStringTokenizerUnitLineBreak: number;
declare var kCFStringTokenizerUnitWordBoundary: number;
declare var kCFStringTokenizerAttributeLatinTranscription: number;
declare var kCFStringTokenizerAttributeLanguage: number;
declare var kCFFileDescriptorWriteCallBack: number;
declare var kCVSMPTETimeType25: number;
declare var kCVSMPTETimeType30Drop: number;
declare var kCVSMPTETimeType30: number;
declare var kCVSMPTETimeType2997: number;
declare var kCVSMPTETimeType2997Drop: number;
declare var kCVSMPTETimeType60: number;
declare var kCVSMPTETimeType5994: number;
declare var kCVSMPTETimeRunning: number;
declare var kCVTimeStampHostTimeValid: number;
declare var kCVTimeStampSMPTETimeValid: number;
declare var kCVTimeStampVideoRefreshPeriodValid: number;
declare var kCVTimeStampRateScalarValid: number;
declare var kCVTimeStampTopField: number;
declare var kCVTimeStampBottomField: number;
declare var kCVTimeStampIsInterlaced: number;
declare var kCVAttachmentMode_ShouldPropagate: number;
declare var kCVPixelFormatType_2Indexed: number;
declare var kCVPixelFormatType_4Indexed: number;
declare var kCVPixelFormatType_8Indexed: number;
declare var kCVPixelFormatType_1IndexedGray_WhiteIsZero: number;
declare var kCVPixelFormatType_2IndexedGray_WhiteIsZero: number;
declare var kCVPixelFormatType_4IndexedGray_WhiteIsZero: number;
declare var kCVPixelFormatType_8IndexedGray_WhiteIsZero: number;
declare var kCVPixelFormatType_16BE555: number;
declare var kCVPixelFormatType_16LE555: number;
declare var kCVPixelFormatType_16LE5551: number;
declare var kCVPixelFormatType_16BE565: number;
declare var kCVPixelFormatType_16LE565: number;
declare var kCVPixelFormatType_24RGB: number;
declare var kCVPixelFormatType_24BGR: number;
declare var kCVPixelFormatType_32ARGB: number;
declare var kCVPixelFormatType_32BGRA: number;
declare var kCVPixelFormatType_32ABGR: number;
declare var kCVPixelFormatType_32RGBA: number;
declare var kCVPixelFormatType_64ARGB: number;
declare var kCVPixelFormatType_48RGB: number;
declare var kCVPixelFormatType_32AlphaGray: number;
declare var kCVPixelFormatType_16Gray: number;
declare var kCVPixelFormatType_30RGB: number;
declare var kCVPixelFormatType_422YpCbCr8: number;
declare var kCVPixelFormatType_4444YpCbCrA8: number;
declare var kCVPixelFormatType_4444YpCbCrA8R: number;
declare var kCVPixelFormatType_4444AYpCbCr8: number;
declare var kCVPixelFormatType_4444AYpCbCr16: number;
declare var kCVPixelFormatType_444YpCbCr8: number;
declare var kCVPixelFormatType_422YpCbCr16: number;
declare var kCVPixelFormatType_422YpCbCr10: number;
declare var kCVPixelFormatType_444YpCbCr10: number;
declare var kCVPixelFormatType_420YpCbCr8Planar: number;
declare var kCVPixelFormatType_420YpCbCr8PlanarFullRange: number;
declare var kCVPixelFormatType_422YpCbCr_4A_8BiPlanar: number;
declare var kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange: number;
declare var kCVPixelFormatType_420YpCbCr8BiPlanarFullRange: number;
declare var kCVPixelFormatType_422YpCbCr8_yuvs: number;
declare var kCVPixelFormatType_422YpCbCr8FullRange: number;
declare var kCVPixelFormatType_OneComponent8: number;
declare var kCVPixelFormatType_TwoComponent8: number;
declare var kCVPixelFormatType_OneComponent16Half: number;
declare var kCVPixelFormatType_OneComponent32Float: number;
declare var kCVPixelFormatType_TwoComponent16Half: number;
declare var kCVPixelFormatType_TwoComponent32Float: number;
declare var kCVPixelFormatType_64RGBAHalf: number;
declare var kCVPixelFormatType_128RGBAFloat: number;
declare var NSBundleExecutableArchitecturePPC: number;
declare var NSBundleExecutableArchitectureX86_64: number;
declare var NSBundleExecutableArchitecturePPC64: number;
declare var NS_LittleEndian: number;
declare var NS_BigEndian: number;
declare var NSUndefinedDateComponent: number;
declare var NSNEXTSTEPStringEncoding: number;
declare var NSJapaneseEUCStringEncoding: number;
declare var NSUTF8StringEncoding: number;
declare var NSISOLatin1StringEncoding: number;
declare var NSSymbolStringEncoding: number;
declare var NSNonLossyASCIIStringEncoding: number;
declare var NSShiftJISStringEncoding: number;
declare var NSISOLatin2StringEncoding: number;
declare var NSUnicodeStringEncoding: number;
declare var NSWindowsCP1251StringEncoding: number;
declare var NSWindowsCP1252StringEncoding: number;
declare var NSWindowsCP1253StringEncoding: number;
declare var NSWindowsCP1254StringEncoding: number;
declare var NSWindowsCP1250StringEncoding: number;
declare var NSISO2022JPStringEncoding: number;
declare var NSMacOSRomanStringEncoding: number;
declare var NSUTF16StringEncoding: number;
declare var NSUTF16BigEndianStringEncoding: number;
declare var NSUTF16LittleEndianStringEncoding: number;
declare var NSUTF32StringEncoding: number;
declare var NSUTF32BigEndianStringEncoding: number;
declare var NSUTF32LittleEndianStringEncoding: number;
declare var NSPointerFunctionsOpaqueMemory: number;
declare var NSPointerFunctionsMallocMemory: number;
declare var NSPointerFunctionsMachVirtualMemory: number;
declare var NSPointerFunctionsWeakMemory: number;
declare var NSPointerFunctionsObjectPersonality: number;
declare var NSPointerFunctionsOpaquePersonality: number;
declare var NSPointerFunctionsObjectPointerPersonality: number;
declare var NSPointerFunctionsCStringPersonality: number;
declare var NSPointerFunctionsStructPersonality: number;
declare var NSPointerFunctionsIntegerPersonality: number;
declare var NSPointerFunctionsCopyIn: number;
declare var NSHashTableCopyIn: number;
declare var NSHashTableObjectPointerPersonality: number;
declare var NSHashTableWeakMemory: number;
declare var NSMapTableCopyIn: number;
declare var NSMapTableObjectPointerPersonality: number;
declare var NSMapTableWeakMemory: number;
declare var NSMachPortDeallocateSendRight: number;
declare var NSMachPortDeallocateReceiveRight: number;
declare var NSWindows95OperatingSystem: number;
declare var NSSolarisOperatingSystem: number;
declare var NSHPUXOperatingSystem: number;
declare var NSMACHOperatingSystem: number;
declare var NSSunOSOperatingSystem: number;
declare var NSOSF1OperatingSystem: number;
declare var NSTextCheckingAllCustomTypes: number;
declare var NSTextCheckingAllTypes: number;
declare var NSURLErrorCancelledReasonBackgroundUpdatesDisabled: number;
declare var NSURLErrorCancelledReasonInsufficientSystemResources: number;
declare var NSURLErrorCancelled: number;
declare var NSURLErrorBadURL: number;
declare var NSURLErrorTimedOut: number;
declare var NSURLErrorUnsupportedURL: number;
declare var NSURLErrorCannotFindHost: number;
declare var NSURLErrorCannotConnectToHost: number;
declare var NSURLErrorNetworkConnectionLost: number;
declare var NSURLErrorDNSLookupFailed: number;
declare var NSURLErrorHTTPTooManyRedirects: number;
declare var NSURLErrorResourceUnavailable: number;
declare var NSURLErrorNotConnectedToInternet: number;
declare var NSURLErrorRedirectToNonExistentLocation: number;
declare var NSURLErrorBadServerResponse: number;
declare var NSURLErrorUserCancelledAuthentication: number;
declare var NSURLErrorUserAuthenticationRequired: number;
declare var NSURLErrorZeroByteResource: number;
declare var NSURLErrorCannotDecodeRawData: number;
declare var NSURLErrorCannotDecodeContentData: number;
declare var NSURLErrorCannotParseResponse: number;
declare var NSURLErrorFileDoesNotExist: number;
declare var NSURLErrorFileIsDirectory: number;
declare var NSURLErrorNoPermissionsToReadFile: number;
declare var NSURLErrorDataLengthExceedsMaximum: number;
declare var NSURLErrorSecureConnectionFailed: number;
declare var NSURLErrorServerCertificateHasBadDate: number;
declare var NSURLErrorServerCertificateUntrusted: number;
declare var NSURLErrorServerCertificateHasUnknownRoot: number;
declare var NSURLErrorServerCertificateNotYetValid: number;
declare var NSURLErrorClientCertificateRejected: number;
declare var NSURLErrorClientCertificateRequired: number;
declare var NSURLErrorCannotLoadFromNetwork: number;
declare var NSURLErrorCannotCreateFile: number;
declare var NSURLErrorCannotOpenFile: number;
declare var NSURLErrorCannotCloseFile: number;
declare var NSURLErrorCannotWriteToFile: number;
declare var NSURLErrorCannotRemoveFile: number;
declare var NSURLErrorCannotMoveFile: number;
declare var NSURLErrorDownloadDecodingFailedMidStream: number;
declare var NSURLErrorDownloadDecodingFailedToComplete: number;
declare var NSURLErrorInternationalRoamingOff: number;
declare var NSURLErrorCallIsActive: number;
declare var NSURLErrorDataNotAllowed: number;
declare var NSURLErrorRequestBodyStreamExhausted: number;
declare var NSURLErrorBackgroundSessionRequiresSharedContainer: number;
declare var NSURLErrorBackgroundSessionInUseByAnotherProcess: number;
declare var NSURLErrorBackgroundSessionWasDisconnected: number;
declare var NSFileLockingError: number;
declare var NSFileReadUnknownError: number;
declare var NSFileReadNoPermissionError: number;
declare var NSFileReadInvalidFileNameError: number;
declare var NSFileReadCorruptFileError: number;
declare var NSFileReadNoSuchFileError: number;
declare var NSFileReadInapplicableStringEncodingError: number;
declare var NSFileReadUnsupportedSchemeError: number;
declare var NSFileReadTooLargeError: number;
declare var NSFileReadUnknownStringEncodingError: number;
declare var NSFileWriteUnknownError: number;
declare var NSFileWriteNoPermissionError: number;
declare var NSFileWriteInvalidFileNameError: number;
declare var NSFileWriteFileExistsError: number;
declare var NSFileWriteInapplicableStringEncodingError: number;
declare var NSFileWriteUnsupportedSchemeError: number;
declare var NSFileWriteOutOfSpaceError: number;
declare var NSFileWriteVolumeReadOnlyError: number;
declare var NSKeyValueValidationError: number;
declare var NSFormattingError: number;
declare var NSUserCancelledError: number;
declare var NSFeatureUnsupportedError: number;
declare var NSExecutableNotLoadableError: number;
declare var NSExecutableArchitectureMismatchError: number;
declare var NSExecutableRuntimeMismatchError: number;
declare var NSExecutableLoadError: number;
declare var NSExecutableLinkError: number;
declare var NSFileErrorMinimum: number;
declare var NSFileErrorMaximum: number;
declare var NSValidationErrorMinimum: number;
declare var NSValidationErrorMaximum: number;
declare var NSExecutableErrorMinimum: number;
declare var NSExecutableErrorMaximum: number;
declare var NSFormattingErrorMinimum: number;
declare var NSFormattingErrorMaximum: number;
declare var NSPropertyListReadCorruptError: number;
declare var NSPropertyListReadUnknownVersionError: number;
declare var NSPropertyListReadStreamError: number;
declare var NSPropertyListWriteStreamError: number;
declare var NSPropertyListWriteInvalidError: number;
declare var NSPropertyListErrorMinimum: number;
declare var NSPropertyListErrorMaximum: number;
declare var NSXPCConnectionInterrupted: number;
declare var NSXPCConnectionInvalid: number;
declare var NSXPCConnectionReplyInvalid: number;
declare var NSXPCConnectionErrorMinimum: number;
declare var NSXPCConnectionErrorMaximum: number;
declare var NSUbiquitousFileUnavailableError: number;
declare var NSUbiquitousFileNotUploadedDueToQuotaError: number;
declare var NSUbiquitousFileUbiquityServerNotAvailable: number;
declare var NSUbiquitousFileErrorMinimum: number;
declare var NSUbiquitousFileErrorMaximum: number;
declare var NSUbiquitousKeyValueStoreInitialSyncChange: number;
declare var NSUbiquitousKeyValueStoreQuotaViolationChange: number;
declare var NSUbiquitousKeyValueStoreAccountChange: number;
declare var errSecUnimplemented: number;
declare var errSecIO: number;
declare var errSecOpWr: number;
declare var errSecParam: number;
declare var errSecAllocate: number;
declare var errSecUserCanceled: number;
declare var errSecBadReq: number;
declare var errSecInternalComponent: number;
declare var errSecNotAvailable: number;
declare var errSecDuplicateItem: number;
declare var errSecItemNotFound: number;
declare var errSecInteractionNotAllowed: number;
declare var errSecDecode: number;
declare var errSecAuthFailed: number;
declare var kSecPaddingPKCS1: number;
declare var kSecPaddingOAEP: number;
declare var kSecPaddingPKCS1MD2: number;
declare var kSecPaddingPKCS1MD5: number;
declare var kSecPaddingPKCS1SHA1: number;
declare var kSecPaddingPKCS1SHA224: number;
declare var kSecPaddingPKCS1SHA256: number;
declare var kSecPaddingPKCS1SHA384: number;
declare var kSecPaddingPKCS1SHA512: number;
declare var kSecRevocationCRLMethod: number;
declare var kSecRevocationPreferCRL: number;
declare var kSecRevocationRequirePositiveResponse: number;
declare var kSecRevocationNetworkAccessDisabled: number;
declare var kSecRevocationUseAnyAvailableMethod: number;
declare var kSecTrustResultProceed: number;
declare var kSecTrustResultConfirm: number;
declare var kSecTrustResultDeny: number;
declare var kSecTrustResultUnspecified: number;
declare var kSecTrustResultRecoverableTrustFailure: number;
declare var kSecTrustResultFatalTrustFailure: number;
declare var kSecTrustResultOtherError: number;
declare var SSL_RSA_WITH_NULL_MD5: number;
declare var SSL_RSA_WITH_NULL_SHA: number;
declare var SSL_RSA_EXPORT_WITH_RC4_40_MD5: number;
declare var SSL_RSA_WITH_RC4_128_MD5: number;
declare var SSL_RSA_WITH_RC4_128_SHA: number;
declare var SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5: number;
declare var SSL_RSA_WITH_IDEA_CBC_SHA: number;
declare var SSL_RSA_EXPORT_WITH_DES40_CBC_SHA: number;
declare var SSL_RSA_WITH_DES_CBC_SHA: number;
declare var SSL_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA: number;
declare var SSL_DH_DSS_WITH_DES_CBC_SHA: number;
declare var SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA: number;
declare var SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA: number;
declare var SSL_DH_RSA_WITH_DES_CBC_SHA: number;
declare var SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA: number;
declare var SSL_DHE_DSS_WITH_DES_CBC_SHA: number;
declare var SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA: number;
declare var SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA: number;
declare var SSL_DHE_RSA_WITH_DES_CBC_SHA: number;
declare var SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var SSL_DH_anon_EXPORT_WITH_RC4_40_MD5: number;
declare var SSL_DH_anon_WITH_RC4_128_MD5: number;
declare var SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA: number;
declare var SSL_DH_anon_WITH_DES_CBC_SHA: number;
declare var SSL_DH_anon_WITH_3DES_EDE_CBC_SHA: number;
declare var SSL_FORTEZZA_DMS_WITH_NULL_SHA: number;
declare var SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA: number;
declare var TLS_RSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_DH_DSS_WITH_AES_128_CBC_SHA: number;
declare var TLS_DH_RSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_DHE_DSS_WITH_AES_128_CBC_SHA: number;
declare var TLS_DHE_RSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_DH_anon_WITH_AES_128_CBC_SHA: number;
declare var TLS_RSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_DH_DSS_WITH_AES_256_CBC_SHA: number;
declare var TLS_DH_RSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_DHE_DSS_WITH_AES_256_CBC_SHA: number;
declare var TLS_DHE_RSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_DH_anon_WITH_AES_256_CBC_SHA: number;
declare var TLS_ECDH_ECDSA_WITH_NULL_SHA: number;
declare var TLS_ECDH_ECDSA_WITH_RC4_128_SHA: number;
declare var TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_ECDHE_ECDSA_WITH_NULL_SHA: number;
declare var TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: number;
declare var TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_ECDH_RSA_WITH_NULL_SHA: number;
declare var TLS_ECDH_RSA_WITH_RC4_128_SHA: number;
declare var TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_ECDHE_RSA_WITH_NULL_SHA: number;
declare var TLS_ECDHE_RSA_WITH_RC4_128_SHA: number;
declare var TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: number;
declare var TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: number;
declare var TLS_ECDH_anon_WITH_NULL_SHA: number;
declare var TLS_ECDH_anon_WITH_RC4_128_SHA: number;
declare var TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_ECDH_anon_WITH_AES_128_CBC_SHA: number;
declare var TLS_ECDH_anon_WITH_AES_256_CBC_SHA: number;
declare var TLS_NULL_WITH_NULL_NULL: number;
declare var TLS_RSA_WITH_NULL_MD5: number;
declare var TLS_RSA_WITH_NULL_SHA: number;
declare var TLS_RSA_WITH_RC4_128_MD5: number;
declare var TLS_RSA_WITH_RC4_128_SHA: number;
declare var TLS_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_RSA_WITH_NULL_SHA256: number;
declare var TLS_RSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_RSA_WITH_AES_256_CBC_SHA256: number;
declare var TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_DH_DSS_WITH_AES_128_CBC_SHA256: number;
declare var TLS_DH_RSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_DHE_DSS_WITH_AES_128_CBC_SHA256: number;
declare var TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_DH_DSS_WITH_AES_256_CBC_SHA256: number;
declare var TLS_DH_RSA_WITH_AES_256_CBC_SHA256: number;
declare var TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: number;
declare var TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: number;
declare var TLS_DH_anon_WITH_RC4_128_MD5: number;
declare var TLS_DH_anon_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_DH_anon_WITH_AES_128_CBC_SHA256: number;
declare var TLS_DH_anon_WITH_AES_256_CBC_SHA256: number;
declare var TLS_PSK_WITH_RC4_128_SHA: number;
declare var TLS_PSK_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_PSK_WITH_AES_128_CBC_SHA: number;
declare var TLS_PSK_WITH_AES_256_CBC_SHA: number;
declare var TLS_DHE_PSK_WITH_RC4_128_SHA: number;
declare var TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_DHE_PSK_WITH_AES_128_CBC_SHA: number;
declare var TLS_DHE_PSK_WITH_AES_256_CBC_SHA: number;
declare var TLS_RSA_PSK_WITH_RC4_128_SHA: number;
declare var TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA: number;
declare var TLS_RSA_PSK_WITH_AES_128_CBC_SHA: number;
declare var TLS_RSA_PSK_WITH_AES_256_CBC_SHA: number;
declare var TLS_PSK_WITH_NULL_SHA: number;
declare var TLS_DHE_PSK_WITH_NULL_SHA: number;
declare var TLS_RSA_PSK_WITH_NULL_SHA: number;
declare var TLS_RSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_RSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_DH_RSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_DH_RSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_DHE_DSS_WITH_AES_128_GCM_SHA256: number;
declare var TLS_DHE_DSS_WITH_AES_256_GCM_SHA384: number;
declare var TLS_DH_DSS_WITH_AES_128_GCM_SHA256: number;
declare var TLS_DH_DSS_WITH_AES_256_GCM_SHA384: number;
declare var TLS_DH_anon_WITH_AES_128_GCM_SHA256: number;
declare var TLS_DH_anon_WITH_AES_256_GCM_SHA384: number;
declare var TLS_PSK_WITH_AES_128_GCM_SHA256: number;
declare var TLS_PSK_WITH_AES_256_GCM_SHA384: number;
declare var TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: number;
declare var TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: number;
declare var TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: number;
declare var TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: number;
declare var TLS_PSK_WITH_AES_128_CBC_SHA256: number;
declare var TLS_PSK_WITH_AES_256_CBC_SHA384: number;
declare var TLS_PSK_WITH_NULL_SHA256: number;
declare var TLS_PSK_WITH_NULL_SHA384: number;
declare var TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: number;
declare var TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: number;
declare var TLS_DHE_PSK_WITH_NULL_SHA256: number;
declare var TLS_DHE_PSK_WITH_NULL_SHA384: number;
declare var TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: number;
declare var TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: number;
declare var TLS_RSA_PSK_WITH_NULL_SHA256: number;
declare var TLS_RSA_PSK_WITH_NULL_SHA384: number;
declare var TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: number;
declare var TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: number;
declare var TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: number;
declare var TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: number;
declare var TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: number;
declare var TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: number;
declare var TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: number;
declare var TLS_EMPTY_RENEGOTIATION_INFO_SCSV: number;
declare var SSL_RSA_WITH_RC2_CBC_MD5: number;
declare var SSL_RSA_WITH_IDEA_CBC_MD5: number;
declare var SSL_RSA_WITH_DES_CBC_MD5: number;
declare var SSL_RSA_WITH_3DES_EDE_CBC_MD5: number;
declare var SSL_NO_SUCH_CIPHERSUITE: number;
declare var errSSLNegotiation: number;
declare var errSSLFatalAlert: number;
declare var errSSLWouldBlock: number;
declare var errSSLSessionNotFound: number;
declare var errSSLClosedGraceful: number;
declare var errSSLClosedAbort: number;
declare var errSSLXCertChainInvalid: number;
declare var errSSLBadCert: number;
declare var errSSLCrypto: number;
declare var errSSLInternal: number;
declare var errSSLModuleAttach: number;
declare var errSSLUnknownRootCert: number;
declare var errSSLNoRootCert: number;
declare var errSSLCertExpired: number;
declare var errSSLCertNotYetValid: number;
declare var errSSLClosedNoNotify: number;
declare var errSSLBufferOverflow: number;
declare var errSSLBadCipherSuite: number;
declare var errSSLPeerUnexpectedMsg: number;
declare var errSSLPeerBadRecordMac: number;
declare var errSSLPeerDecryptionFail: number;
declare var errSSLPeerRecordOverflow: number;
declare var errSSLPeerDecompressFail: number;
declare var errSSLPeerHandshakeFail: number;
declare var errSSLPeerBadCert: number;
declare var errSSLPeerUnsupportedCert: number;
declare var errSSLPeerCertRevoked: number;
declare var errSSLPeerCertExpired: number;
declare var errSSLPeerCertUnknown: number;
declare var errSSLIllegalParam: number;
declare var errSSLPeerUnknownCA: number;
declare var errSSLPeerAccessDenied: number;
declare var errSSLPeerDecodeError: number;
declare var errSSLPeerDecryptError: number;
declare var errSSLPeerExportRestriction: number;
declare var errSSLPeerProtocolVersion: number;
declare var errSSLPeerInsufficientSecurity: number;
declare var errSSLPeerInternalError: number;
declare var errSSLPeerUserCancelled: number;
declare var errSSLPeerNoRenegotiation: number;
declare var errSSLPeerAuthCompleted: number;
declare var errSSLClientCertRequested: number;
declare var errSSLHostNameMismatch: number;
declare var errSSLConnectionRefused: number;
declare var errSSLDecryptionFail: number;
declare var errSSLBadRecordMac: number;
declare var errSSLRecordOverflow: number;
declare var errSSLBadConfiguration: number;
declare var errSSLUnexpectedRecord: number;
declare var kCFStreamErrorSOCKSSubDomainVersionCode: number;
declare var kCFStreamErrorSOCKS4SubDomainResponse: number;
declare var kCFStreamErrorSOCKS5SubDomainUserPass: number;
declare var kCFStreamErrorSOCKS5SubDomainMethod: number;
declare var kCFStreamErrorSOCKS5SubDomainResponse: number;
declare var kCFStreamErrorSOCKS5BadState: number;
declare var kCFStreamErrorSOCKSUnknownClientVersion: number;
declare var kCFStreamErrorSOCKS4IdentdFailed: number;
declare var kCFStreamErrorSOCKS4IdConflict: number;
declare var kABGroupType: number;
declare var kABSourceType: number;
declare var kABStringPropertyType: number;
declare var kABIntegerPropertyType: number;
declare var kABRealPropertyType: number;
declare var kABDateTimePropertyType: number;
declare var kABDictionaryPropertyType: number;
declare var kABMultiStringPropertyType: number;
declare var kABMultiIntegerPropertyType: number;
declare var kABMultiRealPropertyType: number;
declare var kABMultiDateTimePropertyType: number;
declare var kABMultiDictionaryPropertyType: number;
declare var kABOperationNotPermittedByUserError: number;
declare var kABSourceTypeExchange: number;
declare var kABSourceTypeExchangeGAL: number;
declare var kABSourceTypeMobileMe: number;
declare var kABSourceTypeLDAP: number;
declare var kABSourceTypeCardDAV: number;
declare var kABSourceTypeCardDAVSearch: number;
declare var kABPersonSortByLastName: number;
declare var kABPersonCompositeNameFormatLastNameFirst: number;
declare var UIPrintNoContentError: number;
declare var UIPrintUnknownImageFormatError: number;
declare var UIPrintJobFailedError: number;
declare var kCTFontPriorityNetwork: number;
declare var kCTFontPriorityComputer: number;
declare var kCTFontPriorityUser: number;
declare var kCTFontPriorityDynamic: number;
declare var kCTFontPriorityProcess: number;
declare var kCTFontTableCFF: number;
declare var kCTFontTableDSIG: number;
declare var kCTFontTableEBDT: number;
declare var kCTFontTableEBLC: number;
declare var kCTFontTableEBSC: number;
declare var kCTFontTableGDEF: number;
declare var kCTFontTableGPOS: number;
declare var kCTFontTableGSUB: number;
declare var kCTFontTableJSTF: number;
declare var kCTFontTableLTSH: number;
declare var kCTFontTableMATH: number;
declare var kCTFontTableOS2: number;
declare var kCTFontTablePCLT: number;
declare var kCTFontTableVDMX: number;
declare var kCTFontTableVORG: number;
declare var kCTFontTableZapf: number;
declare var kCTFontTableAcnt: number;
declare var kCTFontTableAnkr: number;
declare var kCTFontTableAvar: number;
declare var kCTFontTableBdat: number;
declare var kCTFontTableBhed: number;
declare var kCTFontTableBloc: number;
declare var kCTFontTableBsln: number;
declare var kCTFontTableCmap: number;
declare var kCTFontTableCvar: number;
declare var kCTFontTableCvt: number;
declare var kCTFontTableFdsc: number;
declare var kCTFontTableFeat: number;
declare var kCTFontTableFmtx: number;
declare var kCTFontTableFpgm: number;
declare var kCTFontTableFvar: number;
declare var kCTFontTableGasp: number;
declare var kCTFontTableGlyf: number;
declare var kCTFontTableGvar: number;
declare var kCTFontTableHdmx: number;
declare var kCTFontTableHead: number;
declare var kCTFontTableHhea: number;
declare var kCTFontTableHmtx: number;
declare var kCTFontTableHsty: number;
declare var kCTFontTableJust: number;
declare var kCTFontTableKern: number;
declare var kCTFontTableKerx: number;
declare var kCTFontTableLcar: number;
declare var kCTFontTableLtag: number;
declare var kCTFontTableLoca: number;
declare var kCTFontTableMaxp: number;
declare var kCTFontTableMort: number;
declare var kCTFontTableMorx: number;
declare var kCTFontTableName: number;
declare var kCTFontTableOpbd: number;
declare var kCTFontTablePost: number;
declare var kCTFontTablePrep: number;
declare var kCTFontTableProp: number;
declare var kCTFontTableSbit: number;
declare var kCTFontTableSbix: number;
declare var kCTFontTableTrak: number;
declare var kCTFontTableVhea: number;
declare var kCTFontTableVmtx: number;
declare var kCTFontCollectionCopyUnique: number;
declare var kCTFontCollectionCopyStandardSort: number;
declare var kCTRunDelegateCurrentVersion: number;
declare var kCTWritingDirectionOverride: number;
declare var kLigaturesType: number;
declare var kCursiveConnectionType: number;
declare var kLetterCaseType: number;
declare var kVerticalSubstitutionType: number;
declare var kLinguisticRearrangementType: number;
declare var kNumberSpacingType: number;
declare var kSmartSwashType: number;
declare var kDiacriticsType: number;
declare var kVerticalPositionType: number;
declare var kFractionsType: number;
declare var kOverlappingCharactersType: number;
declare var kTypographicExtrasType: number;
declare var kMathematicalExtrasType: number;
declare var kOrnamentSetsType: number;
declare var kCharacterAlternativesType: number;
declare var kDesignComplexityType: number;
declare var kStyleOptionsType: number;
declare var kCharacterShapeType: number;
declare var kNumberCaseType: number;
declare var kTextSpacingType: number;
declare var kTransliterationType: number;
declare var kAnnotationType: number;
declare var kKanaSpacingType: number;
declare var kIdeographicSpacingType: number;
declare var kUnicodeDecompositionType: number;
declare var kRubyKanaType: number;
declare var kCJKSymbolAlternativesType: number;
declare var kIdeographicAlternativesType: number;
declare var kCJKVerticalRomanPlacementType: number;
declare var kItalicCJKRomanType: number;
declare var kCaseSensitiveLayoutType: number;
declare var kAlternateKanaType: number;
declare var kStylisticAlternativesType: number;
declare var kContextualAlternatesType: number;
declare var kLowerCaseType: number;
declare var kUpperCaseType: number;
declare var kLanguageTagType: number;
declare var kCJKRomanSpacingType: number;
declare var kLastFeatureType: number;
declare var kAllTypeFeaturesOffSelector: number;
declare var kRequiredLigaturesOffSelector: number;
declare var kCommonLigaturesOnSelector: number;
declare var kCommonLigaturesOffSelector: number;
declare var kRareLigaturesOnSelector: number;
declare var kRareLigaturesOffSelector: number;
declare var kLogosOnSelector: number;
declare var kLogosOffSelector: number;
declare var kRebusPicturesOnSelector: number;
declare var kRebusPicturesOffSelector: number;
declare var kDiphthongLigaturesOnSelector: number;
declare var kDiphthongLigaturesOffSelector: number;
declare var kSquaredLigaturesOnSelector: number;
declare var kSquaredLigaturesOffSelector: number;
declare var kAbbrevSquaredLigaturesOnSelector: number;
declare var kAbbrevSquaredLigaturesOffSelector: number;
declare var kSymbolLigaturesOnSelector: number;
declare var kSymbolLigaturesOffSelector: number;
declare var kContextualLigaturesOnSelector: number;
declare var kContextualLigaturesOffSelector: number;
declare var kHistoricalLigaturesOnSelector: number;
declare var kHistoricalLigaturesOffSelector: number;
declare var kPartiallyConnectedSelector: number;
declare var kCursiveSelector: number;
declare var kAllCapsSelector: number;
declare var kAllLowerCaseSelector: number;
declare var kSmallCapsSelector: number;
declare var kInitialCapsSelector: number;
declare var kInitialCapsAndSmallCapsSelector: number;
declare var kSubstituteVerticalFormsOffSelector: number;
declare var kLinguisticRearrangementOffSelector: number;
declare var kProportionalNumbersSelector: number;
declare var kThirdWidthNumbersSelector: number;
declare var kQuarterWidthNumbersSelector: number;
declare var kWordInitialSwashesOffSelector: number;
declare var kWordFinalSwashesOnSelector: number;
declare var kWordFinalSwashesOffSelector: number;
declare var kLineInitialSwashesOnSelector: number;
declare var kLineInitialSwashesOffSelector: number;
declare var kLineFinalSwashesOnSelector: number;
declare var kLineFinalSwashesOffSelector: number;
declare var kNonFinalSwashesOnSelector: number;
declare var kNonFinalSwashesOffSelector: number;
declare var kHideDiacriticsSelector: number;
declare var kDecomposeDiacriticsSelector: number;
declare var kSuperiorsSelector: number;
declare var kInferiorsSelector: number;
declare var kOrdinalsSelector: number;
declare var kScientificInferiorsSelector: number;
declare var kVerticalFractionsSelector: number;
declare var kDiagonalFractionsSelector: number;
declare var kPreventOverlapOffSelector: number;
declare var kHyphensToEmDashOffSelector: number;
declare var kHyphenToEnDashOnSelector: number;
declare var kHyphenToEnDashOffSelector: number;
declare var kSlashedZeroOnSelector: number;
declare var kSlashedZeroOffSelector: number;
declare var kFormInterrobangOnSelector: number;
declare var kFormInterrobangOffSelector: number;
declare var kSmartQuotesOnSelector: number;
declare var kSmartQuotesOffSelector: number;
declare var kPeriodsToEllipsisOnSelector: number;
declare var kPeriodsToEllipsisOffSelector: number;
declare var kHyphenToMinusOffSelector: number;
declare var kAsteriskToMultiplyOnSelector: number;
declare var kAsteriskToMultiplyOffSelector: number;
declare var kSlashToDivideOnSelector: number;
declare var kSlashToDivideOffSelector: number;
declare var kInequalityLigaturesOnSelector: number;
declare var kInequalityLigaturesOffSelector: number;
declare var kExponentsOnSelector: number;
declare var kExponentsOffSelector: number;
declare var kMathematicalGreekOnSelector: number;
declare var kMathematicalGreekOffSelector: number;
declare var kDingbatsSelector: number;
declare var kPiCharactersSelector: number;
declare var kFleuronsSelector: number;
declare var kDecorativeBordersSelector: number;
declare var kInternationalSymbolsSelector: number;
declare var kMathSymbolsSelector: number;
declare var kDesignLevel2Selector: number;
declare var kDesignLevel3Selector: number;
declare var kDesignLevel4Selector: number;
declare var kDesignLevel5Selector: number;
declare var kDisplayTextSelector: number;
declare var kEngravedTextSelector: number;
declare var kIlluminatedCapsSelector: number;
declare var kTitlingCapsSelector: number;
declare var kTallCapsSelector: number;
declare var kSimplifiedCharactersSelector: number;
declare var kJIS1978CharactersSelector: number;
declare var kJIS1983CharactersSelector: number;
declare var kJIS1990CharactersSelector: number;
declare var kTraditionalAltOneSelector: number;
declare var kTraditionalAltTwoSelector: number;
declare var kTraditionalAltThreeSelector: number;
declare var kTraditionalAltFourSelector: number;
declare var kTraditionalAltFiveSelector: number;
declare var kExpertCharactersSelector: number;
declare var kJIS2004CharactersSelector: number;
declare var kHojoCharactersSelector: number;
declare var kNLCCharactersSelector: number;
declare var kTraditionalNamesCharactersSelector: number;
declare var kUpperCaseNumbersSelector: number;
declare var kMonospacedTextSelector: number;
declare var kHalfWidthTextSelector: number;
declare var kThirdWidthTextSelector: number;
declare var kQuarterWidthTextSelector: number;
declare var kAltProportionalTextSelector: number;
declare var kAltHalfWidthTextSelector: number;
declare var kHanjaToHangulSelector: number;
declare var kHiraganaToKatakanaSelector: number;
declare var kKatakanaToHiraganaSelector: number;
declare var kKanaToRomanizationSelector: number;
declare var kRomanizationToHiraganaSelector: number;
declare var kRomanizationToKatakanaSelector: number;
declare var kHanjaToHangulAltOneSelector: number;
declare var kHanjaToHangulAltTwoSelector: number;
declare var kHanjaToHangulAltThreeSelector: number;
declare var kBoxAnnotationSelector: number;
declare var kRoundedBoxAnnotationSelector: number;
declare var kCircleAnnotationSelector: number;
declare var kInvertedCircleAnnotationSelector: number;
declare var kParenthesisAnnotationSelector: number;
declare var kPeriodAnnotationSelector: number;
declare var kRomanNumeralAnnotationSelector: number;
declare var kDiamondAnnotationSelector: number;
declare var kInvertedBoxAnnotationSelector: number;
declare var kInvertedRoundedBoxAnnotationSelector: number;
declare var kProportionalKanaSelector: number;
declare var kProportionalIdeographsSelector: number;
declare var kHalfWidthIdeographsSelector: number;
declare var kCanonicalCompositionOffSelector: number;
declare var kCompatibilityCompositionOnSelector: number;
declare var kCompatibilityCompositionOffSelector: number;
declare var kTranscodingCompositionOnSelector: number;
declare var kTranscodingCompositionOffSelector: number;
declare var kRubyKanaSelector: number;
declare var kRubyKanaOnSelector: number;
declare var kRubyKanaOffSelector: number;
declare var kCJKSymbolAltOneSelector: number;
declare var kCJKSymbolAltTwoSelector: number;
declare var kCJKSymbolAltThreeSelector: number;
declare var kCJKSymbolAltFourSelector: number;
declare var kCJKSymbolAltFiveSelector: number;
declare var kIdeographicAltOneSelector: number;
declare var kIdeographicAltTwoSelector: number;
declare var kIdeographicAltThreeSelector: number;
declare var kIdeographicAltFourSelector: number;
declare var kIdeographicAltFiveSelector: number;
declare var kCJKVerticalRomanHBaselineSelector: number;
declare var kCJKItalicRomanSelector: number;
declare var kCJKItalicRomanOnSelector: number;
declare var kCJKItalicRomanOffSelector: number;
declare var kCaseSensitiveLayoutOffSelector: number;
declare var kCaseSensitiveSpacingOnSelector: number;
declare var kCaseSensitiveSpacingOffSelector: number;
declare var kAlternateHorizKanaOffSelector: number;
declare var kAlternateVertKanaOnSelector: number;
declare var kAlternateVertKanaOffSelector: number;
declare var kStylisticAltOneOnSelector: number;
declare var kStylisticAltOneOffSelector: number;
declare var kStylisticAltTwoOnSelector: number;
declare var kStylisticAltTwoOffSelector: number;
declare var kStylisticAltThreeOnSelector: number;
declare var kStylisticAltThreeOffSelector: number;
declare var kStylisticAltFourOnSelector: number;
declare var kStylisticAltFourOffSelector: number;
declare var kStylisticAltFiveOnSelector: number;
declare var kStylisticAltFiveOffSelector: number;
declare var kStylisticAltSixOnSelector: number;
declare var kStylisticAltSixOffSelector: number;
declare var kStylisticAltSevenOnSelector: number;
declare var kStylisticAltSevenOffSelector: number;
declare var kStylisticAltEightOnSelector: number;
declare var kStylisticAltEightOffSelector: number;
declare var kStylisticAltNineOnSelector: number;
declare var kStylisticAltNineOffSelector: number;
declare var kStylisticAltTenOnSelector: number;
declare var kStylisticAltTenOffSelector: number;
declare var kStylisticAltElevenOnSelector: number;
declare var kStylisticAltElevenOffSelector: number;
declare var kStylisticAltTwelveOnSelector: number;
declare var kStylisticAltTwelveOffSelector: number;
declare var kStylisticAltThirteenOnSelector: number;
declare var kStylisticAltThirteenOffSelector: number;
declare var kStylisticAltFourteenOnSelector: number;
declare var kStylisticAltFourteenOffSelector: number;
declare var kStylisticAltFifteenOnSelector: number;
declare var kStylisticAltFifteenOffSelector: number;
declare var kStylisticAltSixteenOnSelector: number;
declare var kStylisticAltSixteenOffSelector: number;
declare var kStylisticAltSeventeenOnSelector: number;
declare var kStylisticAltSeventeenOffSelector: number;
declare var kStylisticAltEighteenOnSelector: number;
declare var kStylisticAltEighteenOffSelector: number;
declare var kStylisticAltNineteenOnSelector: number;
declare var kStylisticAltNineteenOffSelector: number;
declare var kStylisticAltTwentyOnSelector: number;
declare var kStylisticAltTwentyOffSelector: number;
declare var kContextualAlternatesOffSelector: number;
declare var kSwashAlternatesOnSelector: number;
declare var kSwashAlternatesOffSelector: number;
declare var kContextualSwashAlternatesOnSelector: number;
declare var kContextualSwashAlternatesOffSelector: number;
declare var kLowerCaseSmallCapsSelector: number;
declare var kLowerCasePetiteCapsSelector: number;
declare var kUpperCaseSmallCapsSelector: number;
declare var kUpperCasePetiteCapsSelector: number;
declare var kProportionalCJKRomanSelector: number;
declare var kDefaultCJKRomanSelector: number;
declare var kFullWidthCJKRomanSelector: number;
declare var kSFNTLookupSegmentSingle: number;
declare var kSFNTLookupSegmentArray: number;
declare var kSFNTLookupSingleTable: number;
declare var kSFNTLookupTrimmedArray: number;
declare var kSTClassOutOfBounds: number;
declare var kSTClassDeletedGlyph: number;
declare var kSTClassEndOfLine: number;
declare var kSTSetMark: number;
declare var kSTNoAdvance: number;
declare var kSTMarkEnd: number;
declare var kSTLigActionMask: number;
declare var kSTRearrVerbMask: number;
declare var kLCARCurrentVersion: number;
declare var kLCARLinearFormat: number;
declare var kLCARCtlPointFormat: number;
declare var kJUSTCurrentVersion: number;
declare var kJUSTStandardFormat: number;
declare var kJUSTnoGlyphcode: number;
declare var kJUSTpcDecompositionAction: number;
declare var kJUSTpcUnconditionalAddAction: number;
declare var kJUSTpcConditionalAddAction: number;
declare var kJUSTpcGlyphStretchAction: number;
declare var kJUSTpcDuctilityAction: number;
declare var kJUSTpcGlyphRepeatAddAction: number;
declare var kJUSTSpacePriority: number;
declare var kJUSTLetterPriority: number;
declare var kJUSTNullPriority: number;
declare var kJUSTPriorityCount: number;
declare var kJUSTOverrideLimits: number;
declare var kJUSTOverrideUnlimited: number;
declare var kJUSTUnlimited: number;
declare var kJUSTPriorityMask: number;
declare var kOPBDCurrentVersion: number;
declare var kOPBDDistanceFormat: number;
declare var kOPBDControlPointFormat: number;
declare var kMORTCurrentVersion: number;
declare var kMORTCoverVertical: number;
declare var kMORTCoverDescending: number;
declare var kMORTCoverIgnoreVertical: number;
declare var kMORTCoverTypeMask: number;
declare var kMORTRearrangementType: number;
declare var kMORTContextualType: number;
declare var kMORTLigatureType: number;
declare var kMORTSwashType: number;
declare var kMORTInsertionType: number;
declare var kMORTLigLastAction: number;
declare var kMORTLigStoreLigature: number;
declare var kMORTLigFormOffsetMask: number;
declare var kMORTLigFormOffsetShift: number;
declare var kMORTraNoAction: number;
declare var kMORTraxA: number;
declare var kMORTraDx: number;
declare var kMORTraDxA: number;
declare var kMORTraxAB: number;
declare var kMORTraxBA: number;
declare var kMORTraCDx: number;
declare var kMORTraDCx: number;
declare var kMORTraCDxA: number;
declare var kMORTraDCxA: number;
declare var kMORTraDxAB: number;
declare var kMORTraDxBA: number;
declare var kMORTraCDxAB: number;
declare var kMORTraCDxBA: number;
declare var kMORTraDCxAB: number;
declare var kMORTraDCxBA: number;
declare var kMORTDoInsertionsBefore: number;
declare var kMORTIsSplitVowelPiece: number;
declare var kMORTInsertionsCountMask: number;
declare var kMORTCurrInsertKashidaLike: number;
declare var kMORTMarkInsertKashidaLike: number;
declare var kMORTCurrInsertBefore: number;
declare var kMORTMarkInsertBefore: number;
declare var kMORTMarkJustTableCountMask: number;
declare var kMORTMarkJustTableCountShift: number;
declare var kMORTCurrJustTableCountMask: number;
declare var kMORTCurrJustTableCountShift: number;
declare var kMORTCurrInsertCountMask: number;
declare var kMORTCurrInsertCountShift: number;
declare var kMORTMarkInsertCountMask: number;
declare var kMORTMarkInsertCountShift: number;
declare var kMORXCurrentVersion: number;
declare var kMORXCoverVertical: number;
declare var kMORXCoverDescending: number;
declare var kMORXCoverIgnoreVertical: number;
declare var kMORXCoverTypeMask: number;
declare var kPROPCurrentVersion: number;
declare var kPROPPairOffsetShift: number;
declare var kPROPPairOffsetSign: number;
declare var kPROPIsFloaterMask: number;
declare var kPROPCanHangLTMask: number;
declare var kPROPCanHangRBMask: number;
declare var kPROPUseRLPairMask: number;
declare var kPROPPairOffsetMask: number;
declare var kPROPRightConnectMask: number;
declare var kPROPZeroReserved: number;
declare var kPROPDirectionMask: number;
declare var kPROPRDirectionClass: number;
declare var kPROPALDirectionClass: number;
declare var kPROPENDirectionClass: number;
declare var kPROPESDirectionClass: number;
declare var kPROPETDirectionClass: number;
declare var kPROPANDirectionClass: number;
declare var kPROPCSDirectionClass: number;
declare var kPROPPSDirectionClass: number;
declare var kPROPSDirectionClass: number;
declare var kPROPWSDirectionClass: number;
declare var kPROPONDirectionClass: number;
declare var kPROPSENDirectionClass: number;
declare var kPROPLREDirectionClass: number;
declare var kPROPLRODirectionClass: number;
declare var kPROPRLEDirectionClass: number;
declare var kPROPRLODirectionClass: number;
declare var kPROPPDFDirectionClass: number;
declare var kPROPNSMDirectionClass: number;
declare var kPROPBNDirectionClass: number;
declare var kPROPNumDirectionClasses: number;
declare var kTRAKCurrentVersion: number;
declare var kTRAKUniformFormat: number;
declare var kKERNCurrentVersion: number;
declare var kKERNVertical: number;
declare var kKERNResetCrossStream: number;
declare var kKERNCrossStream: number;
declare var kKERNVariation: number;
declare var kKERNUnusedBits: number;
declare var kKERNFormatMask: number;
declare var kKERNStateTable: number;
declare var kKERNSimpleArray: number;
declare var kKERNIndexArray: number;
declare var kKERNLineEndKerning: number;
declare var kKERNNoCrossKerning: number;
declare var kKERNNotesRequested: number;
declare var kKERNNoStakeNote: number;
declare var kKERNCrossStreamResetNote: number;
declare var kKERNNotApplied: number;
declare var kKERXCurrentVersion: number;
declare var kKERXVertical: number;
declare var kKERXResetCrossStream: number;
declare var kKERXCrossStream: number;
declare var kKERXVariation: number;
declare var kKERXDescending: number;
declare var kKERXUnusedBits: number;
declare var kKERXFormatMask: number;
declare var kKERXStateTable: number;
declare var kKERXSimpleArray: number;
declare var kKERXIndexArray: number;
declare var kKERXControlPoint: number;
declare var kKERXLineEndKerning: number;
declare var kKERXNoCrossKerning: number;
declare var kKERXNotesRequested: number;
declare var kKERXNoStakeNote: number;
declare var kKERXCrossStreamResetNote: number;
declare var kKERXNotApplied: number;
declare var kKERXActionTypeControlPoints: number;
declare var kKERXActionTypeAnchorPoints: number;
declare var kKERXActionTypeCoordinates: number;
declare var kKERXUnusedFlags: number;
declare var kKERXActionOffsetMask: number;
declare var kBSLNCurrentVersion: number;
declare var kBSLNDistanceFormatNoMap: number;
declare var kBSLNDistanceFormatWithMap: number;
declare var kBSLNControlPointFormatNoMap: number;
declare var kBSLNControlPointFormatWithMap: number;
declare var kBSLNIdeographicCenterBaseline: number;
declare var kBSLNIdeographicLowBaseline: number;
declare var kBSLNHangingBaseline: number;
declare var kBSLNMathBaseline: number;
declare var kBSLNIdeographicHighBaseline: number;
declare var kBSLNLastBaseline: number;
declare var kBSLNNumBaselineClasses: number;
declare var kBSLNNoBaseline: number;
declare var kBSLNNoBaselineOverride: number;
declare var kFontMacintoshPlatform: number;
declare var kFontReservedPlatform: number;
declare var kFontMicrosoftPlatform: number;
declare var kFontCustomPlatform: number;
declare var kFontUnicodeV1_1Semantics: number;
declare var kFontISO10646_1993Semantics: number;
declare var kFontUnicodeV2_0BMPOnlySemantics: number;
declare var kFontUnicodeV2_0FullCoverageSemantics: number;
declare var kFontUnicodeV4_0VariationSequenceSemantics: number;
declare var kFontUnicode_FullRepertoire: number;
declare var kFontJapaneseScript: number;
declare var kFontTraditionalChineseScript: number;
declare var kFontChineseScript: number;
declare var kFontKoreanScript: number;
declare var kFontArabicScript: number;
declare var kFontHebrewScript: number;
declare var kFontGreekScript: number;
declare var kFontCyrillicScript: number;
declare var kFontRussian: number;
declare var kFontRSymbolScript: number;
declare var kFontDevanagariScript: number;
declare var kFontGurmukhiScript: number;
declare var kFontGujaratiScript: number;
declare var kFontOriyaScript: number;
declare var kFontBengaliScript: number;
declare var kFontTamilScript: number;
declare var kFontTeluguScript: number;
declare var kFontKannadaScript: number;
declare var kFontMalayalamScript: number;
declare var kFontSinhaleseScript: number;
declare var kFontBurmeseScript: number;
declare var kFontKhmerScript: number;
declare var kFontThaiScript: number;
declare var kFontLaotianScript: number;
declare var kFontGeorgianScript: number;
declare var kFontArmenianScript: number;
declare var kFontSimpleChineseScript: number;
declare var kFontTibetanScript: number;
declare var kFontMongolianScript: number;
declare var kFontGeezScript: number;
declare var kFontEthiopicScript: number;
declare var kFontAmharicScript: number;
declare var kFontSlavicScript: number;
declare var kFontEastEuropeanRomanScript: number;
declare var kFontVietnameseScript: number;
declare var kFontExtendedArabicScript: number;
declare var kFontSindhiScript: number;
declare var kFontUninterpretedScript: number;
declare var kFontMicrosoftStandardScript: number;
declare var kFontMicrosoftUCS4Script: number;
declare var kFontCustom816BitScript: number;
declare var kFontCustom16BitScript: number;
declare var kFontFrenchLanguage: number;
declare var kFontGermanLanguage: number;
declare var kFontItalianLanguage: number;
declare var kFontDutchLanguage: number;
declare var kFontSwedishLanguage: number;
declare var kFontSpanishLanguage: number;
declare var kFontDanishLanguage: number;
declare var kFontPortugueseLanguage: number;
declare var kFontNorwegianLanguage: number;
declare var kFontHebrewLanguage: number;
declare var kFontJapaneseLanguage: number;
declare var kFontArabicLanguage: number;
declare var kFontFinnishLanguage: number;
declare var kFontGreekLanguage: number;
declare var kFontIcelandicLanguage: number;
declare var kFontMalteseLanguage: number;
declare var kFontTurkishLanguage: number;
declare var kFontCroatianLanguage: number;
declare var kFontTradChineseLanguage: number;
declare var kFontUrduLanguage: number;
declare var kFontHindiLanguage: number;
declare var kFontThaiLanguage: number;
declare var kFontKoreanLanguage: number;
declare var kFontLithuanianLanguage: number;
declare var kFontPolishLanguage: number;
declare var kFontHungarianLanguage: number;
declare var kFontEstonianLanguage: number;
declare var kFontLettishLanguage: number;
declare var kFontLatvianLanguage: number;
declare var kFontSaamiskLanguage: number;
declare var kFontLappishLanguage: number;
declare var kFontFaeroeseLanguage: number;
declare var kFontFarsiLanguage: number;
declare var kFontPersianLanguage: number;
declare var kFontRussianLanguage: number;
declare var kFontSimpChineseLanguage: number;
declare var kFontFlemishLanguage: number;
declare var kFontIrishLanguage: number;
declare var kFontAlbanianLanguage: number;
declare var kFontRomanianLanguage: number;
declare var kFontCzechLanguage: number;
declare var kFontSlovakLanguage: number;
declare var kFontSlovenianLanguage: number;
declare var kFontYiddishLanguage: number;
declare var kFontSerbianLanguage: number;
declare var kFontMacedonianLanguage: number;
declare var kFontBulgarianLanguage: number;
declare var kFontUkrainianLanguage: number;
declare var kFontByelorussianLanguage: number;
declare var kFontUzbekLanguage: number;
declare var kFontKazakhLanguage: number;
declare var kFontAzerbaijaniLanguage: number;
declare var kFontAzerbaijanArLanguage: number;
declare var kFontArmenianLanguage: number;
declare var kFontGeorgianLanguage: number;
declare var kFontMoldavianLanguage: number;
declare var kFontKirghizLanguage: number;
declare var kFontTajikiLanguage: number;
declare var kFontTurkmenLanguage: number;
declare var kFontMongolianLanguage: number;
declare var kFontMongolianCyrLanguage: number;
declare var kFontPashtoLanguage: number;
declare var kFontKurdishLanguage: number;
declare var kFontKashmiriLanguage: number;
declare var kFontSindhiLanguage: number;
declare var kFontTibetanLanguage: number;
declare var kFontNepaliLanguage: number;
declare var kFontSanskritLanguage: number;
declare var kFontMarathiLanguage: number;
declare var kFontBengaliLanguage: number;
declare var kFontAssameseLanguage: number;
declare var kFontGujaratiLanguage: number;
declare var kFontPunjabiLanguage: number;
declare var kFontOriyaLanguage: number;
declare var kFontMalayalamLanguage: number;
declare var kFontKannadaLanguage: number;
declare var kFontTamilLanguage: number;
declare var kFontTeluguLanguage: number;
declare var kFontSinhaleseLanguage: number;
declare var kFontBurmeseLanguage: number;
declare var kFontKhmerLanguage: number;
declare var kFontLaoLanguage: number;
declare var kFontVietnameseLanguage: number;
declare var kFontIndonesianLanguage: number;
declare var kFontTagalogLanguage: number;
declare var kFontMalayRomanLanguage: number;
declare var kFontMalayArabicLanguage: number;
declare var kFontAmharicLanguage: number;
declare var kFontTigrinyaLanguage: number;
declare var kFontGallaLanguage: number;
declare var kFontOromoLanguage: number;
declare var kFontSomaliLanguage: number;
declare var kFontSwahiliLanguage: number;
declare var kFontRuandaLanguage: number;
declare var kFontRundiLanguage: number;
declare var kFontChewaLanguage: number;
declare var kFontMalagasyLanguage: number;
declare var kFontEsperantoLanguage: number;
declare var kFontWelshLanguage: number;
declare var kFontBasqueLanguage: number;
declare var kFontCatalanLanguage: number;
declare var kFontLatinLanguage: number;
declare var kFontQuechuaLanguage: number;
declare var kFontGuaraniLanguage: number;
declare var kFontAymaraLanguage: number;
declare var kFontTatarLanguage: number;
declare var kFontUighurLanguage: number;
declare var kFontDzongkhaLanguage: number;
declare var kFontJavaneseRomLanguage: number;
declare var kFontSundaneseRomLanguage: number;
declare var kFontNoScriptCode: number;
declare var kFontNoLanguageCode: number;
declare var kFontFamilyName: number;
declare var kFontStyleName: number;
declare var kFontUniqueName: number;
declare var kFontFullName: number;
declare var kFontVersionName: number;
declare var kFontPostscriptName: number;
declare var kFontTrademarkName: number;
declare var kFontManufacturerName: number;
declare var kFontDesignerName: number;
declare var kFontDescriptionName: number;
declare var kFontVendorURLName: number;
declare var kFontDesignerURLName: number;
declare var kFontLicenseDescriptionName: number;
declare var kFontLicenseInfoURLName: number;
declare var kFontPreferredFamilyName: number;
declare var kFontPreferredSubfamilyName: number;
declare var kFontMacCompatibleFullName: number;
declare var kFontSampleTextName: number;
declare var kFontPostScriptCIDName: number;
declare var kFontLastReservedName: number;
declare var ALAssetsGroupAlbum: number;
declare var ALAssetsGroupEvent: number;
declare var ALAssetsGroupFaces: number;
declare var ALAssetsGroupSavedPhotos: number;
declare var ALAssetsGroupPhotoStream: number;
declare var ALAssetsGroupAll: number;
declare var ALAssetsLibraryWriteFailedError: number;
declare var ALAssetsLibraryWriteBusyError: number;
declare var ALAssetsLibraryWriteInvalidDataError: number;
declare var ALAssetsLibraryWriteIncompatibleDataError: number;
declare var ALAssetsLibraryWriteDataEncodingError: number;
declare var ALAssetsLibraryWriteDiskSpaceError: number;
declare var ALAssetsLibraryDataUnavailableError: number;
declare var ALAssetsLibraryAccessUserDeniedError: number;
declare var ALAssetsLibraryAccessGloballyDeniedError: number;
declare var kAudio_FileNotFoundError: number;
declare var kAudio_FilePermissionError: number;
declare var kAudio_TooManyFilesOpenError: number;
declare var kAudio_BadFilePathError: number;
declare var kAudio_ParamError: number;
declare var kAudio_MemFullError: number;
declare var kAudioFormatAC3: number;
declare var kAudioFormat60958AC3: number;
declare var kAudioFormatAppleIMA4: number;
declare var kAudioFormatMPEG4AAC: number;
declare var kAudioFormatMPEG4CELP: number;
declare var kAudioFormatMPEG4HVXC: number;
declare var kAudioFormatMPEG4TwinVQ: number;
declare var kAudioFormatMACE3: number;
declare var kAudioFormatMACE6: number;
declare var kAudioFormatULaw: number;
declare var kAudioFormatALaw: number;
declare var kAudioFormatQDesign: number;
declare var kAudioFormatQDesign2: number;
declare var kAudioFormatQUALCOMM: number;
declare var kAudioFormatMPEGLayer1: number;
declare var kAudioFormatMPEGLayer2: number;
declare var kAudioFormatMPEGLayer3: number;
declare var kAudioFormatTimeCode: number;
declare var kAudioFormatMIDIStream: number;
declare var kAudioFormatParameterValueStream: number;
declare var kAudioFormatAppleLossless: number;
declare var kAudioFormatMPEG4AAC_HE: number;
declare var kAudioFormatMPEG4AAC_LD: number;
declare var kAudioFormatMPEG4AAC_ELD: number;
declare var kAudioFormatMPEG4AAC_ELD_SBR: number;
declare var kAudioFormatMPEG4AAC_ELD_V2: number;
declare var kAudioFormatMPEG4AAC_HE_V2: number;
declare var kAudioFormatMPEG4AAC_Spatial: number;
declare var kAudioFormatAMR: number;
declare var kAudioFormatAMR_WB: number;
declare var kAudioFormatAudible: number;
declare var kAudioFormatiLBC: number;
declare var kAudioFormatDVIIntelIMA: number;
declare var kAudioFormatMicrosoftGSM: number;
declare var kAudioFormatAES3: number;
declare var kAudioFormatFlagIsBigEndian: number;
declare var kAudioFormatFlagIsSignedInteger: number;
declare var kAudioFormatFlagIsPacked: number;
declare var kAudioFormatFlagIsAlignedHigh: number;
declare var kAudioFormatFlagIsNonInterleaved: number;
declare var kAudioFormatFlagIsNonMixable: number;
declare var kAudioFormatFlagsAreAllClear: number;
declare var kLinearPCMFormatFlagIsFloat: number;
declare var kLinearPCMFormatFlagIsBigEndian: number;
declare var kLinearPCMFormatFlagIsSignedInteger: number;
declare var kLinearPCMFormatFlagIsPacked: number;
declare var kLinearPCMFormatFlagIsAlignedHigh: number;
declare var kLinearPCMFormatFlagIsNonInterleaved: number;
declare var kLinearPCMFormatFlagIsNonMixable: number;
declare var kLinearPCMFormatFlagsSampleFractionShift: number;
declare var kLinearPCMFormatFlagsSampleFractionMask: number;
declare var kLinearPCMFormatFlagsAreAllClear: number;
declare var kAppleLosslessFormatFlag_16BitSourceData: number;
declare var kAppleLosslessFormatFlag_20BitSourceData: number;
declare var kAppleLosslessFormatFlag_24BitSourceData: number;
declare var kAppleLosslessFormatFlag_32BitSourceData: number;
declare var kAudioFormatFlagsCanonical: number;
declare var kAudioFormatFlagsAudioUnitCanonical: number;
declare var kAudioFormatFlagsNativeFloatPacked: number;
declare var kSMPTETimeType25: number;
declare var kSMPTETimeType30Drop: number;
declare var kSMPTETimeType30: number;
declare var kSMPTETimeType2997: number;
declare var kSMPTETimeType2997Drop: number;
declare var kSMPTETimeType60: number;
declare var kSMPTETimeType5994: number;
declare var kSMPTETimeType60Drop: number;
declare var kSMPTETimeType5994Drop: number;
declare var kSMPTETimeType50: number;
declare var kSMPTETimeType2398: number;
declare var kSMPTETimeRunning: number;
declare var kAudioTimeStampHostTimeValid: number;
declare var kAudioTimeStampRateScalarValid: number;
declare var kAudioTimeStampWordClockTimeValid: number;
declare var kAudioTimeStampSMPTETimeValid: number;
declare var kAudioChannelLabel_Unused: number;
declare var kAudioChannelLabel_UseCoordinates: number;
declare var kAudioChannelLabel_Left: number;
declare var kAudioChannelLabel_Right: number;
declare var kAudioChannelLabel_Center: number;
declare var kAudioChannelLabel_LFEScreen: number;
declare var kAudioChannelLabel_LeftSurround: number;
declare var kAudioChannelLabel_RightSurround: number;
declare var kAudioChannelLabel_LeftCenter: number;
declare var kAudioChannelLabel_RightCenter: number;
declare var kAudioChannelLabel_CenterSurround: number;
declare var kAudioChannelLabel_LeftSurroundDirect: number;
declare var kAudioChannelLabel_RightSurroundDirect: number;
declare var kAudioChannelLabel_TopCenterSurround: number;
declare var kAudioChannelLabel_VerticalHeightLeft: number;
declare var kAudioChannelLabel_VerticalHeightCenter: number;
declare var kAudioChannelLabel_VerticalHeightRight: number;
declare var kAudioChannelLabel_TopBackLeft: number;
declare var kAudioChannelLabel_TopBackCenter: number;
declare var kAudioChannelLabel_TopBackRight: number;
declare var kAudioChannelLabel_RearSurroundLeft: number;
declare var kAudioChannelLabel_RearSurroundRight: number;
declare var kAudioChannelLabel_LeftWide: number;
declare var kAudioChannelLabel_RightWide: number;
declare var kAudioChannelLabel_LFE2: number;
declare var kAudioChannelLabel_LeftTotal: number;
declare var kAudioChannelLabel_RightTotal: number;
declare var kAudioChannelLabel_HearingImpaired: number;
declare var kAudioChannelLabel_Narration: number;
declare var kAudioChannelLabel_Mono: number;
declare var kAudioChannelLabel_DialogCentricMix: number;
declare var kAudioChannelLabel_CenterSurroundDirect: number;
declare var kAudioChannelLabel_Haptic: number;
declare var kAudioChannelLabel_Ambisonic_W: number;
declare var kAudioChannelLabel_Ambisonic_X: number;
declare var kAudioChannelLabel_Ambisonic_Y: number;
declare var kAudioChannelLabel_Ambisonic_Z: number;
declare var kAudioChannelLabel_MS_Mid: number;
declare var kAudioChannelLabel_MS_Side: number;
declare var kAudioChannelLabel_XY_X: number;
declare var kAudioChannelLabel_XY_Y: number;
declare var kAudioChannelLabel_HeadphonesLeft: number;
declare var kAudioChannelLabel_HeadphonesRight: number;
declare var kAudioChannelLabel_ClickTrack: number;
declare var kAudioChannelLabel_ForeignLanguage: number;
declare var kAudioChannelLabel_Discrete: number;
declare var kAudioChannelLabel_Discrete_0: number;
declare var kAudioChannelLabel_Discrete_1: number;
declare var kAudioChannelLabel_Discrete_2: number;
declare var kAudioChannelLabel_Discrete_3: number;
declare var kAudioChannelLabel_Discrete_4: number;
declare var kAudioChannelLabel_Discrete_5: number;
declare var kAudioChannelLabel_Discrete_6: number;
declare var kAudioChannelLabel_Discrete_7: number;
declare var kAudioChannelLabel_Discrete_8: number;
declare var kAudioChannelLabel_Discrete_9: number;
declare var kAudioChannelLabel_Discrete_10: number;
declare var kAudioChannelLabel_Discrete_11: number;
declare var kAudioChannelLabel_Discrete_12: number;
declare var kAudioChannelLabel_Discrete_13: number;
declare var kAudioChannelLabel_Discrete_14: number;
declare var kAudioChannelLabel_Discrete_15: number;
declare var kAudioChannelLabel_Discrete_65535: number;
declare var kAudioChannelBit_Right: number;
declare var kAudioChannelBit_Center: number;
declare var kAudioChannelBit_LFEScreen: number;
declare var kAudioChannelBit_LeftSurround: number;
declare var kAudioChannelBit_RightSurround: number;
declare var kAudioChannelBit_LeftCenter: number;
declare var kAudioChannelBit_RightCenter: number;
declare var kAudioChannelBit_CenterSurround: number;
declare var kAudioChannelBit_LeftSurroundDirect: number;
declare var kAudioChannelBit_RightSurroundDirect: number;
declare var kAudioChannelBit_TopCenterSurround: number;
declare var kAudioChannelBit_VerticalHeightLeft: number;
declare var kAudioChannelBit_VerticalHeightCenter: number;
declare var kAudioChannelBit_VerticalHeightRight: number;
declare var kAudioChannelBit_TopBackLeft: number;
declare var kAudioChannelBit_TopBackCenter: number;
declare var kAudioChannelBit_TopBackRight: number;
declare var kAudioChannelFlags_RectangularCoordinates: number;
declare var kAudioChannelFlags_SphericalCoordinates: number;
declare var kAudioChannelFlags_Meters: number;
declare var kAudioChannelCoordinates_BackFront: number;
declare var kAudioChannelCoordinates_DownUp: number;
declare var kAudioChannelCoordinates_Azimuth: number;
declare var kAudioChannelCoordinates_Elevation: number;
declare var kAudioChannelCoordinates_Distance: number;
declare var kAudioChannelLayoutTag_UseChannelBitmap: number;
declare var kAudioChannelLayoutTag_Mono: number;
declare var kAudioChannelLayoutTag_Stereo: number;
declare var kAudioChannelLayoutTag_StereoHeadphones: number;
declare var kAudioChannelLayoutTag_MatrixStereo: number;
declare var kAudioChannelLayoutTag_MidSide: number;
declare var kAudioChannelLayoutTag_XY: number;
declare var kAudioChannelLayoutTag_Binaural: number;
declare var kAudioChannelLayoutTag_Ambisonic_B_Format: number;
declare var kAudioChannelLayoutTag_Quadraphonic: number;
declare var kAudioChannelLayoutTag_Pentagonal: number;
declare var kAudioChannelLayoutTag_Hexagonal: number;
declare var kAudioChannelLayoutTag_Octagonal: number;
declare var kAudioChannelLayoutTag_Cube: number;
declare var kAudioChannelLayoutTag_MPEG_1_0: number;
declare var kAudioChannelLayoutTag_MPEG_2_0: number;
declare var kAudioChannelLayoutTag_MPEG_3_0_A: number;
declare var kAudioChannelLayoutTag_MPEG_3_0_B: number;
declare var kAudioChannelLayoutTag_MPEG_4_0_A: number;
declare var kAudioChannelLayoutTag_MPEG_4_0_B: number;
declare var kAudioChannelLayoutTag_MPEG_5_0_A: number;
declare var kAudioChannelLayoutTag_MPEG_5_0_B: number;
declare var kAudioChannelLayoutTag_MPEG_5_0_C: number;
declare var kAudioChannelLayoutTag_MPEG_5_0_D: number;
declare var kAudioChannelLayoutTag_MPEG_5_1_A: number;
declare var kAudioChannelLayoutTag_MPEG_5_1_B: number;
declare var kAudioChannelLayoutTag_MPEG_5_1_C: number;
declare var kAudioChannelLayoutTag_MPEG_5_1_D: number;
declare var kAudioChannelLayoutTag_MPEG_6_1_A: number;
declare var kAudioChannelLayoutTag_MPEG_7_1_A: number;
declare var kAudioChannelLayoutTag_MPEG_7_1_B: number;
declare var kAudioChannelLayoutTag_MPEG_7_1_C: number;
declare var kAudioChannelLayoutTag_Emagic_Default_7_1: number;
declare var kAudioChannelLayoutTag_SMPTE_DTV: number;
declare var kAudioChannelLayoutTag_ITU_1_0: number;
declare var kAudioChannelLayoutTag_ITU_2_0: number;
declare var kAudioChannelLayoutTag_ITU_2_1: number;
declare var kAudioChannelLayoutTag_ITU_2_2: number;
declare var kAudioChannelLayoutTag_ITU_3_0: number;
declare var kAudioChannelLayoutTag_ITU_3_1: number;
declare var kAudioChannelLayoutTag_ITU_3_2: number;
declare var kAudioChannelLayoutTag_ITU_3_2_1: number;
declare var kAudioChannelLayoutTag_ITU_3_4_1: number;
declare var kAudioChannelLayoutTag_DVD_0: number;
declare var kAudioChannelLayoutTag_DVD_1: number;
declare var kAudioChannelLayoutTag_DVD_2: number;
declare var kAudioChannelLayoutTag_DVD_3: number;
declare var kAudioChannelLayoutTag_DVD_4: number;
declare var kAudioChannelLayoutTag_DVD_5: number;
declare var kAudioChannelLayoutTag_DVD_6: number;
declare var kAudioChannelLayoutTag_DVD_7: number;
declare var kAudioChannelLayoutTag_DVD_8: number;
declare var kAudioChannelLayoutTag_DVD_9: number;
declare var kAudioChannelLayoutTag_DVD_10: number;
declare var kAudioChannelLayoutTag_DVD_11: number;
declare var kAudioChannelLayoutTag_DVD_12: number;
declare var kAudioChannelLayoutTag_DVD_13: number;
declare var kAudioChannelLayoutTag_DVD_14: number;
declare var kAudioChannelLayoutTag_DVD_15: number;
declare var kAudioChannelLayoutTag_DVD_16: number;
declare var kAudioChannelLayoutTag_DVD_17: number;
declare var kAudioChannelLayoutTag_DVD_18: number;
declare var kAudioChannelLayoutTag_DVD_19: number;
declare var kAudioChannelLayoutTag_DVD_20: number;
declare var kAudioChannelLayoutTag_AudioUnit_4: number;
declare var kAudioChannelLayoutTag_AudioUnit_5: number;
declare var kAudioChannelLayoutTag_AudioUnit_6: number;
declare var kAudioChannelLayoutTag_AudioUnit_8: number;
declare var kAudioChannelLayoutTag_AudioUnit_5_0: number;
declare var kAudioChannelLayoutTag_AudioUnit_6_0: number;
declare var kAudioChannelLayoutTag_AudioUnit_7_0: number;
declare var kAudioChannelLayoutTag_AudioUnit_7_0_Front: number;
declare var kAudioChannelLayoutTag_AudioUnit_5_1: number;
declare var kAudioChannelLayoutTag_AudioUnit_6_1: number;
declare var kAudioChannelLayoutTag_AudioUnit_7_1: number;
declare var kAudioChannelLayoutTag_AudioUnit_7_1_Front: number;
declare var kAudioChannelLayoutTag_AAC_3_0: number;
declare var kAudioChannelLayoutTag_AAC_Quadraphonic: number;
declare var kAudioChannelLayoutTag_AAC_4_0: number;
declare var kAudioChannelLayoutTag_AAC_5_0: number;
declare var kAudioChannelLayoutTag_AAC_5_1: number;
declare var kAudioChannelLayoutTag_AAC_6_0: number;
declare var kAudioChannelLayoutTag_AAC_6_1: number;
declare var kAudioChannelLayoutTag_AAC_7_0: number;
declare var kAudioChannelLayoutTag_AAC_7_1: number;
declare var kAudioChannelLayoutTag_AAC_7_1_B: number;
declare var kAudioChannelLayoutTag_AAC_7_1_C: number;
declare var kAudioChannelLayoutTag_AAC_Octagonal: number;
declare var kAudioChannelLayoutTag_TMH_10_2_std: number;
declare var kAudioChannelLayoutTag_TMH_10_2_full: number;
declare var kAudioChannelLayoutTag_AC3_1_0_1: number;
declare var kAudioChannelLayoutTag_AC3_3_0: number;
declare var kAudioChannelLayoutTag_AC3_3_1: number;
declare var kAudioChannelLayoutTag_AC3_3_0_1: number;
declare var kAudioChannelLayoutTag_AC3_2_1_1: number;
declare var kAudioChannelLayoutTag_AC3_3_1_1: number;
declare var kAudioChannelLayoutTag_EAC_6_0_A: number;
declare var kAudioChannelLayoutTag_EAC_7_0_A: number;
declare var kAudioChannelLayoutTag_EAC3_6_1_A: number;
declare var kAudioChannelLayoutTag_EAC3_6_1_B: number;
declare var kAudioChannelLayoutTag_EAC3_6_1_C: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_A: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_B: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_C: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_D: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_E: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_F: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_G: number;
declare var kAudioChannelLayoutTag_EAC3_7_1_H: number;
declare var kAudioChannelLayoutTag_DTS_3_1: number;
declare var kAudioChannelLayoutTag_DTS_4_1: number;
declare var kAudioChannelLayoutTag_DTS_6_0_A: number;
declare var kAudioChannelLayoutTag_DTS_6_0_B: number;
declare var kAudioChannelLayoutTag_DTS_6_0_C: number;
declare var kAudioChannelLayoutTag_DTS_6_1_A: number;
declare var kAudioChannelLayoutTag_DTS_6_1_B: number;
declare var kAudioChannelLayoutTag_DTS_6_1_C: number;
declare var kAudioChannelLayoutTag_DTS_7_0: number;
declare var kAudioChannelLayoutTag_DTS_7_1: number;
declare var kAudioChannelLayoutTag_DTS_8_0_A: number;
declare var kAudioChannelLayoutTag_DTS_8_0_B: number;
declare var kAudioChannelLayoutTag_DTS_8_1_A: number;
declare var kAudioChannelLayoutTag_DTS_8_1_B: number;
declare var kAudioChannelLayoutTag_DTS_6_1_D: number;
declare var kAudioChannelLayoutTag_DiscreteInOrder: number;
declare var kAudioChannelLayoutTag_Unknown: number;
declare var kMPEG4Object_AAC_LC: number;
declare var kMPEG4Object_AAC_SSR: number;
declare var kMPEG4Object_AAC_LTP: number;
declare var kMPEG4Object_AAC_SBR: number;
declare var kMPEG4Object_AAC_Scalable: number;
declare var kMPEG4Object_TwinVQ: number;
declare var kMPEG4Object_CELP: number;
declare var kMPEG4Object_HVXC: number;
declare var kAudioFileAIFCType: number;
declare var kAudioFileWAVEType: number;
declare var kAudioFileSoundDesigner2Type: number;
declare var kAudioFileNextType: number;
declare var kAudioFileMP3Type: number;
declare var kAudioFileMP2Type: number;
declare var kAudioFileMP1Type: number;
declare var kAudioFileAC3Type: number;
declare var kAudioFileAAC_ADTSType: number;
declare var kAudioFileMPEG4Type: number;
declare var kAudioFileM4AType: number;
declare var kAudioFileM4BType: number;
declare var kAudioFileCAFType: number;
declare var kAudioFile3GPType: number;
declare var kAudioFile3GP2Type: number;
declare var kAudioFileAMRType: number;
declare var kAudioFileUnsupportedFileTypeError: number;
declare var kAudioFileUnsupportedDataFormatError: number;
declare var kAudioFileUnsupportedPropertyError: number;
declare var kAudioFileBadPropertySizeError: number;
declare var kAudioFilePermissionsError: number;
declare var kAudioFileNotOptimizedError: number;
declare var kAudioFileInvalidChunkError: number;
declare var kAudioFileDoesNotAllow64BitDataSizeError: number;
declare var kAudioFileInvalidPacketOffsetError: number;
declare var kAudioFileInvalidFileError: number;
declare var kAudioFileOperationNotSupportedError: number;
declare var kAudioFileNotOpenError: number;
declare var kAudioFileEndOfFileError: number;
declare var kAudioFilePositionError: number;
declare var kAudioFileFileNotFoundError: number;
declare var kAudioFileFlags_DontPageAlignAudioData: number;
declare var kAudioFileWritePermission: number;
declare var kAudioFileReadWritePermission: number;
declare var kAudioFileLoopDirection_Forward: number;
declare var kAudioFileLoopDirection_ForwardAndBackward: number;
declare var kAudioFileLoopDirection_Backward: number;
declare var kAudioFileRegionFlag_PlayForward: number;
declare var kAudioFileRegionFlag_PlayBackward: number;
declare var kAudioFilePropertyDataFormat: number;
declare var kAudioFilePropertyIsOptimized: number;
declare var kAudioFilePropertyMagicCookieData: number;
declare var kAudioFilePropertyAudioDataByteCount: number;
declare var kAudioFilePropertyAudioDataPacketCount: number;
declare var kAudioFilePropertyMaximumPacketSize: number;
declare var kAudioFilePropertyDataOffset: number;
declare var kAudioFilePropertyChannelLayout: number;
declare var kAudioFilePropertyDeferSizeUpdates: number;
declare var kAudioFilePropertyDataFormatName: number;
declare var kAudioFilePropertyMarkerList: number;
declare var kAudioFilePropertyRegionList: number;
declare var kAudioFilePropertyPacketToFrame: number;
declare var kAudioFilePropertyFrameToPacket: number;
declare var kAudioFilePropertyPacketToByte: number;
declare var kAudioFilePropertyByteToPacket: number;
declare var kAudioFilePropertyChunkIDs: number;
declare var kAudioFilePropertyInfoDictionary: number;
declare var kAudioFilePropertyPacketTableInfo: number;
declare var kAudioFilePropertyFormatList: number;
declare var kAudioFilePropertyPacketSizeUpperBound: number;
declare var kAudioFilePropertyReserveDuration: number;
declare var kAudioFilePropertyEstimatedDuration: number;
declare var kAudioFilePropertyBitRate: number;
declare var kAudioFilePropertyID3Tag: number;
declare var kAudioFilePropertySourceBitDepth: number;
declare var kAudioFilePropertyAlbumArtwork: number;
declare var kAudioFilePropertyAudioTrackCount: number;
declare var kAudioFilePropertyUseAudioTrack: number;
declare var kAudioFileGlobalInfo_WritableTypes: number;
declare var kAudioFileGlobalInfo_FileTypeName: number;
declare var kAudioFileGlobalInfo_AvailableStreamDescriptionsForFormat: number;
declare var kAudioFileGlobalInfo_AvailableFormatIDs: number;
declare var kAudioFileGlobalInfo_AllExtensions: number;
declare var kAudioFileGlobalInfo_AllHFSTypeCodes: number;
declare var kAudioFileGlobalInfo_AllUTIs: number;
declare var kAudioFileGlobalInfo_AllMIMETypes: number;
declare var kAudioFileGlobalInfo_ExtensionsForType: number;
declare var kAudioFileGlobalInfo_HFSTypeCodesForType: number;
declare var kAudioFileGlobalInfo_UTIsForType: number;
declare var kAudioFileGlobalInfo_MIMETypesForType: number;
declare var kAudioFileGlobalInfo_TypesForMIMEType: number;
declare var kAudioFileGlobalInfo_TypesForUTI: number;
declare var kAudioFileGlobalInfo_TypesForHFSTypeCode: number;
declare var kAudioFileGlobalInfo_TypesForExtension: number;
declare var kAudioFileStreamPropertyFlag_CacheProperty: number;
declare var kAudioFileStreamParseFlag_Discontinuity: number;
declare var kAudioFileStreamSeekFlag_OffsetIsEstimated: number;
declare var kAudioFileStreamError_UnsupportedDataFormat: number;
declare var kAudioFileStreamError_UnsupportedProperty: number;
declare var kAudioFileStreamError_BadPropertySize: number;
declare var kAudioFileStreamError_NotOptimized: number;
declare var kAudioFileStreamError_InvalidPacketOffset: number;
declare var kAudioFileStreamError_InvalidFile: number;
declare var kAudioFileStreamError_ValueUnknown: number;
declare var kAudioFileStreamError_DataUnavailable: number;
declare var kAudioFileStreamError_IllegalOperation: number;
declare var kAudioFileStreamError_UnspecifiedError: number;
declare var kAudioFileStreamError_DiscontinuityCantRecover: number;
declare var kAudioFileStreamProperty_FileFormat: number;
declare var kAudioFileStreamProperty_DataFormat: number;
declare var kAudioFileStreamProperty_FormatList: number;
declare var kAudioFileStreamProperty_MagicCookieData: number;
declare var kAudioFileStreamProperty_AudioDataByteCount: number;
declare var kAudioFileStreamProperty_AudioDataPacketCount: number;
declare var kAudioFileStreamProperty_MaximumPacketSize: number;
declare var kAudioFileStreamProperty_DataOffset: number;
declare var kAudioFileStreamProperty_ChannelLayout: number;
declare var kAudioFileStreamProperty_PacketToFrame: number;
declare var kAudioFileStreamProperty_FrameToPacket: number;
declare var kAudioFileStreamProperty_PacketToByte: number;
declare var kAudioFileStreamProperty_ByteToPacket: number;
declare var kAudioFileStreamProperty_PacketTableInfo: number;
declare var kAudioFileStreamProperty_PacketSizeUpperBound: number;
declare var kAudioFileStreamProperty_AverageBytesPerPacket: number;
declare var kAudioFileStreamProperty_BitRate: number;
declare var kAudioFileStreamProperty_InfoDictionary: number;
declare var kPanningMode_VectorBasedPanning: number;
declare var kAudioBalanceFadeType_EqualPower: number;
declare var kAudioFormatProperty_FormatName: number;
declare var kAudioFormatProperty_EncodeFormatIDs: number;
declare var kAudioFormatProperty_DecodeFormatIDs: number;
declare var kAudioFormatProperty_FormatList: number;
declare var kAudioFormatProperty_ASBDFromESDS: number;
declare var kAudioFormatProperty_ChannelLayoutFromESDS: number;
declare var kAudioFormatProperty_OutputFormatList: number;
declare var kAudioFormatProperty_FirstPlayableFormatFromList: number;
declare var kAudioFormatProperty_FormatIsVBR: number;
declare var kAudioFormatProperty_FormatIsExternallyFramed: number;
declare var kAudioFormatProperty_FormatIsEncrypted: number;
declare var kAudioFormatProperty_Encoders: number;
declare var kAudioFormatProperty_Decoders: number;
declare var kAudioFormatProperty_AvailableEncodeBitRates: number;
declare var kAudioFormatProperty_AvailableEncodeSampleRates: number;
declare var kAudioFormatProperty_AvailableEncodeChannelLayoutTags: number;
declare var kAudioFormatProperty_AvailableEncodeNumberChannels: number;
declare var kAudioFormatProperty_ASBDFromMPEGPacket: number;
declare var kAudioFormatProperty_BitmapForLayoutTag: number;
declare var kAudioFormatProperty_MatrixMixMap: number;
declare var kAudioFormatProperty_ChannelMap: number;
declare var kAudioFormatProperty_NumberOfChannelsForLayout: number;
declare var kAudioFormatProperty_AreChannelLayoutsEquivalent: number;
declare var kAudioFormatProperty_ChannelLayoutHash: number;
declare var kAudioFormatProperty_ValidateChannelLayout: number;
declare var kAudioFormatProperty_ChannelLayoutForTag: number;
declare var kAudioFormatProperty_TagForChannelLayout: number;
declare var kAudioFormatProperty_ChannelLayoutName: number;
declare var kAudioFormatProperty_ChannelLayoutSimpleName: number;
declare var kAudioFormatProperty_ChannelLayoutForBitmap: number;
declare var kAudioFormatProperty_ChannelName: number;
declare var kAudioFormatProperty_ChannelShortName: number;
declare var kAudioFormatProperty_TagsForNumberOfChannels: number;
declare var kAudioFormatProperty_PanningMatrix: number;
declare var kAudioFormatProperty_BalanceFade: number;
declare var kAudioFormatProperty_ID3TagSize: number;
declare var kAudioFormatProperty_ID3TagToDictionary: number;
declare var kAudioEncoderComponentType: number;
declare var kAppleHardwareAudioCodecManufacturer: number;
declare var kAudioFormatUnsupportedPropertyError: number;
declare var kAudioFormatBadPropertySizeError: number;
declare var kAudioFormatBadSpecifierSizeError: number;
declare var kAudioFormatUnsupportedDataFormatError: number;
declare var kAudioFormatUnknownFormatError: number;
declare var kAudioQueueErr_BufferEmpty: number;
declare var kAudioQueueErr_DisposalPending: number;
declare var kAudioQueueErr_InvalidProperty: number;
declare var kAudioQueueErr_InvalidPropertySize: number;
declare var kAudioQueueErr_InvalidParameter: number;
declare var kAudioQueueErr_CannotStart: number;
declare var kAudioQueueErr_InvalidDevice: number;
declare var kAudioQueueErr_BufferInQueue: number;
declare var kAudioQueueErr_InvalidRunState: number;
declare var kAudioQueueErr_InvalidQueueType: number;
declare var kAudioQueueErr_Permissions: number;
declare var kAudioQueueErr_InvalidPropertyValue: number;
declare var kAudioQueueErr_PrimeTimedOut: number;
declare var kAudioQueueErr_CodecNotFound: number;
declare var kAudioQueueErr_InvalidCodecAccess: number;
declare var kAudioQueueErr_QueueInvalidated: number;
declare var kAudioQueueErr_TooManyTaps: number;
declare var kAudioQueueErr_InvalidTapContext: number;
declare var kAudioQueueErr_RecordUnderrun: number;
declare var kAudioQueueErr_InvalidTapType: number;
declare var kAudioQueueErr_BufferEnqueuedTwice: number;
declare var kAudioQueueErr_EnqueueDuringReset: number;
declare var kAudioQueueErr_InvalidOfflineMode: number;
declare var kAudioQueueDeviceProperty_SampleRate: number;
declare var kAudioQueueDeviceProperty_NumberChannels: number;
declare var kAudioQueueProperty_CurrentDevice: number;
declare var kAudioQueueProperty_MagicCookie: number;
declare var kAudioQueueProperty_MaximumOutputPacketSize: number;
declare var kAudioQueueProperty_StreamDescription: number;
declare var kAudioQueueProperty_ChannelLayout: number;
declare var kAudioQueueProperty_EnableLevelMetering: number;
declare var kAudioQueueProperty_CurrentLevelMeter: number;
declare var kAudioQueueProperty_CurrentLevelMeterDB: number;
declare var kAudioQueueProperty_DecodeBufferSizeFrames: number;
declare var kAudioQueueProperty_ConverterError: number;
declare var kAudioQueueProperty_EnableTimePitch: number;
declare var kAudioQueueProperty_TimePitchAlgorithm: number;
declare var kAudioQueueProperty_TimePitchBypass: number;
declare var kAudioQueueTimePitchAlgorithm_TimeDomain: number;
declare var kAudioQueueTimePitchAlgorithm_LowQualityZeroLatency: number;
declare var kAudioQueueTimePitchAlgorithm_Varispeed: number;
declare var kAudioQueueHardwareCodecPolicy_UseSoftwareOnly: number;
declare var kAudioQueueHardwareCodecPolicy_UseHardwareOnly: number;
declare var kAudioQueueHardwareCodecPolicy_PreferSoftware: number;
declare var kAudioQueueHardwareCodecPolicy_PreferHardware: number;
declare var kAudioQueueParam_PlayRate: number;
declare var kAudioQueueParam_Pitch: number;
declare var kAudioQueueParam_VolumeRampTime: number;
declare var kAudioQueueParam_Pan: number;
declare var kAudioQueueProcessingTap_PostEffects: number;
declare var kAudioQueueProcessingTap_Siphon: number;
declare var kAudioQueueProcessingTap_StartOfStream: number;
declare var kAudioQueueProcessingTap_EndOfStream: number;
declare var kAudioSessionNotInitialized: number;
declare var kAudioSessionAlreadyInitialized: number;
declare var kAudioSessionInitializationError: number;
declare var kAudioSessionUnsupportedPropertyError: number;
declare var kAudioSessionBadPropertySizeError: number;
declare var kAudioSessionNotActiveError: number;
declare var kAudioServicesNoHardwareError: number;
declare var kAudioSessionNoCategorySet: number;
declare var kAudioSessionIncompatibleCategory: number;
declare var kAudioSessionUnspecifiedError: number;
declare var kAudioSessionEndInterruption: number;
declare var kAudioSessionCategory_SoloAmbientSound: number;
declare var kAudioSessionCategory_MediaPlayback: number;
declare var kAudioSessionCategory_RecordAudio: number;
declare var kAudioSessionCategory_PlayAndRecord: number;
declare var kAudioSessionCategory_AudioProcessing: number;
declare var kAudioSessionOverrideAudioRoute_Speaker: number;
declare var kAudioSessionRouteChangeReason_NewDeviceAvailable: number;
declare var kAudioSessionRouteChangeReason_OldDeviceUnavailable: number;
declare var kAudioSessionRouteChangeReason_CategoryChange: number;
declare var kAudioSessionRouteChangeReason_Override: number;
declare var kAudioSessionRouteChangeReason_WakeFromSleep: number;
declare var kAudioSessionRouteChangeReason_NoSuitableRouteForCategory: number;
declare var kAudioSessionRouteChangeReason_RouteConfigurationChange: number;
declare var kAudioSessionInterruptionType_ShouldNotResume: number;
declare var kAudioSessionMode_VoiceChat: number;
declare var kAudioSessionMode_VideoRecording: number;
declare var kAudioSessionMode_Measurement: number;
declare var kAudioSessionMode_GameChat: number;
declare var kAudioSessionProperty_PreferredHardwareIOBufferDuration: number;
declare var kAudioSessionProperty_AudioCategory: number;
declare var kAudioSessionProperty_AudioRouteChange: number;
declare var kAudioSessionProperty_CurrentHardwareSampleRate: number;
declare var kAudioSessionProperty_CurrentHardwareInputNumberChannels: number;
declare var kAudioSessionProperty_CurrentHardwareOutputNumberChannels: number;
declare var kAudioSessionProperty_CurrentHardwareOutputVolume: number;
declare var kAudioSessionProperty_CurrentHardwareInputLatency: number;
declare var kAudioSessionProperty_CurrentHardwareOutputLatency: number;
declare var kAudioSessionProperty_CurrentHardwareIOBufferDuration: number;
declare var kAudioSessionProperty_OtherAudioIsPlaying: number;
declare var kAudioSessionProperty_OverrideAudioRoute: number;
declare var kAudioSessionProperty_AudioInputAvailable: number;
declare var kAudioSessionProperty_ServerDied: number;
declare var kAudioSessionProperty_OtherMixableAudioShouldDuck: number;
declare var kAudioSessionProperty_OverrideCategoryMixWithOthers: number;
declare var kAudioSessionProperty_OverrideCategoryDefaultToSpeaker: number;
declare var kAudioSessionProperty_OverrideCategoryEnableBluetoothInput: number;
declare var kAudioSessionProperty_InterruptionType: number;
declare var kAudioSessionProperty_Mode: number;
declare var kAudioSessionProperty_InputSources: number;
declare var kAudioSessionProperty_OutputDestinations: number;
declare var kAudioSessionProperty_InputSource: number;
declare var kAudioSessionProperty_OutputDestination: number;
declare var kAudioSessionProperty_InputGainAvailable: number;
declare var kAudioSessionProperty_InputGainScalar: number;
declare var kAudioSessionProperty_AudioRouteDescription: number;
declare var kAudioSessionCategory_LiveAudio: number;
declare var kAudioServicesUnsupportedPropertyError: number;
declare var kAudioServicesBadPropertySizeError: number;
declare var kAudioServicesBadSpecifierSizeError: number;
declare var kAudioServicesSystemSoundUnspecifiedError: number;
declare var kAudioServicesSystemSoundClientTimedOutError: number;
declare var kAudioServicesPropertyCompletePlaybackIfAppDies: number;
declare var kAUGraphErr_InvalidConnection: number;
declare var kAUGraphErr_OutputNodeErr: number;
declare var kAUGraphErr_CannotDoInCurrentContext: number;
declare var kAUGraphErr_InvalidAudioUnit: number;
declare var kAUNodeInteraction_InputCallback: number;
declare var kAudioConverterPropertyMinimumOutputBufferSize: number;
declare var kAudioConverterPropertyMaximumInputBufferSize: number;
declare var kAudioConverterPropertyMaximumInputPacketSize: number;
declare var kAudioConverterPropertyMaximumOutputPacketSize: number;
declare var kAudioConverterPropertyCalculateInputBufferSize: number;
declare var kAudioConverterPropertyCalculateOutputBufferSize: number;
declare var kAudioConverterPropertyInputCodecParameters: number;
declare var kAudioConverterPropertyOutputCodecParameters: number;
declare var kAudioConverterSampleRateConverterAlgorithm: number;
declare var kAudioConverterSampleRateConverterComplexity: number;
declare var kAudioConverterSampleRateConverterQuality: number;
declare var kAudioConverterSampleRateConverterInitialPhase: number;
declare var kAudioConverterCodecQuality: number;
declare var kAudioConverterPrimeMethod: number;
declare var kAudioConverterPrimeInfo: number;
declare var kAudioConverterChannelMap: number;
declare var kAudioConverterDecompressionMagicCookie: number;
declare var kAudioConverterCompressionMagicCookie: number;
declare var kAudioConverterEncodeBitRate: number;
declare var kAudioConverterEncodeAdjustableSampleRate: number;
declare var kAudioConverterInputChannelLayout: number;
declare var kAudioConverterOutputChannelLayout: number;
declare var kAudioConverterApplicableEncodeBitRates: number;
declare var kAudioConverterAvailableEncodeBitRates: number;
declare var kAudioConverterApplicableEncodeSampleRates: number;
declare var kAudioConverterAvailableEncodeSampleRates: number;
declare var kAudioConverterAvailableEncodeChannelLayoutTags: number;
declare var kAudioConverterCurrentOutputStreamDescription: number;
declare var kAudioConverterCurrentInputStreamDescription: number;
declare var kAudioConverterPropertySettings: number;
declare var kAudioConverterPropertyBitDepthHint: number;
declare var kAudioConverterPropertyFormatList: number;
declare var kAudioConverterQuality_High: number;
declare var kAudioConverterQuality_Medium: number;
declare var kAudioConverterQuality_Low: number;
declare var kAudioConverterQuality_Min: number;
declare var kAudioConverterSampleRateConverterComplexity_Normal: number;
declare var kAudioConverterSampleRateConverterComplexity_Mastering: number;
declare var kConverterPrimeMethod_Normal: number;
declare var kConverterPrimeMethod_None: number;
declare var kAudioConverterErr_OperationNotSupported: number;
declare var kAudioConverterErr_PropertyNotSupported: number;
declare var kAudioConverterErr_InvalidInputSize: number;
declare var kAudioConverterErr_InvalidOutputSize: number;
declare var kAudioConverterErr_UnspecifiedError: number;
declare var kAudioConverterErr_BadPropertySizeError: number;
declare var kAudioConverterErr_RequiresPacketDescriptionsError: number;
declare var kAudioConverterErr_InputSampleRateOutOfRange: number;
declare var kAudioConverterErr_OutputSampleRateOutOfRange: number;
declare var kAudioConverterErr_NoHardwarePermission: number;
declare var kExtAudioFileProperty_FileChannelLayout: number;
declare var kExtAudioFileProperty_ClientDataFormat: number;
declare var kExtAudioFileProperty_ClientChannelLayout: number;
declare var kExtAudioFileProperty_CodecManufacturer: number;
declare var kExtAudioFileProperty_AudioConverter: number;
declare var kExtAudioFileProperty_AudioFile: number;
declare var kExtAudioFileProperty_FileMaxPacketSize: number;
declare var kExtAudioFileProperty_ClientMaxPacketSize: number;
declare var kExtAudioFileProperty_FileLengthFrames: number;
declare var kExtAudioFileProperty_ConverterConfig: number;
declare var kExtAudioFileProperty_IOBufferSizeBytes: number;
declare var kExtAudioFileProperty_IOBuffer: number;
declare var kExtAudioFileProperty_PacketTable: number;
declare var kExtAudioFileError_CodecUnavailableInputNotConsumed: number;
declare var kExtAudioFileError_InvalidProperty: number;
declare var kExtAudioFileError_InvalidPropertySize: number;
declare var kExtAudioFileError_NonPCMClientFormat: number;
declare var kExtAudioFileError_InvalidChannelMap: number;
declare var kExtAudioFileError_InvalidOperationOrder: number;
declare var kExtAudioFileError_InvalidDataFormat: number;
declare var kExtAudioFileError_MaxPacketSizeUnknown: number;
declare var kExtAudioFileError_InvalidSeek: number;
declare var kExtAudioFileError_AsyncWriteTooLarge: number;
declare var kExtAudioFileError_AsyncWriteBufferOverflow: number;
declare var kMusicEventType_ExtendedNote: number;
declare var kMusicEventType_ExtendedTempo: number;
declare var kMusicEventType_User: number;
declare var kMusicEventType_Meta: number;
declare var kMusicEventType_MIDINoteMessage: number;
declare var kMusicEventType_MIDIChannelMessage: number;
declare var kMusicEventType_MIDIRawData: number;
declare var kMusicEventType_Parameter: number;
declare var kMusicEventType_AUPreset: number;
declare var kMusicSequenceType_Seconds: number;
declare var kMusicSequenceType_Samples: number;
declare var kMusicSequenceFile_iMelodyType: number;
declare var kAudioToolboxErr_TrackIndexError: number;
declare var kAudioToolboxErr_TrackNotFound: number;
declare var kAudioToolboxErr_EndOfTrack: number;
declare var kAudioToolboxErr_StartOfTrack: number;
declare var kAudioToolboxErr_IllegalTrackDestination: number;
declare var kAudioToolboxErr_NoSequence: number;
declare var kAudioToolboxErr_InvalidEventType: number;
declare var kAudioToolboxErr_InvalidPlayerState: number;
declare var kAudioToolboxErr_CannotDoInCurrentContext: number;
declare var kSequenceTrackProperty_OffsetTime: number;
declare var kSequenceTrackProperty_MuteStatus: number;
declare var kSequenceTrackProperty_SoloStatus: number;
declare var kSequenceTrackProperty_AutomatedParameters: number;
declare var kSequenceTrackProperty_TrackLength: number;
declare var kSequenceTrackProperty_TimeResolution: number;
declare var kCAF_FileVersion_Initial: number;
declare var kCAF_AudioDataChunkID: number;
declare var kCAF_ChannelLayoutChunkID: number;
declare var kCAF_FillerChunkID: number;
declare var kCAF_MarkerChunkID: number;
declare var kCAF_RegionChunkID: number;
declare var kCAF_InstrumentChunkID: number;
declare var kCAF_MagicCookieID: number;
declare var kCAF_InfoStringsChunkID: number;
declare var kCAF_EditCommentsChunkID: number;
declare var kCAF_PacketTableChunkID: number;
declare var kCAF_StringsChunkID: number;
declare var kCAF_UUIDChunkID: number;
declare var kCAF_PeakChunkID: number;
declare var kCAF_OverviewChunkID: number;
declare var kCAF_MIDIChunkID: number;
declare var kCAF_UMIDChunkID: number;
declare var kCAF_FormatListID: number;
declare var kCAF_iXMLChunkID: number;
declare var kCAFLinearPCMFormatFlagIsLittleEndian: number;
declare var kCAFMarkerType_ProgramStart: number;
declare var kCAFMarkerType_ProgramEnd: number;
declare var kCAFMarkerType_TrackStart: number;
declare var kCAFMarkerType_TrackEnd: number;
declare var kCAFMarkerType_Index: number;
declare var kCAFMarkerType_RegionStart: number;
declare var kCAFMarkerType_RegionEnd: number;
declare var kCAFMarkerType_RegionSyncPoint: number;
declare var kCAFMarkerType_SelectionStart: number;
declare var kCAFMarkerType_SelectionEnd: number;
declare var kCAFMarkerType_EditSourceBegin: number;
declare var kCAFMarkerType_EditSourceEnd: number;
declare var kCAFMarkerType_EditDestinationBegin: number;
declare var kCAFMarkerType_EditDestinationEnd: number;
declare var kCAFMarkerType_SustainLoopStart: number;
declare var kCAFMarkerType_SustainLoopEnd: number;
declare var kCAFMarkerType_ReleaseLoopStart: number;
declare var kCAFMarkerType_ReleaseLoopEnd: number;
declare var kCAFMarkerType_SavedPlayPosition: number;
declare var kCAFMarkerType_Tempo: number;
declare var kCAFMarkerType_TimeSignature: number;
declare var kCAFMarkerType_KeySignature: number;
declare var kCAF_SMPTE_TimeType24: number;
declare var kCAF_SMPTE_TimeType25: number;
declare var kCAF_SMPTE_TimeType30Drop: number;
declare var kCAF_SMPTE_TimeType30: number;
declare var kCAF_SMPTE_TimeType2997: number;
declare var kCAF_SMPTE_TimeType2997Drop: number;
declare var kCAF_SMPTE_TimeType60: number;
declare var kCAF_SMPTE_TimeType5994: number;
declare var kCAF_SMPTE_TimeType60Drop: number;
declare var kCAF_SMPTE_TimeType5994Drop: number;
declare var kCAF_SMPTE_TimeType50: number;
declare var kCAF_SMPTE_TimeType2398: number;
declare var kCAFRegionFlag_PlayForward: number;
declare var kCAFRegionFlag_PlayBackward: number;
declare var kAudioComponentFlag_SandboxSafe: number;
declare var kAudioUnitType_MusicDevice: number;
declare var kAudioUnitType_MusicEffect: number;
declare var kAudioUnitType_FormatConverter: number;
declare var kAudioUnitType_Effect: number;
declare var kAudioUnitType_Mixer: number;
declare var kAudioUnitType_Panner: number;
declare var kAudioUnitType_Generator: number;
declare var kAudioUnitType_OfflineEffect: number;
declare var kAudioUnitType_MIDIProcessor: number;
declare var kAudioUnitType_RemoteGenerator: number;
declare var kAudioUnitType_RemoteInstrument: number;
declare var kAudioUnitType_RemoteMusicEffect: number;
declare var kAudioUnitSubType_RemoteIO: number;
declare var kAudioUnitSubType_VoiceProcessingIO: number;
declare var kAudioUnitSubType_MIDISynth: number;
declare var kAudioUnitSubType_Varispeed: number;
declare var kAudioUnitSubType_DeferredRenderer: number;
declare var kAudioUnitSubType_Splitter: number;
declare var kAudioUnitSubType_Merger: number;
declare var kAudioUnitSubType_NewTimePitch: number;
declare var kAudioUnitSubType_AUiPodTimeOther: number;
declare var kAudioUnitSubType_RoundTripAAC: number;
declare var kAudioUnitSubType_AUiPodTime: number;
declare var kAudioUnitSubType_DynamicsProcessor: number;
declare var kAudioUnitSubType_LowPassFilter: number;
declare var kAudioUnitSubType_HighPassFilter: number;
declare var kAudioUnitSubType_BandPassFilter: number;
declare var kAudioUnitSubType_HighShelfFilter: number;
declare var kAudioUnitSubType_LowShelfFilter: number;
declare var kAudioUnitSubType_ParametricEQ: number;
declare var kAudioUnitSubType_Distortion: number;
declare var kAudioUnitSubType_Delay: number;
declare var kAudioUnitSubType_SampleDelay: number;
declare var kAudioUnitSubType_Reverb2: number;
declare var kAudioUnitSubType_AUiPodEQ: number;
declare var kAudioUnitSubType_NBandEQ: number;
declare var kAudioUnitSubType_MatrixMixer: number;
declare var kAudioUnitSubType_SpatialMixer: number;
declare var kAudioUnitSubType_AU3DMixerEmbedded: number;
declare var kAudioUnitSubType_AudioFilePlayer: number;
declare var kAudioUnitRenderAction_PostRender: number;
declare var kAudioUnitRenderAction_OutputIsSilence: number;
declare var kAudioOfflineUnitRenderAction_Preflight: number;
declare var kAudioOfflineUnitRenderAction_Render: number;
declare var kAudioOfflineUnitRenderAction_Complete: number;
declare var kAudioUnitRenderAction_PostRenderError: number;
declare var kAudioUnitRenderAction_DoNotCheckRenderArgs: number;
declare var kAudioUnitErr_InvalidParameter: number;
declare var kAudioUnitErr_InvalidElement: number;
declare var kAudioUnitErr_NoConnection: number;
declare var kAudioUnitErr_FailedInitialization: number;
declare var kAudioUnitErr_TooManyFramesToProcess: number;
declare var kAudioUnitErr_InvalidFile: number;
declare var kAudioUnitErr_FormatNotSupported: number;
declare var kAudioUnitErr_Uninitialized: number;
declare var kAudioUnitErr_InvalidScope: number;
declare var kAudioUnitErr_PropertyNotWritable: number;
declare var kAudioUnitErr_CannotDoInCurrentContext: number;
declare var kAudioUnitErr_InvalidPropertyValue: number;
declare var kAudioUnitErr_PropertyNotInUse: number;
declare var kAudioUnitErr_Initialized: number;
declare var kAudioUnitErr_InvalidOfflineRender: number;
declare var kAudioUnitErr_Unauthorized: number;
declare var kAudioComponentErr_UnsupportedType: number;
declare var kAudioComponentErr_TooManyInstances: number;
declare var kAudioComponentErr_InstanceInvalidated: number;
declare var kAudioComponentErr_NotPermitted: number;
declare var kAudioComponentErr_InitializationTimedOut: number;
declare var kAudioComponentErr_InvalidFormat: number;
declare var kParameterEvent_Ramped: number;
declare var kAudioUnitInitializeSelect: number;
declare var kAudioUnitUninitializeSelect: number;
declare var kAudioUnitGetPropertyInfoSelect: number;
declare var kAudioUnitGetPropertySelect: number;
declare var kAudioUnitSetPropertySelect: number;
declare var kAudioUnitAddPropertyListenerSelect: number;
declare var kAudioUnitRemovePropertyListenerSelect: number;
declare var kAudioUnitRemovePropertyListenerWithUserDataSelect: number;
declare var kAudioUnitAddRenderNotifySelect: number;
declare var kAudioUnitRemoveRenderNotifySelect: number;
declare var kAudioUnitGetParameterSelect: number;
declare var kAudioUnitSetParameterSelect: number;
declare var kAudioUnitScheduleParametersSelect: number;
declare var kAudioUnitRenderSelect: number;
declare var kAudioUnitResetSelect: number;
declare var kAudioUnitComplexRenderSelect: number;
declare var kAudioUnitProcessSelect: number;
declare var kAudioUnitProcessMultipleSelect: number;
declare var kAudioUnitErr_InstrumentTypeNotFound: number;
declare var kAudioUnitErr_UnknownFileType: number;
declare var kAudioUnitErr_FileNotSpecified: number;
declare var kAudioOutputUnitStartSelect: number;
declare var kAudioOutputUnitStopSelect: number;
declare var kAudioUnitScope_Input: number;
declare var kAudioUnitScope_Output: number;
declare var kAudioUnitScope_Group: number;
declare var kAudioUnitScope_Part: number;
declare var kAudioUnitScope_Note: number;
declare var kAudioUnitScope_Layer: number;
declare var kAudioUnitScope_LayerItem: number;
declare var kAudioUnitProperty_MakeConnection: number;
declare var kAudioUnitProperty_SampleRate: number;
declare var kAudioUnitProperty_ParameterList: number;
declare var kAudioUnitProperty_ParameterInfo: number;
declare var kAudioUnitProperty_CPULoad: number;
declare var kAudioUnitProperty_StreamFormat: number;
declare var kAudioUnitProperty_ElementCount: number;
declare var kAudioUnitProperty_Latency: number;
declare var kAudioUnitProperty_SupportedNumChannels: number;
declare var kAudioUnitProperty_MaximumFramesPerSlice: number;
declare var kAudioUnitProperty_ParameterValueStrings: number;
declare var kAudioUnitProperty_AudioChannelLayout: number;
declare var kAudioUnitProperty_TailTime: number;
declare var kAudioUnitProperty_BypassEffect: number;
declare var kAudioUnitProperty_LastRenderError: number;
declare var kAudioUnitProperty_SetRenderCallback: number;
declare var kAudioUnitProperty_FactoryPresets: number;
declare var kAudioUnitProperty_RenderQuality: number;
declare var kAudioUnitProperty_HostCallbacks: number;
declare var kAudioUnitProperty_InPlaceProcessing: number;
declare var kAudioUnitProperty_ElementName: number;
declare var kAudioUnitProperty_SupportedChannelLayoutTags: number;
declare var kAudioUnitProperty_PresentPreset: number;
declare var kAudioUnitProperty_DependentParameters: number;
declare var kAudioUnitProperty_InputSamplesInOutput: number;
declare var kAudioUnitProperty_ShouldAllocateBuffer: number;
declare var kAudioUnitProperty_FrequencyResponse: number;
declare var kAudioUnitProperty_ParameterHistoryInfo: number;
declare var kAudioUnitProperty_NickName: number;
declare var kAudioUnitProperty_OfflineRender: number;
declare var kAudioUnitProperty_ParameterIDName: number;
declare var kAudioUnitProperty_ParameterStringFromValue: number;
declare var kAudioUnitProperty_ParameterValueFromString: number;
declare var kAudioUnitProperty_IsInterAppConnected: number;
declare var kAudioUnitProperty_PeerURL: number;
declare var kRenderQuality_High: number;
declare var kRenderQuality_Medium: number;
declare var kRenderQuality_Low: number;
declare var kRenderQuality_Min: number;
declare var kAudioUnitParameterUnit_Indexed: number;
declare var kAudioUnitParameterUnit_Boolean: number;
declare var kAudioUnitParameterUnit_Percent: number;
declare var kAudioUnitParameterUnit_Seconds: number;
declare var kAudioUnitParameterUnit_SampleFrames: number;
declare var kAudioUnitParameterUnit_Phase: number;
declare var kAudioUnitParameterUnit_Rate: number;
declare var kAudioUnitParameterUnit_Hertz: number;
declare var kAudioUnitParameterUnit_Cents: number;
declare var kAudioUnitParameterUnit_RelativeSemiTones: number;
declare var kAudioUnitParameterUnit_MIDINoteNumber: number;
declare var kAudioUnitParameterUnit_MIDIController: number;
declare var kAudioUnitParameterUnit_Decibels: number;
declare var kAudioUnitParameterUnit_LinearGain: number;
declare var kAudioUnitParameterUnit_Degrees: number;
declare var kAudioUnitParameterUnit_EqualPowerCrossfade: number;
declare var kAudioUnitParameterUnit_MixerFaderCurve1: number;
declare var kAudioUnitParameterUnit_Pan: number;
declare var kAudioUnitParameterUnit_Meters: number;
declare var kAudioUnitParameterUnit_AbsoluteCents: number;
declare var kAudioUnitParameterUnit_Octaves: number;
declare var kAudioUnitParameterUnit_BPM: number;
declare var kAudioUnitParameterUnit_Beats: number;
declare var kAudioUnitParameterUnit_Milliseconds: number;
declare var kAudioUnitParameterUnit_Ratio: number;
declare var kAudioUnitParameterUnit_CustomUnit: number;
declare var kAudioUnitParameterFlag_OmitFromPresets: number;
declare var kAudioUnitParameterFlag_PlotHistory: number;
declare var kAudioUnitParameterFlag_MeterReadOnly: number;
declare var kAudioUnitParameterFlag_DisplayMask: number;
declare var kAudioUnitParameterFlag_DisplaySquareRoot: number;
declare var kAudioUnitParameterFlag_DisplaySquared: number;
declare var kAudioUnitParameterFlag_DisplayCubed: number;
declare var kAudioUnitParameterFlag_DisplayCubeRoot: number;
declare var kAudioUnitParameterFlag_DisplayExponential: number;
declare var kAudioUnitParameterFlag_HasClump: number;
declare var kAudioUnitParameterFlag_ValuesHaveStrings: number;
declare var kAudioUnitParameterFlag_DisplayLogarithmic: number;
declare var kAudioUnitParameterFlag_IsHighResolution: number;
declare var kAudioUnitParameterFlag_NonRealTime: number;
declare var kAudioUnitParameterFlag_CanRamp: number;
declare var kAudioUnitParameterFlag_ExpertMode: number;
declare var kAudioUnitParameterFlag_HasCFNameString: number;
declare var kAudioUnitParameterFlag_IsGlobalMeta: number;
declare var kAudioUnitParameterFlag_IsElementMeta: number;
declare var kAudioUnitParameterFlag_IsReadable: number;
declare var kAudioUnitParameterFlag_IsWritable: number;
declare var kAudioUnitRemoteControlEvent_ToggleRecord: number;
declare var kAudioUnitRemoteControlEvent_Rewind: number;
declare var kAudioUnitSampleRateConverterComplexity_Normal: number;
declare var kAudioUnitSampleRateConverterComplexity_Mastering: number;
declare var kAudioOutputUnitProperty_ChannelMap: number;
declare var kAudioOutputUnitProperty_EnableIO: number;
declare var kAudioOutputUnitProperty_StartTime: number;
declare var kAudioOutputUnitProperty_SetInputCallback: number;
declare var kAudioOutputUnitProperty_HasIO: number;
declare var kAudioOutputUnitProperty_StartTimestampsAtZero: number;
declare var kAudioOutputUnitProperty_HostReceivesRemoteControlEvents: number;
declare var kAudioOutputUnitProperty_RemoteControlToHost: number;
declare var kAudioOutputUnitProperty_HostTransportState: number;
declare var kAudioOutputUnitProperty_NodeComponentDescription: number;
declare var kAUVoiceIOProperty_VoiceProcessingEnableAGC: number;
declare var kAUVoiceIOProperty_MuteOutput: number;
declare var kAUVoiceIOProperty_VoiceProcessingQuality: number;
declare var kAUNBandEQProperty_MaxNumberOfBands: number;
declare var kAUNBandEQProperty_BiquadCoefficients: number;
declare var kAudioUnitProperty_MatrixLevels: number;
declare var kAudioUnitProperty_MatrixDimensions: number;
declare var kAudioUnitProperty_MeterClipping: number;
declare var kAudioUnitProperty_UsesInternalReverb: number;
declare var kAudioUnitProperty_SpatializationAlgorithm: number;
declare var kAudioUnitProperty_SpatialMixerDistanceParams: number;
declare var kAudioUnitProperty_SpatialMixerAttenuationCurve: number;
declare var kAudioUnitProperty_SpatialMixerRenderingFlags: number;
declare var kSpatializationAlgorithm_SphericalHead: number;
declare var kSpatializationAlgorithm_HRTF: number;
declare var kSpatializationAlgorithm_SoundField: number;
declare var kSpatializationAlgorithm_VectorBasedPanning: number;
declare var kSpatializationAlgorithm_StereoPassThrough: number;
declare var kReverbRoomType_MediumRoom: number;
declare var kReverbRoomType_LargeRoom: number;
declare var kReverbRoomType_MediumHall: number;
declare var kReverbRoomType_LargeHall: number;
declare var kReverbRoomType_Plate: number;
declare var kReverbRoomType_MediumChamber: number;
declare var kReverbRoomType_LargeChamber: number;
declare var kReverbRoomType_Cathedral: number;
declare var kReverbRoomType_LargeRoom2: number;
declare var kReverbRoomType_MediumHall2: number;
declare var kReverbRoomType_MediumHall3: number;
declare var kReverbRoomType_LargeHall2: number;
declare var kSpatialMixerAttenuationCurve_Exponential: number;
declare var kSpatialMixerAttenuationCurve_Inverse: number;
declare var kSpatialMixerAttenuationCurve_Linear: number;
declare var kSpatialMixerRenderingFlags_DistanceAttenuation: number;
declare var kAudioUnitProperty_3DMixerAttenuationCurve: number;
declare var kAudioUnitProperty_DopplerShift: number;
declare var kAudioUnitProperty_3DMixerRenderingFlags: number;
declare var kAudioUnitProperty_3DMixerDistanceAtten: number;
declare var kAudioUnitProperty_ReverbPreset: number;
declare var k3DMixerRenderingFlags_DopplerShift: number;
declare var k3DMixerRenderingFlags_DistanceAttenuation: number;
declare var k3DMixerRenderingFlags_DistanceFilter: number;
declare var k3DMixerRenderingFlags_DistanceDiffusion: number;
declare var k3DMixerRenderingFlags_LinearDistanceAttenuation: number;
declare var k3DMixerRenderingFlags_ConstantReverbBlend: number;
declare var k3DMixerAttenuationCurve_Exponential: number;
declare var k3DMixerAttenuationCurve_Inverse: number;
declare var k3DMixerAttenuationCurve_Linear: number;
declare var kAudioUnitProperty_ScheduleStartTimeStamp: number;
declare var kAudioUnitProperty_CurrentPlayTime: number;
declare var kScheduledAudioSliceFlag_BeganToRender: number;
declare var kScheduledAudioSliceFlag_BeganToRenderLate: number;
declare var kScheduledAudioSliceFlag_Loop: number;
declare var kScheduledAudioSliceFlag_Interrupt: number;
declare var kScheduledAudioSliceFlag_InterruptAtLoop: number;
declare var kAudioUnitProperty_ScheduledFileRegion: number;
declare var kAudioUnitProperty_ScheduledFilePrime: number;
declare var kAudioUnitProperty_ScheduledFileBufferSizeFrames: number;
declare var kAudioUnitProperty_ScheduledFileNumberBuffers: number;
declare var kMusicDeviceProperty_InstrumentNumber: number;
declare var kMusicDeviceProperty_BankName: number;
declare var kMusicDeviceProperty_SoundBankURL: number;
declare var kAUSamplerProperty_LoadAudioFiles: number;
declare var kInstrumentType_SF2Preset: number;
declare var kInstrumentType_AUPreset: number;
declare var kInstrumentType_Audiofile: number;
declare var kInstrumentType_EXS24: number;
declare var kAUSampler_DefaultMelodicBankMSB: number;
declare var kAUSampler_DefaultBankLSB: number;
declare var kAudioUnitProperty_DeferredRendererExtraLatency: number;
declare var kAudioUnitProperty_DeferredRendererWaitFrames: number;
declare var kAUSamplerProperty_BankAndPreset: number;
declare var kAUGroupParameterID_Sustain: number;
declare var kAUGroupParameterID_Sostenuto: number;
declare var kAUGroupParameterID_AllNotesOff: number;
declare var kAUGroupParameterID_ModWheel: number;
declare var kAUGroupParameterID_PitchBend: number;
declare var kAUGroupParameterID_AllSoundOff: number;
declare var kAUGroupParameterID_ResetAllControllers: number;
declare var kAUGroupParameterID_Pan: number;
declare var kAUGroupParameterID_Foot: number;
declare var kAUGroupParameterID_ChannelPressure: number;
declare var kAUGroupParameterID_KeyPressure: number;
declare var kAUGroupParameterID_Expression: number;
declare var kAUGroupParameterID_DataEntry: number;
declare var kAUGroupParameterID_Volume_LSB: number;
declare var kAUGroupParameterID_ModWheel_LSB: number;
declare var kAUGroupParameterID_Pan_LSB: number;
declare var kAUGroupParameterID_Foot_LSB: number;
declare var kAUGroupParameterID_Expression_LSB: number;
declare var kAUGroupParameterID_DataEntry_LSB: number;
declare var kAUGroupParameterID_KeyPressure_FirstKey: number;
declare var kAUGroupParameterID_KeyPressure_LastKey: number;
declare var kSpatialMixerParam_Elevation: number;
declare var kSpatialMixerParam_Distance: number;
declare var kSpatialMixerParam_Gain: number;
declare var kSpatialMixerParam_PlaybackRate: number;
declare var kSpatialMixerParam_Enable: number;
declare var kSpatialMixerParam_MinGain: number;
declare var kSpatialMixerParam_MaxGain: number;
declare var kSpatialMixerParam_ReverbBlend: number;
declare var kSpatialMixerParam_GlobalReverbGain: number;
declare var kSpatialMixerParam_OcclusionAttenuation: number;
declare var kSpatialMixerParam_ObstructionAttenuation: number;
declare var kReverbParam_FilterBandwidth: number;
declare var kReverbParam_FilterGain: number;
declare var kReverbParam_FilterType: number;
declare var kReverbParam_FilterEnable: number;
declare var k3DMixerParam_Elevation: number;
declare var k3DMixerParam_Distance: number;
declare var k3DMixerParam_Gain: number;
declare var k3DMixerParam_PlaybackRate: number;
declare var k3DMixerParam_Enable: number;
declare var k3DMixerParam_MinGain: number;
declare var k3DMixerParam_MaxGain: number;
declare var k3DMixerParam_ReverbBlend: number;
declare var k3DMixerParam_GlobalReverbGain: number;
declare var k3DMixerParam_OcclusionAttenuation: number;
declare var k3DMixerParam_ObstructionAttenuation: number;
declare var kMultiChannelMixerParam_Enable: number;
declare var kMultiChannelMixerParam_Pan: number;
declare var kMultiChannelMixerParam_PreAveragePower: number;
declare var kMultiChannelMixerParam_PrePeakHoldLevel: number;
declare var kMultiChannelMixerParam_PostAveragePower: number;
declare var kMultiChannelMixerParam_PostPeakHoldLevel: number;
declare var kMatrixMixerParam_Enable: number;
declare var kMatrixMixerParam_PreAveragePower: number;
declare var kMatrixMixerParam_PrePeakHoldLevel: number;
declare var kMatrixMixerParam_PostAveragePower: number;
declare var kMatrixMixerParam_PostPeakHoldLevel: number;
declare var kMatrixMixerParam_PreAveragePowerLinear: number;
declare var kMatrixMixerParam_PrePeakHoldLevelLinear: number;
declare var kMatrixMixerParam_PostAveragePowerLinear: number;
declare var kMatrixMixerParam_PostPeakHoldLevelLinear: number;
declare var kNewTimePitchParam_Pitch: number;
declare var kNewTimePitchParam_Overlap: number;
declare var kNewTimePitchParam_EnablePeakLocking: number;
declare var kAUSamplerParam_CoarseTuning: number;
declare var kAUSamplerParam_FineTuning: number;
declare var kAUSamplerParam_Pan: number;
declare var kBandpassParam_Bandwidth: number;
declare var kHipassParam_Resonance: number;
declare var kLowPassParam_Resonance: number;
declare var kHighShelfParam_Gain: number;
declare var kAULowShelfParam_Gain: number;
declare var kParametricEQParam_Q: number;
declare var kParametricEQParam_Gain: number;
declare var kLimiterParam_DecayTime: number;
declare var kLimiterParam_PreGain: number;
declare var kDynamicsProcessorParam_HeadRoom: number;
declare var kDynamicsProcessorParam_ExpansionRatio: number;
declare var kDynamicsProcessorParam_ExpansionThreshold: number;
declare var kDynamicsProcessorParam_AttackTime: number;
declare var kDynamicsProcessorParam_ReleaseTime: number;
declare var kDynamicsProcessorParam_MasterGain: number;
declare var kDynamicsProcessorParam_CompressionAmount: number;
declare var kDynamicsProcessorParam_InputAmplitude: number;
declare var kDynamicsProcessorParam_OutputAmplitude: number;
declare var kVarispeedParam_PlaybackCents: number;
declare var kDistortionParam_Decay: number;
declare var kDistortionParam_DelayMix: number;
declare var kDistortionParam_Decimation: number;
declare var kDistortionParam_Rounding: number;
declare var kDistortionParam_DecimationMix: number;
declare var kDistortionParam_LinearTerm: number;
declare var kDistortionParam_SquaredTerm: number;
declare var kDistortionParam_CubicTerm: number;
declare var kDistortionParam_PolynomialMix: number;
declare var kDistortionParam_RingModFreq1: number;
declare var kDistortionParam_RingModFreq2: number;
declare var kDistortionParam_RingModBalance: number;
declare var kDistortionParam_RingModMix: number;
declare var kDistortionParam_SoftClipGain: number;
declare var kDistortionParam_FinalMix: number;
declare var kDelayParam_DelayTime: number;
declare var kDelayParam_Feedback: number;
declare var kDelayParam_LopassCutoff: number;
declare var kAUNBandEQParam_BypassBand: number;
declare var kAUNBandEQParam_FilterType: number;
declare var kAUNBandEQParam_Frequency: number;
declare var kAUNBandEQParam_Gain: number;
declare var kAUNBandEQParam_Bandwidth: number;
declare var kAUNBandEQFilterType_2ndOrderButterworthLowPass: number;
declare var kAUNBandEQFilterType_2ndOrderButterworthHighPass: number;
declare var kAUNBandEQFilterType_ResonantLowPass: number;
declare var kAUNBandEQFilterType_ResonantHighPass: number;
declare var kAUNBandEQFilterType_BandPass: number;
declare var kAUNBandEQFilterType_BandStop: number;
declare var kAUNBandEQFilterType_LowShelf: number;
declare var kAUNBandEQFilterType_HighShelf: number;
declare var kAUNBandEQFilterType_ResonantLowShelf: number;
declare var kAUNBandEQFilterType_ResonantHighShelf: number;
declare var kNumAUNBandEQFilterTypes: number;
declare var kRoundTripAACParam_EncodingStrategy: number;
declare var kRoundTripAACParam_RateOrQuality: number;
declare var kRandomParam_BoundB: number;
declare var kRandomParam_Curve: number;
declare var kReverb2Param_Gain: number;
declare var kReverb2Param_MinDelayTime: number;
declare var kReverb2Param_MaxDelayTime: number;
declare var kReverb2Param_DecayTimeAt0Hz: number;
declare var kReverb2Param_DecayTimeAtNyquist: number;
declare var kReverb2Param_RandomizeReflections: number;
declare var kMusicNoteEvent_Unused: number;
declare var kMusicDeviceMIDIEventSelect: number;
declare var kMusicDeviceSysExSelect: number;
declare var kMusicDevicePrepareInstrumentSelect: number;
declare var kMusicDeviceReleaseInstrumentSelect: number;
declare var kMusicDeviceStartNoteSelect: number;
declare var kMusicDeviceStopNoteSelect: number;
declare var kCMAttachmentMode_ShouldPropagate: number;
declare var kCMBlockBufferStructureAllocationFailedErr: number;
declare var kCMBlockBufferBlockAllocationFailedErr: number;
declare var kCMBlockBufferBadCustomBlockSourceErr: number;
declare var kCMBlockBufferBadOffsetParameterErr: number;
declare var kCMBlockBufferBadLengthParameterErr: number;
declare var kCMBlockBufferBadPointerParameterErr: number;
declare var kCMBlockBufferEmptyBBufErr: number;
declare var kCMBlockBufferUnallocatedBlockErr: number;
declare var kCMBlockBufferInsufficientSpaceErr: number;
declare var kCMBlockBufferAlwaysCopyDataFlag: number;
declare var kCMBlockBufferDontOptimizeDepthFlag: number;
declare var kCMBlockBufferPermitEmptyReferenceFlag: number;
declare var kCMFormatDescriptionError_AllocationFailed: number;
declare var kCMFormatDescriptionError_ValueNotAvailable: number;
declare var kCMMediaType_Audio: number;
declare var kCMMediaType_Muxed: number;
declare var kCMMediaType_Text: number;
declare var kCMMediaType_ClosedCaption: number;
declare var kCMMediaType_Subtitle: number;
declare var kCMMediaType_TimeCode: number;
declare var kCMMediaType_Metadata: number;
declare var kCMAudioCodecType_AAC_AudibleProtected: number;
declare var kCMAudioFormatDescriptionMask_MagicCookie: number;
declare var kCMAudioFormatDescriptionMask_ChannelLayout: number;
declare var kCMAudioFormatDescriptionMask_Extensions: number;
declare var kCMAudioFormatDescriptionMask_All: number;
declare var kCMPixelFormat_32BGRA: number;
declare var kCMPixelFormat_24RGB: number;
declare var kCMPixelFormat_16BE555: number;
declare var kCMPixelFormat_16BE565: number;
declare var kCMPixelFormat_16LE555: number;
declare var kCMPixelFormat_16LE565: number;
declare var kCMPixelFormat_16LE5551: number;
declare var kCMPixelFormat_422YpCbCr8: number;
declare var kCMPixelFormat_422YpCbCr8_yuvs: number;
declare var kCMPixelFormat_444YpCbCr8: number;
declare var kCMPixelFormat_4444YpCbCrA8: number;
declare var kCMPixelFormat_422YpCbCr16: number;
declare var kCMPixelFormat_422YpCbCr10: number;
declare var kCMPixelFormat_444YpCbCr10: number;
declare var kCMPixelFormat_8IndexedGray_WhiteIsZero: number;
declare var kCMVideoCodecType_Animation: number;
declare var kCMVideoCodecType_Cinepak: number;
declare var kCMVideoCodecType_JPEG: number;
declare var kCMVideoCodecType_JPEG_OpenDML: number;
declare var kCMVideoCodecType_SorensonVideo: number;
declare var kCMVideoCodecType_SorensonVideo3: number;
declare var kCMVideoCodecType_H263: number;
declare var kCMVideoCodecType_H264: number;
declare var kCMVideoCodecType_MPEG4Video: number;
declare var kCMVideoCodecType_MPEG2Video: number;
declare var kCMVideoCodecType_MPEG1Video: number;
declare var kCMVideoCodecType_DVCNTSC: number;
declare var kCMVideoCodecType_DVCPAL: number;
declare var kCMVideoCodecType_DVCProPAL: number;
declare var kCMVideoCodecType_DVCPro50NTSC: number;
declare var kCMVideoCodecType_DVCPro50PAL: number;
declare var kCMVideoCodecType_DVCPROHD720p60: number;
declare var kCMVideoCodecType_DVCPROHD720p50: number;
declare var kCMVideoCodecType_DVCPROHD1080i60: number;
declare var kCMVideoCodecType_DVCPROHD1080i50: number;
declare var kCMVideoCodecType_DVCPROHD1080p30: number;
declare var kCMVideoCodecType_DVCPROHD1080p25: number;
declare var kCMVideoCodecType_AppleProRes4444: number;
declare var kCMVideoCodecType_AppleProRes422HQ: number;
declare var kCMVideoCodecType_AppleProRes422: number;
declare var kCMVideoCodecType_AppleProRes422LT: number;
declare var kCMVideoCodecType_AppleProRes422Proxy: number;
declare var kCMMPEG2VideoProfile_HDV_1080i60: number;
declare var kCMMPEG2VideoProfile_HDV_1080i50: number;
declare var kCMMPEG2VideoProfile_HDV_720p24: number;
declare var kCMMPEG2VideoProfile_HDV_720p25: number;
declare var kCMMPEG2VideoProfile_HDV_1080p24: number;
declare var kCMMPEG2VideoProfile_HDV_1080p25: number;
declare var kCMMPEG2VideoProfile_HDV_1080p30: number;
declare var kCMMPEG2VideoProfile_HDV_720p60: number;
declare var kCMMPEG2VideoProfile_HDV_720p50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD_1080i60_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD_1080i50_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD_1080p24_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD_1080p25_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD_1080p30_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_720p24_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_720p25_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_720p30_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_720p50_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_720p60_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_1080i60_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_1080i50_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_1080p24_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_1080p25_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_EX_1080p30_VBR35: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_720p50_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_720p60_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_1080i60_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_1080i50_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_1080p24_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_1080p25_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_1080p30_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD_540p: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_540p: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_720p24_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_720p25_CBR50: number;
declare var kCMMPEG2VideoProfile_XDCAM_HD422_720p30_CBR50: number;
declare var kCMMPEG2VideoProfile_XF: number;
declare var kCMMuxedStreamType_MPEG2Transport: number;
declare var kCMMuxedStreamType_MPEG2Program: number;
declare var kCMMuxedStreamType_DV: number;
declare var kCMClosedCaptionFormatType_CEA708: number;
declare var kCMClosedCaptionFormatType_ATSC: number;
declare var kCMTextFormatType_3GText: number;
declare var kCMTextDisplayFlag_scrollOut: number;
declare var kCMTextDisplayFlag_scrollDirectionMask: number;
declare var kCMTextDisplayFlag_scrollDirection_bottomToTop: number;
declare var kCMTextDisplayFlag_scrollDirection_rightToLeft: number;
declare var kCMTextDisplayFlag_scrollDirection_topToBottom: number;
declare var kCMTextDisplayFlag_scrollDirection_leftToRight: number;
declare var kCMTextDisplayFlag_continuousKaraoke: number;
declare var kCMTextDisplayFlag_writeTextVertically: number;
declare var kCMTextDisplayFlag_fillTextRegion: number;
declare var kCMTextDisplayFlag_obeySubtitleFormatting: number;
declare var kCMTextDisplayFlag_forcedSubtitlesPresent: number;
declare var kCMTextDisplayFlag_allSubtitlesForced: number;
declare var kCMTextJustification_centered: number;
declare var kCMTextJustification_bottom_right: number;
declare var kCMSubtitleFormatType_WebVTT: number;
declare var kCMTimeCodeFormatType_TimeCode64: number;
declare var kCMTimeCodeFormatType_Counter32: number;
declare var kCMTimeCodeFormatType_Counter64: number;
declare var kCMTimeCodeFlag_24HourMax: number;
declare var kCMTimeCodeFlag_NegTimesOK: number;
declare var kCMMetadataFormatType_ID3: number;
declare var kCMMetadataFormatType_Boxed: number;
declare var kCMSampleBufferError_RequiredParameterMissing: number;
declare var kCMSampleBufferError_AlreadyHasDataBuffer: number;
declare var kCMSampleBufferError_BufferNotReady: number;
declare var kCMSampleBufferError_SampleIndexOutOfRange: number;
declare var kCMSampleBufferError_BufferHasNoSampleSizes: number;
declare var kCMSampleBufferError_BufferHasNoSampleTimingInfo: number;
declare var kCMSampleBufferError_ArrayTooSmall: number;
declare var kCMSampleBufferError_InvalidEntryCount: number;
declare var kCMSampleBufferError_CannotSubdivide: number;
declare var kCMSampleBufferError_SampleTimingInfoInvalid: number;
declare var kCMSampleBufferError_InvalidMediaTypeForOperation: number;
declare var kCMSampleBufferError_InvalidSampleData: number;
declare var kCMSampleBufferError_InvalidMediaFormat: number;
declare var kCMSampleBufferError_Invalidated: number;
declare var kCMSampleBufferError_DataFailed: number;
declare var kCMSampleBufferError_DataCanceled: number;
declare var kCMClockError_InvalidParameter: number;
declare var kCMClockError_AllocationFailed: number;
declare var kCMClockError_UnsupportedOperation: number;
declare var kCMTimebaseError_InvalidParameter: number;
declare var kCMTimebaseError_AllocationFailed: number;
declare var kCMTimebaseError_TimerIntervalTooShort: number;
declare var kCMTimebaseError_ReadOnly: number;
declare var kCMSyncError_InvalidParameter: number;
declare var kCMSyncError_AllocationFailed: number;
declare var kCMSyncError_RateMustBeNonZero: number;
declare var kCMFormatDescriptionBridgeError_AllocationFailed: number;
declare var kCMFormatDescriptionBridgeError_InvalidSerializedSampleDescription: number;
declare var kCMFormatDescriptionBridgeError_InvalidFormatDescription: number;
declare var kCMFormatDescriptionBridgeError_IncompatibleFormatDescription: number;
declare var kCMFormatDescriptionBridgeError_UnsupportedSampleDescriptionFlavor: number;
declare var kCMFormatDescriptionBridgeError_InvalidSlice: number;
declare var kCMBufferQueueError_RequiredParameterMissing: number;
declare var kCMBufferQueueError_InvalidCMBufferCallbacksStruct: number;
declare var kCMBufferQueueError_EnqueueAfterEndOfData: number;
declare var kCMBufferQueueError_QueueIsFull: number;
declare var kCMBufferQueueError_BadTriggerDuration: number;
declare var kCMBufferQueueError_CannotModifyQueueFromTriggerCallback: number;
declare var kCMBufferQueueError_InvalidTriggerCondition: number;
declare var kCMBufferQueueError_InvalidTriggerToken: number;
declare var kCMBufferQueueError_InvalidBuffer: number;
declare var kCMBufferQueueTrigger_WhenDurationBecomesLessThanOrEqualTo: number;
declare var kCMBufferQueueTrigger_WhenDurationBecomesGreaterThan: number;
declare var kCMBufferQueueTrigger_WhenDurationBecomesGreaterThanOrEqualTo: number;
declare var kCMBufferQueueTrigger_WhenMinPresentationTimeStampChanges: number;
declare var kCMBufferQueueTrigger_WhenMaxPresentationTimeStampChanges: number;
declare var kCMBufferQueueTrigger_WhenDataBecomesReady: number;
declare var kCMBufferQueueTrigger_WhenEndOfDataReached: number;
declare var kCMBufferQueueTrigger_WhenReset: number;
declare var kCMBufferQueueTrigger_WhenBufferCountBecomesLessThan: number;
declare var kCMBufferQueueTrigger_WhenBufferCountBecomesGreaterThan: number;
declare var kCMSimpleQueueError_RequiredParameterMissing: number;
declare var kCMSimpleQueueError_ParameterOutOfRange: number;
declare var kCMSimpleQueueError_QueueIsFull: number;
declare var kCMMetadataIdentifierError_RequiredParameterMissing: number;
declare var kCMMetadataIdentifierError_BadKey: number;
declare var kCMMetadataIdentifierError_BadKeyLength: number;
declare var kCMMetadataIdentifierError_BadKeyType: number;
declare var kCMMetadataIdentifierError_BadNumberKey: number;
declare var kCMMetadataIdentifierError_BadKeySpace: number;
declare var kCMMetadataIdentifierError_BadIdentifier: number;
declare var kCMMetadataIdentifierError_NoKeyValueAvailable: number;
declare var kCMMetadataDataTypeRegistryError_RequiredParameterMissing: number;
declare var kCMMetadataDataTypeRegistryError_BadDataTypeIdentifier: number;
declare var kCMMetadataDataTypeRegistryError_DataTypeAlreadyRegistered: number;
declare var kCMMetadataDataTypeRegistryError_RequiresConformingBaseType: number;
declare var kCMMetadataDataTypeRegistryError_MultipleConformingBaseTypes: number;
declare var kMTAudioProcessingTapCreationFlag_PostEffects: number;
declare var kMTAudioProcessingTapFlag_EndOfStream: number;
declare var kCTErrorDomainPOSIX: number;
declare var kCTErrorDomainMach: number;
declare var EKMonday: number;
declare var EKTuesday: number;
declare var EKWednesday: number;
declare var EKThursday: number;
declare var EKFriday: number;
declare var EKSaturday: number;
declare var EKCalendarEventAvailabilityBusy: number;
declare var EKCalendarEventAvailabilityFree: number;
declare var EKCalendarEventAvailabilityTentative: number;
declare var EKCalendarEventAvailabilityUnavailable: number;
declare var EKEntityTypeReminder: number;
declare var EKEntityMaskReminder: number;
declare var EKAlarmProximityEnter: number;
declare var EKAlarmProximityLeave: number;
declare var GKPhotoSizeNormal: number;
declare var GKPeerPickerConnectionTypeNearby: number;
declare var kJSPropertyAttributeReadOnly: number;
declare var kJSPropertyAttributeDontEnum: number;
declare var kJSPropertyAttributeDontDelete: number;
declare var kJSClassAttributeNoAutomaticPrototype: number;
declare var SKErrorClientInvalid: number;
declare var SKErrorPaymentCancelled: number;
declare var SKErrorPaymentInvalid: number;
declare var SKErrorPaymentNotAllowed: number;
declare var SKErrorStoreProductNotAvailable: number;
declare var kSCStatusFailed: number;
declare var kSCStatusInvalidArgument: number;
declare var kSCStatusAccessError: number;
declare var kSCStatusNoKey: number;
declare var kSCStatusKeyExists: number;
declare var kSCStatusLocked: number;
declare var kSCStatusNeedLock: number;
declare var kSCStatusNoStoreSession: number;
declare var kSCStatusNoStoreServer: number;
declare var kSCStatusNotifierActive: number;
declare var kSCStatusNoPrefsSession: number;
declare var kSCStatusPrefsBusy: number;
declare var kSCStatusNoConfigFile: number;
declare var kSCStatusNoLink: number;
declare var kSCStatusStale: number;
declare var kSCStatusMaxLink: number;
declare var kSCStatusReachabilityUnknown: number;
declare var kSCStatusConnectionNoService: number;
declare var kSCStatusConnectionIgnore: number;
declare var kSCPreferencesNotificationApply: number;
declare var kSCBondStatusLinkInvalid: number;
declare var kSCBondStatusNoPartner: number;
declare var kSCBondStatusNotInActiveGroup: number;
declare var kSCBondStatusUnknown: number;
declare var kSCNetworkFlagsReachable: number;
declare var kSCNetworkFlagsConnectionRequired: number;
declare var kSCNetworkFlagsConnectionAutomatic: number;
declare var kSCNetworkFlagsInterventionRequired: number;
declare var kSCNetworkFlagsIsLocalAddress: number;
declare var kSCNetworkFlagsIsDirect: number;
declare var kSCNetworkReachabilityFlagsReachable: number;
declare var kSCNetworkReachabilityFlagsConnectionRequired: number;
declare var kSCNetworkReachabilityFlagsConnectionOnTraffic: number;
declare var kSCNetworkReachabilityFlagsInterventionRequired: number;
declare var kSCNetworkReachabilityFlagsConnectionOnDemand: number;
declare var kSCNetworkReachabilityFlagsIsLocalAddress: number;
declare var kSCNetworkReachabilityFlagsIsDirect: number;
declare var kSCNetworkReachabilityFlagsIsWWAN: number;
declare var kSCNetworkReachabilityFlagsConnectionAutomatic: number;
declare var kSCNetworkConnectionDisconnected: number;
declare var kSCNetworkConnectionConnecting: number;
declare var kSCNetworkConnectionConnected: number;
declare var kSCNetworkConnectionDisconnecting: number;
declare var kSCNetworkConnectionPPPInitializing: number;
declare var kSCNetworkConnectionPPPConnectingLink: number;
declare var kSCNetworkConnectionPPPDialOnTraffic: number;
declare var kSCNetworkConnectionPPPNegotiatingLink: number;
declare var kSCNetworkConnectionPPPAuthenticating: number;
declare var kSCNetworkConnectionPPPWaitingForCallBack: number;
declare var kSCNetworkConnectionPPPNegotiatingNetwork: number;
declare var kSCNetworkConnectionPPPConnected: number;
declare var kSCNetworkConnectionPPPTerminating: number;
declare var kSCNetworkConnectionPPPDisconnectingLink: number;
declare var kSCNetworkConnectionPPPHoldingLinkOff: number;
declare var kSCNetworkConnectionPPPSuspended: number;
declare var kSCNetworkConnectionPPPWaitingForRedial: number;
declare var TWRequestMethodPOST: number;
declare var TWRequestMethodDELETE: number;
declare var TWTweetComposeViewControllerResultDone: number;
declare var kVTPropertyReadOnlyErr: number;
declare var kVTParameterErr: number;
declare var kVTInvalidSessionErr: number;
declare var kVTAllocationFailedErr: number;
declare var kVTPixelTransferNotSupportedErr: number;
declare var kVTCouldNotFindVideoDecoderErr: number;
declare var kVTCouldNotCreateInstanceErr: number;
declare var kVTCouldNotFindVideoEncoderErr: number;
declare var kVTVideoDecoderBadDataErr: number;
declare var kVTVideoDecoderUnsupportedDataFormatErr: number;
declare var kVTVideoDecoderMalfunctionErr: number;
declare var kVTVideoEncoderMalfunctionErr: number;
declare var kVTVideoDecoderNotAvailableNowErr: number;
declare var kVTImageRotationNotSupportedErr: number;
declare var kVTVideoEncoderNotAvailableNowErr: number;
declare var kVTFormatDescriptionChangeNotSupportedErr: number;
declare var kVTInsufficientSourceColorDataErr: number;
declare var kVTCouldNotCreateColorCorrectionDataErr: number;
declare var kVTColorSyncTransformConvertFailedErr: number;
declare var kVTVideoDecoderAuthorizationErr: number;
declare var kVTVideoEncoderAuthorizationErr: number;
declare var kVTColorCorrectionPixelTransferFailedErr: number;
declare var kVTMultiPassStorageIdentifierMismatchErr: number;
declare var kVTMultiPassStorageInvalidErr: number;
declare var kVTFrameSiloInvalidTimeStampErr: number;
declare var kVTFrameSiloInvalidTimeRangeErr: number;
declare var kVTCouldNotFindTemporalFilterErr: number;
declare var kVTPixelTransferNotPermittedErr: number;
declare var kVTDecodeFrame_DoNotOutputFrame: number;
declare var kVTDecodeFrame_1xRealTimePlayback: number;
declare var kVTDecodeFrame_EnableTemporalProcessing: number;
declare var kVTDecodeInfo_FrameDropped: number;
declare var kVTDecodeInfo_ImageBufferModifiable: number;
declare var kVTEncodeInfo_FrameDropped: number;
declare function sel_getName(sel: any): string;
declare function sel_registerName(str: string): any;
declare function object_getClassName(obj: any): string;
declare function sel_isMapped(sel: any): boolean;
declare function sel_getUid(str: string): any;
declare function os_retain(object: any): any;
declare function os_release(object: any): void;
declare function __math_errhandling(): number;
declare function __fpclassifyf(arg: number): number;
declare function __fpclassifyd(arg: number): number;
declare function __fpclassifyl(arg: number): number;
declare function acosf(arg: number): number;
declare function acos(arg: number): number;
declare function acosl(arg: number): number;
declare function asinf(arg: number): number;
declare function asin(arg: number): number;
declare function asinl(arg: number): number;
declare function atanf(arg: number): number;
declare function atan(arg: number): number;
declare function atanl(arg: number): number;
declare function atan2f(arg: number, arg1: number): number;
declare function atan2(arg: number, arg1: number): number;
declare function atan2l(arg: number, arg1: number): number;
declare function cosf(arg: number): number;
declare function cos(arg: number): number;
declare function cosl(arg: number): number;
declare function sinf(arg: number): number;
declare function sin(arg: number): number;
declare function sinl(arg: number): number;
declare function tanf(arg: number): number;
declare function tan(arg: number): number;
declare function tanl(arg: number): number;
declare function acoshf(arg: number): number;
declare function acosh(arg: number): number;
declare function acoshl(arg: number): number;
declare function asinhf(arg: number): number;
declare function asinh(arg: number): number;
declare function asinhl(arg: number): number;
declare function atanhf(arg: number): number;
declare function atanh(arg: number): number;
declare function atanhl(arg: number): number;
declare function coshf(arg: number): number;
declare function cosh(arg: number): number;
declare function coshl(arg: number): number;
declare function sinhf(arg: number): number;
declare function sinh(arg: number): number;
declare function sinhl(arg: number): number;
declare function tanhf(arg: number): number;
declare function tanh(arg: number): number;
declare function tanhl(arg: number): number;
declare function expf(arg: number): number;
declare function exp(arg: number): number;
declare function expl(arg: number): number;
declare function exp2f(arg: number): number;
declare function exp2(arg: number): number;
declare function exp2l(arg: number): number;
declare function expm1f(arg: number): number;
declare function expm1(arg: number): number;
declare function expm1l(arg: number): number;
declare function logf(arg: number): number;
declare function log(arg: number): number;
declare function logl(arg: number): number;
declare function log10f(arg: number): number;
declare function log10(arg: number): number;
declare function log10l(arg: number): number;
declare function log2f(arg: number): number;
declare function log2(arg: number): number;
declare function log2l(arg: number): number;
declare function log1pf(arg: number): number;
declare function log1p(arg: number): number;
declare function log1pl(arg: number): number;
declare function logbf(arg: number): number;
declare function logb(arg: number): number;
declare function logbl(arg: number): number;
declare function modff(arg: number, arg1: any): number;
declare function modf(arg: number, arg1: any): number;
declare function modfl(arg: number, arg1: any): number;
declare function ldexpf(arg: number, arg1: number): number;
declare function ldexp(arg: number, arg1: number): number;
declare function ldexpl(arg: number, arg1: number): number;
declare function frexpf(arg: number, arg1: any): number;
declare function frexp(arg: number, arg1: any): number;
declare function frexpl(arg: number, arg1: any): number;
declare function ilogbf(arg: number): number;
declare function ilogb(arg: number): number;
declare function ilogbl(arg: number): number;
declare function scalbnf(arg: number, arg1: number): number;
declare function scalbn(arg: number, arg1: number): number;
declare function scalbnl(arg: number, arg1: number): number;
declare function scalblnf(arg: number, arg1: number): number;
declare function scalbln(arg: number, arg1: number): number;
declare function scalblnl(arg: number, arg1: number): number;
declare function fabsf(arg: number): number;
declare function fabs(arg: number): number;
declare function fabsl(arg: number): number;
declare function cbrtf(arg: number): number;
declare function cbrt(arg: number): number;
declare function cbrtl(arg: number): number;
declare function hypotf(arg: number, arg1: number): number;
declare function hypot(arg: number, arg1: number): number;
declare function hypotl(arg: number, arg1: number): number;
declare function powf(arg: number, arg1: number): number;
declare function pow(arg: number, arg1: number): number;
declare function powl(arg: number, arg1: number): number;
declare function sqrtf(arg: number): number;
declare function sqrt(arg: number): number;
declare function sqrtl(arg: number): number;
declare function erff(arg: number): number;
declare function erf(arg: number): number;
declare function erfl(arg: number): number;
declare function erfcf(arg: number): number;
declare function erfc(arg: number): number;
declare function erfcl(arg: number): number;
declare function lgammaf(arg: number): number;
declare function lgamma(arg: number): number;
declare function lgammal(arg: number): number;
declare function tgammaf(arg: number): number;
declare function tgamma(arg: number): number;
declare function tgammal(arg: number): number;
declare function ceilf(arg: number): number;
declare function ceil(arg: number): number;
declare function ceill(arg: number): number;
declare function floorf(arg: number): number;
declare function floor(arg: number): number;
declare function floorl(arg: number): number;
declare function nearbyintf(arg: number): number;
declare function nearbyint(arg: number): number;
declare function nearbyintl(arg: number): number;
declare function rintf(arg: number): number;
declare function rint(arg: number): number;
declare function rintl(arg: number): number;
declare function lrintf(arg: number): number;
declare function lrint(arg: number): number;
declare function lrintl(arg: number): number;
declare function roundf(arg: number): number;
declare function round(arg: number): number;
declare function roundl(arg: number): number;
declare function lroundf(arg: number): number;
declare function lround(arg: number): number;
declare function lroundl(arg: number): number;
declare function llrintf(arg: number): number;
declare function llrint(arg: number): number;
declare function llrintl(arg: number): number;
declare function llroundf(arg: number): number;
declare function llround(arg: number): number;
declare function llroundl(arg: number): number;
declare function truncf(arg: number): number;
declare function trunc(arg: number): number;
declare function truncl(arg: number): number;
declare function fmodf(arg: number, arg1: number): number;
declare function fmod(arg: number, arg1: number): number;
declare function fmodl(arg: number, arg1: number): number;
declare function remainderf(arg: number, arg1: number): number;
declare function remainder(arg: number, arg1: number): number;
declare function remainderl(arg: number, arg1: number): number;
declare function remquof(arg: number, arg1: number, arg2: any): number;
declare function remquo(arg: number, arg1: number, arg2: any): number;
declare function remquol(arg: number, arg1: number, arg2: any): number;
declare function copysignf(arg: number, arg1: number): number;
declare function copysign(arg: number, arg1: number): number;
declare function copysignl(arg: number, arg1: number): number;
declare function nanf(arg: string): number;
declare function nan(arg: string): number;
declare function nanl(arg: string): number;
declare function nextafterf(arg: number, arg1: number): number;
declare function nextafter(arg: number, arg1: number): number;
declare function nextafterl(arg: number, arg1: number): number;
declare function nexttoward(arg: number, arg1: number): number;
declare function nexttowardf(arg: number, arg1: number): number;
declare function nexttowardl(arg: number, arg1: number): number;
declare function fdimf(arg: number, arg1: number): number;
declare function fdim(arg: number, arg1: number): number;
declare function fdiml(arg: number, arg1: number): number;
declare function fmaxf(arg: number, arg1: number): number;
declare function fmax(arg: number, arg1: number): number;
declare function fmaxl(arg: number, arg1: number): number;
declare function fminf(arg: number, arg1: number): number;
declare function fmin(arg: number, arg1: number): number;
declare function fminl(arg: number, arg1: number): number;
declare function fmaf(arg: number, arg1: number, arg2: number): number;
declare function fma(arg: number, arg1: number, arg2: number): number;
declare function fmal(arg: number, arg1: number, arg2: number): number;
declare function __exp10f(arg: number): number;
declare function __exp10(arg: number): number;
declare function __cospif(arg: number): number;
declare function __cospi(arg: number): number;
declare function __sinpif(arg: number): number;
declare function __sinpi(arg: number): number;
declare function __tanpif(arg: number): number;
declare function __tanpi(arg: number): number;
declare function __sincosf_stret(arg: number): __float2;
declare function __sincos_stret(arg: number): __double2;
declare function __sincospif_stret(arg: number): __float2;
declare function __sincospi_stret(arg: number): __double2;
declare function j0(arg: number): number;
declare function j1(arg: number): number;
declare function jn(arg: number, arg1: number): number;
declare function y0(arg: number): number;
declare function y1(arg: number): number;
declare function yn(arg: number, arg1: number): number;
declare function scalb(arg: number, arg1: number): number;
declare function getattrlistbulk(arg: number, arg1: any, arg2: any, arg3: number, arg4: number): number;
declare function faccessat(arg: number, arg1: string, arg2: number, arg3: number): number;
declare function fchownat(arg: number, arg1: string, arg2: number, arg3: number, arg4: number): number;
declare function linkat(arg: number, arg1: string, arg2: number, arg3: string, arg4: number): number;
declare function readlinkat(arg: number, arg1: string, arg2: string, arg3: number): number;
declare function symlinkat(arg: string, arg1: number, arg2: string): number;
declare function unlinkat(arg: number, arg1: string, arg2: number): number;
declare function getattrlistat(arg: number, arg1: string, arg2: any, arg3: any, arg4: number, arg5: number): number;
declare function _exit(arg: number): void;
declare function access(arg: string, arg1: number): number;
declare function alarm(arg: number): number;
declare function chdir(arg: string): number;
declare function chown(arg: string, arg1: number, arg2: number): number;
declare function close(arg: number): number;
declare function dup(arg: number): number;
declare function dup2(arg: number, arg1: number): number;
declare function execv(arg: string, arg1: any): number;
declare function execve(arg: string, arg1: any, arg2: any): number;
declare function execvp(arg: string, arg1: any): number;
declare function fork(): number;
declare function fpathconf(arg: number, arg1: number): number;
declare function getcwd(arg: string, arg1: number): string;
declare function getegid(): number;
declare function geteuid(): number;
declare function getgid(): number;
declare function getgroups(arg: number, arg1: any): number;
declare function getlogin(): string;
declare function getpgrp(): number;
declare function getpid(): number;
declare function getppid(): number;
declare function getuid(): number;
declare function isatty(arg: number): number;
declare function link(arg: string, arg1: string): number;
declare function lseek(arg: number, arg1: number, arg2: number): number;
declare function pathconf(arg: string, arg1: number): number;
declare function pause(): number;
declare function pipe(arg: number[]): number;
declare function read(arg: number, arg1: any, arg2: number): number;
declare function rmdir(arg: string): number;
declare function setgid(arg: number): number;
declare function setpgid(arg: number, arg1: number): number;
declare function setsid(): number;
declare function setuid(arg: number): number;
declare function sleep(arg: number): number;
declare function sysconf(arg: number): number;
declare function tcgetpgrp(arg: number): number;
declare function tcsetpgrp(arg: number, arg1: number): number;
declare function ttyname(arg: number): string;
declare function ttyname_r(arg: number, arg1: string, arg2: number): number;
declare function unlink(arg: string): number;
declare function write(arg: number, arg1: any, arg2: number): number;
declare function confstr(arg: number, arg1: string, arg2: number): number;
declare function getopt(arg: number, arg1: any, arg2: string): number;
declare function brk(arg: any): any;
declare function chroot(arg: string): number;
declare function crypt(arg: string, arg1: string): string;
declare function ctermid(arg: string): string;
declare function encrypt(arg: string, arg1: number): void;
declare function fchdir(arg: number): number;
declare function gethostid(): number;
declare function getpgid(arg: number): number;
declare function getsid(arg: number): number;
declare function getdtablesize(): number;
declare function getpagesize(): number;
declare function getpass(arg: string): string;
declare function getwd(arg: string): string;
declare function lchown(arg: string, arg1: number, arg2: number): number;
declare function lockf(arg: number, arg1: number, arg2: number): number;
declare function nice(arg: number): number;
declare function pread(arg: number, arg1: any, arg2: number, arg3: number): number;
declare function pwrite(arg: number, arg1: any, arg2: number, arg3: number): number;
declare function sbrk(arg: number): any;
declare function setpgrp(): number;
declare function setregid(arg: number, arg1: number): number;
declare function setreuid(arg: number, arg1: number): number;
declare function swab(arg: any, arg1: any, arg2: number): void;
declare function sync(): void;
declare function truncate(arg: string, arg1: number): number;
declare function ualarm(arg: number, arg1: number): number;
declare function usleep(arg: number): number;
declare function vfork(): number;
declare function fsync(arg: number): number;
declare function ftruncate(arg: number, arg1: number): number;
declare function getlogin_r(arg: string, arg1: number): number;
declare function fchown(arg: number, arg1: number, arg2: number): number;
declare function gethostname(arg: string, arg1: number): number;
declare function readlink(arg: string, arg1: string, arg2: number): number;
declare function setegid(arg: number): number;
declare function seteuid(arg: number): number;
declare function symlink(arg: string, arg1: string): number;
declare function pselect(arg: number, arg1: any, arg2: any, arg3: any, arg4: any, arg5: any): number;
declare function select(arg: number, arg1: any, arg2: any, arg3: any, arg4: any): number;
declare function _Exit(arg: number): void;
declare function accessx_np(arg: any, arg1: number, arg2: any, arg3: number): number;
declare function acct(arg: string): number;
declare function endusershell(): void;
declare function execvP(arg: string, arg1: string, arg2: any): number;
declare function fflagstostr(arg: number): string;
declare function getdomainname(arg: string, arg1: number): number;
declare function getgrouplist(arg: string, arg1: number, arg2: any, arg3: any): number;
declare function getmode(arg: any, arg1: number): number;
declare function getpeereid(arg: number, arg1: any, arg2: any): number;
declare function getsgroups_np(arg: any, arg1: number[]): number;
declare function getusershell(): string;
declare function getwgroups_np(arg: any, arg1: number[]): number;
declare function initgroups(arg: string, arg1: number): number;
declare function iruserok(arg: number, arg1: number, arg2: string, arg3: string): number;
declare function iruserok_sa(arg: any, arg1: number, arg2: number, arg3: string, arg4: string): number;
declare function issetugid(): number;
declare function mkdtemp(arg: string): string;
declare function mknod(arg: string, arg1: number, arg2: number): number;
declare function mkpath_np(path: string, omode: number): number;
declare function mkstemp(arg: string): number;
declare function mkstemps(arg: string, arg1: number): number;
declare function mktemp(arg: string): string;
declare function nfssvc(arg: number, arg1: any): number;
declare function pthread_setugid_np(arg: number, arg1: number): number;
declare function pthread_getugid_np(arg: any, arg1: any): number;
declare function rcmd(arg: any, arg1: number, arg2: string, arg3: string, arg4: string, arg5: any): number;
declare function rcmd_af(arg: any, arg1: number, arg2: string, arg3: string, arg4: string, arg5: any, arg6: number): number;
declare function reboot(arg: number): number;
declare function revoke(arg: string): number;
declare function rresvport(arg: any): number;
declare function rresvport_af(arg: any, arg1: number): number;
declare function ruserok(arg: string, arg1: number, arg2: string, arg3: string): number;
declare function setdomainname(arg: string, arg1: number): number;
declare function setgroups(arg: number, arg1: any): number;
declare function sethostid(arg: number): void;
declare function sethostname(arg: string, arg1: number): number;
declare function setkey(arg: string): void;
declare function setlogin(arg: string): number;
declare function setmode(arg: string): any;
declare function setrgid(arg: number): number;
declare function setruid(arg: number): number;
declare function setsgroups_np(arg: number, arg1: number[]): number;
declare function setusershell(): void;
declare function setwgroups_np(arg: number, arg1: number[]): number;
declare function strtofflags(arg: any, arg1: any, arg2: any): number;
declare function swapon(arg: string): number;
declare function ttyslot(): number;
declare function undelete(arg: string): number;
declare function valloc(arg: number): any;
declare function getsubopt(arg: any, arg1: any, arg2: any): number;
declare function fgetattrlist(arg: number, arg1: any, arg2: any, arg3: number, arg4: number): number;
declare function fsetattrlist(arg: number, arg1: any, arg2: any, arg3: number, arg4: number): number;
declare function getattrlist(arg: string, arg1: any, arg2: any, arg3: number, arg4: number): number;
declare function setattrlist(arg: string, arg1: any, arg2: any, arg3: number, arg4: number): number;
declare function exchangedata(arg: string, arg1: string, arg2: number): number;
declare function getdirentriesattr(arg: number, arg1: any, arg2: any, arg3: number, arg4: any, arg5: any, arg6: any, arg7: number): number;
declare function searchfs(arg: string, arg1: any, arg2: any, arg3: number, arg4: number, arg5: any): number;
declare function fsctl(arg: string, arg1: number, arg2: any, arg3: number): number;
declare function ffsctl(arg: number, arg1: number, arg2: any, arg3: number): number;
declare function fsync_volume_np(arg: number, arg1: number): number;
declare function sync_volume_np(arg: string, arg1: number): number;
declare function _Block_copy(aBlock: any): any;
declare function _Block_release(aBlock: any): void;
declare function _Block_object_assign(arg: any, arg1: any, arg2: number): void;
declare function _Block_object_dispose(arg: any, arg1: number): void;
declare function __assert_rtn(arg: string, arg1: string, arg2: number, arg3: string): void;
declare function ___runetype(arg: number): number;
declare function ___tolower(arg: number): number;
declare function ___toupper(arg: number): number;
declare function __maskrune(arg: number, arg1: number): number;
declare function __toupper(arg: number): number;
declare function __tolower(arg: number): number;
declare function __error(): any;
declare function localeconv(): any;
declare function setlocale(arg: number, arg1: string): string;
declare function setjmp(arg: number[]): number;
declare function longjmp(arg: number[], arg1: number): void;
declare function _setjmp(arg: number[]): number;
declare function _longjmp(arg: number[], arg1: number): void;
declare function sigsetjmp(arg: number[], arg1: number): number;
declare function siglongjmp(arg: number[], arg1: number): void;
declare function signal(arg: number, arg1: (arg1: number) => void): (arg1: number) => void;
declare function raise(arg: number): number;
declare function bsd_signal(arg: number, arg1: (arg1: number) => void): (arg1: number) => void;
declare function kill(arg: number, arg1: number): number;
declare function killpg(arg: number, arg1: number): number;
declare function pthread_kill(arg: any, arg1: number): number;
declare function pthread_sigmask(arg: number, arg1: any, arg2: any): number;
declare function sighold(arg: number): number;
declare function sigignore(arg: number): number;
declare function siginterrupt(arg: number, arg1: number): number;
declare function sigpause(arg: number): number;
declare function sigpending(arg: any): number;
declare function sigprocmask(arg: number, arg1: any, arg2: any): number;
declare function sigrelse(arg: number): number;
declare function sigset(arg: number, arg1: (arg1: number) => void): (arg1: number) => void;
declare function sigsuspend(arg: any): number;
declare function sigwait(arg: any, arg1: any): number;
declare function psignal(arg: number, arg1: string): void;
declare function sigblock(arg: number): number;
declare function sigsetmask(arg: number): number;
declare function sigvec(arg: number, arg1: any, arg2: any): number;
declare function renameat(arg: number, arg1: string, arg2: number, arg3: string): number;
declare function clearerr(arg: any): void;
declare function fclose(arg: any): number;
declare function feof(arg: any): number;
declare function ferror(arg: any): number;
declare function fflush(arg: any): number;
declare function fgetc(arg: any): number;
declare function fgetpos(arg: any, arg1: any): number;
declare function fgets(arg: string, arg1: number, arg2: any): string;
declare function fopen(arg: string, arg1: string): any;
declare function fputc(arg: number, arg1: any): number;
declare function fputs(arg: string, arg1: any): number;
declare function fread(arg: any, arg1: number, arg2: number, arg3: any): number;
declare function freopen(arg: string, arg1: string, arg2: any): any;
declare function fseek(arg: any, arg1: number, arg2: number): number;
declare function fsetpos(arg: any, arg1: any): number;
declare function ftell(arg: any): number;
declare function fwrite(arg: any, arg1: number, arg2: number, arg3: any): number;
declare function getc(arg: any): number;
declare function getchar(): number;
declare function gets(arg: string): string;
declare function perror(arg: string): void;
declare function putc(arg: number, arg1: any): number;
declare function putchar(arg: number): number;
declare function puts(arg: string): number;
declare function remove(arg: string): number;
declare function rename(arg: string, arg1: string): number;
declare function rewind(arg: any): void;
declare function setbuf(arg: any, arg1: string): void;
declare function setvbuf(arg: any, arg1: string, arg2: number, arg3: number): number;
declare function tmpfile(): any;
declare function tmpnam(arg: string): string;
declare function ungetc(arg: number, arg1: any): number;
declare function fdopen(arg: number, arg1: string): any;
declare function fileno(arg: any): number;
declare function pclose(arg: any): number;
declare function popen(arg: string, arg1: string): any;
declare function __srget(arg: any): number;
declare function __swbuf(arg: number, arg1: any): number;
declare function flockfile(arg: any): void;
declare function ftrylockfile(arg: any): number;
declare function funlockfile(arg: any): void;
declare function getc_unlocked(arg: any): number;
declare function getchar_unlocked(): number;
declare function putc_unlocked(arg: number, arg1: any): number;
declare function putchar_unlocked(arg: number): number;
declare function getw(arg: any): number;
declare function putw(arg: number, arg1: any): number;
declare function tempnam(arg: string, arg1: string): string;
declare function fseeko(arg: any, arg1: number, arg2: number): number;
declare function ftello(arg: any): number;
declare function getdelim(arg: any, arg1: any, arg2: number, arg3: any): number;
declare function getline(arg: any, arg1: any, arg2: any): number;
declare function ctermid_r(arg: string): string;
declare function fgetln(arg: any, arg1: any): string;
declare function fmtcheck(arg: string, arg1: string): string;
declare function fpurge(arg: any): number;
declare function setbuffer(arg: any, arg1: string, arg2: number): void;
declare function setlinebuf(arg: any): number;
declare function funopen(arg: any, arg1: (arg1: any, arg2: string, arg3: number) => number, arg2: (arg1: any, arg2: string, arg3: number) => number, arg3: (arg1: any, arg2: number, arg3: number) => number, arg4: (arg1: any) => number): any;
declare function getpriority(arg: number, arg1: number): number;
declare function getiopolicy_np(arg: number, arg1: number): number;
declare function getrlimit(arg: number, arg1: any): number;
declare function getrusage(arg: number, arg1: any): number;
declare function setpriority(arg: number, arg1: number, arg2: number): number;
declare function setiopolicy_np(arg: number, arg1: number, arg2: number): number;
declare function setrlimit(arg: number, arg1: any): number;
declare function wait(arg: any): number;
declare function waitpid(arg: number, arg1: any, arg2: number): number;
declare function wait3(arg: any, arg1: number, arg2: any): number;
declare function wait4(arg: number, arg1: any, arg2: number, arg3: any): number;
declare function alloca(arg: number): any;
declare function abort(): void;
declare function abs(arg: number): number;
declare function atexit(arg: () => void): number;
declare function atof(arg: string): number;
declare function atoi(arg: string): number;
declare function atol(arg: string): number;
declare function atoll(arg: string): number;
declare function bsearch(arg: any, arg1: any, arg2: number, arg3: number, arg4: (arg1: any, arg2: any) => number): any;
declare function calloc(arg: number, arg1: number): any;
declare function div(arg: number, arg1: number): div_t;
declare function exit(arg: number): void;
declare function free(arg: any): void;
declare function getenv(arg: string): string;
declare function labs(arg: number): number;
declare function ldiv(arg: number, arg1: number): ldiv_t;
declare function llabs(arg: number): number;
declare function lldiv(arg: number, arg1: number): lldiv_t;
declare function malloc(arg: number): any;
declare function mblen(arg: string, arg1: number): number;
declare function mbstowcs(arg: any, arg1: string, arg2: number): number;
declare function mbtowc(arg: any, arg1: string, arg2: number): number;
declare function posix_memalign(arg: any, arg1: number, arg2: number): number;
declare function qsort(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): void;
declare function rand(): number;
declare function realloc(arg: any, arg1: number): any;
declare function srand(arg: number): void;
declare function strtod(arg: string, arg1: any): number;
declare function strtof(arg: string, arg1: any): number;
declare function strtol(arg: string, arg1: any, arg2: number): number;
declare function strtold(arg: string, arg1: any): number;
declare function strtoll(arg: string, arg1: any, arg2: number): number;
declare function strtoul(arg: string, arg1: any, arg2: number): number;
declare function strtoull(arg: string, arg1: any, arg2: number): number;
declare function system(arg: string): number;
declare function wcstombs(arg: string, arg1: any, arg2: number): number;
declare function wctomb(arg: string, arg1: number): number;
declare function a64l(arg: string): number;
declare function drand48(): number;
declare function ecvt(arg: number, arg1: number, arg2: any, arg3: any): string;
declare function erand48(arg: number[]): number;
declare function fcvt(arg: number, arg1: number, arg2: any, arg3: any): string;
declare function gcvt(arg: number, arg1: number, arg2: string): string;
declare function grantpt(arg: number): number;
declare function initstate(arg: number, arg1: string, arg2: number): string;
declare function jrand48(arg: number[]): number;
declare function l64a(arg: number): string;
declare function lcong48(arg: number[]): void;
declare function lrand48(): number;
declare function mrand48(): number;
declare function nrand48(arg: number[]): number;
declare function posix_openpt(arg: number): number;
declare function ptsname(arg: number): string;
declare function putenv(arg: string): number;
declare function random(): number;
declare function rand_r(arg: any): number;
declare function realpath(arg: string, arg1: string): string;
declare function seed48(arg: number[]): any;
declare function setenv(arg: string, arg1: string, arg2: number): number;
declare function setstate(arg: string): string;
declare function srand48(arg: number): void;
declare function srandom(arg: number): void;
declare function unlockpt(arg: number): number;
declare function unsetenv(arg: string): number;
declare function arc4random(): number;
declare function arc4random_addrandom(arg: string, arg1: number): void;
declare function arc4random_buf(arg: any, arg1: number): void;
declare function arc4random_stir(): void;
declare function arc4random_uniform(arg: number): number;
declare function atexit_b(arg: () => void): number;
declare function bsearch_b(arg: any, arg1: any, arg2: number, arg3: number, arg4: (arg1: any, arg2: any) => number): any;
declare function cgetcap(arg: string, arg1: string, arg2: number): string;
declare function cgetclose(): number;
declare function cgetent(arg: any, arg1: any, arg2: string): number;
declare function cgetfirst(arg: any, arg1: any): number;
declare function cgetmatch(arg: string, arg1: string): number;
declare function cgetnext(arg: any, arg1: any): number;
declare function cgetnum(arg: string, arg1: string, arg2: any): number;
declare function cgetset(arg: string): number;
declare function cgetstr(arg: string, arg1: string, arg2: any): number;
declare function cgetustr(arg: string, arg1: string, arg2: any): number;
declare function daemon(arg: number, arg1: number): number;
declare function devname(arg: number, arg1: number): string;
declare function devname_r(arg: number, arg1: number, buf: string, len: number): string;
declare function getbsize(arg: any, arg1: any): string;
declare function getloadavg(arg: any, arg1: number): number;
declare function getprogname(): string;
declare function heapsort(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): number;
declare function heapsort_b(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): number;
declare function mergesort(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): number;
declare function mergesort_b(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): number;
declare function psort(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): void;
declare function psort_b(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): void;
declare function psort_r(arg: any, arg1: number, arg2: number, arg3: any, arg4: (arg1: any, arg2: any, arg3: any) => number): void;
declare function qsort_b(arg: any, arg1: number, arg2: number, arg3: (arg1: any, arg2: any) => number): void;
declare function qsort_r(arg: any, arg1: number, arg2: number, arg3: any, arg4: (arg1: any, arg2: any, arg3: any) => number): void;
declare function radixsort(arg: any, arg1: number, arg2: string, arg3: number): number;
declare function setprogname(arg: string): void;
declare function sradixsort(arg: any, arg1: number, arg2: string, arg3: number): number;
declare function sranddev(): void;
declare function srandomdev(): void;
declare function reallocf(arg: any, arg1: number): any;
declare function strtoq(arg: string, arg1: any, arg2: number): number;
declare function strtouq(arg: string, arg1: any, arg2: number): number;
declare function memchr(arg: any, arg1: number, arg2: number): any;
declare function memcmp(arg: any, arg1: any, arg2: number): number;
declare function memcpy(arg: any, arg1: any, arg2: number): any;
declare function memmove(arg: any, arg1: any, arg2: number): any;
declare function memset(arg: any, arg1: number, arg2: number): any;
declare function strcat(arg: string, arg1: string): string;
declare function strchr(arg: string, arg1: number): string;
declare function strcmp(arg: string, arg1: string): number;
declare function strcoll(arg: string, arg1: string): number;
declare function strcpy(arg: string, arg1: string): string;
declare function strcspn(arg: string, arg1: string): number;
declare function strerror(arg: number): string;
declare function strlen(arg: string): number;
declare function strncat(arg: string, arg1: string, arg2: number): string;
declare function strncmp(arg: string, arg1: string, arg2: number): number;
declare function strncpy(arg: string, arg1: string, arg2: number): string;
declare function strpbrk(arg: string, arg1: string): string;
declare function strrchr(arg: string, arg1: number): string;
declare function strspn(arg: string, arg1: string): number;
declare function strstr(arg: string, arg1: string): string;
declare function strtok(arg: string, arg1: string): string;
declare function strxfrm(arg: string, arg1: string, arg2: number): number;
declare function strtok_r(arg: string, arg1: string, arg2: any): string;
declare function strerror_r(arg: number, arg1: string, arg2: number): number;
declare function strdup(arg: string): string;
declare function memccpy(arg: any, arg1: any, arg2: number, arg3: number): any;
declare function stpcpy(arg: string, arg1: string): string;
declare function stpncpy(arg: string, arg1: string, arg2: number): string;
declare function strndup(arg: string, arg1: number): string;
declare function strnlen(arg: string, arg1: number): number;
declare function strsignal(sig: number): string;
declare function memset_s(arg: any, arg1: number, arg2: number, arg3: number): number;
declare function memmem(arg: any, arg1: number, arg2: any, arg3: number): any;
declare function memset_pattern4(arg: any, arg1: any, arg2: number): void;
declare function memset_pattern8(arg: any, arg1: any, arg2: number): void;
declare function memset_pattern16(arg: any, arg1: any, arg2: number): void;
declare function strcasestr(arg: string, arg1: string): string;
declare function strnstr(arg: string, arg1: string, arg2: number): string;
declare function strlcat(arg: string, arg1: string, arg2: number): number;
declare function strlcpy(arg: string, arg1: string, arg2: number): number;
declare function strmode(arg: number, arg1: string): void;
declare function strsep(arg: any, arg1: string): string;
declare function bcmp(arg: any, arg1: any, arg2: number): number;
declare function bcopy(arg: any, arg1: any, arg2: number): void;
declare function bzero(arg: any, arg1: number): void;
declare function index(arg: string, arg1: number): string;
declare function rindex(arg: string, arg1: number): string;
declare function ffs(arg: number): number;
declare function strcasecmp(arg: string, arg1: string): number;
declare function strncasecmp(arg: string, arg1: string, arg2: number): number;
declare function ffsl(arg: number): number;
declare function ffsll(arg: number): number;
declare function fls(arg: number): number;
declare function flsl(arg: number): number;
declare function flsll(arg: number): number;
declare function asctime(arg: any): string;
declare function clock(): number;
declare function ctime(arg: any): string;
declare function difftime(arg: number, arg1: number): number;
declare function getdate(arg: string): any;
declare function gmtime(arg: any): any;
declare function localtime(arg: any): any;
declare function mktime(arg: any): number;
declare function strftime(arg: string, arg1: number, arg2: string, arg3: any): number;
declare function strptime(arg: string, arg1: string, arg2: any): string;
declare function time(arg: any): number;
declare function tzset(): void;
declare function asctime_r(arg: any, arg1: string): string;
declare function ctime_r(arg: any, arg1: string): string;
declare function gmtime_r(arg: any, arg1: any): any;
declare function localtime_r(arg: any, arg1: any): any;
declare function posix2time(arg: number): number;
declare function tzsetwall(): void;
declare function time2posix(arg: number): number;
declare function timelocal(arg: any): number;
declare function timegm(arg: any): number;
declare function nanosleep(arg: any, arg1: any): number;
declare function imaxabs(j: number): number;
declare function imaxdiv(__numer: number, __denom: number): imaxdiv_t;
declare function strtoimax(__nptr: string, __endptr: any, __base: number): number;
declare function strtoumax(__nptr: string, __endptr: any, __base: number): number;
declare function wcstoimax(__nptr: any, __endptr: any, __base: number): number;
declare function wcstoumax(__nptr: any, __endptr: any, __base: number): number;
declare function creat(arg: string, arg1: number): number;
declare function openx_np(arg: string, arg1: number, arg2: any): number;
declare function flock(arg: number, arg1: number): number;
declare function filesec_init(): any;
declare function filesec_dup(arg: any): any;
declare function filesec_free(arg: any): void;
declare function filesec_get_property(arg: any, arg1: number, arg2: any): number;
declare function filesec_query_property(arg: any, arg1: number, arg2: any): number;
declare function filesec_set_property(arg: any, arg1: number, arg2: any): number;
declare function filesec_unset_property(arg: any, arg1: number): number;
declare function dispatch_time(when: number, delta: number): number;
declare function dispatch_walltime(when: any, delta: number): number;
declare function dispatch_get_context(object: NSObject): any;
declare function dispatch_set_context(object: NSObject, context: any): void;
declare function dispatch_set_finalizer_f(object: NSObject, finalizer: (arg1: any) => void): void;
declare function dispatch_suspend(object: NSObject): void;
declare function dispatch_resume(object: NSObject): void;
declare function dispatch_async(queue: NSObject, block: () => void): void;
declare function dispatch_async_f(queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_sync(queue: NSObject, block: () => void): void;
declare function dispatch_sync_f(queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_apply(iterations: number, queue: NSObject, block: (arg1: number) => void): void;
declare function dispatch_apply_f(iterations: number, queue: NSObject, context: any, work: (arg1: any, arg2: number) => void): void;
declare function dispatch_get_current_queue(): NSObject;
declare function qos_class_self(): number;
declare function qos_class_main(): number;
declare function dispatch_get_global_queue(identifier: number, flags: number): NSObject;
declare function dispatch_queue_attr_make_with_qos_class(attr: NSObject, qos_class: number, relative_priority: number): NSObject;
declare function dispatch_queue_create(label: string, attr: NSObject): NSObject;
declare function dispatch_queue_get_label(queue: NSObject): string;
declare function dispatch_queue_get_qos_class(queue: NSObject, relative_priority_ptr: any): number;
declare function dispatch_set_target_queue(object: NSObject, queue: NSObject): void;
declare function dispatch_main(): void;
declare function dispatch_after(when: number, queue: NSObject, block: () => void): void;
declare function dispatch_after_f(when: number, queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_barrier_async(queue: NSObject, block: () => void): void;
declare function dispatch_barrier_async_f(queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_barrier_sync(queue: NSObject, block: () => void): void;
declare function dispatch_barrier_sync_f(queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_queue_set_specific(queue: NSObject, key: any, context: any, destructor: (arg1: any) => void): void;
declare function dispatch_queue_get_specific(queue: NSObject, key: any): any;
declare function dispatch_get_specific(key: any): any;
declare function dispatch_block_create(flags: number, block: () => void): () => void;
declare function dispatch_block_create_with_qos_class(flags: number, qos_class: number, relative_priority: number, block: () => void): () => void;
declare function dispatch_block_perform(flags: number, block: () => void): void;
declare function dispatch_block_wait(block: () => void, timeout: number): number;
declare function dispatch_block_notify(block: () => void, queue: NSObject, notification_block: () => void): void;
declare function dispatch_block_cancel(block: () => void): void;
declare function dispatch_block_testcancel(block: () => void): number;
declare function mach_msg_overwrite(msg: any, option: number, send_size: number, rcv_size: number, rcv_name: number, timeout: number, notify: number, rcv_msg: any, rcv_limit: number): number;
declare function mach_msg(msg: any, option: number, send_size: number, rcv_size: number, rcv_name: number, timeout: number, notify: number): number;
declare function mach_voucher_deallocate(voucher: number): number;
declare function dispatch_source_create(type: any, handle: number, mask: number, queue: NSObject): NSObject;
declare function dispatch_source_set_event_handler(source: NSObject, handler: () => void): void;
declare function dispatch_source_set_event_handler_f(source: NSObject, handler: (arg1: any) => void): void;
declare function dispatch_source_set_cancel_handler(source: NSObject, handler: () => void): void;
declare function dispatch_source_set_cancel_handler_f(source: NSObject, handler: (arg1: any) => void): void;
declare function dispatch_source_cancel(source: NSObject): void;
declare function dispatch_source_testcancel(source: NSObject): number;
declare function dispatch_source_get_handle(source: NSObject): number;
declare function dispatch_source_get_mask(source: NSObject): number;
declare function dispatch_source_get_data(source: NSObject): number;
declare function dispatch_source_merge_data(source: NSObject, value: number): void;
declare function dispatch_source_set_timer(source: NSObject, start: number, interval: number, leeway: number): void;
declare function dispatch_source_set_registration_handler(source: NSObject, handler: () => void): void;
declare function dispatch_source_set_registration_handler_f(source: NSObject, handler: (arg1: any) => void): void;
declare function dispatch_group_create(): NSObject;
declare function dispatch_group_async(group: NSObject, queue: NSObject, block: () => void): void;
declare function dispatch_group_async_f(group: NSObject, queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_group_wait(group: NSObject, timeout: number): number;
declare function dispatch_group_notify(group: NSObject, queue: NSObject, block: () => void): void;
declare function dispatch_group_notify_f(group: NSObject, queue: NSObject, context: any, work: (arg1: any) => void): void;
declare function dispatch_group_enter(group: NSObject): void;
declare function dispatch_group_leave(group: NSObject): void;
declare function dispatch_semaphore_create(value: number): NSObject;
declare function dispatch_semaphore_wait(dsema: NSObject, timeout: number): number;
declare function dispatch_semaphore_signal(dsema: NSObject): number;
declare function dispatch_once(predicate: any, block: () => void): void;
declare function dispatch_once_f(predicate: any, context: any, funcArg: (arg1: any) => void): void;
declare function dispatch_data_create(buffer: any, size: number, queue: NSObject, destructor: () => void): NSObject;
declare function dispatch_data_get_size(data: NSObject): number;
declare function dispatch_data_create_map(data: NSObject, buffer_ptr: any, size_ptr: any): NSObject;
declare function dispatch_data_create_concat(data1: NSObject, data2: NSObject): NSObject;
declare function dispatch_data_create_subrange(data: NSObject, offset: number, length: number): NSObject;
declare function dispatch_data_apply(data: NSObject, applier: (arg1: NSObject, arg2: number, arg3: any, arg4: number) => boolean): boolean;
declare function dispatch_data_copy_region(data: NSObject, location: number, offset_ptr: any): NSObject;
declare function dispatch_read(fd: number, length: number, queue: NSObject, handler: (arg1: NSObject, arg2: number) => void): void;
declare function dispatch_write(fd: number, data: NSObject, queue: NSObject, handler: (arg1: NSObject, arg2: number) => void): void;
declare function dispatch_io_create(type: number, fd: number, queue: NSObject, cleanup_handler: (arg1: number) => void): NSObject;
declare function dispatch_io_create_with_path(type: number, path: string, oflag: number, mode: number, queue: NSObject, cleanup_handler: (arg1: number) => void): NSObject;
declare function dispatch_io_create_with_io(type: number, io: NSObject, queue: NSObject, cleanup_handler: (arg1: number) => void): NSObject;
declare function dispatch_io_read(channel: NSObject, offset: number, length: number, queue: NSObject, io_handler: (arg1: boolean, arg2: NSObject, arg3: number) => void): void;
declare function dispatch_io_write(channel: NSObject, offset: number, data: NSObject, queue: NSObject, io_handler: (arg1: boolean, arg2: NSObject, arg3: number) => void): void;
declare function dispatch_io_close(channel: NSObject, flags: number): void;
declare function dispatch_io_barrier(channel: NSObject, barrier: () => void): void;
declare function dispatch_io_get_descriptor(channel: NSObject): number;
declare function dispatch_io_set_high_water(channel: NSObject, high_water: number): void;
declare function dispatch_io_set_low_water(channel: NSObject, low_water: number): void;
declare function dispatch_io_set_interval(channel: NSObject, interval: number, flags: number): void;
declare function acl_dup(acl: any): any;
declare function acl_free(obj_p: any): number;
declare function acl_init(count: number): any;
declare function acl_copy_entry(dest_d: any, src_d: any): number;
declare function acl_create_entry(acl_p: any, entry_p: any): number;
declare function acl_create_entry_np(acl_p: any, entry_p: any, entry_index: number): number;
declare function acl_delete_entry(acl: any, entry_d: any): number;
declare function acl_get_entry(acl: any, entry_id: number, entry_p: any): number;
declare function acl_valid(acl: any): number;
declare function acl_valid_fd_np(fd: number, type: number, acl: any): number;
declare function acl_valid_file_np(path: string, type: number, acl: any): number;
declare function acl_add_perm(permset_d: any, perm: number): number;
declare function acl_calc_mask(acl_p: any): number;
declare function acl_clear_perms(permset_d: any): number;
declare function acl_delete_perm(permset_d: any, perm: number): number;
declare function acl_get_perm_np(permset_d: any, perm: number): number;
declare function acl_get_permset(entry_d: any, permset_p: any): number;
declare function acl_set_permset(entry_d: any, permset_d: any): number;
declare function acl_maximal_permset_mask_np(mask_p: any): number;
declare function acl_get_permset_mask_np(entry_d: any, mask_p: any): number;
declare function acl_set_permset_mask_np(entry_d: any, mask: number): number;
declare function acl_add_flag_np(flagset_d: any, flag: number): number;
declare function acl_clear_flags_np(flagset_d: any): number;
declare function acl_delete_flag_np(flagset_d: any, flag: number): number;
declare function acl_get_flag_np(flagset_d: any, flag: number): number;
declare function acl_get_flagset_np(obj_p: any, flagset_p: any): number;
declare function acl_set_flagset_np(obj_p: any, flagset_d: any): number;
declare function acl_get_qualifier(entry_d: any): any;
declare function acl_get_tag_type(entry_d: any, tag_type_p: any): number;
declare function acl_set_qualifier(entry_d: any, tag_qualifier_p: any): number;
declare function acl_set_tag_type(entry_d: any, tag_type: number): number;
declare function acl_delete_def_file(path_p: string): number;
declare function acl_get_fd(fd: number): any;
declare function acl_get_fd_np(fd: number, type: number): any;
declare function acl_get_file(path_p: string, type: number): any;
declare function acl_get_link_np(path_p: string, type: number): any;
declare function acl_set_fd(fd: number, acl: any): number;
declare function acl_set_fd_np(fd: number, acl: any, acl_type: number): number;
declare function acl_set_file(path_p: string, type: number, acl: any): number;
declare function acl_set_link_np(path_p: string, type: number, acl: any): number;
declare function acl_copy_ext(buf_p: any, acl: any, size: number): number;
declare function acl_copy_ext_native(buf_p: any, acl: any, size: number): number;
declare function acl_copy_int(buf_p: any): any;
declare function acl_copy_int_native(buf_p: any): any;
declare function acl_from_text(buf_p: string): any;
declare function acl_size(acl: any): number;
declare function acl_to_text(acl: any, len_p: any): string;
declare function uuid_clear(uu: number[]): void;
declare function uuid_compare(uu1: number[], uu2: number[]): number;
declare function uuid_copy(dst: number[], src: number[]): void;
declare function uuid_generate(out: number[]): void;
declare function uuid_generate_random(out: number[]): void;
declare function uuid_generate_time(out: number[]): void;
declare function uuid_is_null(uu: number[]): number;
declare function uuid_parse(input: string[], uu: number[]): number;
declare function uuid_unparse(uu: number[], out: string[]): void;
declare function uuid_unparse_lower(uu: number[], out: string[]): void;
declare function uuid_unparse_upper(uu: number[], out: string[]): void;
declare function accept(arg: number, arg1: any, arg2: any): number;
declare function bind(arg: number, arg1: any, arg2: number): number;
declare function connect(arg: number, arg1: any, arg2: number): number;
declare function getpeername(arg: number, arg1: any, arg2: any): number;
declare function getsockname(arg: number, arg1: any, arg2: any): number;
declare function getsockopt(arg: number, arg1: number, arg2: number, arg3: any, arg4: any): number;
declare function listen(arg: number, arg1: number): number;
declare function recv(arg: number, arg1: any, arg2: number, arg3: number): number;
declare function recvfrom(arg: number, arg1: any, arg2: number, arg3: number, arg4: any, arg5: any): number;
declare function recvmsg(arg: number, arg1: any, arg2: number): number;
declare function send(arg: number, arg1: any, arg2: number, arg3: number): number;
declare function sendmsg(arg: number, arg1: any, arg2: number): number;
declare function sendto(arg: number, arg1: any, arg2: number, arg3: number, arg4: any, arg5: number): number;
declare function setsockopt(arg: number, arg1: number, arg2: number, arg3: any, arg4: number): number;
declare function shutdown(arg: number, arg1: number): number;
declare function sockatmark(arg: number): number;
declare function socket(arg: number, arg1: number, arg2: number): number;
declare function socketpair(arg: number, arg1: number, arg2: number, arg3: any): number;
declare function sendfile(arg: number, arg1: number, arg2: number, arg3: any, arg4: any, arg5: number): number;
declare function adjtime(arg: any, arg1: any): number;
declare function futimes(arg: number, arg1: any): number;
declare function lutimes(arg: string, arg1: any): number;
declare function settimeofday(arg: any, arg1: any): number;
declare function getitimer(arg: number, arg1: any): number;
declare function gettimeofday(arg: any, arg1: any): number;
declare function setitimer(arg: number, arg1: any, arg2: any): number;
declare function utimes(arg: string, arg1: any): number;
declare function audit(arg: any, arg1: number): number;
declare function auditon(arg: number, arg1: any, arg2: number): number;
declare function auditctl(arg: string): number;
declare function getauid(arg: any): number;
declare function setauid(arg: any): number;
declare function getaudit_addr(arg: any, arg1: number): number;
declare function setaudit_addr(arg: any, arg1: number): number;
declare function getaudit(arg: any): number;
declare function setaudit(arg: any): number;
declare function audit_session_self(): number;
declare function audit_session_join(port: number): number;
declare function audit_session_port(asid: number, portname: any): number;
declare function kqueue(): number;
declare function kevent(kq: number, changelist: any, nchanges: number, eventlist: any, nevents: number, timeout: any): number;
declare function kevent64(kq: number, changelist: any, nchanges: number, eventlist: any, nevents: number, flags: number, timeout: any): number;
declare function sysctl(arg: any, arg1: number, arg2: any, arg3: any, arg4: any, arg5: number): number;
declare function sysctlbyname(arg: string, arg1: any, arg2: any, arg3: any, arg4: number): number;
declare function sysctlnametomib(arg: string, arg1: any, arg2: any): number;
declare function CGRectGetMinX(rect: CGRect): number;
declare function CGRectGetMidX(rect: CGRect): number;
declare function CGRectGetMaxX(rect: CGRect): number;
declare function CGRectGetMinY(rect: CGRect): number;
declare function CGRectGetMidY(rect: CGRect): number;
declare function CGRectGetMaxY(rect: CGRect): number;
declare function CGRectGetWidth(rect: CGRect): number;
declare function CGRectGetHeight(rect: CGRect): number;
declare function CGPointEqualToPoint(point1: CGPoint, point2: CGPoint): boolean;
declare function CGSizeEqualToSize(size1: CGSize, size2: CGSize): boolean;
declare function CGRectEqualToRect(rect1: CGRect, rect2: CGRect): boolean;
declare function CGRectStandardize(rect: CGRect): CGRect;
declare function CGRectIsEmpty(rect: CGRect): boolean;
declare function CGRectIsNull(rect: CGRect): boolean;
declare function CGRectIsInfinite(rect: CGRect): boolean;
declare function CGRectInset(rect: CGRect, dx: number, dy: number): CGRect;
declare function CGRectIntegral(rect: CGRect): CGRect;
declare function CGRectUnion(r1: CGRect, r2: CGRect): CGRect;
declare function CGRectIntersection(r1: CGRect, r2: CGRect): CGRect;
declare function CGRectOffset(rect: CGRect, dx: number, dy: number): CGRect;
declare function CGRectDivide(rect: CGRect, slice: any, remainder: any, amount: number, edge: number): void;
declare function CGRectContainsPoint(rect: CGRect, point: CGPoint): boolean;
declare function CGRectContainsRect(rect1: CGRect, rect2: CGRect): boolean;
declare function CGRectIntersectsRect(rect1: CGRect, rect2: CGRect): boolean;
declare function CGPointCreateDictionaryRepresentation(point: CGPoint): NSDictionary;
declare function CGPointMakeWithDictionaryRepresentation(dict: NSDictionary, point: any): boolean;
declare function CGSizeCreateDictionaryRepresentation(size: CGSize): NSDictionary;
declare function CGSizeMakeWithDictionaryRepresentation(dict: NSDictionary, size: any): boolean;
declare function CGRectCreateDictionaryRepresentation(arg: CGRect): NSDictionary;
declare function CGRectMakeWithDictionaryRepresentation(dict: NSDictionary, rect: any): boolean;
declare function CGAffineTransformMake(a: number, b: number, c: number, d: number, tx: number, ty: number): CGAffineTransform;
declare function CGAffineTransformMakeTranslation(tx: number, ty: number): CGAffineTransform;
declare function CGAffineTransformMakeScale(sx: number, sy: number): CGAffineTransform;
declare function CGAffineTransformMakeRotation(angle: number): CGAffineTransform;
declare function CGAffineTransformIsIdentity(t: CGAffineTransform): boolean;
declare function CGAffineTransformTranslate(t: CGAffineTransform, tx: number, ty: number): CGAffineTransform;
declare function CGAffineTransformScale(t: CGAffineTransform, sx: number, sy: number): CGAffineTransform;
declare function CGAffineTransformRotate(t: CGAffineTransform, angle: number): CGAffineTransform;
declare function CGAffineTransformInvert(t: CGAffineTransform): CGAffineTransform;
declare function CGAffineTransformConcat(t1: CGAffineTransform, t2: CGAffineTransform): CGAffineTransform;
declare function CGAffineTransformEqualToTransform(t1: CGAffineTransform, t2: CGAffineTransform): boolean;
declare function CGPointApplyAffineTransform(point: CGPoint, t: CGAffineTransform): CGPoint;
declare function CGSizeApplyAffineTransform(size: CGSize, t: CGAffineTransform): CGSize;
declare function CGRectApplyAffineTransform(rect: CGRect, t: CGAffineTransform): CGRect;
declare function CGDataProviderGetTypeID(): number;
declare function CGDataProviderCreateSequential(info: any, callbacks: any): any;
declare function CGDataProviderCreateDirect(info: any, size: number, callbacks: any): any;
declare function CGDataProviderCreateWithData(info: any, data: any, size: number, releaseData: (arg1: any, arg2: any, arg3: number) => void): any;
declare function CGDataProviderCreateWithCFData(data: NSData): any;
declare function CGDataProviderCreateWithURL(url: NSURL): any;
declare function CGDataProviderCreateWithFilename(filename: string): any;
declare function CGDataProviderRetain(provider: any): any;
declare function CGDataProviderRelease(provider: any): void;
declare function CGDataProviderCopyData(provider: any): NSData;
declare function CGColorSpaceCreateDeviceGray(): any;
declare function CGColorSpaceCreateDeviceRGB(): any;
declare function CGColorSpaceCreateDeviceCMYK(): any;
declare function CGColorSpaceCreateCalibratedGray(whitePoint: number[], blackPoint: number[], gamma: number): any;
declare function CGColorSpaceCreateCalibratedRGB(whitePoint: number[], blackPoint: number[], gamma: number[], matrix: number[]): any;
declare function CGColorSpaceCreateLab(whitePoint: number[], blackPoint: number[], range: number[]): any;
declare function CGColorSpaceCreateWithICCProfile(data: NSData): any;
declare function CGColorSpaceCreateICCBased(nComponents: number, range: any, profile: any, alternate: any): any;
declare function CGColorSpaceCreateIndexed(baseSpace: any, lastIndex: number, colorTable: string): any;
declare function CGColorSpaceCreatePattern(baseSpace: any): any;
declare function CGColorSpaceCreateWithName(name: string): any;
declare function CGColorSpaceRetain(space: any): any;
declare function CGColorSpaceRelease(space: any): void;
declare function CGColorSpaceGetTypeID(): number;
declare function CGColorSpaceGetNumberOfComponents(space: any): number;
declare function CGColorSpaceGetModel(space: any): number;
declare function CGColorSpaceGetBaseColorSpace(space: any): any;
declare function CGColorSpaceGetColorTableCount(space: any): number;
declare function CGColorSpaceGetColorTable(space: any, table: string): void;
declare function CGColorSpaceCopyICCProfile(space: any): NSData;
declare function CGPatternGetTypeID(): number;
declare function CGPatternCreate(info: any, bounds: CGRect, matrix: CGAffineTransform, xStep: number, yStep: number, tiling: number, isColored: boolean, callbacks: any): any;
declare function CGPatternRetain(pattern: any): any;
declare function CGPatternRelease(pattern: any): void;
declare function CGColorCreate(space: any, components: any): any;
declare function CGColorCreateWithPattern(space: any, pattern: any, components: any): any;
declare function CGColorCreateCopy(color: any): any;
declare function CGColorCreateCopyWithAlpha(color: any, alpha: number): any;
declare function CGColorRetain(color: any): any;
declare function CGColorRelease(color: any): void;
declare function CGColorEqualToColor(color1: any, color2: any): boolean;
declare function CGColorGetNumberOfComponents(color: any): number;
declare function CGColorGetComponents(color: any): any;
declare function CGColorGetAlpha(color: any): number;
declare function CGColorGetColorSpace(color: any): any;
declare function CGColorGetPattern(color: any): any;
declare function CGColorGetTypeID(): number;
declare function CGFontGetTypeID(): number;
declare function CGFontCreateWithDataProvider(provider: any): any;
declare function CGFontCreateWithFontName(name: string): any;
declare function CGFontCreateCopyWithVariations(font: any, variations: NSDictionary): any;
declare function CGFontRetain(font: any): any;
declare function CGFontRelease(font: any): void;
declare function CGFontGetNumberOfGlyphs(font: any): number;
declare function CGFontGetUnitsPerEm(font: any): number;
declare function CGFontCopyPostScriptName(font: any): string;
declare function CGFontCopyFullName(font: any): string;
declare function CGFontGetAscent(font: any): number;
declare function CGFontGetDescent(font: any): number;
declare function CGFontGetLeading(font: any): number;
declare function CGFontGetCapHeight(font: any): number;
declare function CGFontGetXHeight(font: any): number;
declare function CGFontGetFontBBox(font: any): CGRect;
declare function CGFontGetItalicAngle(font: any): number;
declare function CGFontGetStemV(font: any): number;
declare function CGFontCopyVariationAxes(font: any): NSArray;
declare function CGFontCopyVariations(font: any): NSDictionary;
declare function CGFontGetGlyphAdvances(font: any, glyphs: any, count: number, advances: any): boolean;
declare function CGFontGetGlyphBBoxes(font: any, glyphs: any, count: number, bboxes: any): boolean;
declare function CGFontGetGlyphWithGlyphName(font: any, name: string): number;
declare function CGFontCopyGlyphNameForGlyph(font: any, glyph: number): string;
declare function CGFontCanCreatePostScriptSubset(font: any, format: number): boolean;
declare function CGFontCreatePostScriptSubset(font: any, subsetName: string, format: number, glyphs: any, count: number, encoding: number[]): NSData;
declare function CGFontCreatePostScriptEncoding(font: any, encoding: number[]): NSData;
declare function CGFontCopyTableTags(font: any): NSArray;
declare function CGFontCopyTableForTag(font: any, tag: number): NSData;
declare function CGGradientGetTypeID(): number;
declare function CGGradientCreateWithColorComponents(space: any, components: any, locations: any, count: number): any;
declare function CGGradientCreateWithColors(space: any, colors: NSArray, locations: any): any;
declare function CGGradientRetain(gradient: any): any;
declare function CGGradientRelease(gradient: any): void;
declare function CGImageGetTypeID(): number;
declare function CGImageCreate(width: number, height: number, bitsPerComponent: number, bitsPerPixel: number, bytesPerRow: number, space: any, bitmapInfo: number, provider: any, decode: any, shouldInterpolate: boolean, intent: number): any;
declare function CGImageMaskCreate(width: number, height: number, bitsPerComponent: number, bitsPerPixel: number, bytesPerRow: number, provider: any, decode: any, shouldInterpolate: boolean): any;
declare function CGImageCreateCopy(image: any): any;
declare function CGImageCreateWithJPEGDataProvider(source: any, decode: any, shouldInterpolate: boolean, intent: number): any;
declare function CGImageCreateWithPNGDataProvider(source: any, decode: any, shouldInterpolate: boolean, intent: number): any;
declare function CGImageCreateWithImageInRect(image: any, rect: CGRect): any;
declare function CGImageCreateWithMask(image: any, mask: any): any;
declare function CGImageCreateWithMaskingColors(image: any, components: any): any;
declare function CGImageCreateCopyWithColorSpace(image: any, space: any): any;
declare function CGImageRetain(image: any): any;
declare function CGImageRelease(image: any): void;
declare function CGImageIsMask(image: any): boolean;
declare function CGImageGetWidth(image: any): number;
declare function CGImageGetHeight(image: any): number;
declare function CGImageGetBitsPerComponent(image: any): number;
declare function CGImageGetBitsPerPixel(image: any): number;
declare function CGImageGetBytesPerRow(image: any): number;
declare function CGImageGetColorSpace(image: any): any;
declare function CGImageGetAlphaInfo(image: any): number;
declare function CGImageGetDataProvider(image: any): any;
declare function CGImageGetDecode(image: any): any;
declare function CGImageGetShouldInterpolate(image: any): boolean;
declare function CGImageGetRenderingIntent(image: any): number;
declare function CGImageGetBitmapInfo(image: any): number;
declare function CGPathGetTypeID(): number;
declare function CGPathCreateMutable(): any;
declare function CGPathCreateCopy(path: any): any;
declare function CGPathCreateCopyByTransformingPath(path: any, transform: any): any;
declare function CGPathCreateMutableCopy(path: any): any;
declare function CGPathCreateMutableCopyByTransformingPath(path: any, transform: any): any;
declare function CGPathCreateWithRect(rect: CGRect, transform: any): any;
declare function CGPathCreateWithEllipseInRect(rect: CGRect, transform: any): any;
declare function CGPathCreateWithRoundedRect(rect: CGRect, cornerWidth: number, cornerHeight: number, transform: any): any;
declare function CGPathAddRoundedRect(path: any, transform: any, rect: CGRect, cornerWidth: number, cornerHeight: number): void;
declare function CGPathCreateCopyByDashingPath(path: any, transform: any, phase: number, lengths: any, count: number): any;
declare function CGPathCreateCopyByStrokingPath(path: any, transform: any, lineWidth: number, lineCap: number, lineJoin: number, miterLimit: number): any;
declare function CGPathRetain(path: any): any;
declare function CGPathRelease(path: any): void;
declare function CGPathEqualToPath(path1: any, path2: any): boolean;
declare function CGPathMoveToPoint(path: any, m: any, x: number, y: number): void;
declare function CGPathAddLineToPoint(path: any, m: any, x: number, y: number): void;
declare function CGPathAddQuadCurveToPoint(path: any, m: any, cpx: number, cpy: number, x: number, y: number): void;
declare function CGPathAddCurveToPoint(path: any, m: any, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
declare function CGPathCloseSubpath(path: any): void;
declare function CGPathAddRect(path: any, m: any, rect: CGRect): void;
declare function CGPathAddRects(path: any, m: any, rects: any, count: number): void;
declare function CGPathAddLines(path: any, m: any, points: any, count: number): void;
declare function CGPathAddEllipseInRect(path: any, m: any, rect: CGRect): void;
declare function CGPathAddRelativeArc(path: any, matrix: any, x: number, y: number, radius: number, startAngle: number, delta: number): void;
declare function CGPathAddArc(path: any, m: any, x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;
declare function CGPathAddArcToPoint(path: any, m: any, x1: number, y1: number, x2: number, y2: number, radius: number): void;
declare function CGPathAddPath(path1: any, m: any, path2: any): void;
declare function CGPathIsEmpty(path: any): boolean;
declare function CGPathIsRect(path: any, rect: any): boolean;
declare function CGPathGetCurrentPoint(path: any): CGPoint;
declare function CGPathGetBoundingBox(path: any): CGRect;
declare function CGPathGetPathBoundingBox(path: any): CGRect;
declare function CGPathContainsPoint(path: any, m: any, point: CGPoint, eoFill: boolean): boolean;
declare function CGPathApply(path: any, info: any, funcArg: (arg1: any, arg2: any) => void): void;
declare function CGPDFStreamGetDictionary(stream: any): any;
declare function CGPDFStreamCopyData(stream: any, format: any): NSData;
declare function CGPDFStringGetLength(string: any): number;
declare function CGPDFStringGetBytePtr(string: any): string;
declare function CGPDFStringCopyTextString(string: any): string;
declare function CGPDFStringCopyDate(string: any): NSDate;
declare function CGPDFArrayGetCount(array: any): number;
declare function CGPDFArrayGetNull(array: any, index: number): boolean;
declare function CGPDFArrayGetBoolean(array: any, index: number, value: string): boolean;
declare function CGPDFArrayGetInteger(array: any, index: number, value: any): boolean;
declare function CGPDFArrayGetNumber(array: any, index: number, value: any): boolean;
declare function CGPDFArrayGetName(array: any, index: number, value: any): boolean;
declare function CGPDFArrayGetString(array: any, index: number, value: any): boolean;
declare function CGPDFArrayGetArray(array: any, index: number, value: any): boolean;
declare function CGPDFArrayGetDictionary(array: any, index: number, value: any): boolean;
declare function CGPDFArrayGetStream(array: any, index: number, value: any): boolean;
declare function CGPDFDictionaryGetCount(dict: any): number;
declare function CGPDFDictionaryGetBoolean(dict: any, key: string, value: string): boolean;
declare function CGPDFDictionaryGetInteger(dict: any, key: string, value: any): boolean;
declare function CGPDFDictionaryGetNumber(dict: any, key: string, value: any): boolean;
declare function CGPDFDictionaryGetName(dict: any, key: string, value: any): boolean;
declare function CGPDFDictionaryGetString(dict: any, key: string, value: any): boolean;
declare function CGPDFDictionaryGetArray(dict: any, key: string, value: any): boolean;
declare function CGPDFDictionaryGetDictionary(dict: any, key: string, value: any): boolean;
declare function CGPDFDictionaryGetStream(dict: any, key: string, value: any): boolean;
declare function CGPDFPageRetain(page: any): any;
declare function CGPDFPageRelease(page: any): void;
declare function CGPDFPageGetDocument(page: any): any;
declare function CGPDFPageGetPageNumber(page: any): number;
declare function CGPDFPageGetBoxRect(page: any, box: number): CGRect;
declare function CGPDFPageGetRotationAngle(page: any): number;
declare function CGPDFPageGetDrawingTransform(page: any, box: number, rect: CGRect, rotate: number, preserveAspectRatio: boolean): CGAffineTransform;
declare function CGPDFPageGetDictionary(page: any): any;
declare function CGPDFPageGetTypeID(): number;
declare function CGPDFDocumentCreateWithProvider(provider: any): any;
declare function CGPDFDocumentCreateWithURL(url: NSURL): any;
declare function CGPDFDocumentRetain(document: any): any;
declare function CGPDFDocumentRelease(document: any): void;
declare function CGPDFDocumentGetVersion(document: any, majorVersion: any, minorVersion: any): void;
declare function CGPDFDocumentIsEncrypted(document: any): boolean;
declare function CGPDFDocumentUnlockWithPassword(document: any, password: string): boolean;
declare function CGPDFDocumentIsUnlocked(document: any): boolean;
declare function CGPDFDocumentAllowsPrinting(document: any): boolean;
declare function CGPDFDocumentAllowsCopying(document: any): boolean;
declare function CGPDFDocumentGetNumberOfPages(document: any): number;
declare function CGPDFDocumentGetPage(document: any, pageNumber: number): any;
declare function CGPDFDocumentGetCatalog(document: any): any;
declare function CGPDFDocumentGetInfo(document: any): any;
declare function CGPDFDocumentGetID(document: any): any;
declare function CGPDFDocumentGetTypeID(): number;
declare function CGFunctionGetTypeID(): number;
declare function CGFunctionCreate(info: any, domainDimension: number, domain: any, rangeDimension: number, range: any, callbacks: any): any;
declare function CGFunctionRetain(funcArg: any): any;
declare function CGFunctionRelease(funcArg: any): void;
declare function CGShadingGetTypeID(): number;
declare function CGShadingCreateAxial(space: any, start: CGPoint, end: CGPoint, funcArg: any, extendStart: boolean, extendEnd: boolean): any;
declare function CGShadingCreateRadial(space: any, start: CGPoint, startRadius: number, end: CGPoint, endRadius: number, funcArg: any, extendStart: boolean, extendEnd: boolean): any;
declare function CGShadingRetain(shading: any): any;
declare function CGShadingRelease(shading: any): void;
declare function CGContextGetTypeID(): number;
declare function CGContextSaveGState(c: any): void;
declare function CGContextRestoreGState(c: any): void;
declare function CGContextScaleCTM(c: any, sx: number, sy: number): void;
declare function CGContextTranslateCTM(c: any, tx: number, ty: number): void;
declare function CGContextRotateCTM(c: any, angle: number): void;
declare function CGContextConcatCTM(c: any, transform: CGAffineTransform): void;
declare function CGContextGetCTM(c: any): CGAffineTransform;
declare function CGContextSetLineWidth(c: any, width: number): void;
declare function CGContextSetLineCap(c: any, cap: number): void;
declare function CGContextSetLineJoin(c: any, join: number): void;
declare function CGContextSetMiterLimit(c: any, limit: number): void;
declare function CGContextSetLineDash(c: any, phase: number, lengths: any, count: number): void;
declare function CGContextSetFlatness(c: any, flatness: number): void;
declare function CGContextSetAlpha(c: any, alpha: number): void;
declare function CGContextSetBlendMode(context: any, mode: number): void;
declare function CGContextBeginPath(c: any): void;
declare function CGContextMoveToPoint(c: any, x: number, y: number): void;
declare function CGContextAddLineToPoint(c: any, x: number, y: number): void;
declare function CGContextAddCurveToPoint(c: any, cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
declare function CGContextAddQuadCurveToPoint(c: any, cpx: number, cpy: number, x: number, y: number): void;
declare function CGContextClosePath(c: any): void;
declare function CGContextAddRect(c: any, rect: CGRect): void;
declare function CGContextAddRects(c: any, rects: any, count: number): void;
declare function CGContextAddLines(c: any, points: any, count: number): void;
declare function CGContextAddEllipseInRect(context: any, rect: CGRect): void;
declare function CGContextAddArc(c: any, x: number, y: number, radius: number, startAngle: number, endAngle: number, clockwise: number): void;
declare function CGContextAddArcToPoint(c: any, x1: number, y1: number, x2: number, y2: number, radius: number): void;
declare function CGContextAddPath(context: any, path: any): void;
declare function CGContextReplacePathWithStrokedPath(c: any): void;
declare function CGContextIsPathEmpty(context: any): boolean;
declare function CGContextGetPathCurrentPoint(context: any): CGPoint;
declare function CGContextGetPathBoundingBox(context: any): CGRect;
declare function CGContextCopyPath(context: any): any;
declare function CGContextPathContainsPoint(context: any, point: CGPoint, mode: number): boolean;
declare function CGContextDrawPath(c: any, mode: number): void;
declare function CGContextFillPath(c: any): void;
declare function CGContextEOFillPath(c: any): void;
declare function CGContextStrokePath(c: any): void;
declare function CGContextFillRect(c: any, rect: CGRect): void;
declare function CGContextFillRects(c: any, rects: any, count: number): void;
declare function CGContextStrokeRect(c: any, rect: CGRect): void;
declare function CGContextStrokeRectWithWidth(c: any, rect: CGRect, width: number): void;
declare function CGContextClearRect(c: any, rect: CGRect): void;
declare function CGContextFillEllipseInRect(context: any, rect: CGRect): void;
declare function CGContextStrokeEllipseInRect(context: any, rect: CGRect): void;
declare function CGContextStrokeLineSegments(c: any, points: any, count: number): void;
declare function CGContextClip(c: any): void;
declare function CGContextEOClip(c: any): void;
declare function CGContextClipToMask(c: any, rect: CGRect, mask: any): void;
declare function CGContextGetClipBoundingBox(c: any): CGRect;
declare function CGContextClipToRect(c: any, rect: CGRect): void;
declare function CGContextClipToRects(c: any, rects: any, count: number): void;
declare function CGContextSetFillColorWithColor(c: any, color: any): void;
declare function CGContextSetStrokeColorWithColor(c: any, color: any): void;
declare function CGContextSetFillColorSpace(context: any, space: any): void;
declare function CGContextSetStrokeColorSpace(context: any, space: any): void;
declare function CGContextSetFillColor(context: any, components: any): void;
declare function CGContextSetStrokeColor(context: any, components: any): void;
declare function CGContextSetFillPattern(context: any, pattern: any, components: any): void;
declare function CGContextSetStrokePattern(context: any, pattern: any, components: any): void;
declare function CGContextSetPatternPhase(context: any, phase: CGSize): void;
declare function CGContextSetGrayFillColor(context: any, gray: number, alpha: number): void;
declare function CGContextSetGrayStrokeColor(context: any, gray: number, alpha: number): void;
declare function CGContextSetRGBFillColor(context: any, red: number, green: number, blue: number, alpha: number): void;
declare function CGContextSetRGBStrokeColor(context: any, red: number, green: number, blue: number, alpha: number): void;
declare function CGContextSetCMYKFillColor(context: any, cyan: number, magenta: number, yellow: number, black: number, alpha: number): void;
declare function CGContextSetCMYKStrokeColor(context: any, cyan: number, magenta: number, yellow: number, black: number, alpha: number): void;
declare function CGContextSetRenderingIntent(context: any, intent: number): void;
declare function CGContextDrawImage(c: any, rect: CGRect, image: any): void;
declare function CGContextDrawTiledImage(c: any, rect: CGRect, image: any): void;
declare function CGContextGetInterpolationQuality(context: any): number;
declare function CGContextSetInterpolationQuality(context: any, quality: number): void;
declare function CGContextSetShadowWithColor(context: any, offset: CGSize, blur: number, color: any): void;
declare function CGContextSetShadow(context: any, offset: CGSize, blur: number): void;
declare function CGContextDrawLinearGradient(context: any, gradient: any, startPoint: CGPoint, endPoint: CGPoint, options: number): void;
declare function CGContextDrawRadialGradient(context: any, gradient: any, startCenter: CGPoint, startRadius: number, endCenter: CGPoint, endRadius: number, options: number): void;
declare function CGContextDrawShading(context: any, shading: any): void;
declare function CGContextSetCharacterSpacing(context: any, spacing: number): void;
declare function CGContextSetTextPosition(c: any, x: number, y: number): void;
declare function CGContextGetTextPosition(context: any): CGPoint;
declare function CGContextSetTextMatrix(c: any, t: CGAffineTransform): void;
declare function CGContextGetTextMatrix(c: any): CGAffineTransform;
declare function CGContextSetTextDrawingMode(c: any, mode: number): void;
declare function CGContextSetFont(c: any, font: any): void;
declare function CGContextSetFontSize(c: any, size: number): void;
declare function CGContextShowGlyphsAtPositions(context: any, glyphs: any, positions: any, count: number): void;
declare function CGContextDrawPDFPage(c: any, page: any): void;
declare function CGContextBeginPage(c: any, mediaBox: any): void;
declare function CGContextEndPage(c: any): void;
declare function CGContextRetain(c: any): any;
declare function CGContextRelease(c: any): void;
declare function CGContextFlush(c: any): void;
declare function CGContextSynchronize(c: any): void;
declare function CGContextSetShouldAntialias(context: any, shouldAntialias: boolean): void;
declare function CGContextSetAllowsAntialiasing(context: any, allowsAntialiasing: boolean): void;
declare function CGContextSetShouldSmoothFonts(context: any, shouldSmoothFonts: boolean): void;
declare function CGContextSetAllowsFontSmoothing(context: any, allowsFontSmoothing: boolean): void;
declare function CGContextSetShouldSubpixelPositionFonts(context: any, shouldSubpixelPositionFonts: boolean): void;
declare function CGContextSetAllowsFontSubpixelPositioning(context: any, allowsFontSubpixelPositioning: boolean): void;
declare function CGContextSetShouldSubpixelQuantizeFonts(context: any, shouldSubpixelQuantizeFonts: boolean): void;
declare function CGContextSetAllowsFontSubpixelQuantization(context: any, allowsFontSubpixelQuantization: boolean): void;
declare function CGContextBeginTransparencyLayer(context: any, auxiliaryInfo: NSDictionary): void;
declare function CGContextBeginTransparencyLayerWithRect(context: any, rect: CGRect, auxiliaryInfo: NSDictionary): void;
declare function CGContextEndTransparencyLayer(context: any): void;
declare function CGContextGetUserSpaceToDeviceSpaceTransform(context: any): CGAffineTransform;
declare function CGContextConvertPointToDeviceSpace(context: any, point: CGPoint): CGPoint;
declare function CGContextConvertPointToUserSpace(context: any, point: CGPoint): CGPoint;
declare function CGContextConvertSizeToDeviceSpace(context: any, size: CGSize): CGSize;
declare function CGContextConvertSizeToUserSpace(context: any, size: CGSize): CGSize;
declare function CGContextConvertRectToDeviceSpace(context: any, rect: CGRect): CGRect;
declare function CGContextConvertRectToUserSpace(context: any, rect: CGRect): CGRect;
declare function CGContextSelectFont(c: any, name: string, size: number, textEncoding: number): void;
declare function CGContextShowText(c: any, string: string, length: number): void;
declare function CGContextShowTextAtPoint(c: any, x: number, y: number, string: string, length: number): void;
declare function CGContextShowGlyphs(c: any, g: any, count: number): void;
declare function CGContextShowGlyphsAtPoint(context: any, x: number, y: number, glyphs: any, count: number): void;
declare function CGContextShowGlyphsWithAdvances(context: any, glyphs: any, advances: any, count: number): void;
declare function CGBitmapContextCreateWithData(data: any, width: number, height: number, bitsPerComponent: number, bytesPerRow: number, space: any, bitmapInfo: number, releaseCallback: (arg1: any, arg2: any) => void, releaseInfo: any): any;
declare function CGBitmapContextCreate(data: any, width: number, height: number, bitsPerComponent: number, bytesPerRow: number, space: any, bitmapInfo: number): any;
declare function CGBitmapContextGetData(context: any): any;
declare function CGBitmapContextGetWidth(context: any): number;
declare function CGBitmapContextGetHeight(context: any): number;
declare function CGBitmapContextGetBitsPerComponent(context: any): number;
declare function CGBitmapContextGetBitsPerPixel(context: any): number;
declare function CGBitmapContextGetBytesPerRow(context: any): number;
declare function CGBitmapContextGetColorSpace(context: any): any;
declare function CGBitmapContextGetAlphaInfo(context: any): number;
declare function CGBitmapContextGetBitmapInfo(context: any): number;
declare function CGBitmapContextCreateImage(context: any): any;
declare function CGDataConsumerGetTypeID(): number;
declare function CGDataConsumerCreate(info: any, callbacks: any): any;
declare function CGDataConsumerCreateWithURL(url: NSURL): any;
declare function CGDataConsumerCreateWithCFData(data: NSMutableData): any;
declare function CGDataConsumerRetain(consumer: any): any;
declare function CGDataConsumerRelease(consumer: any): void;
declare function CGLayerCreateWithContext(context: any, size: CGSize, auxiliaryInfo: NSDictionary): any;
declare function CGLayerRetain(layer: any): any;
declare function CGLayerRelease(layer: any): void;
declare function CGLayerGetSize(layer: any): CGSize;
declare function CGLayerGetContext(layer: any): any;
declare function CGContextDrawLayerInRect(context: any, rect: CGRect, layer: any): void;
declare function CGContextDrawLayerAtPoint(context: any, point: CGPoint, layer: any): void;
declare function CGLayerGetTypeID(): number;
declare function CGPDFContentStreamCreateWithPage(page: any): any;
declare function CGPDFContentStreamCreateWithStream(stream: any, streamResources: any, parent: any): any;
declare function CGPDFContentStreamRetain(cs: any): any;
declare function CGPDFContentStreamRelease(cs: any): void;
declare function CGPDFContentStreamGetStreams(cs: any): NSArray;
declare function CGPDFContextCreate(consumer: any, mediaBox: any, auxiliaryInfo: NSDictionary): any;
declare function CGPDFContextCreateWithURL(url: NSURL, mediaBox: any, auxiliaryInfo: NSDictionary): any;
declare function CGPDFContextClose(context: any): void;
declare function CGPDFContextBeginPage(context: any, pageInfo: NSDictionary): void;
declare function CGPDFContextEndPage(context: any): void;
declare function CGPDFContextAddDocumentMetadata(context: any, metadata: NSData): void;
declare function CGPDFContextSetURLForRect(context: any, url: NSURL, rect: CGRect): void;
declare function CGPDFContextAddDestinationAtPoint(context: any, name: string, point: CGPoint): void;
declare function CGPDFContextSetDestinationForRect(context: any, name: string, rect: CGRect): void;
declare function CGPDFScannerCreate(cs: any, table: any, info: any): any;
declare function CGPDFScannerRetain(scanner: any): any;
declare function CGPDFScannerRelease(scanner: any): void;
declare function CGPDFScannerScan(scanner: any): boolean;
declare function CGPDFScannerGetContentStream(scanner: any): any;
declare function CGPDFScannerPopBoolean(scanner: any, value: string): boolean;
declare function CGPDFScannerPopInteger(scanner: any, value: any): boolean;
declare function CGPDFScannerPopNumber(scanner: any, value: any): boolean;
declare function CGPDFScannerPopName(scanner: any, value: any): boolean;
declare function CGPDFScannerPopString(scanner: any, value: any): boolean;
declare function CGPDFScannerPopArray(scanner: any, value: any): boolean;
declare function CGPDFScannerPopDictionary(scanner: any, value: any): boolean;
declare function CGPDFScannerPopStream(scanner: any, value: any): boolean;
declare function CGPDFOperatorTableCreate(): any;
declare function CGPDFOperatorTableRetain(table: any): any;
declare function CGPDFOperatorTableRelease(table: any): void;
declare function CGPDFOperatorTableSetCallback(table: any, name: string, callback: (arg1: any, arg2: any) => void): void;
declare function __CFRangeMake(loc: number, len: number): CFRange;
declare function CFNullGetTypeID(): number;
declare function CFAllocatorGetTypeID(): number;
declare function CFAllocatorSetDefault(allocator: any): void;
declare function CFAllocatorGetDefault(): any;
declare function CFAllocatorCreate(allocator: any, context: any): any;
declare function CFAllocatorAllocate(allocator: any, size: number, hint: number): any;
declare function CFAllocatorReallocate(allocator: any, ptr: any, newsize: number, hint: number): any;
declare function CFAllocatorDeallocate(allocator: any, ptr: any): void;
declare function CFAllocatorGetPreferredSizeForSize(allocator: any, size: number, hint: number): number;
declare function CFAllocatorGetContext(allocator: any, context: any): void;
declare function CFGetTypeID(cf: any): number;
declare function CFCopyTypeIDDescription(type_id: number): string;
declare function CFRetain(cf: any): any;
declare function CFRelease(cf: any): void;
declare function CFAutorelease(arg: any): any;
declare function CFGetRetainCount(cf: any): number;
declare function CFEqual(cf1: any, cf2: any): boolean;
declare function CFHash(cf: any): number;
declare function CFCopyDescription(cf: any): string;
declare function CFGetAllocator(cf: any): any;
declare function CFDictionaryGetTypeID(): number;
declare function CFDictionaryCreate(allocator: any, keys: any, values: any, numValues: number, keyCallBacks: any, valueCallBacks: any): NSDictionary;
declare function CFDictionaryCreateCopy(allocator: any, theDict: NSDictionary): NSDictionary;
declare function CFDictionaryCreateMutable(allocator: any, capacity: number, keyCallBacks: any, valueCallBacks: any): NSMutableDictionary;
declare function CFDictionaryCreateMutableCopy(allocator: any, capacity: number, theDict: NSDictionary): NSMutableDictionary;
declare function CFDictionaryGetCount(theDict: NSDictionary): number;
declare function CFDictionaryGetCountOfKey(theDict: NSDictionary, key: any): number;
declare function CFDictionaryGetCountOfValue(theDict: NSDictionary, value: any): number;
declare function CFDictionaryContainsKey(theDict: NSDictionary, key: any): boolean;
declare function CFDictionaryContainsValue(theDict: NSDictionary, value: any): boolean;
declare function CFDictionaryGetValue(theDict: NSDictionary, key: any): any;
declare function CFDictionaryGetValueIfPresent(theDict: NSDictionary, key: any, value: any): boolean;
declare function CFDictionaryGetKeysAndValues(theDict: NSDictionary, keys: any, values: any): void;
declare function CFDictionaryApplyFunction(theDict: NSDictionary, applier: (arg1: any, arg2: any, arg3: any) => void, context: any): void;
declare function CFDictionaryAddValue(theDict: NSMutableDictionary, key: any, value: any): void;
declare function CFDictionarySetValue(theDict: NSMutableDictionary, key: any, value: any): void;
declare function CFDictionaryReplaceValue(theDict: NSMutableDictionary, key: any, value: any): void;
declare function CFDictionaryRemoveValue(theDict: NSMutableDictionary, key: any): void;
declare function CFDictionaryRemoveAllValues(theDict: NSMutableDictionary): void;
declare function CFDataGetTypeID(): number;
declare function CFDataCreate(allocator: any, bytes: string, length: number): NSData;
declare function CFDataCreateWithBytesNoCopy(allocator: any, bytes: string, length: number, bytesDeallocator: any): NSData;
declare function CFDataCreateCopy(allocator: any, theData: NSData): NSData;
declare function CFDataCreateMutable(allocator: any, capacity: number): NSMutableData;
declare function CFDataCreateMutableCopy(allocator: any, capacity: number, theData: NSData): NSMutableData;
declare function CFDataGetLength(theData: NSData): number;
declare function CFDataGetBytePtr(theData: NSData): string;
declare function CFDataGetMutableBytePtr(theData: NSMutableData): string;
declare function CFDataGetBytes(theData: NSData, range: CFRange, buffer: string): void;
declare function CFDataSetLength(theData: NSMutableData, length: number): void;
declare function CFDataIncreaseLength(theData: NSMutableData, extraLength: number): void;
declare function CFDataAppendBytes(theData: NSMutableData, bytes: string, length: number): void;
declare function CFDataReplaceBytes(theData: NSMutableData, range: CFRange, newBytes: string, newLength: number): void;
declare function CFDataDeleteBytes(theData: NSMutableData, range: CFRange): void;
declare function CFDataFind(theData: NSData, dataToFind: NSData, searchRange: CFRange, compareOptions: number): CFRange;
declare function CFArrayGetTypeID(): number;
declare function CFArrayCreate(allocator: any, values: any, numValues: number, callBacks: any): NSArray;
declare function CFArrayCreateCopy(allocator: any, theArray: NSArray): NSArray;
declare function CFArrayCreateMutable(allocator: any, capacity: number, callBacks: any): NSMutableArray;
declare function CFArrayCreateMutableCopy(allocator: any, capacity: number, theArray: NSArray): NSMutableArray;
declare function CFArrayGetCount(theArray: NSArray): number;
declare function CFArrayGetCountOfValue(theArray: NSArray, range: CFRange, value: any): number;
declare function CFArrayContainsValue(theArray: NSArray, range: CFRange, value: any): boolean;
declare function CFArrayGetValueAtIndex(theArray: NSArray, idx: number): any;
declare function CFArrayGetValues(theArray: NSArray, range: CFRange, values: any): void;
declare function CFArrayApplyFunction(theArray: NSArray, range: CFRange, applier: (arg1: any, arg2: any) => void, context: any): void;
declare function CFArrayGetFirstIndexOfValue(theArray: NSArray, range: CFRange, value: any): number;
declare function CFArrayGetLastIndexOfValue(theArray: NSArray, range: CFRange, value: any): number;
declare function CFArrayBSearchValues(theArray: NSArray, range: CFRange, value: any, comparator: (arg1: any, arg2: any, arg3: any) => number, context: any): number;
declare function CFArrayAppendValue(theArray: NSMutableArray, value: any): void;
declare function CFArrayInsertValueAtIndex(theArray: NSMutableArray, idx: number, value: any): void;
declare function CFArraySetValueAtIndex(theArray: NSMutableArray, idx: number, value: any): void;
declare function CFArrayRemoveValueAtIndex(theArray: NSMutableArray, idx: number): void;
declare function CFArrayRemoveAllValues(theArray: NSMutableArray): void;
declare function CFArrayReplaceValues(theArray: NSMutableArray, range: CFRange, newValues: any, newCount: number): void;
declare function CFArrayExchangeValuesAtIndices(theArray: NSMutableArray, idx1: number, idx2: number): void;
declare function CFArraySortValues(theArray: NSMutableArray, range: CFRange, comparator: (arg1: any, arg2: any, arg3: any) => number, context: any): void;
declare function CFArrayAppendArray(theArray: NSMutableArray, otherArray: NSArray, otherRange: CFRange): void;
declare function CFCharacterSetGetTypeID(): number;
declare function CFCharacterSetGetPredefined(theSetIdentifier: number): NSCharacterSet;
declare function CFCharacterSetCreateWithCharactersInRange(alloc: any, theRange: CFRange): NSCharacterSet;
declare function CFCharacterSetCreateWithCharactersInString(alloc: any, theString: string): NSCharacterSet;
declare function CFCharacterSetCreateWithBitmapRepresentation(alloc: any, theData: NSData): NSCharacterSet;
declare function CFCharacterSetCreateInvertedSet(alloc: any, theSet: NSCharacterSet): NSCharacterSet;
declare function CFCharacterSetIsSupersetOfSet(theSet: NSCharacterSet, theOtherset: NSCharacterSet): boolean;
declare function CFCharacterSetHasMemberInPlane(theSet: NSCharacterSet, thePlane: number): boolean;
declare function CFCharacterSetCreateMutable(alloc: any): NSMutableCharacterSet;
declare function CFCharacterSetCreateCopy(alloc: any, theSet: NSCharacterSet): NSCharacterSet;
declare function CFCharacterSetCreateMutableCopy(alloc: any, theSet: NSCharacterSet): NSMutableCharacterSet;
declare function CFCharacterSetIsCharacterMember(theSet: NSCharacterSet, theChar: number): boolean;
declare function CFCharacterSetIsLongCharacterMember(theSet: NSCharacterSet, theChar: number): boolean;
declare function CFCharacterSetCreateBitmapRepresentation(alloc: any, theSet: NSCharacterSet): NSData;
declare function CFCharacterSetAddCharactersInRange(theSet: NSMutableCharacterSet, theRange: CFRange): void;
declare function CFCharacterSetRemoveCharactersInRange(theSet: NSMutableCharacterSet, theRange: CFRange): void;
declare function CFCharacterSetAddCharactersInString(theSet: NSMutableCharacterSet, theString: string): void;
declare function CFCharacterSetRemoveCharactersInString(theSet: NSMutableCharacterSet, theString: string): void;
declare function CFCharacterSetUnion(theSet: NSMutableCharacterSet, theOtherSet: NSCharacterSet): void;
declare function CFCharacterSetIntersect(theSet: NSMutableCharacterSet, theOtherSet: NSCharacterSet): void;
declare function CFCharacterSetInvert(theSet: NSMutableCharacterSet): void;
declare function CFLocaleGetTypeID(): number;
declare function CFLocaleGetSystem(): NSLocale;
declare function CFLocaleCopyCurrent(): NSLocale;
declare function CFLocaleCopyAvailableLocaleIdentifiers(): NSArray;
declare function CFLocaleCopyISOLanguageCodes(): NSArray;
declare function CFLocaleCopyISOCountryCodes(): NSArray;
declare function CFLocaleCopyISOCurrencyCodes(): NSArray;
declare function CFLocaleCopyCommonISOCurrencyCodes(): NSArray;
declare function CFLocaleCopyPreferredLanguages(): NSArray;
declare function CFLocaleCreateCanonicalLanguageIdentifierFromString(allocator: any, localeIdentifier: string): string;
declare function CFLocaleCreateCanonicalLocaleIdentifierFromString(allocator: any, localeIdentifier: string): string;
declare function CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(allocator: any, lcode: number, rcode: number): string;
declare function CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(allocator: any, lcid: number): string;
declare function CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(localeIdentifier: string): number;
declare function CFLocaleGetLanguageCharacterDirection(isoLangCode: string): number;
declare function CFLocaleGetLanguageLineDirection(isoLangCode: string): number;
declare function CFLocaleCreateComponentsFromLocaleIdentifier(allocator: any, localeID: string): NSDictionary;
declare function CFLocaleCreateLocaleIdentifierFromComponents(allocator: any, dictionary: NSDictionary): string;
declare function CFLocaleCreate(allocator: any, localeIdentifier: string): NSLocale;
declare function CFLocaleCreateCopy(allocator: any, locale: NSLocale): NSLocale;
declare function CFLocaleGetIdentifier(locale: NSLocale): string;
declare function CFLocaleGetValue(locale: NSLocale, key: string): any;
declare function CFLocaleCopyDisplayNameForPropertyValue(displayLocale: NSLocale, key: string, value: string): string;
declare function CFStringGetTypeID(): number;
declare function CFStringCreateWithPascalString(alloc: any, pStr: string, encoding: number): string;
declare function CFStringCreateWithCString(alloc: any, cStr: string, encoding: number): string;
declare function CFStringCreateWithBytes(alloc: any, bytes: string, numBytes: number, encoding: number, isExternalRepresentation: boolean): string;
declare function CFStringCreateWithCharacters(alloc: any, chars: any, numChars: number): string;
declare function CFStringCreateWithPascalStringNoCopy(alloc: any, pStr: string, encoding: number, contentsDeallocator: any): string;
declare function CFStringCreateWithCStringNoCopy(alloc: any, cStr: string, encoding: number, contentsDeallocator: any): string;
declare function CFStringCreateWithBytesNoCopy(alloc: any, bytes: string, numBytes: number, encoding: number, isExternalRepresentation: boolean, contentsDeallocator: any): string;
declare function CFStringCreateWithCharactersNoCopy(alloc: any, chars: any, numChars: number, contentsDeallocator: any): string;
declare function CFStringCreateWithSubstring(alloc: any, str: string, range: CFRange): string;
declare function CFStringCreateCopy(alloc: any, theString: string): string;
declare function CFStringCreateWithFormatAndArguments(alloc: any, formatOptions: NSDictionary, format: string, args: number): string;
declare function CFStringCreateMutable(alloc: any, maxLength: number): NSMutableString;
declare function CFStringCreateMutableCopy(alloc: any, maxLength: number, theString: string): NSMutableString;
declare function CFStringCreateMutableWithExternalCharactersNoCopy(alloc: any, chars: any, numChars: number, capacity: number, externalCharactersAllocator: any): NSMutableString;
declare function CFStringGetLength(theString: string): number;
declare function CFStringGetCharacterAtIndex(theString: string, idx: number): number;
declare function CFStringGetCharacters(theString: string, range: CFRange, buffer: any): void;
declare function CFStringGetPascalString(theString: string, buffer: string, bufferSize: number, encoding: number): boolean;
declare function CFStringGetCString(theString: string, buffer: string, bufferSize: number, encoding: number): boolean;
declare function CFStringGetPascalStringPtr(theString: string, encoding: number): string;
declare function CFStringGetCStringPtr(theString: string, encoding: number): string;
declare function CFStringGetCharactersPtr(theString: string): any;
declare function CFStringGetBytes(theString: string, range: CFRange, encoding: number, lossByte: number, isExternalRepresentation: boolean, buffer: string, maxBufLen: number, usedBufLen: any): number;
declare function CFStringCreateFromExternalRepresentation(alloc: any, data: NSData, encoding: number): string;
declare function CFStringCreateExternalRepresentation(alloc: any, theString: string, encoding: number, lossByte: number): NSData;
declare function CFStringGetSmallestEncoding(theString: string): number;
declare function CFStringGetFastestEncoding(theString: string): number;
declare function CFStringGetSystemEncoding(): number;
declare function CFStringGetMaximumSizeForEncoding(length: number, encoding: number): number;
declare function CFStringGetFileSystemRepresentation(string: string, buffer: string, maxBufLen: number): boolean;
declare function CFStringGetMaximumSizeOfFileSystemRepresentation(string: string): number;
declare function CFStringCreateWithFileSystemRepresentation(alloc: any, buffer: string): string;
declare function CFStringCompareWithOptionsAndLocale(theString1: string, theString2: string, rangeToCompare: CFRange, compareOptions: number, locale: NSLocale): number;
declare function CFStringCompareWithOptions(theString1: string, theString2: string, rangeToCompare: CFRange, compareOptions: number): number;
declare function CFStringCompare(theString1: string, theString2: string, compareOptions: number): number;
declare function CFStringFindWithOptionsAndLocale(theString: string, stringToFind: string, rangeToSearch: CFRange, searchOptions: number, locale: NSLocale, result: any): boolean;
declare function CFStringFindWithOptions(theString: string, stringToFind: string, rangeToSearch: CFRange, searchOptions: number, result: any): boolean;
declare function CFStringCreateArrayWithFindResults(alloc: any, theString: string, stringToFind: string, rangeToSearch: CFRange, compareOptions: number): NSArray;
declare function CFStringFind(theString: string, stringToFind: string, compareOptions: number): CFRange;
declare function CFStringHasPrefix(theString: string, prefix: string): boolean;
declare function CFStringHasSuffix(theString: string, suffix: string): boolean;
declare function CFStringGetRangeOfComposedCharactersAtIndex(theString: string, theIndex: number): CFRange;
declare function CFStringFindCharacterFromSet(theString: string, theSet: NSCharacterSet, rangeToSearch: CFRange, searchOptions: number, result: any): boolean;
declare function CFStringGetLineBounds(theString: string, range: CFRange, lineBeginIndex: any, lineEndIndex: any, contentsEndIndex: any): void;
declare function CFStringGetParagraphBounds(string: string, range: CFRange, parBeginIndex: any, parEndIndex: any, contentsEndIndex: any): void;
declare function CFStringGetHyphenationLocationBeforeIndex(string: string, location: number, limitRange: CFRange, options: number, locale: NSLocale, character: any): number;
declare function CFStringIsHyphenationAvailableForLocale(locale: NSLocale): boolean;
declare function CFStringCreateByCombiningStrings(alloc: any, theArray: NSArray, separatorString: string): string;
declare function CFStringCreateArrayBySeparatingStrings(alloc: any, theString: string, separatorString: string): NSArray;
declare function CFStringGetIntValue(str: string): number;
declare function CFStringGetDoubleValue(str: string): number;
declare function CFStringAppend(theString: NSMutableString, appendedString: string): void;
declare function CFStringAppendCharacters(theString: NSMutableString, chars: any, numChars: number): void;
declare function CFStringAppendPascalString(theString: NSMutableString, pStr: string, encoding: number): void;
declare function CFStringAppendCString(theString: NSMutableString, cStr: string, encoding: number): void;
declare function CFStringAppendFormatAndArguments(theString: NSMutableString, formatOptions: NSDictionary, format: string, args: number): void;
declare function CFStringInsert(str: NSMutableString, idx: number, insertedStr: string): void;
declare function CFStringDelete(theString: NSMutableString, range: CFRange): void;
declare function CFStringReplace(theString: NSMutableString, range: CFRange, replacement: string): void;
declare function CFStringReplaceAll(theString: NSMutableString, replacement: string): void;
declare function CFStringFindAndReplace(theString: NSMutableString, stringToFind: string, replacementString: string, rangeToSearch: CFRange, compareOptions: number): number;
declare function CFStringSetExternalCharactersNoCopy(theString: NSMutableString, chars: any, length: number, capacity: number): void;
declare function CFStringPad(theString: NSMutableString, padString: string, length: number, indexIntoPad: number): void;
declare function CFStringTrim(theString: NSMutableString, trimString: string): void;
declare function CFStringTrimWhitespace(theString: NSMutableString): void;
declare function CFStringLowercase(theString: NSMutableString, locale: NSLocale): void;
declare function CFStringUppercase(theString: NSMutableString, locale: NSLocale): void;
declare function CFStringCapitalize(theString: NSMutableString, locale: NSLocale): void;
declare function CFStringNormalize(theString: NSMutableString, theForm: number): void;
declare function CFStringFold(theString: NSMutableString, theFlags: number, theLocale: NSLocale): void;
declare function CFStringTransform(string: NSMutableString, range: any, transform: string, reverse: boolean): boolean;
declare function CFStringIsEncodingAvailable(encoding: number): boolean;
declare function CFStringGetListOfAvailableEncodings(): any;
declare function CFStringGetNameOfEncoding(encoding: number): string;
declare function CFStringConvertEncodingToNSStringEncoding(encoding: number): number;
declare function CFStringConvertNSStringEncodingToEncoding(encoding: number): number;
declare function CFStringConvertEncodingToWindowsCodepage(encoding: number): number;
declare function CFStringConvertWindowsCodepageToEncoding(codepage: number): number;
declare function CFStringConvertIANACharSetNameToEncoding(theString: string): number;
declare function CFStringConvertEncodingToIANACharSetName(encoding: number): string;
declare function CFStringGetMostCompatibleMacStringEncoding(encoding: number): number;
declare function CFShow(obj: any): void;
declare function CFShowStr(str: string): void;
declare function __CFStringMakeConstantString(cStr: string): string;
declare function CFErrorGetTypeID(): number;
declare function CFErrorCreate(allocator: any, domain: string, code: number, userInfo: NSDictionary): NSError;
declare function CFErrorCreateWithUserInfoKeysAndValues(allocator: any, domain: string, code: number, userInfoKeys: any, userInfoValues: any, numUserInfoValues: number): NSError;
declare function CFErrorGetDomain(err: NSError): string;
declare function CFErrorGetCode(err: NSError): number;
declare function CFErrorCopyUserInfo(err: NSError): NSDictionary;
declare function CFErrorCopyDescription(err: NSError): string;
declare function CFErrorCopyFailureReason(err: NSError): string;
declare function CFErrorCopyRecoverySuggestion(err: NSError): string;
declare function CFURLGetTypeID(): number;
declare function CFURLCreateWithBytes(allocator: any, URLBytes: string, length: number, encoding: number, baseURL: NSURL): NSURL;
declare function CFURLCreateData(allocator: any, url: NSURL, encoding: number, escapeWhitespace: boolean): NSData;
declare function CFURLCreateWithString(allocator: any, URLString: string, baseURL: NSURL): NSURL;
declare function CFURLCreateAbsoluteURLWithBytes(alloc: any, relativeURLBytes: string, length: number, encoding: number, baseURL: NSURL, useCompatibilityMode: boolean): NSURL;
declare function CFURLCreateWithFileSystemPath(allocator: any, filePath: string, pathStyle: number, isDirectory: boolean): NSURL;
declare function CFURLCreateFromFileSystemRepresentation(allocator: any, buffer: string, bufLen: number, isDirectory: boolean): NSURL;
declare function CFURLCreateWithFileSystemPathRelativeToBase(allocator: any, filePath: string, pathStyle: number, isDirectory: boolean, baseURL: NSURL): NSURL;
declare function CFURLCreateFromFileSystemRepresentationRelativeToBase(allocator: any, buffer: string, bufLen: number, isDirectory: boolean, baseURL: NSURL): NSURL;
declare function CFURLGetFileSystemRepresentation(url: NSURL, resolveAgainstBase: boolean, buffer: string, maxBufLen: number): boolean;
declare function CFURLCopyAbsoluteURL(relativeURL: NSURL): NSURL;
declare function CFURLGetString(anURL: NSURL): string;
declare function CFURLGetBaseURL(anURL: NSURL): NSURL;
declare function CFURLCanBeDecomposed(anURL: NSURL): boolean;
declare function CFURLCopyScheme(anURL: NSURL): string;
declare function CFURLCopyNetLocation(anURL: NSURL): string;
declare function CFURLCopyPath(anURL: NSURL): string;
declare function CFURLCopyStrictPath(anURL: NSURL, isAbsolute: string): string;
declare function CFURLCopyFileSystemPath(anURL: NSURL, pathStyle: number): string;
declare function CFURLHasDirectoryPath(anURL: NSURL): boolean;
declare function CFURLCopyResourceSpecifier(anURL: NSURL): string;
declare function CFURLCopyHostName(anURL: NSURL): string;
declare function CFURLGetPortNumber(anURL: NSURL): number;
declare function CFURLCopyUserName(anURL: NSURL): string;
declare function CFURLCopyPassword(anURL: NSURL): string;
declare function CFURLCopyParameterString(anURL: NSURL, charactersToLeaveEscaped: string): string;
declare function CFURLCopyQueryString(anURL: NSURL, charactersToLeaveEscaped: string): string;
declare function CFURLCopyFragment(anURL: NSURL, charactersToLeaveEscaped: string): string;
declare function CFURLCopyLastPathComponent(url: NSURL): string;
declare function CFURLCopyPathExtension(url: NSURL): string;
declare function CFURLCreateCopyAppendingPathComponent(allocator: any, url: NSURL, pathComponent: string, isDirectory: boolean): NSURL;
declare function CFURLCreateCopyDeletingLastPathComponent(allocator: any, url: NSURL): NSURL;
declare function CFURLCreateCopyAppendingPathExtension(allocator: any, url: NSURL, extension: string): NSURL;
declare function CFURLCreateCopyDeletingPathExtension(allocator: any, url: NSURL): NSURL;
declare function CFURLGetBytes(url: NSURL, buffer: string, bufferLength: number): number;
declare function CFURLGetByteRangeForComponent(url: NSURL, component: number, rangeIncludingSeparators: any): CFRange;
declare function CFURLCreateStringByReplacingPercentEscapes(allocator: any, originalString: string, charactersToLeaveEscaped: string): string;
declare function CFURLCreateStringByReplacingPercentEscapesUsingEncoding(allocator: any, origString: string, charsToLeaveEscaped: string, encoding: number): string;
declare function CFURLCreateStringByAddingPercentEscapes(allocator: any, originalString: string, charactersToLeaveUnescaped: string, legalURLCharactersToBeEscaped: string, encoding: number): string;
declare function CFURLIsFileReferenceURL(url: NSURL): boolean;
declare function CFURLCreateFileReferenceURL(allocator: any, url: NSURL, error: any): NSURL;
declare function CFURLCreateFilePathURL(allocator: any, url: NSURL, error: any): NSURL;
declare function CFURLCopyResourcePropertyForKey(url: NSURL, key: string, propertyValueTypeRefPtr: any, error: any): boolean;
declare function CFURLCopyResourcePropertiesForKeys(url: NSURL, keys: NSArray, error: any): NSDictionary;
declare function CFURLSetResourcePropertyForKey(url: NSURL, key: string, propertyValue: any, error: any): boolean;
declare function CFURLSetResourcePropertiesForKeys(url: NSURL, keyedPropertyValues: NSDictionary, error: any): boolean;
declare function CFURLClearResourcePropertyCacheForKey(url: NSURL, key: string): void;
declare function CFURLClearResourcePropertyCache(url: NSURL): void;
declare function CFURLSetTemporaryResourcePropertyForKey(url: NSURL, key: string, propertyValue: any): void;
declare function CFURLResourceIsReachable(url: NSURL, error: any): boolean;
declare function CFURLCreateBookmarkData(allocator: any, url: NSURL, options: number, resourcePropertiesToInclude: NSArray, relativeToURL: NSURL, error: any): NSData;
declare function CFURLCreateByResolvingBookmarkData(allocator: any, bookmark: NSData, options: number, relativeToURL: NSURL, resourcePropertiesToInclude: NSArray, isStale: string, error: any): NSURL;
declare function CFURLCreateResourcePropertiesForKeysFromBookmarkData(allocator: any, resourcePropertiesToReturn: NSArray, bookmark: NSData): NSDictionary;
declare function CFURLCreateResourcePropertyForKeyFromBookmarkData(allocator: any, resourcePropertyKey: string, bookmark: NSData): any;
declare function CFURLCreateBookmarkDataFromFile(allocator: any, fileURL: NSURL, errorRef: any): NSData;
declare function CFURLWriteBookmarkDataToFile(bookmarkRef: NSData, fileURL: NSURL, options: number, errorRef: any): boolean;
declare function CFURLStartAccessingSecurityScopedResource(url: NSURL): boolean;
declare function CFURLStopAccessingSecurityScopedResource(url: NSURL): void;
declare function CFAbsoluteTimeGetCurrent(): number;
declare function CFDateGetTypeID(): number;
declare function CFDateCreate(allocator: any, at: number): NSDate;
declare function CFDateGetAbsoluteTime(theDate: NSDate): number;
declare function CFDateGetTimeIntervalSinceDate(theDate: NSDate, otherDate: NSDate): number;
declare function CFDateCompare(theDate: NSDate, otherDate: NSDate, context: any): number;
declare function CFGregorianDateIsValid(gdate: CFGregorianDate, unitFlags: number): boolean;
declare function CFGregorianDateGetAbsoluteTime(gdate: CFGregorianDate, tz: NSTimeZone): number;
declare function CFAbsoluteTimeGetGregorianDate(at: number, tz: NSTimeZone): CFGregorianDate;
declare function CFAbsoluteTimeAddGregorianUnits(at: number, tz: NSTimeZone, units: CFGregorianUnits): number;
declare function CFAbsoluteTimeGetDifferenceAsGregorianUnits(at1: number, at2: number, tz: NSTimeZone, unitFlags: number): CFGregorianUnits;
declare function CFAbsoluteTimeGetDayOfWeek(at: number, tz: NSTimeZone): number;
declare function CFAbsoluteTimeGetDayOfYear(at: number, tz: NSTimeZone): number;
declare function CFAbsoluteTimeGetWeekOfYear(at: number, tz: NSTimeZone): number;
declare function CFBagGetTypeID(): number;
declare function CFBagCreate(allocator: any, values: any, numValues: number, callBacks: any): any;
declare function CFBagCreateCopy(allocator: any, theBag: any): any;
declare function CFBagCreateMutable(allocator: any, capacity: number, callBacks: any): any;
declare function CFBagCreateMutableCopy(allocator: any, capacity: number, theBag: any): any;
declare function CFBagGetCount(theBag: any): number;
declare function CFBagGetCountOfValue(theBag: any, value: any): number;
declare function CFBagContainsValue(theBag: any, value: any): boolean;
declare function CFBagGetValue(theBag: any, value: any): any;
declare function CFBagGetValueIfPresent(theBag: any, candidate: any, value: any): boolean;
declare function CFBagGetValues(theBag: any, values: any): void;
declare function CFBagApplyFunction(theBag: any, applier: (arg1: any, arg2: any) => void, context: any): void;
declare function CFBagAddValue(theBag: any, value: any): void;
declare function CFBagReplaceValue(theBag: any, value: any): void;
declare function CFBagSetValue(theBag: any, value: any): void;
declare function CFBagRemoveValue(theBag: any, value: any): void;
declare function CFBagRemoveAllValues(theBag: any): void;
declare function CFBinaryHeapGetTypeID(): number;
declare function CFBinaryHeapCreate(allocator: any, capacity: number, callBacks: any, compareContext: any): any;
declare function CFBinaryHeapCreateCopy(allocator: any, capacity: number, heap: any): any;
declare function CFBinaryHeapGetCount(heap: any): number;
declare function CFBinaryHeapGetCountOfValue(heap: any, value: any): number;
declare function CFBinaryHeapContainsValue(heap: any, value: any): boolean;
declare function CFBinaryHeapGetMinimum(heap: any): any;
declare function CFBinaryHeapGetMinimumIfPresent(heap: any, value: any): boolean;
declare function CFBinaryHeapGetValues(heap: any, values: any): void;
declare function CFBinaryHeapApplyFunction(heap: any, applier: (arg1: any, arg2: any) => void, context: any): void;
declare function CFBinaryHeapAddValue(heap: any, value: any): void;
declare function CFBinaryHeapRemoveMinimumValue(heap: any): void;
declare function CFBinaryHeapRemoveAllValues(heap: any): void;
declare function CFBitVectorGetTypeID(): number;
declare function CFBitVectorCreate(allocator: any, bytes: string, numBits: number): any;
declare function CFBitVectorCreateCopy(allocator: any, bv: any): any;
declare function CFBitVectorCreateMutable(allocator: any, capacity: number): any;
declare function CFBitVectorCreateMutableCopy(allocator: any, capacity: number, bv: any): any;
declare function CFBitVectorGetCount(bv: any): number;
declare function CFBitVectorGetCountOfBit(bv: any, range: CFRange, value: number): number;
declare function CFBitVectorContainsBit(bv: any, range: CFRange, value: number): boolean;
declare function CFBitVectorGetBitAtIndex(bv: any, idx: number): number;
declare function CFBitVectorGetBits(bv: any, range: CFRange, bytes: string): void;
declare function CFBitVectorGetFirstIndexOfBit(bv: any, range: CFRange, value: number): number;
declare function CFBitVectorGetLastIndexOfBit(bv: any, range: CFRange, value: number): number;
declare function CFBitVectorSetCount(bv: any, count: number): void;
declare function CFBitVectorFlipBitAtIndex(bv: any, idx: number): void;
declare function CFBitVectorFlipBits(bv: any, range: CFRange): void;
declare function CFBitVectorSetBitAtIndex(bv: any, idx: number, value: number): void;
declare function CFBitVectorSetBits(bv: any, range: CFRange, value: number): void;
declare function CFBitVectorSetAllBits(bv: any, value: number): void;
declare function CFTimeZoneGetTypeID(): number;
declare function CFTimeZoneCopySystem(): NSTimeZone;
declare function CFTimeZoneResetSystem(): void;
declare function CFTimeZoneCopyDefault(): NSTimeZone;
declare function CFTimeZoneSetDefault(tz: NSTimeZone): void;
declare function CFTimeZoneCopyKnownNames(): NSArray;
declare function CFTimeZoneCopyAbbreviationDictionary(): NSDictionary;
declare function CFTimeZoneSetAbbreviationDictionary(dict: NSDictionary): void;
declare function CFTimeZoneCreate(allocator: any, name: string, data: NSData): NSTimeZone;
declare function CFTimeZoneCreateWithTimeIntervalFromGMT(allocator: any, ti: number): NSTimeZone;
declare function CFTimeZoneCreateWithName(allocator: any, name: string, tryAbbrev: boolean): NSTimeZone;
declare function CFTimeZoneGetName(tz: NSTimeZone): string;
declare function CFTimeZoneGetData(tz: NSTimeZone): NSData;
declare function CFTimeZoneGetSecondsFromGMT(tz: NSTimeZone, at: number): number;
declare function CFTimeZoneCopyAbbreviation(tz: NSTimeZone, at: number): string;
declare function CFTimeZoneIsDaylightSavingTime(tz: NSTimeZone, at: number): boolean;
declare function CFTimeZoneGetDaylightSavingTimeOffset(tz: NSTimeZone, at: number): number;
declare function CFTimeZoneGetNextDaylightSavingTimeTransition(tz: NSTimeZone, at: number): number;
declare function CFTimeZoneCopyLocalizedName(tz: NSTimeZone, style: number, locale: NSLocale): string;
declare function CFCalendarGetTypeID(): number;
declare function CFCalendarCopyCurrent(): NSCalendar;
declare function CFCalendarCreateWithIdentifier(allocator: any, identifier: string): NSCalendar;
declare function CFCalendarGetIdentifier(calendar: NSCalendar): string;
declare function CFCalendarCopyLocale(calendar: NSCalendar): NSLocale;
declare function CFCalendarSetLocale(calendar: NSCalendar, locale: NSLocale): void;
declare function CFCalendarCopyTimeZone(calendar: NSCalendar): NSTimeZone;
declare function CFCalendarSetTimeZone(calendar: NSCalendar, tz: NSTimeZone): void;
declare function CFCalendarGetFirstWeekday(calendar: NSCalendar): number;
declare function CFCalendarSetFirstWeekday(calendar: NSCalendar, wkdy: number): void;
declare function CFCalendarGetMinimumDaysInFirstWeek(calendar: NSCalendar): number;
declare function CFCalendarSetMinimumDaysInFirstWeek(calendar: NSCalendar, mwd: number): void;
declare function CFCalendarGetMinimumRangeOfUnit(calendar: NSCalendar, unit: number): CFRange;
declare function CFCalendarGetMaximumRangeOfUnit(calendar: NSCalendar, unit: number): CFRange;
declare function CFCalendarGetRangeOfUnit(calendar: NSCalendar, smallerUnit: number, biggerUnit: number, at: number): CFRange;
declare function CFCalendarGetOrdinalityOfUnit(calendar: NSCalendar, smallerUnit: number, biggerUnit: number, at: number): number;
declare function CFCalendarGetTimeRangeOfUnit(calendar: NSCalendar, unit: number, at: number, startp: any, tip: any): boolean;
declare function CFDateFormatterCreateDateFormatFromTemplate(allocator: any, tmplate: string, options: number, locale: NSLocale): string;
declare function CFDateFormatterGetTypeID(): number;
declare function CFDateFormatterCreate(allocator: any, locale: NSLocale, dateStyle: number, timeStyle: number): any;
declare function CFDateFormatterGetLocale(formatter: any): NSLocale;
declare function CFDateFormatterGetDateStyle(formatter: any): number;
declare function CFDateFormatterGetTimeStyle(formatter: any): number;
declare function CFDateFormatterGetFormat(formatter: any): string;
declare function CFDateFormatterSetFormat(formatter: any, formatString: string): void;
declare function CFDateFormatterCreateStringWithDate(allocator: any, formatter: any, date: NSDate): string;
declare function CFDateFormatterCreateStringWithAbsoluteTime(allocator: any, formatter: any, at: number): string;
declare function CFDateFormatterCreateDateFromString(allocator: any, formatter: any, string: string, rangep: any): NSDate;
declare function CFDateFormatterGetAbsoluteTimeFromString(formatter: any, string: string, rangep: any, atp: any): boolean;
declare function CFDateFormatterSetProperty(formatter: any, key: string, value: any): void;
declare function CFDateFormatterCopyProperty(formatter: any, key: string): any;
declare function CFBooleanGetTypeID(): number;
declare function CFBooleanGetValue(boolean: any): boolean;
declare function CFNumberGetTypeID(): number;
declare function CFNumberCreate(allocator: any, theType: number, valuePtr: any): NSNumber;
declare function CFNumberGetType(number: NSNumber): number;
declare function CFNumberGetByteSize(number: NSNumber): number;
declare function CFNumberIsFloatType(number: NSNumber): boolean;
declare function CFNumberGetValue(number: NSNumber, theType: number, valuePtr: any): boolean;
declare function CFNumberCompare(number: NSNumber, otherNumber: NSNumber, context: any): number;
declare function CFNumberFormatterGetTypeID(): number;
declare function CFNumberFormatterCreate(allocator: any, locale: NSLocale, style: number): any;
declare function CFNumberFormatterGetLocale(formatter: any): NSLocale;
declare function CFNumberFormatterGetStyle(formatter: any): number;
declare function CFNumberFormatterGetFormat(formatter: any): string;
declare function CFNumberFormatterSetFormat(formatter: any, formatString: string): void;
declare function CFNumberFormatterCreateStringWithNumber(allocator: any, formatter: any, number: NSNumber): string;
declare function CFNumberFormatterCreateStringWithValue(allocator: any, formatter: any, numberType: number, valuePtr: any): string;
declare function CFNumberFormatterCreateNumberFromString(allocator: any, formatter: any, string: string, rangep: any, options: number): NSNumber;
declare function CFNumberFormatterGetValueFromString(formatter: any, string: string, rangep: any, numberType: number, valuePtr: any): boolean;
declare function CFNumberFormatterSetProperty(formatter: any, key: string, value: any): void;
declare function CFNumberFormatterCopyProperty(formatter: any, key: string): any;
declare function CFNumberFormatterGetDecimalInfoForCurrencyCode(currencyCode: string, defaultFractionDigits: any, roundingIncrement: any): boolean;
declare function CFPreferencesCopyAppValue(key: string, applicationID: string): any;
declare function CFPreferencesGetAppBooleanValue(key: string, applicationID: string, keyExistsAndHasValidFormat: string): boolean;
declare function CFPreferencesGetAppIntegerValue(key: string, applicationID: string, keyExistsAndHasValidFormat: string): number;
declare function CFPreferencesSetAppValue(key: string, value: any, applicationID: string): void;
declare function CFPreferencesAddSuitePreferencesToApp(applicationID: string, suiteID: string): void;
declare function CFPreferencesRemoveSuitePreferencesFromApp(applicationID: string, suiteID: string): void;
declare function CFPreferencesAppSynchronize(applicationID: string): boolean;
declare function CFPreferencesCopyValue(key: string, applicationID: string, userName: string, hostName: string): any;
declare function CFPreferencesCopyMultiple(keysToFetch: NSArray, applicationID: string, userName: string, hostName: string): NSDictionary;
declare function CFPreferencesSetValue(key: string, value: any, applicationID: string, userName: string, hostName: string): void;
declare function CFPreferencesSetMultiple(keysToSet: NSDictionary, keysToRemove: NSArray, applicationID: string, userName: string, hostName: string): void;
declare function CFPreferencesSynchronize(applicationID: string, userName: string, hostName: string): boolean;
declare function CFPreferencesCopyApplicationList(userName: string, hostName: string): NSArray;
declare function CFPreferencesCopyKeyList(applicationID: string, userName: string, hostName: string): NSArray;
declare function CFPreferencesAppValueIsForced(key: string, applicationID: string): boolean;
declare function CFRunLoopGetTypeID(): number;
declare function CFRunLoopGetCurrent(): any;
declare function CFRunLoopGetMain(): any;
declare function CFRunLoopCopyCurrentMode(rl: any): string;
declare function CFRunLoopCopyAllModes(rl: any): NSArray;
declare function CFRunLoopAddCommonMode(rl: any, mode: string): void;
declare function CFRunLoopGetNextTimerFireDate(rl: any, mode: string): number;
declare function CFRunLoopRun(): void;
declare function CFRunLoopRunInMode(mode: string, seconds: number, returnAfterSourceHandled: boolean): number;
declare function CFRunLoopIsWaiting(rl: any): boolean;
declare function CFRunLoopWakeUp(rl: any): void;
declare function CFRunLoopStop(rl: any): void;
declare function CFRunLoopPerformBlock(rl: any, mode: any, block: () => void): void;
declare function CFRunLoopContainsSource(rl: any, source: any, mode: string): boolean;
declare function CFRunLoopAddSource(rl: any, source: any, mode: string): void;
declare function CFRunLoopRemoveSource(rl: any, source: any, mode: string): void;
declare function CFRunLoopContainsObserver(rl: any, observer: any, mode: string): boolean;
declare function CFRunLoopAddObserver(rl: any, observer: any, mode: string): void;
declare function CFRunLoopRemoveObserver(rl: any, observer: any, mode: string): void;
declare function CFRunLoopContainsTimer(rl: any, timer: NSTimer, mode: string): boolean;
declare function CFRunLoopAddTimer(rl: any, timer: NSTimer, mode: string): void;
declare function CFRunLoopRemoveTimer(rl: any, timer: NSTimer, mode: string): void;
declare function CFRunLoopSourceGetTypeID(): number;
declare function CFRunLoopSourceCreate(allocator: any, order: number, context: any): any;
declare function CFRunLoopSourceGetOrder(source: any): number;
declare function CFRunLoopSourceInvalidate(source: any): void;
declare function CFRunLoopSourceIsValid(source: any): boolean;
declare function CFRunLoopSourceGetContext(source: any, context: any): void;
declare function CFRunLoopSourceSignal(source: any): void;
declare function CFRunLoopObserverGetTypeID(): number;
declare function CFRunLoopObserverCreate(allocator: any, activities: number, repeats: boolean, order: number, callout: (arg1: any, arg2: number, arg3: any) => void, context: any): any;
declare function CFRunLoopObserverCreateWithHandler(allocator: any, activities: number, repeats: boolean, order: number, block: (arg1: any, arg2: number) => void): any;
declare function CFRunLoopObserverGetActivities(observer: any): number;
declare function CFRunLoopObserverDoesRepeat(observer: any): boolean;
declare function CFRunLoopObserverGetOrder(observer: any): number;
declare function CFRunLoopObserverInvalidate(observer: any): void;
declare function CFRunLoopObserverIsValid(observer: any): boolean;
declare function CFRunLoopObserverGetContext(observer: any, context: any): void;
declare function CFRunLoopTimerGetTypeID(): number;
declare function CFRunLoopTimerCreate(allocator: any, fireDate: number, interval: number, flags: number, order: number, callout: (arg1: NSTimer, arg2: any) => void, context: any): NSTimer;
declare function CFRunLoopTimerCreateWithHandler(allocator: any, fireDate: number, interval: number, flags: number, order: number, block: (arg1: NSTimer) => void): NSTimer;
declare function CFRunLoopTimerGetNextFireDate(timer: NSTimer): number;
declare function CFRunLoopTimerSetNextFireDate(timer: NSTimer, fireDate: number): void;
declare function CFRunLoopTimerGetInterval(timer: NSTimer): number;
declare function CFRunLoopTimerDoesRepeat(timer: NSTimer): boolean;
declare function CFRunLoopTimerGetOrder(timer: NSTimer): number;
declare function CFRunLoopTimerInvalidate(timer: NSTimer): void;
declare function CFRunLoopTimerIsValid(timer: NSTimer): boolean;
declare function CFRunLoopTimerGetContext(timer: NSTimer, context: any): void;
declare function CFRunLoopTimerGetTolerance(timer: NSTimer): number;
declare function CFRunLoopTimerSetTolerance(timer: NSTimer, tolerance: number): void;
declare function CFSocketGetTypeID(): number;
declare function CFSocketCreate(allocator: any, protocolFamily: number, socketType: number, protocol: number, callBackTypes: number, callout: (arg1: any, arg2: number, arg3: NSData, arg4: any, arg5: any) => void, context: any): any;
declare function CFSocketCreateWithNative(allocator: any, sock: number, callBackTypes: number, callout: (arg1: any, arg2: number, arg3: NSData, arg4: any, arg5: any) => void, context: any): any;
declare function CFSocketCreateWithSocketSignature(allocator: any, signature: any, callBackTypes: number, callout: (arg1: any, arg2: number, arg3: NSData, arg4: any, arg5: any) => void, context: any): any;
declare function CFSocketCreateConnectedToSocketSignature(allocator: any, signature: any, callBackTypes: number, callout: (arg1: any, arg2: number, arg3: NSData, arg4: any, arg5: any) => void, context: any, timeout: number): any;
declare function CFSocketSetAddress(s: any, address: NSData): number;
declare function CFSocketConnectToAddress(s: any, address: NSData, timeout: number): number;
declare function CFSocketInvalidate(s: any): void;
declare function CFSocketIsValid(s: any): boolean;
declare function CFSocketCopyAddress(s: any): NSData;
declare function CFSocketCopyPeerAddress(s: any): NSData;
declare function CFSocketGetContext(s: any, context: any): void;
declare function CFSocketGetNative(s: any): number;
declare function CFSocketCreateRunLoopSource(allocator: any, s: any, order: number): any;
declare function CFSocketGetSocketFlags(s: any): number;
declare function CFSocketSetSocketFlags(s: any, flags: number): void;
declare function CFSocketDisableCallBacks(s: any, callBackTypes: number): void;
declare function CFSocketEnableCallBacks(s: any, callBackTypes: number): void;
declare function CFSocketSendData(s: any, address: NSData, data: NSData, timeout: number): number;
declare function CFSocketRegisterValue(nameServerSignature: any, timeout: number, name: string, value: any): number;
declare function CFSocketCopyRegisteredValue(nameServerSignature: any, timeout: number, name: string, value: any, nameServerAddress: any): number;
declare function CFSocketRegisterSocketSignature(nameServerSignature: any, timeout: number, name: string, signature: any): number;
declare function CFSocketCopyRegisteredSocketSignature(nameServerSignature: any, timeout: number, name: string, signature: any, nameServerAddress: any): number;
declare function CFSocketUnregister(nameServerSignature: any, timeout: number, name: string): number;
declare function CFSocketSetDefaultNameRegistryPortNumber(port: number): void;
declare function CFSocketGetDefaultNameRegistryPortNumber(): number;
declare function CFReadStreamGetTypeID(): number;
declare function CFWriteStreamGetTypeID(): number;
declare function CFReadStreamCreateWithBytesNoCopy(alloc: any, bytes: string, length: number, bytesDeallocator: any): NSInputStream;
declare function CFWriteStreamCreateWithBuffer(alloc: any, buffer: string, bufferCapacity: number): NSOutputStream;
declare function CFWriteStreamCreateWithAllocatedBuffers(alloc: any, bufferAllocator: any): NSOutputStream;
declare function CFReadStreamCreateWithFile(alloc: any, fileURL: NSURL): NSInputStream;
declare function CFWriteStreamCreateWithFile(alloc: any, fileURL: NSURL): NSOutputStream;
declare function CFStreamCreateBoundPair(alloc: any, readStream: any, writeStream: any, transferBufferSize: number): void;
declare function CFStreamCreatePairWithSocket(alloc: any, sock: number, readStream: any, writeStream: any): void;
declare function CFStreamCreatePairWithSocketToHost(alloc: any, host: string, port: number, readStream: any, writeStream: any): void;
declare function CFStreamCreatePairWithPeerSocketSignature(alloc: any, signature: any, readStream: any, writeStream: any): void;
declare function CFReadStreamGetStatus(stream: NSInputStream): number;
declare function CFWriteStreamGetStatus(stream: NSOutputStream): number;
declare function CFReadStreamCopyError(stream: NSInputStream): NSError;
declare function CFWriteStreamCopyError(stream: NSOutputStream): NSError;
declare function CFReadStreamOpen(stream: NSInputStream): boolean;
declare function CFWriteStreamOpen(stream: NSOutputStream): boolean;
declare function CFReadStreamClose(stream: NSInputStream): void;
declare function CFWriteStreamClose(stream: NSOutputStream): void;
declare function CFReadStreamHasBytesAvailable(stream: NSInputStream): boolean;
declare function CFReadStreamRead(stream: NSInputStream, buffer: string, bufferLength: number): number;
declare function CFReadStreamGetBuffer(stream: NSInputStream, maxBytesToRead: number, numBytesRead: any): string;
declare function CFWriteStreamCanAcceptBytes(stream: NSOutputStream): boolean;
declare function CFWriteStreamWrite(stream: NSOutputStream, buffer: string, bufferLength: number): number;
declare function CFReadStreamCopyProperty(stream: NSInputStream, propertyName: string): any;
declare function CFWriteStreamCopyProperty(stream: NSOutputStream, propertyName: string): any;
declare function CFReadStreamSetProperty(stream: NSInputStream, propertyName: string, propertyValue: any): boolean;
declare function CFWriteStreamSetProperty(stream: NSOutputStream, propertyName: string, propertyValue: any): boolean;
declare function CFReadStreamSetClient(stream: NSInputStream, streamEvents: number, clientCB: (arg1: NSInputStream, arg2: number, arg3: any) => void, clientContext: any): boolean;
declare function CFWriteStreamSetClient(stream: NSOutputStream, streamEvents: number, clientCB: (arg1: NSOutputStream, arg2: number, arg3: any) => void, clientContext: any): boolean;
declare function CFReadStreamScheduleWithRunLoop(stream: NSInputStream, runLoop: any, runLoopMode: string): void;
declare function CFWriteStreamScheduleWithRunLoop(stream: NSOutputStream, runLoop: any, runLoopMode: string): void;
declare function CFReadStreamUnscheduleFromRunLoop(stream: NSInputStream, runLoop: any, runLoopMode: string): void;
declare function CFWriteStreamUnscheduleFromRunLoop(stream: NSOutputStream, runLoop: any, runLoopMode: string): void;
declare function CFReadStreamSetDispatchQueue(stream: NSInputStream, q: NSObject): void;
declare function CFWriteStreamSetDispatchQueue(stream: NSOutputStream, q: NSObject): void;
declare function CFReadStreamCopyDispatchQueue(stream: NSInputStream): NSObject;
declare function CFWriteStreamCopyDispatchQueue(stream: NSOutputStream): NSObject;
declare function CFReadStreamGetError(stream: NSInputStream): CFStreamError;
declare function CFWriteStreamGetError(stream: NSOutputStream): CFStreamError;
declare function CFPropertyListCreateFromXMLData(allocator: any, xmlData: NSData, mutabilityOption: number, errorString: any): any;
declare function CFPropertyListCreateXMLData(allocator: any, propertyList: any): NSData;
declare function CFPropertyListCreateDeepCopy(allocator: any, propertyList: any, mutabilityOption: number): any;
declare function CFPropertyListIsValid(plist: any, format: number): boolean;
declare function CFPropertyListWriteToStream(propertyList: any, stream: NSOutputStream, format: number, errorString: any): number;
declare function CFPropertyListCreateFromStream(allocator: any, stream: NSInputStream, streamLength: number, mutabilityOption: number, format: any, errorString: any): any;
declare function CFPropertyListCreateWithData(allocator: any, data: NSData, options: number, format: any, error: any): any;
declare function CFPropertyListCreateWithStream(allocator: any, stream: NSInputStream, streamLength: number, options: number, format: any, error: any): any;
declare function CFPropertyListWrite(propertyList: any, stream: NSOutputStream, format: number, options: number, error: any): number;
declare function CFPropertyListCreateData(allocator: any, propertyList: any, format: number, options: number, error: any): NSData;
declare function CFSetGetTypeID(): number;
declare function CFSetCreate(allocator: any, values: any, numValues: number, callBacks: any): NSSet;
declare function CFSetCreateCopy(allocator: any, theSet: NSSet): NSSet;
declare function CFSetCreateMutable(allocator: any, capacity: number, callBacks: any): NSMutableSet;
declare function CFSetCreateMutableCopy(allocator: any, capacity: number, theSet: NSSet): NSMutableSet;
declare function CFSetGetCount(theSet: NSSet): number;
declare function CFSetGetCountOfValue(theSet: NSSet, value: any): number;
declare function CFSetContainsValue(theSet: NSSet, value: any): boolean;
declare function CFSetGetValue(theSet: NSSet, value: any): any;
declare function CFSetGetValueIfPresent(theSet: NSSet, candidate: any, value: any): boolean;
declare function CFSetGetValues(theSet: NSSet, values: any): void;
declare function CFSetApplyFunction(theSet: NSSet, applier: (arg1: any, arg2: any) => void, context: any): void;
declare function CFSetAddValue(theSet: NSMutableSet, value: any): void;
declare function CFSetReplaceValue(theSet: NSMutableSet, value: any): void;
declare function CFSetSetValue(theSet: NSMutableSet, value: any): void;
declare function CFSetRemoveValue(theSet: NSMutableSet, value: any): void;
declare function CFSetRemoveAllValues(theSet: NSMutableSet): void;
declare function CFTreeGetTypeID(): number;
declare function CFTreeCreate(allocator: any, context: any): any;
declare function CFTreeGetParent(tree: any): any;
declare function CFTreeGetNextSibling(tree: any): any;
declare function CFTreeGetFirstChild(tree: any): any;
declare function CFTreeGetContext(tree: any, context: any): void;
declare function CFTreeGetChildCount(tree: any): number;
declare function CFTreeGetChildAtIndex(tree: any, idx: number): any;
declare function CFTreeGetChildren(tree: any, children: any): void;
declare function CFTreeApplyFunctionToChildren(tree: any, applier: (arg1: any, arg2: any) => void, context: any): void;
declare function CFTreeFindRoot(tree: any): any;
declare function CFTreeSetContext(tree: any, context: any): void;
declare function CFTreePrependChild(tree: any, newChild: any): void;
declare function CFTreeAppendChild(tree: any, newChild: any): void;
declare function CFTreeInsertSibling(tree: any, newSibling: any): void;
declare function CFTreeRemove(tree: any): void;
declare function CFTreeRemoveAllChildren(tree: any): void;
declare function CFTreeSortChildren(tree: any, comparator: (arg1: any, arg2: any, arg3: any) => number, context: any): void;
declare function CFURLCreateDataAndPropertiesFromResource(alloc: any, url: NSURL, resourceData: any, properties: any, desiredProperties: NSArray, errorCode: any): boolean;
declare function CFURLWriteDataAndPropertiesToResource(url: NSURL, dataToWrite: NSData, propertiesToWrite: NSDictionary, errorCode: any): boolean;
declare function CFURLDestroyResource(url: NSURL, errorCode: any): boolean;
declare function CFURLCreatePropertyFromResource(alloc: any, url: NSURL, property: string, errorCode: any): any;
declare function CFUUIDGetTypeID(): number;
declare function CFUUIDCreate(alloc: any): any;
declare function CFUUIDCreateWithBytes(alloc: any, byte0: number, byte1: number, byte2: number, byte3: number, byte4: number, byte5: number, byte6: number, byte7: number, byte8: number, byte9: number, byte10: number, byte11: number, byte12: number, byte13: number, byte14: number, byte15: number): any;
declare function CFUUIDCreateFromString(alloc: any, uuidStr: string): any;
declare function CFUUIDCreateString(alloc: any, uuid: any): string;
declare function CFUUIDGetConstantUUIDWithBytes(alloc: any, byte0: number, byte1: number, byte2: number, byte3: number, byte4: number, byte5: number, byte6: number, byte7: number, byte8: number, byte9: number, byte10: number, byte11: number, byte12: number, byte13: number, byte14: number, byte15: number): any;
declare function CFUUIDGetUUIDBytes(uuid: any): CFUUIDBytes;
declare function CFUUIDCreateFromUUIDBytes(alloc: any, bytes: CFUUIDBytes): any;
declare function CFCopyHomeDirectoryURL(): NSURL;
declare function CFBundleGetMainBundle(): any;
declare function CFBundleGetBundleWithIdentifier(bundleID: string): any;
declare function CFBundleGetAllBundles(): NSArray;
declare function CFBundleGetTypeID(): number;
declare function CFBundleCreate(allocator: any, bundleURL: NSURL): any;
declare function CFBundleCreateBundlesFromDirectory(allocator: any, directoryURL: NSURL, bundleType: string): NSArray;
declare function CFBundleCopyBundleURL(bundle: any): NSURL;
declare function CFBundleGetValueForInfoDictionaryKey(bundle: any, key: string): any;
declare function CFBundleGetInfoDictionary(bundle: any): NSDictionary;
declare function CFBundleGetLocalInfoDictionary(bundle: any): NSDictionary;
declare function CFBundleGetPackageInfo(bundle: any, packageType: any, packageCreator: any): void;
declare function CFBundleGetIdentifier(bundle: any): string;
declare function CFBundleGetVersionNumber(bundle: any): number;
declare function CFBundleGetDevelopmentRegion(bundle: any): string;
declare function CFBundleCopySupportFilesDirectoryURL(bundle: any): NSURL;
declare function CFBundleCopyResourcesDirectoryURL(bundle: any): NSURL;
declare function CFBundleCopyPrivateFrameworksURL(bundle: any): NSURL;
declare function CFBundleCopySharedFrameworksURL(bundle: any): NSURL;
declare function CFBundleCopySharedSupportURL(bundle: any): NSURL;
declare function CFBundleCopyBuiltInPlugInsURL(bundle: any): NSURL;
declare function CFBundleCopyInfoDictionaryInDirectory(bundleURL: NSURL): NSDictionary;
declare function CFBundleGetPackageInfoInDirectory(url: NSURL, packageType: any, packageCreator: any): boolean;
declare function CFBundleCopyResourceURL(bundle: any, resourceName: string, resourceType: string, subDirName: string): NSURL;
declare function CFBundleCopyResourceURLsOfType(bundle: any, resourceType: string, subDirName: string): NSArray;
declare function CFBundleCopyLocalizedString(bundle: any, key: string, value: string, tableName: string): string;
declare function CFBundleCopyResourceURLInDirectory(bundleURL: NSURL, resourceName: string, resourceType: string, subDirName: string): NSURL;
declare function CFBundleCopyResourceURLsOfTypeInDirectory(bundleURL: NSURL, resourceType: string, subDirName: string): NSArray;
declare function CFBundleCopyBundleLocalizations(bundle: any): NSArray;
declare function CFBundleCopyPreferredLocalizationsFromArray(locArray: NSArray): NSArray;
declare function CFBundleCopyLocalizationsForPreferences(locArray: NSArray, prefArray: NSArray): NSArray;
declare function CFBundleCopyResourceURLForLocalization(bundle: any, resourceName: string, resourceType: string, subDirName: string, localizationName: string): NSURL;
declare function CFBundleCopyResourceURLsOfTypeForLocalization(bundle: any, resourceType: string, subDirName: string, localizationName: string): NSArray;
declare function CFBundleCopyInfoDictionaryForURL(url: NSURL): NSDictionary;
declare function CFBundleCopyLocalizationsForURL(url: NSURL): NSArray;
declare function CFBundleCopyExecutableArchitecturesForURL(url: NSURL): NSArray;
declare function CFBundleCopyExecutableURL(bundle: any): NSURL;
declare function CFBundleCopyExecutableArchitectures(bundle: any): NSArray;
declare function CFBundlePreflightExecutable(bundle: any, error: any): boolean;
declare function CFBundleLoadExecutableAndReturnError(bundle: any, error: any): boolean;
declare function CFBundleLoadExecutable(bundle: any): boolean;
declare function CFBundleIsExecutableLoaded(bundle: any): boolean;
declare function CFBundleUnloadExecutable(bundle: any): void;
declare function CFBundleGetFunctionPointerForName(bundle: any, functionName: string): any;
declare function CFBundleGetFunctionPointersForNames(bundle: any, functionNames: NSArray, ftbl: any): void;
declare function CFBundleGetDataPointerForName(bundle: any, symbolName: string): any;
declare function CFBundleGetDataPointersForNames(bundle: any, symbolNames: NSArray, stbl: any): void;
declare function CFBundleCopyAuxiliaryExecutableURL(bundle: any, executableName: string): NSURL;
declare function CFBundleGetPlugIn(bundle: any): any;
declare function CFMessagePortGetTypeID(): number;
declare function CFMessagePortCreateLocal(allocator: any, name: string, callout: (arg1: any, arg2: number, arg3: NSData, arg4: any) => NSData, context: any, shouldFreeInfo: string): any;
declare function CFMessagePortCreateRemote(allocator: any, name: string): any;
declare function CFMessagePortIsRemote(ms: any): boolean;
declare function CFMessagePortGetName(ms: any): string;
declare function CFMessagePortSetName(ms: any, newName: string): boolean;
declare function CFMessagePortGetContext(ms: any, context: any): void;
declare function CFMessagePortInvalidate(ms: any): void;
declare function CFMessagePortIsValid(ms: any): boolean;
declare function CFMessagePortGetInvalidationCallBack(ms: any): (arg1: any, arg2: any) => void;
declare function CFMessagePortSetInvalidationCallBack(ms: any, callout: (arg1: any, arg2: any) => void): void;
declare function CFMessagePortSendRequest(remote: any, msgid: number, data: NSData, sendTimeout: number, rcvTimeout: number, replyMode: string, returnData: any): number;
declare function CFMessagePortCreateRunLoopSource(allocator: any, local: any, order: number): any;
declare function CFMessagePortSetDispatchQueue(ms: any, queue: NSObject): void;
declare function CFPlugInGetTypeID(): number;
declare function CFPlugInCreate(allocator: any, plugInURL: NSURL): any;
declare function CFPlugInGetBundle(plugIn: any): any;
declare function CFPlugInSetLoadOnDemand(plugIn: any, flag: boolean): void;
declare function CFPlugInIsLoadOnDemand(plugIn: any): boolean;
declare function CFPlugInFindFactoriesForPlugInType(typeUUID: any): NSArray;
declare function CFPlugInFindFactoriesForPlugInTypeInPlugIn(typeUUID: any, plugIn: any): NSArray;
declare function CFPlugInInstanceCreate(allocator: any, factoryUUID: any, typeUUID: any): any;
declare function CFPlugInRegisterFactoryFunction(factoryUUID: any, func: (arg1: any, arg2: any) => any): boolean;
declare function CFPlugInRegisterFactoryFunctionByName(factoryUUID: any, plugIn: any, functionName: string): boolean;
declare function CFPlugInUnregisterFactory(factoryUUID: any): boolean;
declare function CFPlugInRegisterPlugInType(factoryUUID: any, typeUUID: any): boolean;
declare function CFPlugInUnregisterPlugInType(factoryUUID: any, typeUUID: any): boolean;
declare function CFPlugInAddInstanceForFactory(factoryID: any): void;
declare function CFPlugInRemoveInstanceForFactory(factoryID: any): void;
declare function CFPlugInInstanceGetInterfaceFunctionTable(instance: any, interfaceName: string, ftbl: any): boolean;
declare function CFPlugInInstanceGetFactoryName(instance: any): string;
declare function CFPlugInInstanceGetInstanceData(instance: any): any;
declare function CFPlugInInstanceGetTypeID(): number;
declare function CFPlugInInstanceCreateWithInstanceDataSize(allocator: any, instanceDataSize: number, deallocateInstanceFunction: (arg1: any) => void, factoryName: string, getInterfaceFunction: (arg1: any, arg2: string, arg3: any) => boolean): any;
declare function CFAttributedStringGetTypeID(): number;
declare function CFAttributedStringCreate(alloc: any, str: string, attributes: NSDictionary): NSAttributedString;
declare function CFAttributedStringCreateWithSubstring(alloc: any, aStr: NSAttributedString, range: CFRange): NSAttributedString;
declare function CFAttributedStringCreateCopy(alloc: any, aStr: NSAttributedString): NSAttributedString;
declare function CFAttributedStringGetString(aStr: NSAttributedString): string;
declare function CFAttributedStringGetLength(aStr: NSAttributedString): number;
declare function CFAttributedStringGetAttributes(aStr: NSAttributedString, loc: number, effectiveRange: any): NSDictionary;
declare function CFAttributedStringGetAttribute(aStr: NSAttributedString, loc: number, attrName: string, effectiveRange: any): any;
declare function CFAttributedStringGetAttributesAndLongestEffectiveRange(aStr: NSAttributedString, loc: number, inRange: CFRange, longestEffectiveRange: any): NSDictionary;
declare function CFAttributedStringGetAttributeAndLongestEffectiveRange(aStr: NSAttributedString, loc: number, attrName: string, inRange: CFRange, longestEffectiveRange: any): any;
declare function CFAttributedStringCreateMutableCopy(alloc: any, maxLength: number, aStr: NSAttributedString): NSMutableAttributedString;
declare function CFAttributedStringCreateMutable(alloc: any, maxLength: number): NSMutableAttributedString;
declare function CFAttributedStringReplaceString(aStr: NSMutableAttributedString, range: CFRange, replacement: string): void;
declare function CFAttributedStringGetMutableString(aStr: NSMutableAttributedString): NSMutableString;
declare function CFAttributedStringSetAttributes(aStr: NSMutableAttributedString, range: CFRange, replacement: NSDictionary, clearOtherAttributes: boolean): void;
declare function CFAttributedStringSetAttribute(aStr: NSMutableAttributedString, range: CFRange, attrName: string, value: any): void;
declare function CFAttributedStringRemoveAttribute(aStr: NSMutableAttributedString, range: CFRange, attrName: string): void;
declare function CFAttributedStringReplaceAttributedString(aStr: NSMutableAttributedString, range: CFRange, replacement: NSAttributedString): void;
declare function CFAttributedStringBeginEditing(aStr: NSMutableAttributedString): void;
declare function CFAttributedStringEndEditing(aStr: NSMutableAttributedString): void;
declare function CFNotificationCenterGetTypeID(): number;
declare function CFNotificationCenterGetLocalCenter(): any;
declare function CFNotificationCenterGetDarwinNotifyCenter(): any;
declare function CFNotificationCenterAddObserver(center: any, observer: any, callBack: (arg1: any, arg2: any, arg3: string, arg4: any, arg5: NSDictionary) => void, name: string, object: any, suspensionBehavior: number): void;
declare function CFNotificationCenterRemoveObserver(center: any, observer: any, name: string, object: any): void;
declare function CFNotificationCenterRemoveEveryObserver(center: any, observer: any): void;
declare function CFNotificationCenterPostNotification(center: any, name: string, object: any, userInfo: NSDictionary, deliverImmediately: boolean): void;
declare function CFNotificationCenterPostNotificationWithOptions(center: any, name: string, object: any, userInfo: NSDictionary, options: number): void;
declare function CFURLEnumeratorGetTypeID(): number;
declare function CFURLEnumeratorCreateForDirectoryURL(alloc: any, directoryURL: NSURL, option: number, propertyKeys: NSArray): any;
declare function CFURLEnumeratorCreateForMountedVolumes(alloc: any, option: number, propertyKeys: NSArray): any;
declare function CFURLEnumeratorGetNextURL(enumerator: any, url: any, error: any): number;
declare function CFURLEnumeratorSkipDescendents(enumerator: any): void;
declare function CFURLEnumeratorGetDescendentLevel(enumerator: any): number;
declare function CFURLEnumeratorGetSourceDidChange(enumerator: any): boolean;
declare function CFFileSecurityGetTypeID(): number;
declare function CFFileSecurityCreate(allocator: any): any;
declare function CFFileSecurityCreateCopy(allocator: any, fileSec: any): any;
declare function CFFileSecurityCopyOwnerUUID(fileSec: any, ownerUUID: any): boolean;
declare function CFFileSecuritySetOwnerUUID(fileSec: any, ownerUUID: any): boolean;
declare function CFFileSecurityCopyGroupUUID(fileSec: any, groupUUID: any): boolean;
declare function CFFileSecuritySetGroupUUID(fileSec: any, groupUUID: any): boolean;
declare function CFFileSecurityCopyAccessControlList(fileSec: any, accessControlList: any): boolean;
declare function CFFileSecuritySetAccessControlList(fileSec: any, accessControlList: any): boolean;
declare function CFFileSecurityGetOwner(fileSec: any, owner: any): boolean;
declare function CFFileSecuritySetOwner(fileSec: any, owner: number): boolean;
declare function CFFileSecurityGetGroup(fileSec: any, group: any): boolean;
declare function CFFileSecuritySetGroup(fileSec: any, group: number): boolean;
declare function CFFileSecurityGetMode(fileSec: any, mode: any): boolean;
declare function CFFileSecuritySetMode(fileSec: any, mode: number): boolean;
declare function CFFileSecurityClearProperties(fileSec: any, clearPropertyMask: number): boolean;
declare function CFMachPortGetTypeID(): number;
declare function CFMachPortCreate(allocator: any, callout: (arg1: any, arg2: any, arg3: number, arg4: any) => void, context: any, shouldFreeInfo: string): any;
declare function CFMachPortCreateWithPort(allocator: any, portNum: number, callout: (arg1: any, arg2: any, arg3: number, arg4: any) => void, context: any, shouldFreeInfo: string): any;
declare function CFMachPortGetPort(port: any): number;
declare function CFMachPortGetContext(port: any, context: any): void;
declare function CFMachPortInvalidate(port: any): void;
declare function CFMachPortIsValid(port: any): boolean;
declare function CFMachPortGetInvalidationCallBack(port: any): (arg1: any, arg2: any) => void;
declare function CFMachPortSetInvalidationCallBack(port: any, callout: (arg1: any, arg2: any) => void): void;
declare function CFMachPortCreateRunLoopSource(allocator: any, port: any, order: number): any;
declare function CFStringTokenizerCopyBestStringLanguage(string: string, range: CFRange): string;
declare function CFStringTokenizerGetTypeID(): number;
declare function CFStringTokenizerCreate(alloc: any, string: string, range: CFRange, options: number, locale: NSLocale): any;
declare function CFStringTokenizerSetString(tokenizer: any, string: string, range: CFRange): void;
declare function CFStringTokenizerGoToTokenAtIndex(tokenizer: any, index: number): number;
declare function CFStringTokenizerAdvanceToNextToken(tokenizer: any): number;
declare function CFStringTokenizerGetCurrentTokenRange(tokenizer: any): CFRange;
declare function CFStringTokenizerCopyCurrentTokenAttribute(tokenizer: any, attribute: number): any;
declare function CFStringTokenizerGetCurrentSubTokens(tokenizer: any, ranges: any, maxRangeLength: number, derivedSubTokens: NSMutableArray): number;
declare function CFFileDescriptorGetTypeID(): number;
declare function CFFileDescriptorCreate(allocator: any, fd: number, closeOnInvalidate: boolean, callout: (arg1: any, arg2: number, arg3: any) => void, context: any): any;
declare function CFFileDescriptorGetNativeDescriptor(f: any): number;
declare function CFFileDescriptorGetContext(f: any, context: any): void;
declare function CFFileDescriptorEnableCallBacks(f: any, callBackTypes: number): void;
declare function CFFileDescriptorDisableCallBacks(f: any, callBackTypes: number): void;
declare function CFFileDescriptorInvalidate(f: any): void;
declare function CFFileDescriptorIsValid(f: any): boolean;
declare function CFFileDescriptorCreateRunLoopSource(allocator: any, f: any, order: number): any;
declare function CVBufferRetain(buffer: any): any;
declare function CVBufferRelease(buffer: any): void;
declare function CVBufferSetAttachment(buffer: any, key: string, value: any, attachmentMode: number): void;
declare function CVBufferGetAttachment(buffer: any, key: string, attachmentMode: any): any;
declare function CVBufferRemoveAttachment(buffer: any, key: string): void;
declare function CVBufferRemoveAllAttachments(buffer: any): void;
declare function CVBufferGetAttachments(buffer: any, attachmentMode: number): NSDictionary;
declare function CVBufferSetAttachments(buffer: any, theAttachments: NSDictionary, attachmentMode: number): void;
declare function CVBufferPropagateAttachments(sourceBuffer: any, destinationBuffer: any): void;
declare function CVImageBufferGetEncodedSize(imageBuffer: any): CGSize;
declare function CVImageBufferGetDisplaySize(imageBuffer: any): CGSize;
declare function CVImageBufferGetCleanRect(imageBuffer: any): CGRect;
declare function CVImageBufferIsFlipped(imageBuffer: any): boolean;
declare function CVPixelBufferGetTypeID(): number;
declare function CVPixelBufferRetain(texture: any): any;
declare function CVPixelBufferRelease(texture: any): void;
declare function CVPixelBufferCreateResolvedAttributesDictionary(allocator: any, attributes: NSArray, resolvedDictionaryOut: any): number;
declare function CVPixelBufferCreate(allocator: any, width: number, height: number, pixelFormatType: number, pixelBufferAttributes: NSDictionary, pixelBufferOut: any): number;
declare function CVPixelBufferCreateWithBytes(allocator: any, width: number, height: number, pixelFormatType: number, baseAddress: any, bytesPerRow: number, releaseCallback: (arg1: any, arg2: any) => void, releaseRefCon: any, pixelBufferAttributes: NSDictionary, pixelBufferOut: any): number;
declare function CVPixelBufferCreateWithPlanarBytes(allocator: any, width: number, height: number, pixelFormatType: number, dataPtr: any, dataSize: number, numberOfPlanes: number, planeBaseAddress: any, planeWidth: any, planeHeight: any, planeBytesPerRow: any, releaseCallback: (arg1: any, arg2: any, arg3: number, arg4: number, arg5: any) => void, releaseRefCon: any, pixelBufferAttributes: NSDictionary, pixelBufferOut: any): number;
declare function CVPixelBufferLockBaseAddress(pixelBuffer: any, lockFlags: number): number;
declare function CVPixelBufferUnlockBaseAddress(pixelBuffer: any, unlockFlags: number): number;
declare function CVPixelBufferGetWidth(pixelBuffer: any): number;
declare function CVPixelBufferGetHeight(pixelBuffer: any): number;
declare function CVPixelBufferGetPixelFormatType(pixelBuffer: any): number;
declare function CVPixelBufferGetBaseAddress(pixelBuffer: any): any;
declare function CVPixelBufferGetBytesPerRow(pixelBuffer: any): number;
declare function CVPixelBufferGetDataSize(pixelBuffer: any): number;
declare function CVPixelBufferIsPlanar(pixelBuffer: any): boolean;
declare function CVPixelBufferGetPlaneCount(pixelBuffer: any): number;
declare function CVPixelBufferGetWidthOfPlane(pixelBuffer: any, planeIndex: number): number;
declare function CVPixelBufferGetHeightOfPlane(pixelBuffer: any, planeIndex: number): number;
declare function CVPixelBufferGetBaseAddressOfPlane(pixelBuffer: any, planeIndex: number): any;
declare function CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer: any, planeIndex: number): number;
declare function CVPixelBufferGetExtendedPixels(pixelBuffer: any, extraColumnsOnLeft: any, extraColumnsOnRight: any, extraRowsOnTop: any, extraRowsOnBottom: any): void;
declare function CVPixelBufferFillExtendedPixels(pixelBuffer: any): number;
declare function CVPixelBufferPoolGetTypeID(): number;
declare function CVPixelBufferPoolRetain(pixelBufferPool: any): any;
declare function CVPixelBufferPoolRelease(pixelBufferPool: any): void;
declare function CVPixelBufferPoolCreate(allocator: any, poolAttributes: NSDictionary, pixelBufferAttributes: NSDictionary, poolOut: any): number;
declare function CVPixelBufferPoolGetAttributes(pool: any): NSDictionary;
declare function CVPixelBufferPoolGetPixelBufferAttributes(pool: any): NSDictionary;
declare function CVPixelBufferPoolCreatePixelBuffer(allocator: any, pixelBufferPool: any, pixelBufferOut: any): number;
declare function CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(allocator: any, pixelBufferPool: any, auxAttributes: NSDictionary, pixelBufferOut: any): number;
declare function CVOpenGLESTextureGetTypeID(): number;
declare function CVOpenGLESTextureGetTarget(image: any): number;
declare function CVOpenGLESTextureGetName(image: any): number;
declare function CVOpenGLESTextureIsFlipped(image: any): boolean;
declare function CVOpenGLESTextureGetCleanTexCoords(image: any, lowerLeft: number[], lowerRight: number[], upperRight: number[], upperLeft: number[]): void;
declare function CVOpenGLESTextureCacheGetTypeID(): number;
declare function CVOpenGLESTextureCacheCreate(allocator: any, cacheAttributes: NSDictionary, eaglContext: EAGLContext, textureAttributes: NSDictionary, cacheOut: any): number;
declare function CVOpenGLESTextureCacheCreateTextureFromImage(allocator: any, textureCache: any, sourceImage: any, textureAttributes: NSDictionary, target: number, internalFormat: number, width: number, height: number, format: number, type: number, planeIndex: number, textureOut: any): number;
declare function CVOpenGLESTextureCacheFlush(textureCache: any, options: number): void;
declare function CVPixelFormatDescriptionCreateWithPixelFormatType(allocator: any, pixelFormat: number): NSDictionary;
declare function CVPixelFormatDescriptionArrayCreateWithAllPixelFormatTypes(allocator: any): NSArray;
declare function CVPixelFormatDescriptionRegisterDescriptionWithPixelFormatType(description: NSDictionary, pixelFormat: number): void;
declare function CVMetalTextureGetTypeID(): number;
declare function CVMetalTextureGetTexture(image: any): any;
declare function CVMetalTextureIsFlipped(image: any): boolean;
declare function CVMetalTextureGetCleanTexCoords(image: any, lowerLeft: number[], lowerRight: number[], upperRight: number[], upperLeft: number[]): void;
declare function CVMetalTextureCacheGetTypeID(): number;
declare function CVMetalTextureCacheCreate(allocator: any, cacheAttributes: NSDictionary, metalDevice: any, textureAttributes: NSDictionary, cacheOut: any): number;
declare function CVMetalTextureCacheCreateTextureFromImage(allocator: any, textureCache: any, sourceImage: any, textureAttributes: NSDictionary, pixelFormat: number, width: number, height: number, planeIndex: number, textureOut: any): number;
declare function CVMetalTextureCacheFlush(textureCache: any, options: number): void;
declare function NSStringFromSelector(aSelector: any): string;
declare function NSSelectorFromString(aSelectorName: string): any;
declare function NSStringFromClass(aClass: any): string;
declare function NSClassFromString(aClassName: string): any;
declare function NSStringFromProtocol(proto: any): string;
declare function NSProtocolFromString(namestr: string): any;
declare function NSGetSizeAndAlignment(typePtr: string, sizep: any, alignp: any): string;
declare function NSDefaultMallocZone(): any;
declare function NSCreateZone(startSize: number, granularity: number, canFree: boolean): any;
declare function NSRecycleZone(zone: any): void;
declare function NSSetZoneName(zone: any, name: string): void;
declare function NSZoneName(zone: any): string;
declare function NSZoneFromPointer(ptr: any): any;
declare function NSZoneMalloc(zone: any, size: number): any;
declare function NSZoneCalloc(zone: any, numElems: number, byteSize: number): any;
declare function NSZoneRealloc(zone: any, ptr: any, size: number): any;
declare function NSZoneFree(zone: any, ptr: any): void;
declare function NSPageSize(): number;
declare function NSLogPageSize(): number;
declare function NSRoundUpToMultipleOfPageSize(bytes: number): number;
declare function NSRoundDownToMultipleOfPageSize(bytes: number): number;
declare function NSAllocateMemoryPages(bytes: number): any;
declare function NSDeallocateMemoryPages(ptr: any, bytes: number): void;
declare function NSCopyMemoryPages(source: any, dest: any, bytes: number): void;
declare function NSRealMemoryAvailable(): number;
declare function NSUnionRange(range1: NSRange, range2: NSRange): NSRange;
declare function NSIntersectionRange(range1: NSRange, range2: NSRange): NSRange;
declare function NSStringFromRange(range: NSRange): string;
declare function NSRangeFromString(aString: string): NSRange;
declare function NSDecimalCopy(destination: any, source: any): void;
declare function NSDecimalCompact(number: any): void;
declare function NSDecimalCompare(leftOperand: any, rightOperand: any): number;
declare function NSDecimalRound(result: any, number: any, scale: number, roundingMode: number): void;
declare function NSDecimalNormalize(number1: any, number2: any, roundingMode: number): number;
declare function NSDecimalAdd(result: any, leftOperand: any, rightOperand: any, roundingMode: number): number;
declare function NSDecimalSubtract(result: any, leftOperand: any, rightOperand: any, roundingMode: number): number;
declare function NSDecimalMultiply(result: any, leftOperand: any, rightOperand: any, roundingMode: number): number;
declare function NSDecimalDivide(result: any, leftOperand: any, rightOperand: any, roundingMode: number): number;
declare function NSDecimalPower(result: any, number: any, power: number, roundingMode: number): number;
declare function NSDecimalMultiplyByPowerOf10(result: any, number: any, power: number, roundingMode: number): number;
declare function NSDecimalString(dcm: any, locale: any): string;
declare function NSGetUncaughtExceptionHandler(): any;
declare function NSSetUncaughtExceptionHandler(arg: any): void;
declare function NSUserName(): string;
declare function NSFullUserName(): string;
declare function NSHomeDirectory(): string;
declare function NSHomeDirectoryForUser(userName: string): string;
declare function NSTemporaryDirectory(): string;
declare function NSOpenStepRootDirectory(): string;
declare function NSSearchPathForDirectoriesInDomains(directory: number, domainMask: number, expandTilde: boolean): NSArray;
declare function SecCertificateGetTypeID(): number;
declare function SecCertificateCreateWithData(allocator: any, data: NSData): any;
declare function SecCertificateCopyData(certificate: any): NSData;
declare function SecCertificateCopySubjectSummary(certificate: any): string;
declare function SecIdentityGetTypeID(): number;
declare function SecIdentityCopyCertificate(identityRef: any, certificateRef: any): number;
declare function SecIdentityCopyPrivateKey(identityRef: any, privateKeyRef: any): number;
declare function SecPKCS12Import(pkcs12_data: NSData, options: NSDictionary, items: any): number;
declare function SecAccessControlGetTypeID(): number;
declare function SecAccessControlCreateWithFlags(allocator: any, protection: any, flags: number, error: any): any;
declare function SecItemCopyMatching(query: NSDictionary, result: any): number;
declare function SecItemAdd(attributes: NSDictionary, result: any): number;
declare function SecItemUpdate(query: NSDictionary, attributesToUpdate: NSDictionary): number;
declare function SecItemDelete(query: NSDictionary): number;
declare function SecKeyGetTypeID(): number;
declare function SecKeyGeneratePair(parameters: NSDictionary, publicKey: any, privateKey: any): number;
declare function SecKeyRawSign(key: any, padding: number, dataToSign: string, dataToSignLen: number, sig: string, sigLen: any): number;
declare function SecKeyRawVerify(key: any, padding: number, signedData: string, signedDataLen: number, sig: string, sigLen: number): number;
declare function SecKeyEncrypt(key: any, padding: number, plainText: string, plainTextLen: number, cipherText: string, cipherTextLen: any): number;
declare function SecKeyDecrypt(key: any, padding: number, cipherText: string, cipherTextLen: number, plainText: string, plainTextLen: any): number;
declare function SecKeyGetBlockSize(key: any): number;
declare function SecPolicyGetTypeID(): number;
declare function SecPolicyCopyProperties(policyRef: any): NSDictionary;
declare function SecPolicyCreateBasicX509(): any;
declare function SecPolicyCreateSSL(server: boolean, hostname: string): any;
declare function SecPolicyCreateRevocation(revocationFlags: number): any;
declare function SecPolicyCreateWithProperties(policyIdentifier: any, properties: NSDictionary): any;
declare function SecRandomCopyBytes(rnd: any, count: number, bytes: string): number;
declare function SecAddSharedWebCredential(fqdn: string, account: string, password: string, completionHandler: (arg1: NSError) => void): void;
declare function SecRequestSharedWebCredential(fqdn: string, account: string, completionHandler: (arg1: NSArray, arg2: NSError) => void): void;
declare function SecCreateSharedWebCredentialPassword(): string;
declare function SecTrustGetTypeID(): number;
declare function SecTrustCreateWithCertificates(certificates: any, policies: any, trust: any): number;
declare function SecTrustSetPolicies(trust: any, policies: any): number;
declare function SecTrustCopyPolicies(trust: any, policies: any): number;
declare function SecTrustSetNetworkFetchAllowed(trust: any, allowFetch: boolean): number;
declare function SecTrustGetNetworkFetchAllowed(trust: any, allowFetch: string): number;
declare function SecTrustSetAnchorCertificates(trust: any, anchorCertificates: NSArray): number;
declare function SecTrustSetAnchorCertificatesOnly(trust: any, anchorCertificatesOnly: boolean): number;
declare function SecTrustCopyCustomAnchorCertificates(trust: any, anchors: any): number;
declare function SecTrustSetVerifyDate(trust: any, verifyDate: NSDate): number;
declare function SecTrustGetVerifyTime(trust: any): number;
declare function SecTrustEvaluate(trust: any, result: any): number;
declare function SecTrustEvaluateAsync(trust: any, queue: NSObject, result: (arg1: any, arg2: number) => void): number;
declare function SecTrustGetTrustResult(trust: any, result: any): number;
declare function SecTrustCopyPublicKey(trust: any): any;
declare function SecTrustGetCertificateCount(trust: any): number;
declare function SecTrustGetCertificateAtIndex(trust: any, ix: number): any;
declare function SecTrustCopyExceptions(trust: any): NSData;
declare function SecTrustSetExceptions(trust: any, exceptions: NSData): boolean;
declare function SecTrustCopyProperties(trust: any): NSArray;
declare function SecTrustCopyResult(trust: any): NSDictionary;
declare function SecTrustSetOCSPResponse(trust: any, responseData: any): number;
declare function SSLContextGetTypeID(): number;
declare function SSLCreateContext(alloc: any, protocolSide: number, connectionType: number): any;
declare function SSLGetSessionState(context: any, state: any): number;
declare function SSLSetSessionOption(context: any, option: number, value: boolean): number;
declare function SSLGetSessionOption(context: any, option: number, value: string): number;
declare function SSLSetIOFuncs(context: any, readFunc: (arg1: any, arg2: any, arg3: any) => number, writeFunc: (arg1: any, arg2: any, arg3: any) => number): number;
declare function SSLSetProtocolVersionMin(context: any, minVersion: number): number;
declare function SSLGetProtocolVersionMin(context: any, minVersion: any): number;
declare function SSLSetProtocolVersionMax(context: any, maxVersion: number): number;
declare function SSLGetProtocolVersionMax(context: any, maxVersion: any): number;
declare function SSLSetCertificate(context: any, certRefs: NSArray): number;
declare function SSLSetConnection(context: any, connection: any): number;
declare function SSLGetConnection(context: any, connection: any): number;
declare function SSLSetPeerDomainName(context: any, peerName: string, peerNameLen: number): number;
declare function SSLGetPeerDomainNameLength(context: any, peerNameLen: any): number;
declare function SSLGetPeerDomainName(context: any, peerName: string, peerNameLen: any): number;
declare function SSLSetDatagramHelloCookie(dtlsContext: any, cookie: any, cookieLen: number): number;
declare function SSLSetMaxDatagramRecordSize(dtlsContext: any, maxSize: number): number;
declare function SSLGetMaxDatagramRecordSize(dtlsContext: any, maxSize: any): number;
declare function SSLGetNegotiatedProtocolVersion(context: any, protocol: any): number;
declare function SSLGetNumberSupportedCiphers(context: any, numCiphers: any): number;
declare function SSLGetSupportedCiphers(context: any, ciphers: any, numCiphers: any): number;
declare function SSLSetEnabledCiphers(context: any, ciphers: any, numCiphers: number): number;
declare function SSLGetNumberEnabledCiphers(context: any, numCiphers: any): number;
declare function SSLGetEnabledCiphers(context: any, ciphers: any, numCiphers: any): number;
declare function SSLCopyPeerTrust(context: any, trust: any): number;
declare function SSLSetPeerID(context: any, peerID: any, peerIDLen: number): number;
declare function SSLGetPeerID(context: any, peerID: any, peerIDLen: any): number;
declare function SSLGetNegotiatedCipher(context: any, cipherSuite: any): number;
declare function SSLSetEncryptionCertificate(context: any, certRefs: NSArray): number;
declare function SSLSetClientSideAuthenticate(context: any, auth: number): number;
declare function SSLAddDistinguishedName(context: any, derDN: any, derDNLen: number): number;
declare function SSLCopyDistinguishedNames(context: any, names: any): number;
declare function SSLGetClientCertificateState(context: any, clientState: any): number;
declare function SSLHandshake(context: any): number;
declare function SSLWrite(context: any, data: any, dataLength: number, processed: any): number;
declare function SSLRead(context: any, data: any, dataLength: number, processed: any): number;
declare function SSLGetBufferedReadSize(context: any, bufSize: any): number;
declare function SSLGetDatagramWriteSize(dtlsContext: any, bufSize: any): number;
declare function SSLClose(context: any): number;
declare function CFHostGetTypeID(): number;
declare function CFHostCreateWithName(allocator: any, hostname: string): any;
declare function CFHostCreateWithAddress(allocator: any, addr: NSData): any;
declare function CFHostCreateCopy(alloc: any, host: any): any;
declare function CFHostStartInfoResolution(theHost: any, info: number, error: any): boolean;
declare function CFHostGetAddressing(theHost: any, hasBeenResolved: string): NSArray;
declare function CFHostGetNames(theHost: any, hasBeenResolved: string): NSArray;
declare function CFHostGetReachability(theHost: any, hasBeenResolved: string): NSData;
declare function CFHostCancelInfoResolution(theHost: any, info: number): void;
declare function CFHostSetClient(theHost: any, clientCB: (arg1: any, arg2: number, arg3: any, arg4: any) => void, clientContext: any): boolean;
declare function CFHostScheduleWithRunLoop(theHost: any, runLoop: any, runLoopMode: string): void;
declare function CFHostUnscheduleFromRunLoop(theHost: any, runLoop: any, runLoopMode: string): void;
declare function CFNetServiceGetTypeID(): number;
declare function CFNetServiceMonitorGetTypeID(): number;
declare function CFNetServiceBrowserGetTypeID(): number;
declare function CFNetServiceCreate(alloc: any, domain: string, serviceType: string, name: string, port: number): any;
declare function CFNetServiceCreateCopy(alloc: any, service: any): any;
declare function CFNetServiceGetDomain(theService: any): string;
declare function CFNetServiceGetType(theService: any): string;
declare function CFNetServiceGetName(theService: any): string;
declare function CFNetServiceRegisterWithOptions(theService: any, options: number, error: any): boolean;
declare function CFNetServiceResolveWithTimeout(theService: any, timeout: number, error: any): boolean;
declare function CFNetServiceCancel(theService: any): void;
declare function CFNetServiceGetTargetHost(theService: any): string;
declare function CFNetServiceGetPortNumber(theService: any): number;
declare function CFNetServiceGetAddressing(theService: any): NSArray;
declare function CFNetServiceGetTXTData(theService: any): NSData;
declare function CFNetServiceSetTXTData(theService: any, txtRecord: NSData): boolean;
declare function CFNetServiceCreateDictionaryWithTXTData(alloc: any, txtRecord: NSData): NSDictionary;
declare function CFNetServiceCreateTXTDataWithDictionary(alloc: any, keyValuePairs: NSDictionary): NSData;
declare function CFNetServiceSetClient(theService: any, clientCB: (arg1: any, arg2: any, arg3: any) => void, clientContext: any): boolean;
declare function CFNetServiceScheduleWithRunLoop(theService: any, runLoop: any, runLoopMode: string): void;
declare function CFNetServiceUnscheduleFromRunLoop(theService: any, runLoop: any, runLoopMode: string): void;
declare function CFNetServiceMonitorCreate(alloc: any, theService: any, clientCB: (arg1: any, arg2: any, arg3: number, arg4: NSData, arg5: any, arg6: any) => void, clientContext: any): any;
declare function CFNetServiceMonitorInvalidate(monitor: any): void;
declare function CFNetServiceMonitorStart(monitor: any, recordType: number, error: any): boolean;
declare function CFNetServiceMonitorStop(monitor: any, error: any): void;
declare function CFNetServiceMonitorScheduleWithRunLoop(monitor: any, runLoop: any, runLoopMode: string): void;
declare function CFNetServiceMonitorUnscheduleFromRunLoop(monitor: any, runLoop: any, runLoopMode: string): void;
declare function CFNetServiceBrowserCreate(alloc: any, clientCB: (arg1: any, arg2: number, arg3: any, arg4: any, arg5: any) => void, clientContext: any): any;
declare function CFNetServiceBrowserInvalidate(browser: any): void;
declare function CFNetServiceBrowserSearchForDomains(browser: any, registrationDomains: boolean, error: any): boolean;
declare function CFNetServiceBrowserSearchForServices(browser: any, domain: string, serviceType: string, error: any): boolean;
declare function CFNetServiceBrowserStopSearch(browser: any, error: any): void;
declare function CFNetServiceBrowserScheduleWithRunLoop(browser: any, runLoop: any, runLoopMode: string): void;
declare function CFNetServiceBrowserUnscheduleFromRunLoop(browser: any, runLoop: any, runLoopMode: string): void;
declare function CFStreamCreatePairWithSocketToCFHost(alloc: any, host: any, port: number, readStream: any, writeStream: any): void;
declare function CFStreamCreatePairWithSocketToNetService(alloc: any, service: any, readStream: any, writeStream: any): void;
declare function CFReadStreamCreateWithFTPURL(alloc: any, ftpURL: NSURL): NSInputStream;
declare function CFFTPCreateParsedResourceListing(alloc: any, buffer: string, bufferLength: number, parsed: any): number;
declare function CFWriteStreamCreateWithFTPURL(alloc: any, ftpURL: NSURL): NSOutputStream;
declare function CFHTTPMessageGetTypeID(): number;
declare function CFHTTPMessageCreateRequest(alloc: any, requestMethod: string, url: NSURL, httpVersion: string): any;
declare function CFHTTPMessageCreateResponse(alloc: any, statusCode: number, statusDescription: string, httpVersion: string): any;
declare function CFHTTPMessageCreateEmpty(alloc: any, isRequest: boolean): any;
declare function CFHTTPMessageCreateCopy(alloc: any, message: any): any;
declare function CFHTTPMessageIsRequest(message: any): boolean;
declare function CFHTTPMessageCopyVersion(message: any): string;
declare function CFHTTPMessageCopyBody(message: any): NSData;
declare function CFHTTPMessageSetBody(message: any, bodyData: NSData): void;
declare function CFHTTPMessageCopyHeaderFieldValue(message: any, headerField: string): string;
declare function CFHTTPMessageCopyAllHeaderFields(message: any): NSDictionary;
declare function CFHTTPMessageSetHeaderFieldValue(message: any, headerField: string, value: string): void;
declare function CFHTTPMessageAppendBytes(message: any, newBytes: string, numBytes: number): boolean;
declare function CFHTTPMessageIsHeaderComplete(message: any): boolean;
declare function CFHTTPMessageCopySerializedMessage(message: any): NSData;
declare function CFHTTPMessageCopyRequestURL(request: any): NSURL;
declare function CFHTTPMessageCopyRequestMethod(request: any): string;
declare function CFHTTPMessageAddAuthentication(request: any, authenticationFailureResponse: any, username: string, password: string, authenticationScheme: string, forProxy: boolean): boolean;
declare function CFHTTPMessageGetResponseStatusCode(response: any): number;
declare function CFHTTPMessageCopyResponseStatusLine(response: any): string;
declare function CFReadStreamCreateForHTTPRequest(alloc: any, request: any): NSInputStream;
declare function CFReadStreamCreateForStreamedHTTPRequest(alloc: any, requestHeaders: any, requestBody: NSInputStream): NSInputStream;
declare function CFHTTPAuthenticationGetTypeID(): number;
declare function CFHTTPAuthenticationCreateFromResponse(alloc: any, response: any): any;
declare function CFHTTPAuthenticationIsValid(auth: any, error: any): boolean;
declare function CFHTTPAuthenticationAppliesToRequest(auth: any, request: any): boolean;
declare function CFHTTPAuthenticationRequiresOrderedRequests(auth: any): boolean;
declare function CFHTTPMessageApplyCredentials(request: any, auth: any, username: string, password: string, error: any): boolean;
declare function CFHTTPMessageApplyCredentialDictionary(request: any, auth: any, dict: NSDictionary, error: any): boolean;
declare function CFHTTPAuthenticationCopyRealm(auth: any): string;
declare function CFHTTPAuthenticationCopyDomains(auth: any): NSArray;
declare function CFHTTPAuthenticationCopyMethod(auth: any): string;
declare function CFHTTPAuthenticationRequiresUserNameAndPassword(auth: any): boolean;
declare function CFHTTPAuthenticationRequiresAccountDomain(auth: any): boolean;
declare function CFNetDiagnosticCreateWithStreams(alloc: any, readStream: NSInputStream, writeStream: NSOutputStream): any;
declare function CFNetDiagnosticCreateWithURL(alloc: any, url: NSURL): any;
declare function CFNetDiagnosticSetName(details: any, name: string): void;
declare function CFNetDiagnosticDiagnoseProblemInteractively(details: any): number;
declare function CFNetDiagnosticCopyNetworkStatusPassively(details: any, description: any): number;
declare function CFNetworkCopySystemProxySettings(): NSDictionary;
declare function CFNetworkCopyProxiesForURL(url: NSURL, proxySettings: NSDictionary): NSArray;
declare function CFNetworkCopyProxiesForAutoConfigurationScript(proxyAutoConfigurationScript: string, targetURL: NSURL, error: any): NSArray;
declare function CFNetworkExecuteProxyAutoConfigurationScript(proxyAutoConfigurationScript: string, targetURL: NSURL, cb: (arg1: any, arg2: NSArray, arg3: NSError) => void, clientContext: any): any;
declare function CFNetworkExecuteProxyAutoConfigurationURL(proxyAutoConfigURL: NSURL, targetURL: NSURL, cb: (arg1: any, arg2: NSArray, arg3: NSError) => void, clientContext: any): any;
declare function ABRecordGetRecordID(record: any): number;
declare function ABRecordGetRecordType(record: any): number;
declare function ABRecordCopyValue(record: any, property: number): any;
declare function ABRecordSetValue(record: any, property: number, value: any, error: any): boolean;
declare function ABRecordRemoveValue(record: any, property: number, error: any): boolean;
declare function ABRecordCopyCompositeName(record: any): string;
declare function ABAddressBookGetAuthorizationStatus(): number;
declare function ABAddressBookCreateWithOptions(options: NSDictionary, error: any): any;
declare function ABAddressBookCreate(): any;
declare function ABAddressBookRequestAccessWithCompletion(addressBook: any, completion: (arg1: boolean, arg2: NSError) => void): void;
declare function ABAddressBookSave(addressBook: any, error: any): boolean;
declare function ABAddressBookHasUnsavedChanges(addressBook: any): boolean;
declare function ABAddressBookAddRecord(addressBook: any, record: any, error: any): boolean;
declare function ABAddressBookRemoveRecord(addressBook: any, record: any, error: any): boolean;
declare function ABAddressBookCopyLocalizedLabel(label: string): string;
declare function ABAddressBookRegisterExternalChangeCallback(addressBook: any, callback: (arg1: any, arg2: NSDictionary, arg3: any) => void, context: any): void;
declare function ABAddressBookUnregisterExternalChangeCallback(addressBook: any, callback: (arg1: any, arg2: NSDictionary, arg3: any) => void, context: any): void;
declare function ABAddressBookRevert(addressBook: any): void;
declare function ABAddressBookCopyDefaultSource(addressBook: any): any;
declare function ABAddressBookGetSourceWithRecordID(addressBook: any, sourceID: number): any;
declare function ABAddressBookCopyArrayOfAllSources(addressBook: any): NSArray;
declare function ABPersonCreate(): any;
declare function ABPersonCreateInSource(source: any): any;
declare function ABPersonCopySource(person: any): any;
declare function ABPersonCopyArrayOfAllLinkedPeople(person: any): NSArray;
declare function ABPersonGetTypeOfProperty(property: number): number;
declare function ABPersonCopyLocalizedPropertyName(property: number): string;
declare function ABPersonGetSortOrdering(): number;
declare function ABPersonGetCompositeNameFormat(): number;
declare function ABPersonGetCompositeNameFormatForRecord(record: any): number;
declare function ABPersonCopyCompositeNameDelimiterForRecord(record: any): string;
declare function ABPersonSetImageData(person: any, imageData: NSData, error: any): boolean;
declare function ABPersonCopyImageData(person: any): NSData;
declare function ABPersonCopyImageDataWithFormat(person: any, format: number): NSData;
declare function ABPersonHasImageData(person: any): boolean;
declare function ABPersonRemoveImageData(person: any, error: any): boolean;
declare function ABPersonComparePeopleByName(person1: any, person2: any, ordering: number): number;
declare function ABAddressBookGetPersonCount(addressBook: any): number;
declare function ABAddressBookGetPersonWithRecordID(addressBook: any, recordID: number): any;
declare function ABAddressBookCopyArrayOfAllPeople(addressBook: any): NSArray;
declare function ABAddressBookCopyArrayOfAllPeopleInSource(addressBook: any, source: any): NSArray;
declare function ABAddressBookCopyArrayOfAllPeopleInSourceWithSortOrdering(addressBook: any, source: any, sortOrdering: number): NSArray;
declare function ABAddressBookCopyPeopleWithName(addressBook: any, name: string): NSArray;
declare function ABPersonCreatePeopleInSourceWithVCardRepresentation(source: any, vCardData: NSData): NSArray;
declare function ABPersonCreateVCardRepresentationWithPeople(people: NSArray): NSData;
declare function ABGroupCreate(): any;
declare function ABGroupCreateInSource(source: any): any;
declare function ABGroupCopySource(group: any): any;
declare function ABGroupCopyArrayOfAllMembers(group: any): NSArray;
declare function ABGroupCopyArrayOfAllMembersWithSortOrdering(group: any, sortOrdering: number): NSArray;
declare function ABGroupAddMember(group: any, person: any, error: any): boolean;
declare function ABGroupRemoveMember(group: any, member: any, error: any): boolean;
declare function ABAddressBookGetGroupWithRecordID(addressBook: any, recordID: number): any;
declare function ABAddressBookGetGroupCount(addressBook: any): number;
declare function ABAddressBookCopyArrayOfAllGroups(addressBook: any): NSArray;
declare function ABAddressBookCopyArrayOfAllGroupsInSource(addressBook: any, source: any): NSArray;
declare function ABMultiValueGetPropertyType(multiValue: any): number;
declare function ABMultiValueGetCount(multiValue: any): number;
declare function ABMultiValueCopyValueAtIndex(multiValue: any, index: number): any;
declare function ABMultiValueCopyArrayOfAllValues(multiValue: any): NSArray;
declare function ABMultiValueCopyLabelAtIndex(multiValue: any, index: number): string;
declare function ABMultiValueGetIndexForIdentifier(multiValue: any, identifier: number): number;
declare function ABMultiValueGetIdentifierAtIndex(multiValue: any, index: number): number;
declare function ABMultiValueGetFirstIndexOfValue(multiValue: any, value: any): number;
declare function ABMultiValueCreateMutable(type: number): any;
declare function ABMultiValueCreateMutableCopy(multiValue: any): any;
declare function ABMultiValueAddValueAndLabel(multiValue: any, value: any, label: string, outIdentifier: any): boolean;
declare function ABMultiValueInsertValueAndLabelAtIndex(multiValue: any, value: any, label: string, index: number, outIdentifier: any): boolean;
declare function ABMultiValueRemoveValueAndLabelAtIndex(multiValue: any, index: number): boolean;
declare function ABMultiValueReplaceValueAtIndex(multiValue: any, value: any, index: number): boolean;
declare function ABMultiValueReplaceLabelAtIndex(multiValue: any, label: string, index: number): boolean;
declare function NSStringFromCGPoint(point: CGPoint): string;
declare function NSStringFromCGVector(vector: CGVector): string;
declare function NSStringFromCGSize(size: CGSize): string;
declare function NSStringFromCGRect(rect: CGRect): string;
declare function NSStringFromCGAffineTransform(transform: CGAffineTransform): string;
declare function NSStringFromUIEdgeInsets(insets: UIEdgeInsets): string;
declare function NSStringFromUIOffset(offset: UIOffset): string;
declare function CGPointFromString(string: string): CGPoint;
declare function CGVectorFromString(string: string): CGVector;
declare function CGSizeFromString(string: string): CGSize;
declare function CGRectFromString(string: string): CGRect;
declare function CGAffineTransformFromString(string: string): CGAffineTransform;
declare function UIEdgeInsetsFromString(string: string): UIEdgeInsets;
declare function UIOffsetFromString(string: string): UIOffset;
declare function NSTextAlignmentToCTTextAlignment(nsTextAlignment: number): number;
declare function NSTextAlignmentFromCTTextAlignment(ctTextAlignment: number): number;
declare function UIApplicationMain(argc: number, argv: any, principalClassName: string, delegateClassName: string): number;
declare function UIImagePNGRepresentation(image: UIImage): NSData;
declare function UIImageJPEGRepresentation(image: UIImage, compressionQuality: number): NSData;
declare function UIAccessibilityZoomFocusChanged(type: number, frame: CGRect, view: UIView): void;
declare function UIAccessibilityRegisterGestureConflictWithZoom(): void;
declare function UIGuidedAccessRestrictionStateForIdentifier(restrictionIdentifier: string): number;
declare function UIAccessibilityConvertFrameToScreenCoordinates(rect: CGRect, view: UIView): CGRect;
declare function UIAccessibilityConvertPathToScreenCoordinates(path: UIBezierPath, view: UIView): UIBezierPath;
declare function UIAccessibilityPostNotification(notification: number, argument: any): void;
declare function UIAccessibilityIsVoiceOverRunning(): boolean;
declare function UIAccessibilityIsMonoAudioEnabled(): boolean;
declare function UIAccessibilityIsClosedCaptioningEnabled(): boolean;
declare function UIAccessibilityIsInvertColorsEnabled(): boolean;
declare function UIAccessibilityIsGuidedAccessEnabled(): boolean;
declare function UIAccessibilityIsBoldTextEnabled(): boolean;
declare function UIAccessibilityIsGrayscaleEnabled(): boolean;
declare function UIAccessibilityIsReduceTransparencyEnabled(): boolean;
declare function UIAccessibilityIsReduceMotionEnabled(): boolean;
declare function UIAccessibilityDarkerSystemColorsEnabled(): boolean;
declare function UIAccessibilityIsSwitchControlRunning(): boolean;
declare function UIAccessibilityIsSpeakSelectionEnabled(): boolean;
declare function UIAccessibilityIsSpeakScreenEnabled(): boolean;
declare function UIAccessibilityRequestGuidedAccessSession(enable: boolean, completionHandler: (arg1: boolean) => void): void;
declare function UIGraphicsGetCurrentContext(): any;
declare function UIGraphicsPushContext(context: any): void;
declare function UIGraphicsPopContext(): void;
declare function UIRectFillUsingBlendMode(rect: CGRect, blendMode: number): void;
declare function UIRectFill(rect: CGRect): void;
declare function UIRectFrameUsingBlendMode(rect: CGRect, blendMode: number): void;
declare function UIRectFrame(rect: CGRect): void;
declare function UIRectClip(rect: CGRect): void;
declare function UIGraphicsBeginImageContext(size: CGSize): void;
declare function UIGraphicsBeginImageContextWithOptions(size: CGSize, opaque: boolean, scale: number): void;
declare function UIGraphicsGetImageFromCurrentImageContext(): UIImage;
declare function UIGraphicsEndImageContext(): void;
declare function UIGraphicsBeginPDFContextToFile(path: string, bounds: CGRect, documentInfo: NSDictionary): boolean;
declare function UIGraphicsBeginPDFContextToData(data: NSMutableData, bounds: CGRect, documentInfo: NSDictionary): void;
declare function UIGraphicsEndPDFContext(): void;
declare function UIGraphicsBeginPDFPage(): void;
declare function UIGraphicsBeginPDFPageWithInfo(bounds: CGRect, pageInfo: NSDictionary): void;
declare function UIGraphicsGetPDFContextBounds(): CGRect;
declare function UIGraphicsSetPDFContextURLForRect(url: NSURL, rect: CGRect): void;
declare function UIGraphicsAddPDFContextDestinationAtPoint(name: string, point: CGPoint): void;
declare function UIGraphicsSetPDFContextDestinationForRect(name: string, rect: CGRect): void;
declare function UIImageWriteToSavedPhotosAlbum(image: UIImage, completionTarget: any, completionSelector: any, contextInfo: any): void;
declare function UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(videoPath: string): boolean;
declare function UISaveVideoAtPathToSavedPhotosAlbum(videoPath: string, completionTarget: any, completionSelector: any, contextInfo: any): void;
declare function EAGLGetVersion(major: any, minor: any): void;
declare function glActiveTexture(texture: number): void;
declare function glAttachShader(program: number, shader: number): void;
declare function glBindAttribLocation(program: number, index: number, name: string): void;
declare function glBindBuffer(target: number, buffer: number): void;
declare function glBindFramebuffer(target: number, framebuffer: number): void;
declare function glBindRenderbuffer(target: number, renderbuffer: number): void;
declare function glBindTexture(target: number, texture: number): void;
declare function glBlendColor(red: number, green: number, blue: number, alpha: number): void;
declare function glBlendEquation(mode: number): void;
declare function glBlendEquationSeparate(modeRGB: number, modeAlpha: number): void;
declare function glBlendFunc(sfactor: number, dfactor: number): void;
declare function glBlendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;
declare function glBufferData(target: number, size: number, data: any, usage: number): void;
declare function glBufferSubData(target: number, offset: number, size: number, data: any): void;
declare function glCheckFramebufferStatus(target: number): number;
declare function glClear(mask: number): void;
declare function glClearColor(red: number, green: number, blue: number, alpha: number): void;
declare function glClearDepthf(depth: number): void;
declare function glClearStencil(s: number): void;
declare function glColorMask(red: number, green: number, blue: number, alpha: number): void;
declare function glCompileShader(shader: number): void;
declare function glCompressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, imageSize: number, data: any): void;
declare function glCompressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, imageSize: number, data: any): void;
declare function glCopyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;
declare function glCopyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
declare function glCreateProgram(): number;
declare function glCreateShader(type: number): number;
declare function glCullFace(mode: number): void;
declare function glDeleteBuffers(n: number, buffers: any): void;
declare function glDeleteFramebuffers(n: number, framebuffers: any): void;
declare function glDeleteProgram(program: number): void;
declare function glDeleteRenderbuffers(n: number, renderbuffers: any): void;
declare function glDeleteShader(shader: number): void;
declare function glDeleteTextures(n: number, textures: any): void;
declare function glDepthFunc(func: number): void;
declare function glDepthMask(flag: number): void;
declare function glDepthRangef(zNear: number, zFar: number): void;
declare function glDetachShader(program: number, shader: number): void;
declare function glDisable(cap: number): void;
declare function glDisableVertexAttribArray(index: number): void;
declare function glDrawArrays(mode: number, first: number, count: number): void;
declare function glDrawElements(mode: number, count: number, type: number, indices: any): void;
declare function glEnable(cap: number): void;
declare function glEnableVertexAttribArray(index: number): void;
declare function glFinish(): void;
declare function glFlush(): void;
declare function glFramebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: number): void;
declare function glFramebufferTexture2D(target: number, attachment: number, textarget: number, texture: number, level: number): void;
declare function glFrontFace(mode: number): void;
declare function glGenBuffers(n: number, buffers: any): void;
declare function glGenerateMipmap(target: number): void;
declare function glGenFramebuffers(n: number, framebuffers: any): void;
declare function glGenRenderbuffers(n: number, renderbuffers: any): void;
declare function glGenTextures(n: number, textures: any): void;
declare function glGetActiveAttrib(program: number, index: number, bufsize: number, length: any, size: any, type: any, name: string): void;
declare function glGetActiveUniform(program: number, index: number, bufsize: number, length: any, size: any, type: any, name: string): void;
declare function glGetAttachedShaders(program: number, maxcount: number, count: any, shaders: any): void;
declare function glGetAttribLocation(program: number, name: string): number;
declare function glGetBooleanv(pname: number, params: string): void;
declare function glGetBufferParameteriv(target: number, pname: number, params: any): void;
declare function glGetError(): number;
declare function glGetFloatv(pname: number, params: any): void;
declare function glGetFramebufferAttachmentParameteriv(target: number, attachment: number, pname: number, params: any): void;
declare function glGetIntegerv(pname: number, params: any): void;
declare function glGetProgramiv(program: number, pname: number, params: any): void;
declare function glGetProgramInfoLog(program: number, bufsize: number, length: any, infolog: string): void;
declare function glGetRenderbufferParameteriv(target: number, pname: number, params: any): void;
declare function glGetShaderiv(shader: number, pname: number, params: any): void;
declare function glGetShaderInfoLog(shader: number, bufsize: number, length: any, infolog: string): void;
declare function glGetShaderPrecisionFormat(shadertype: number, precisiontype: number, range: any, precision: any): void;
declare function glGetShaderSource(shader: number, bufsize: number, length: any, source: string): void;
declare function glGetString(name: number): string;
declare function glGetTexParameterfv(target: number, pname: number, params: any): void;
declare function glGetTexParameteriv(target: number, pname: number, params: any): void;
declare function glGetUniformfv(program: number, location: number, params: any): void;
declare function glGetUniformiv(program: number, location: number, params: any): void;
declare function glGetUniformLocation(program: number, name: string): number;
declare function glGetVertexAttribfv(index: number, pname: number, params: any): void;
declare function glGetVertexAttribiv(index: number, pname: number, params: any): void;
declare function glGetVertexAttribPointerv(index: number, pname: number, pointer: any): void;
declare function glHint(target: number, mode: number): void;
declare function glIsBuffer(buffer: number): number;
declare function glIsEnabled(cap: number): number;
declare function glIsFramebuffer(framebuffer: number): number;
declare function glIsProgram(program: number): number;
declare function glIsRenderbuffer(renderbuffer: number): number;
declare function glIsShader(shader: number): number;
declare function glIsTexture(texture: number): number;
declare function glLineWidth(width: number): void;
declare function glLinkProgram(program: number): void;
declare function glPixelStorei(pname: number, param: number): void;
declare function glPolygonOffset(factor: number, units: number): void;
declare function glReadPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: any): void;
declare function glReleaseShaderCompiler(): void;
declare function glRenderbufferStorage(target: number, internalformat: number, width: number, height: number): void;
declare function glSampleCoverage(value: number, invert: number): void;
declare function glScissor(x: number, y: number, width: number, height: number): void;
declare function glShaderBinary(n: number, shaders: any, binaryformat: number, binary: any, length: number): void;
declare function glShaderSource(shader: number, count: number, string: any, length: any): void;
declare function glStencilFunc(func: number, ref: number, mask: number): void;
declare function glStencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;
declare function glStencilMask(mask: number): void;
declare function glStencilMaskSeparate(face: number, mask: number): void;
declare function glStencilOp(fail: number, zfail: number, zpass: number): void;
declare function glStencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;
declare function glTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: any): void;
declare function glTexParameterf(target: number, pname: number, param: number): void;
declare function glTexParameterfv(target: number, pname: number, params: any): void;
declare function glTexParameteri(target: number, pname: number, param: number): void;
declare function glTexParameteriv(target: number, pname: number, params: any): void;
declare function glTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: any): void;
declare function glUniform1f(location: number, x: number): void;
declare function glUniform1fv(location: number, count: number, v: any): void;
declare function glUniform1i(location: number, x: number): void;
declare function glUniform1iv(location: number, count: number, v: any): void;
declare function glUniform2f(location: number, x: number, y: number): void;
declare function glUniform2fv(location: number, count: number, v: any): void;
declare function glUniform2i(location: number, x: number, y: number): void;
declare function glUniform2iv(location: number, count: number, v: any): void;
declare function glUniform3f(location: number, x: number, y: number, z: number): void;
declare function glUniform3fv(location: number, count: number, v: any): void;
declare function glUniform3i(location: number, x: number, y: number, z: number): void;
declare function glUniform3iv(location: number, count: number, v: any): void;
declare function glUniform4f(location: number, x: number, y: number, z: number, w: number): void;
declare function glUniform4fv(location: number, count: number, v: any): void;
declare function glUniform4i(location: number, x: number, y: number, z: number, w: number): void;
declare function glUniform4iv(location: number, count: number, v: any): void;
declare function glUniformMatrix2fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix3fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix4fv(location: number, count: number, transpose: number, value: any): void;
declare function glUseProgram(program: number): void;
declare function glValidateProgram(program: number): void;
declare function glVertexAttrib1f(indx: number, x: number): void;
declare function glVertexAttrib1fv(indx: number, values: any): void;
declare function glVertexAttrib2f(indx: number, x: number, y: number): void;
declare function glVertexAttrib2fv(indx: number, values: any): void;
declare function glVertexAttrib3f(indx: number, x: number, y: number, z: number): void;
declare function glVertexAttrib3fv(indx: number, values: any): void;
declare function glVertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;
declare function glVertexAttrib4fv(indx: number, values: any): void;
declare function glVertexAttribPointer(indx: number, size: number, type: number, normalized: number, stride: number, ptr: any): void;
declare function glViewport(x: number, y: number, width: number, height: number): void;
declare function glReadBuffer(mode: number): void;
declare function glDrawRangeElements(mode: number, start: number, end: number, count: number, type: number, indices: any): void;
declare function glTexImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, format: number, type: number, pixels: any): void;
declare function glTexSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, type: number, pixels: any): void;
declare function glCopyTexSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, x: number, y: number, width: number, height: number): void;
declare function glCompressedTexImage3D(target: number, level: number, internalformat: number, width: number, height: number, depth: number, border: number, imageSize: number, data: any): void;
declare function glCompressedTexSubImage3D(target: number, level: number, xoffset: number, yoffset: number, zoffset: number, width: number, height: number, depth: number, format: number, imageSize: number, data: any): void;
declare function glGenQueries(n: number, ids: any): void;
declare function glDeleteQueries(n: number, ids: any): void;
declare function glIsQuery(id: number): number;
declare function glBeginQuery(target: number, id: number): void;
declare function glEndQuery(target: number): void;
declare function glGetQueryiv(target: number, pname: number, params: any): void;
declare function glGetQueryObjectuiv(id: number, pname: number, params: any): void;
declare function glUnmapBuffer(target: number): number;
declare function glGetBufferPointerv(target: number, pname: number, params: any): void;
declare function glDrawBuffers(n: number, bufs: any): void;
declare function glUniformMatrix2x3fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix3x2fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix2x4fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix4x2fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix3x4fv(location: number, count: number, transpose: number, value: any): void;
declare function glUniformMatrix4x3fv(location: number, count: number, transpose: number, value: any): void;
declare function glBlitFramebuffer(srcX0: number, srcY0: number, srcX1: number, srcY1: number, dstX0: number, dstY0: number, dstX1: number, dstY1: number, mask: number, filter: number): void;
declare function glRenderbufferStorageMultisample(target: number, samples: number, internalformat: number, width: number, height: number): void;
declare function glFramebufferTextureLayer(target: number, attachment: number, texture: number, level: number, layer: number): void;
declare function glMapBufferRange(target: number, offset: number, length: number, access: number): any;
declare function glFlushMappedBufferRange(target: number, offset: number, length: number): void;
declare function glBindVertexArray(array: number): void;
declare function glDeleteVertexArrays(n: number, arrays: any): void;
declare function glGenVertexArrays(n: number, arrays: any): void;
declare function glIsVertexArray(array: number): number;
declare function glGetIntegeri_v(target: number, index: number, data: any): void;
declare function glBeginTransformFeedback(primitiveMode: number): void;
declare function glEndTransformFeedback(): void;
declare function glBindBufferRange(target: number, index: number, buffer: number, offset: number, size: number): void;
declare function glBindBufferBase(target: number, index: number, buffer: number): void;
declare function glTransformFeedbackVaryings(program: number, count: number, varyings: any, bufferMode: number): void;
declare function glGetTransformFeedbackVarying(program: number, index: number, bufSize: number, length: any, size: any, type: any, name: string): void;
declare function glVertexAttribIPointer(index: number, size: number, type: number, stride: number, pointer: any): void;
declare function glGetVertexAttribIiv(index: number, pname: number, params: any): void;
declare function glGetVertexAttribIuiv(index: number, pname: number, params: any): void;
declare function glVertexAttribI4i(index: number, x: number, y: number, z: number, w: number): void;
declare function glVertexAttribI4ui(index: number, x: number, y: number, z: number, w: number): void;
declare function glVertexAttribI4iv(index: number, v: any): void;
declare function glVertexAttribI4uiv(index: number, v: any): void;
declare function glGetUniformuiv(program: number, location: number, params: any): void;
declare function glGetFragDataLocation(program: number, name: string): number;
declare function glUniform1ui(location: number, v0: number): void;
declare function glUniform2ui(location: number, v0: number, v1: number): void;
declare function glUniform3ui(location: number, v0: number, v1: number, v2: number): void;
declare function glUniform4ui(location: number, v0: number, v1: number, v2: number, v3: number): void;
declare function glUniform1uiv(location: number, count: number, value: any): void;
declare function glUniform2uiv(location: number, count: number, value: any): void;
declare function glUniform3uiv(location: number, count: number, value: any): void;
declare function glUniform4uiv(location: number, count: number, value: any): void;
declare function glClearBufferiv(buffer: number, drawbuffer: number, value: any): void;
declare function glClearBufferuiv(buffer: number, drawbuffer: number, value: any): void;
declare function glClearBufferfv(buffer: number, drawbuffer: number, value: any): void;
declare function glClearBufferfi(buffer: number, drawbuffer: number, depth: number, stencil: number): void;
declare function glGetStringi(name: number, index: number): string;
declare function glCopyBufferSubData(readTarget: number, writeTarget: number, readOffset: number, writeOffset: number, size: number): void;
declare function glGetUniformIndices(program: number, uniformCount: number, uniformNames: any, uniformIndices: any): void;
declare function glGetActiveUniformsiv(program: number, uniformCount: number, uniformIndices: any, pname: number, params: any): void;
declare function glGetUniformBlockIndex(program: number, uniformBlockName: string): number;
declare function glGetActiveUniformBlockiv(program: number, uniformBlockIndex: number, pname: number, params: any): void;
declare function glGetActiveUniformBlockName(program: number, uniformBlockIndex: number, bufSize: number, length: any, uniformBlockName: string): void;
declare function glUniformBlockBinding(program: number, uniformBlockIndex: number, uniformBlockBinding: number): void;
declare function glDrawArraysInstanced(mode: number, first: number, count: number, instancecount: number): void;
declare function glDrawElementsInstanced(mode: number, count: number, type: number, indices: any, instancecount: number): void;
declare function glFenceSync(condition: number, flags: number): any;
declare function glIsSync(sync: any): number;
declare function glDeleteSync(sync: any): void;
declare function glClientWaitSync(sync: any, flags: number, timeout: number): number;
declare function glWaitSync(sync: any, flags: number, timeout: number): void;
declare function glGetInteger64v(pname: number, params: any): void;
declare function glGetSynciv(sync: any, pname: number, bufSize: number, length: any, values: any): void;
declare function glGetInteger64i_v(target: number, index: number, data: any): void;
declare function glGetBufferParameteri64v(target: number, pname: number, params: any): void;
declare function glGenSamplers(count: number, samplers: any): void;
declare function glDeleteSamplers(count: number, samplers: any): void;
declare function glIsSampler(sampler: number): number;
declare function glBindSampler(unit: number, sampler: number): void;
declare function glSamplerParameteri(sampler: number, pname: number, param: number): void;
declare function glSamplerParameteriv(sampler: number, pname: number, param: any): void;
declare function glSamplerParameterf(sampler: number, pname: number, param: number): void;
declare function glSamplerParameterfv(sampler: number, pname: number, param: any): void;
declare function glGetSamplerParameteriv(sampler: number, pname: number, params: any): void;
declare function glGetSamplerParameterfv(sampler: number, pname: number, params: any): void;
declare function glVertexAttribDivisor(index: number, divisor: number): void;
declare function glBindTransformFeedback(target: number, id: number): void;
declare function glDeleteTransformFeedbacks(n: number, ids: any): void;
declare function glGenTransformFeedbacks(n: number, ids: any): void;
declare function glIsTransformFeedback(id: number): number;
declare function glPauseTransformFeedback(): void;
declare function glResumeTransformFeedback(): void;
declare function glGetProgramBinary(program: number, bufSize: number, length: any, binaryFormat: any, binary: any): void;
declare function glProgramBinary(program: number, binaryFormat: number, binary: any, length: number): void;
declare function glProgramParameteri(program: number, pname: number, value: number): void;
declare function glInvalidateFramebuffer(target: number, numAttachments: number, attachments: any): void;
declare function glInvalidateSubFramebuffer(target: number, numAttachments: number, attachments: any, x: number, y: number, width: number, height: number): void;
declare function glTexStorage2D(target: number, levels: number, internalformat: number, width: number, height: number): void;
declare function glTexStorage3D(target: number, levels: number, internalformat: number, width: number, height: number, depth: number): void;
declare function glGetInternalformativ(target: number, internalformat: number, pname: number, bufSize: number, params: any): void;
declare function glCopyTextureLevelsAPPLE(destinationTexture: number, sourceTexture: number, sourceBaseLevel: number, sourceLevelCount: number): void;
declare function glLabelObjectEXT(type: number, object: number, length: number, label: string): void;
declare function glGetObjectLabelEXT(type: number, object: number, bufSize: number, length: any, label: string): void;
declare function glInsertEventMarkerEXT(length: number, marker: string): void;
declare function glPushGroupMarkerEXT(length: number, marker: string): void;
declare function glPopGroupMarkerEXT(): void;
declare function glUseProgramStagesEXT(pipeline: number, stages: number, program: number): void;
declare function glActiveShaderProgramEXT(pipeline: number, program: number): void;
declare function glCreateShaderProgramvEXT(type: number, count: number, strings: any): number;
declare function glBindProgramPipelineEXT(pipeline: number): void;
declare function glDeleteProgramPipelinesEXT(n: number, pipelines: any): void;
declare function glGenProgramPipelinesEXT(n: number, pipelines: any): void;
declare function glIsProgramPipelineEXT(pipeline: number): number;
declare function glProgramParameteriEXT(program: number, pname: number, value: number): void;
declare function glGetProgramPipelineivEXT(pipeline: number, pname: number, params: any): void;
declare function glValidateProgramPipelineEXT(pipeline: number): void;
declare function glGetProgramPipelineInfoLogEXT(pipeline: number, bufSize: number, length: any, infoLog: string): void;
declare function glProgramUniform1iEXT(program: number, location: number, x: number): void;
declare function glProgramUniform2iEXT(program: number, location: number, x: number, y: number): void;
declare function glProgramUniform3iEXT(program: number, location: number, x: number, y: number, z: number): void;
declare function glProgramUniform4iEXT(program: number, location: number, x: number, y: number, z: number, w: number): void;
declare function glProgramUniform1fEXT(program: number, location: number, x: number): void;
declare function glProgramUniform2fEXT(program: number, location: number, x: number, y: number): void;
declare function glProgramUniform3fEXT(program: number, location: number, x: number, y: number, z: number): void;
declare function glProgramUniform4fEXT(program: number, location: number, x: number, y: number, z: number, w: number): void;
declare function glProgramUniform1uiEXT(program: number, location: number, x: number): void;
declare function glProgramUniform2uiEXT(program: number, location: number, x: number, y: number): void;
declare function glProgramUniform3uiEXT(program: number, location: number, x: number, y: number, z: number): void;
declare function glProgramUniform4uiEXT(program: number, location: number, x: number, y: number, z: number, w: number): void;
declare function glProgramUniform1ivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform2ivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform3ivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform4ivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform1fvEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform2fvEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform3fvEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform4fvEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform1uivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform2uivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform3uivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniform4uivEXT(program: number, location: number, count: number, value: any): void;
declare function glProgramUniformMatrix2fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix3fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix4fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix2x3fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix3x2fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix2x4fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix4x2fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix3x4fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function glProgramUniformMatrix4x3fvEXT(program: number, location: number, count: number, transpose: number, value: any): void;
declare function MTLCreateSystemDefaultDevice(): any;
declare function CTParagraphStyleGetTypeID(): number;
declare function CTParagraphStyleCreate(settings: any, settingCount: number): any;
declare function CTParagraphStyleCreateCopy(paragraphStyle: any): any;
declare function CTParagraphStyleGetValueForSpecifier(paragraphStyle: any, spec: number, valueBufferSize: number, valueBuffer: any): boolean;
declare function CTFontDescriptorGetTypeID(): number;
declare function CTFontDescriptorCreateWithNameAndSize(name: string, size: number): any;
declare function CTFontDescriptorCreateWithAttributes(attributes: NSDictionary): any;
declare function CTFontDescriptorCreateCopyWithAttributes(original: any, attributes: NSDictionary): any;
declare function CTFontDescriptorCreateCopyWithFamily(original: any, family: string): any;
declare function CTFontDescriptorCreateCopyWithSymbolicTraits(original: any, symTraitValue: number, symTraitMask: number): any;
declare function CTFontDescriptorCreateCopyWithVariation(original: any, variationIdentifier: NSNumber, variationValue: number): any;
declare function CTFontDescriptorCreateCopyWithFeature(original: any, featureTypeIdentifier: NSNumber, featureSelectorIdentifier: NSNumber): any;
declare function CTFontDescriptorCreateMatchingFontDescriptors(descriptor: any, mandatoryAttributes: NSSet): NSArray;
declare function CTFontDescriptorCreateMatchingFontDescriptor(descriptor: any, mandatoryAttributes: NSSet): any;
declare function CTFontDescriptorMatchFontDescriptorsWithProgressHandler(descriptors: NSArray, mandatoryAttributes: NSSet, progressBlock: (arg1: number, arg2: NSDictionary) => boolean): boolean;
declare function CTFontDescriptorCopyAttributes(descriptor: any): NSDictionary;
declare function CTFontDescriptorCopyAttribute(descriptor: any, attribute: string): any;
declare function CTFontDescriptorCopyLocalizedAttribute(descriptor: any, attribute: string, language: any): any;
declare function CTFontGetTypeID(): number;
declare function CTFontCreateWithName(name: string, size: number, matrix: any): any;
declare function CTFontCreateWithFontDescriptor(descriptor: any, size: number, matrix: any): any;
declare function CTFontCreateWithNameAndOptions(name: string, size: number, matrix: any, options: number): any;
declare function CTFontCreateWithFontDescriptorAndOptions(descriptor: any, size: number, matrix: any, options: number): any;
declare function CTFontCreateUIFontForLanguage(uiType: number, size: number, language: string): any;
declare function CTFontCreateCopyWithAttributes(font: any, size: number, matrix: any, attributes: any): any;
declare function CTFontCreateCopyWithSymbolicTraits(font: any, size: number, matrix: any, symTraitValue: number, symTraitMask: number): any;
declare function CTFontCreateCopyWithFamily(font: any, size: number, matrix: any, family: string): any;
declare function CTFontCreateForString(currentFont: any, string: string, range: CFRange): any;
declare function CTFontCopyFontDescriptor(font: any): any;
declare function CTFontCopyAttribute(font: any, attribute: string): any;
declare function CTFontGetSize(font: any): number;
declare function CTFontGetMatrix(font: any): CGAffineTransform;
declare function CTFontGetSymbolicTraits(font: any): number;
declare function CTFontCopyTraits(font: any): NSDictionary;
declare function CTFontCopyPostScriptName(font: any): string;
declare function CTFontCopyFamilyName(font: any): string;
declare function CTFontCopyFullName(font: any): string;
declare function CTFontCopyDisplayName(font: any): string;
declare function CTFontCopyName(font: any, nameKey: string): string;
declare function CTFontCopyLocalizedName(font: any, nameKey: string, actualLanguage: any): string;
declare function CTFontCopyCharacterSet(font: any): NSCharacterSet;
declare function CTFontGetStringEncoding(font: any): number;
declare function CTFontCopySupportedLanguages(font: any): NSArray;
declare function CTFontGetGlyphsForCharacters(font: any, characters: any, glyphs: any, count: number): boolean;
declare function CTFontGetAscent(font: any): number;
declare function CTFontGetDescent(font: any): number;
declare function CTFontGetLeading(font: any): number;
declare function CTFontGetUnitsPerEm(font: any): number;
declare function CTFontGetGlyphCount(font: any): number;
declare function CTFontGetBoundingBox(font: any): CGRect;
declare function CTFontGetUnderlinePosition(font: any): number;
declare function CTFontGetUnderlineThickness(font: any): number;
declare function CTFontGetSlantAngle(font: any): number;
declare function CTFontGetCapHeight(font: any): number;
declare function CTFontGetXHeight(font: any): number;
declare function CTFontGetGlyphWithName(font: any, glyphName: string): number;
declare function CTFontGetBoundingRectsForGlyphs(font: any, orientation: number, glyphs: any, boundingRects: any, count: number): CGRect;
declare function CTFontGetOpticalBoundsForGlyphs(font: any, glyphs: any, boundingRects: any, count: number, options: number): CGRect;
declare function CTFontGetAdvancesForGlyphs(font: any, orientation: number, glyphs: any, advances: any, count: number): number;
declare function CTFontGetVerticalTranslationsForGlyphs(font: any, glyphs: any, translations: any, count: number): void;
declare function CTFontCreatePathForGlyph(font: any, glyph: number, transform: any): any;
declare function CTFontCopyVariationAxes(font: any): NSArray;
declare function CTFontCopyVariation(font: any): NSDictionary;
declare function CTFontCopyFeatures(font: any): NSArray;
declare function CTFontCopyFeatureSettings(font: any): NSArray;
declare function CTFontCopyGraphicsFont(font: any, attributes: any): any;
declare function CTFontCreateWithGraphicsFont(graphicsFont: any, size: number, matrix: any, attributes: any): any;
declare function CTFontCopyAvailableTables(font: any, options: number): NSArray;
declare function CTFontCopyTable(font: any, table: number, options: number): NSData;
declare function CTFontDrawGlyphs(font: any, glyphs: any, positions: any, count: number, context: any): void;
declare function CTFontGetLigatureCaretPositions(font: any, glyph: number, positions: any, maxPositions: number): number;
declare function CTFontCopyDefaultCascadeListForLanguages(font: any, languagePrefList: NSArray): NSArray;
declare function CTFontCollectionGetTypeID(): number;
declare function CTFontCollectionCreateFromAvailableFonts(options: NSDictionary): any;
declare function CTFontCollectionCreateWithFontDescriptors(queryDescriptors: NSArray, options: NSDictionary): any;
declare function CTFontCollectionCreateCopyWithFontDescriptors(original: any, queryDescriptors: NSArray, options: NSDictionary): any;
declare function CTFontCollectionCreateMatchingFontDescriptors(collection: any): NSArray;
declare function CTFontCollectionCreateMatchingFontDescriptorsSortedWithCallback(collection: any, sortCallback: (arg1: any, arg2: any, arg3: any) => number, refCon: any): NSArray;
declare function CTFontManagerCreateFontDescriptorsFromURL(fileURL: NSURL): NSArray;
declare function CTFontManagerCreateFontDescriptorFromData(data: NSData): any;
declare function CTFontManagerRegisterFontsForURL(fontURL: NSURL, scope: number, error: any): boolean;
declare function CTFontManagerUnregisterFontsForURL(fontURL: NSURL, scope: number, error: any): boolean;
declare function CTFontManagerRegisterGraphicsFont(font: any, error: any): boolean;
declare function CTFontManagerUnregisterGraphicsFont(font: any, error: any): boolean;
declare function CTFontManagerRegisterFontsForURLs(fontURLs: NSArray, scope: number, errors: any): boolean;
declare function CTFontManagerUnregisterFontsForURLs(fontURLs: NSArray, scope: number, errors: any): boolean;
declare function CTFrameGetTypeID(): number;
declare function CTFrameGetStringRange(frame: any): CFRange;
declare function CTFrameGetVisibleStringRange(frame: any): CFRange;
declare function CTFrameGetPath(frame: any): any;
declare function CTFrameGetFrameAttributes(frame: any): NSDictionary;
declare function CTFrameGetLines(frame: any): NSArray;
declare function CTFrameGetLineOrigins(frame: any, range: CFRange, origins: any): void;
declare function CTFrameDraw(frame: any, context: any): void;
declare function CTLineGetTypeID(): number;
declare function CTLineCreateWithAttributedString(string: NSAttributedString): any;
declare function CTLineCreateTruncatedLine(line: any, width: number, truncationType: number, truncationToken: any): any;
declare function CTLineCreateJustifiedLine(line: any, justificationFactor: number, justificationWidth: number): any;
declare function CTLineGetGlyphCount(line: any): number;
declare function CTLineGetGlyphRuns(line: any): NSArray;
declare function CTLineGetStringRange(line: any): CFRange;
declare function CTLineGetPenOffsetForFlush(line: any, flushFactor: number, flushWidth: number): number;
declare function CTLineDraw(line: any, context: any): void;
declare function CTLineGetTypographicBounds(line: any, ascent: any, descent: any, leading: any): number;
declare function CTLineGetBoundsWithOptions(line: any, options: number): CGRect;
declare function CTLineGetTrailingWhitespaceWidth(line: any): number;
declare function CTLineGetImageBounds(line: any, context: any): CGRect;
declare function CTLineGetStringIndexForPosition(line: any, position: CGPoint): number;
declare function CTLineGetOffsetForStringIndex(line: any, charIndex: number, secondaryOffset: any): number;
declare function CTTypesetterGetTypeID(): number;
declare function CTTypesetterCreateWithAttributedString(string: NSAttributedString): any;
declare function CTTypesetterCreateWithAttributedStringAndOptions(string: NSAttributedString, options: NSDictionary): any;
declare function CTTypesetterCreateLineWithOffset(typesetter: any, stringRange: CFRange, offset: number): any;
declare function CTTypesetterCreateLine(typesetter: any, stringRange: CFRange): any;
declare function CTTypesetterSuggestLineBreakWithOffset(typesetter: any, startIndex: number, width: number, offset: number): number;
declare function CTTypesetterSuggestLineBreak(typesetter: any, startIndex: number, width: number): number;
declare function CTTypesetterSuggestClusterBreakWithOffset(typesetter: any, startIndex: number, width: number, offset: number): number;
declare function CTTypesetterSuggestClusterBreak(typesetter: any, startIndex: number, width: number): number;
declare function CTFramesetterGetTypeID(): number;
declare function CTFramesetterCreateWithAttributedString(string: NSAttributedString): any;
declare function CTFramesetterCreateFrame(framesetter: any, stringRange: CFRange, path: any, frameAttributes: NSDictionary): any;
declare function CTFramesetterGetTypesetter(framesetter: any): any;
declare function CTFramesetterSuggestFrameSizeWithConstraints(framesetter: any, stringRange: CFRange, frameAttributes: NSDictionary, constraints: CGSize, fitRange: any): CGSize;
declare function CTGlyphInfoGetTypeID(): number;
declare function CTGlyphInfoCreateWithGlyphName(glyphName: string, font: any, baseString: string): any;
declare function CTGlyphInfoCreateWithGlyph(glyph: number, font: any, baseString: string): any;
declare function CTGlyphInfoCreateWithCharacterIdentifier(cid: number, collection: number, baseString: string): any;
declare function CTGlyphInfoGetGlyphName(glyphInfo: any): string;
declare function CTGlyphInfoGetCharacterIdentifier(glyphInfo: any): number;
declare function CTGlyphInfoGetCharacterCollection(glyphInfo: any): number;
declare function CTRubyAnnotationGetTypeID(): number;
declare function CTRubyAnnotationCreate(alignment: number, overhang: number, sizeFactor: number, text: string[]): any;
declare function CTRubyAnnotationCreateCopy(rubyAnnotation: any): any;
declare function CTRubyAnnotationGetAlignment(rubyAnnotation: any): number;
declare function CTRubyAnnotationGetOverhang(rubyAnnotation: any): number;
declare function CTRubyAnnotationGetSizeFactor(rubyAnnotation: any): number;
declare function CTRubyAnnotationGetTextForPosition(rubyAnnotation: any, position: number): string;
declare function CTRunGetTypeID(): number;
declare function CTRunGetGlyphCount(run: any): number;
declare function CTRunGetAttributes(run: any): NSDictionary;
declare function CTRunGetStatus(run: any): number;
declare function CTRunGetGlyphsPtr(run: any): any;
declare function CTRunGetGlyphs(run: any, range: CFRange, buffer: any): void;
declare function CTRunGetPositionsPtr(run: any): any;
declare function CTRunGetPositions(run: any, range: CFRange, buffer: any): void;
declare function CTRunGetAdvancesPtr(run: any): any;
declare function CTRunGetAdvances(run: any, range: CFRange, buffer: any): void;
declare function CTRunGetStringIndicesPtr(run: any): any;
declare function CTRunGetStringIndices(run: any, range: CFRange, buffer: any): void;
declare function CTRunGetStringRange(run: any): CFRange;
declare function CTRunGetTypographicBounds(run: any, range: CFRange, ascent: any, descent: any, leading: any): number;
declare function CTRunGetImageBounds(run: any, context: any, range: CFRange): CGRect;
declare function CTRunGetTextMatrix(run: any): CGAffineTransform;
declare function CTRunDraw(run: any, context: any, range: CFRange): void;
declare function CTRunDelegateGetTypeID(): number;
declare function CTRunDelegateCreate(callbacks: any, refCon: any): any;
declare function CTRunDelegateGetRefCon(runDelegate: any): any;
declare function CTTextTabGetTypeID(): number;
declare function CTTextTabCreate(alignment: number, location: number, options: NSDictionary): any;
declare function CTTextTabGetAlignment(tab: any): number;
declare function CTTextTabGetLocation(tab: any): number;
declare function CTTextTabGetOptions(tab: any): NSDictionary;
declare function CTGetCoreTextVersion(): number;
declare function ABCreateStringWithAddressDictionary(address: NSDictionary, addCountryName: boolean): string;
declare function CACurrentMediaTime(): number;
declare function CATransform3DIsIdentity(t: CATransform3D): boolean;
declare function CATransform3DEqualToTransform(a: CATransform3D, b: CATransform3D): boolean;
declare function CATransform3DMakeTranslation(tx: number, ty: number, tz: number): CATransform3D;
declare function CATransform3DMakeScale(sx: number, sy: number, sz: number): CATransform3D;
declare function CATransform3DMakeRotation(angle: number, x: number, y: number, z: number): CATransform3D;
declare function CATransform3DTranslate(t: CATransform3D, tx: number, ty: number, tz: number): CATransform3D;
declare function CATransform3DScale(t: CATransform3D, sx: number, sy: number, sz: number): CATransform3D;
declare function CATransform3DRotate(t: CATransform3D, angle: number, x: number, y: number, z: number): CATransform3D;
declare function CATransform3DConcat(a: CATransform3D, b: CATransform3D): CATransform3D;
declare function CATransform3DInvert(t: CATransform3D): CATransform3D;
declare function CATransform3DMakeAffineTransform(m: CGAffineTransform): CATransform3D;
declare function CATransform3DIsAffine(t: CATransform3D): boolean;
declare function CATransform3DGetAffineTransform(t: CATransform3D): CGAffineTransform;
declare function AudioFileCreateWithURL(inFileRef: NSURL, inFileType: number, inFormat: any, inFlags: number, outAudioFile: any): number;
declare function AudioFileOpenURL(inFileRef: NSURL, inPermissions: string, inFileTypeHint: number, outAudioFile: any): number;
declare function AudioFileInitializeWithCallbacks(inClientData: any, inReadFunc: (arg1: any, arg2: number, arg3: number, arg4: any, arg5: any) => number, inWriteFunc: (arg1: any, arg2: number, arg3: number, arg4: any, arg5: any) => number, inGetSizeFunc: (arg1: any) => number, inSetSizeFunc: (arg1: any, arg2: number) => number, inFileType: number, inFormat: any, inFlags: number, outAudioFile: any): number;
declare function AudioFileOpenWithCallbacks(inClientData: any, inReadFunc: (arg1: any, arg2: number, arg3: number, arg4: any, arg5: any) => number, inWriteFunc: (arg1: any, arg2: number, arg3: number, arg4: any, arg5: any) => number, inGetSizeFunc: (arg1: any) => number, inSetSizeFunc: (arg1: any, arg2: number) => number, inFileTypeHint: number, outAudioFile: any): number;
declare function AudioFileClose(inAudioFile: any): number;
declare function AudioFileOptimize(inAudioFile: any): number;
declare function AudioFileReadBytes(inAudioFile: any, inUseCache: boolean, inStartingByte: number, ioNumBytes: any, outBuffer: any): number;
declare function AudioFileWriteBytes(inAudioFile: any, inUseCache: boolean, inStartingByte: number, ioNumBytes: any, inBuffer: any): number;
declare function AudioFileReadPacketData(inAudioFile: any, inUseCache: boolean, ioNumBytes: any, outPacketDescriptions: any, inStartingPacket: number, ioNumPackets: any, outBuffer: any): number;
declare function AudioFileReadPackets(inAudioFile: any, inUseCache: boolean, outNumBytes: any, outPacketDescriptions: any, inStartingPacket: number, ioNumPackets: any, outBuffer: any): number;
declare function AudioFileWritePackets(inAudioFile: any, inUseCache: boolean, inNumBytes: number, inPacketDescriptions: any, inStartingPacket: number, ioNumPackets: any, inBuffer: any): number;
declare function AudioFileCountUserData(inAudioFile: any, inUserDataID: number, outNumberItems: any): number;
declare function AudioFileGetUserDataSize(inAudioFile: any, inUserDataID: number, inIndex: number, outUserDataSize: any): number;
declare function AudioFileGetUserData(inAudioFile: any, inUserDataID: number, inIndex: number, ioUserDataSize: any, outUserData: any): number;
declare function AudioFileSetUserData(inAudioFile: any, inUserDataID: number, inIndex: number, inUserDataSize: number, inUserData: any): number;
declare function AudioFileRemoveUserData(inAudioFile: any, inUserDataID: number, inIndex: number): number;
declare function AudioFileGetPropertyInfo(inAudioFile: any, inPropertyID: number, outDataSize: any, isWritable: any): number;
declare function AudioFileGetProperty(inAudioFile: any, inPropertyID: number, ioDataSize: any, outPropertyData: any): number;
declare function AudioFileSetProperty(inAudioFile: any, inPropertyID: number, inDataSize: number, inPropertyData: any): number;
declare function AudioFileGetGlobalInfoSize(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, outDataSize: any): number;
declare function AudioFileGetGlobalInfo(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, ioDataSize: any, outPropertyData: any): number;
declare function AudioFileStreamOpen(inClientData: any, inPropertyListenerProc: (arg1: any, arg2: any, arg3: number, arg4: any) => void, inPacketsProc: (arg1: any, arg2: number, arg3: number, arg4: any, arg5: any) => void, inFileTypeHint: number, outAudioFileStream: any): number;
declare function AudioFileStreamParseBytes(inAudioFileStream: any, inDataByteSize: number, inData: any, inFlags: number): number;
declare function AudioFileStreamSeek(inAudioFileStream: any, inPacketOffset: number, outDataByteOffset: any, ioFlags: any): number;
declare function AudioFileStreamGetPropertyInfo(inAudioFileStream: any, inPropertyID: number, outPropertyDataSize: any, outWritable: string): number;
declare function AudioFileStreamGetProperty(inAudioFileStream: any, inPropertyID: number, ioPropertyDataSize: any, outPropertyData: any): number;
declare function AudioFileStreamSetProperty(inAudioFileStream: any, inPropertyID: number, inPropertyDataSize: number, inPropertyData: any): number;
declare function AudioFileStreamClose(inAudioFileStream: any): number;
declare function AudioFormatGetPropertyInfo(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, outPropertyDataSize: any): number;
declare function AudioFormatGetProperty(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, ioPropertyDataSize: any, outPropertyData: any): number;
declare function AudioQueueNewOutput(inFormat: any, inCallbackProc: (arg1: any, arg2: any, arg3: any) => void, inUserData: any, inCallbackRunLoop: any, inCallbackRunLoopMode: string, inFlags: number, outAQ: any): number;
declare function AudioQueueNewInput(inFormat: any, inCallbackProc: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: number, arg6: any) => void, inUserData: any, inCallbackRunLoop: any, inCallbackRunLoopMode: string, inFlags: number, outAQ: any): number;
declare function AudioQueueDispose(inAQ: any, inImmediate: boolean): number;
declare function AudioQueueAllocateBuffer(inAQ: any, inBufferByteSize: number, outBuffer: any): number;
declare function AudioQueueAllocateBufferWithPacketDescriptions(inAQ: any, inBufferByteSize: number, inNumberPacketDescriptions: number, outBuffer: any): number;
declare function AudioQueueFreeBuffer(inAQ: any, inBuffer: any): number;
declare function AudioQueueEnqueueBuffer(inAQ: any, inBuffer: any, inNumPacketDescs: number, inPacketDescs: any): number;
declare function AudioQueueEnqueueBufferWithParameters(inAQ: any, inBuffer: any, inNumPacketDescs: number, inPacketDescs: any, inTrimFramesAtStart: number, inTrimFramesAtEnd: number, inNumParamValues: number, inParamValues: any, inStartTime: any, outActualStartTime: any): number;
declare function AudioQueueStart(inAQ: any, inStartTime: any): number;
declare function AudioQueuePrime(inAQ: any, inNumberOfFramesToPrepare: number, outNumberOfFramesPrepared: any): number;
declare function AudioQueueStop(inAQ: any, inImmediate: boolean): number;
declare function AudioQueuePause(inAQ: any): number;
declare function AudioQueueFlush(inAQ: any): number;
declare function AudioQueueReset(inAQ: any): number;
declare function AudioQueueGetParameter(inAQ: any, inParamID: number, outValue: any): number;
declare function AudioQueueSetParameter(inAQ: any, inParamID: number, inValue: number): number;
declare function AudioQueueGetProperty(inAQ: any, inID: number, outData: any, ioDataSize: any): number;
declare function AudioQueueSetProperty(inAQ: any, inID: number, inData: any, inDataSize: number): number;
declare function AudioQueueGetPropertySize(inAQ: any, inID: number, outDataSize: any): number;
declare function AudioQueueAddPropertyListener(inAQ: any, inID: number, inProc: (arg1: any, arg2: any, arg3: number) => void, inUserData: any): number;
declare function AudioQueueRemovePropertyListener(inAQ: any, inID: number, inProc: (arg1: any, arg2: any, arg3: number) => void, inUserData: any): number;
declare function AudioQueueCreateTimeline(inAQ: any, outTimeline: any): number;
declare function AudioQueueDisposeTimeline(inAQ: any, inTimeline: any): number;
declare function AudioQueueGetCurrentTime(inAQ: any, inTimeline: any, outTimeStamp: any, outTimelineDiscontinuity: string): number;
declare function AudioQueueDeviceGetCurrentTime(inAQ: any, outTimeStamp: any): number;
declare function AudioQueueDeviceTranslateTime(inAQ: any, inTime: any, outTime: any): number;
declare function AudioQueueDeviceGetNearestStartTime(inAQ: any, ioRequestedStartTime: any, inFlags: number): number;
declare function AudioQueueSetOfflineRenderFormat(inAQ: any, inFormat: any, inLayout: any): number;
declare function AudioQueueOfflineRender(inAQ: any, inTimestamp: any, ioBuffer: any, inNumberFrames: number): number;
declare function AudioQueueProcessingTapNew(inAQ: any, inCallback: (arg1: any, arg2: any, arg3: number, arg4: any, arg5: any, arg6: any, arg7: any) => void, inClientData: any, inFlags: number, outMaxFrames: any, outProcessingFormat: any, outAQTap: any): number;
declare function AudioQueueProcessingTapDispose(inAQTap: any): number;
declare function AudioQueueProcessingTapGetSourceAudio(inAQTap: any, inNumberFrames: number, ioTimeStamp: any, outFlags: any, outNumberFrames: any, ioData: any): number;
declare function AudioQueueProcessingTapGetQueueTime(inAQTap: any, outQueueSampleTime: any, outQueueFrameCount: any): number;
declare function AudioSessionInitialize(inRunLoop: any, inRunLoopMode: string, inInterruptionListener: (arg1: any, arg2: number) => void, inClientData: any): number;
declare function AudioSessionSetActive(active: boolean): number;
declare function AudioSessionSetActiveWithFlags(active: boolean, inFlags: number): number;
declare function AudioSessionGetProperty(inID: number, ioDataSize: any, outData: any): number;
declare function AudioSessionSetProperty(inID: number, inDataSize: number, inData: any): number;
declare function AudioSessionGetPropertySize(inID: number, outDataSize: any): number;
declare function AudioSessionAddPropertyListener(inID: number, inProc: (arg1: any, arg2: number, arg3: number, arg4: any) => void, inClientData: any): number;
declare function AudioSessionRemovePropertyListener(inID: number): number;
declare function AudioSessionRemovePropertyListenerWithUserData(inID: number, inProc: (arg1: any, arg2: number, arg3: number, arg4: any) => void, inClientData: any): number;
declare function AudioServicesPlayAlertSound(inSystemSoundID: number): void;
declare function AudioServicesPlaySystemSound(inSystemSoundID: number): void;
declare function AudioServicesCreateSystemSoundID(inFileURL: NSURL, outSystemSoundID: any): number;
declare function AudioServicesDisposeSystemSoundID(inSystemSoundID: number): number;
declare function AudioServicesAddSystemSoundCompletion(inSystemSoundID: number, inRunLoop: any, inRunLoopMode: string, inCompletionRoutine: (arg1: number, arg2: any) => void, inClientData: any): number;
declare function AudioServicesRemoveSystemSoundCompletion(inSystemSoundID: number): void;
declare function AudioServicesGetPropertyInfo(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, outPropertyDataSize: any, outWritable: string): number;
declare function AudioServicesGetProperty(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, ioPropertyDataSize: any, outPropertyData: any): number;
declare function AudioServicesSetProperty(inPropertyID: number, inSpecifierSize: number, inSpecifier: any, inPropertyDataSize: number, inPropertyData: any): number;
declare function NewAUGraph(outGraph: any): number;
declare function DisposeAUGraph(inGraph: any): number;
declare function AUGraphAddNode(inGraph: any, inDescription: any, outNode: any): number;
declare function AUGraphRemoveNode(inGraph: any, inNode: number): number;
declare function AUGraphGetNodeCount(inGraph: any, outNumberOfNodes: any): number;
declare function AUGraphGetIndNode(inGraph: any, inIndex: number, outNode: any): number;
declare function AUGraphNodeInfo(inGraph: any, inNode: number, outDescription: any, outAudioUnit: any): number;
declare function AUGraphConnectNodeInput(inGraph: any, inSourceNode: number, inSourceOutputNumber: number, inDestNode: number, inDestInputNumber: number): number;
declare function AUGraphSetNodeInputCallback(inGraph: any, inDestNode: number, inDestInputNumber: number, inInputCallback: any): number;
declare function AUGraphDisconnectNodeInput(inGraph: any, inDestNode: number, inDestInputNumber: number): number;
declare function AUGraphClearConnections(inGraph: any): number;
declare function AUGraphGetNumberOfInteractions(inGraph: any, outNumInteractions: any): number;
declare function AUGraphCountNodeInteractions(inGraph: any, inNode: number, outNumInteractions: any): number;
declare function AUGraphUpdate(inGraph: any, outIsUpdated: string): number;
declare function AUGraphOpen(inGraph: any): number;
declare function AUGraphClose(inGraph: any): number;
declare function AUGraphInitialize(inGraph: any): number;
declare function AUGraphUninitialize(inGraph: any): number;
declare function AUGraphStart(inGraph: any): number;
declare function AUGraphStop(inGraph: any): number;
declare function AUGraphIsOpen(inGraph: any, outIsOpen: string): number;
declare function AUGraphIsInitialized(inGraph: any, outIsInitialized: string): number;
declare function AUGraphIsRunning(inGraph: any, outIsRunning: string): number;
declare function AUGraphGetCPULoad(inGraph: any, outAverageCPULoad: any): number;
declare function AUGraphGetMaxCPULoad(inGraph: any, outMaxLoad: any): number;
declare function AUGraphAddRenderNotify(inGraph: any, inCallback: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: number, arg6: any) => number, inRefCon: any): number;
declare function AUGraphRemoveRenderNotify(inGraph: any, inCallback: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: number, arg6: any) => number, inRefCon: any): number;
declare function AudioConverterNew(inSourceFormat: any, inDestinationFormat: any, outAudioConverter: any): number;
declare function AudioConverterNewSpecific(inSourceFormat: any, inDestinationFormat: any, inNumberClassDescriptions: number, inClassDescriptions: any, outAudioConverter: any): number;
declare function AudioConverterDispose(inAudioConverter: any): number;
declare function AudioConverterReset(inAudioConverter: any): number;
declare function AudioConverterGetPropertyInfo(inAudioConverter: any, inPropertyID: number, outSize: any, outWritable: string): number;
declare function AudioConverterGetProperty(inAudioConverter: any, inPropertyID: number, ioPropertyDataSize: any, outPropertyData: any): number;
declare function AudioConverterSetProperty(inAudioConverter: any, inPropertyID: number, inPropertyDataSize: number, inPropertyData: any): number;
declare function AudioConverterConvertBuffer(inAudioConverter: any, inInputDataSize: number, inInputData: any, ioOutputDataSize: any, outOutputData: any): number;
declare function AudioConverterFillComplexBuffer(inAudioConverter: any, inInputDataProc: (arg1: any, arg2: any, arg3: any, arg4: any, arg5: any) => number, inInputDataProcUserData: any, ioOutputDataPacketSize: any, outOutputData: any, outPacketDescription: any): number;
declare function AudioConverterConvertComplexBuffer(inAudioConverter: any, inNumberPCMFrames: number, inInputData: any, outOutputData: any): number;
declare function ExtAudioFileOpenURL(inURL: NSURL, outExtAudioFile: any): number;
declare function ExtAudioFileWrapAudioFileID(inFileID: any, inForWriting: boolean, outExtAudioFile: any): number;
declare function ExtAudioFileCreateWithURL(inURL: NSURL, inFileType: number, inStreamDesc: any, inChannelLayout: any, inFlags: number, outExtAudioFile: any): number;
declare function ExtAudioFileDispose(inExtAudioFile: any): number;
declare function ExtAudioFileRead(inExtAudioFile: any, ioNumberFrames: any, ioData: any): number;
declare function ExtAudioFileWrite(inExtAudioFile: any, inNumberFrames: number, ioData: any): number;
declare function ExtAudioFileWriteAsync(inExtAudioFile: any, inNumberFrames: number, ioData: any): number;
declare function ExtAudioFileSeek(inExtAudioFile: any, inFrameOffset: number): number;
declare function ExtAudioFileTell(inExtAudioFile: any, outFrameOffset: any): number;
declare function ExtAudioFileGetPropertyInfo(inExtAudioFile: any, inPropertyID: number, outSize: any, outWritable: string): number;
declare function ExtAudioFileGetProperty(inExtAudioFile: any, inPropertyID: number, ioPropertyDataSize: any, outPropertyData: any): number;
declare function ExtAudioFileSetProperty(inExtAudioFile: any, inPropertyID: number, inPropertyDataSize: number, inPropertyData: any): number;
declare function NewMusicPlayer(outPlayer: any): number;
declare function DisposeMusicPlayer(inPlayer: any): number;
declare function MusicPlayerSetSequence(inPlayer: any, inSequence: any): number;
declare function MusicPlayerGetSequence(inPlayer: any, outSequence: any): number;
declare function MusicPlayerSetTime(inPlayer: any, inTime: number): number;
declare function MusicPlayerGetTime(inPlayer: any, outTime: any): number;
declare function MusicPlayerGetHostTimeForBeats(inPlayer: any, inBeats: number, outHostTime: any): number;
declare function MusicPlayerGetBeatsForHostTime(inPlayer: any, inHostTime: number, outBeats: any): number;
declare function MusicPlayerPreroll(inPlayer: any): number;
declare function MusicPlayerStart(inPlayer: any): number;
declare function MusicPlayerStop(inPlayer: any): number;
declare function MusicPlayerIsPlaying(inPlayer: any, outIsPlaying: string): number;
declare function MusicPlayerSetPlayRateScalar(inPlayer: any, inScaleRate: number): number;
declare function MusicPlayerGetPlayRateScalar(inPlayer: any, outScaleRate: any): number;
declare function NewMusicSequence(outSequence: any): number;
declare function DisposeMusicSequence(inSequence: any): number;
declare function MusicSequenceNewTrack(inSequence: any, outTrack: any): number;
declare function MusicSequenceDisposeTrack(inSequence: any, inTrack: any): number;
declare function MusicSequenceGetTrackCount(inSequence: any, outNumberOfTracks: any): number;
declare function MusicSequenceGetIndTrack(inSequence: any, inTrackIndex: number, outTrack: any): number;
declare function MusicSequenceGetTrackIndex(inSequence: any, inTrack: any, outTrackIndex: any): number;
declare function MusicSequenceGetTempoTrack(inSequence: any, outTrack: any): number;
declare function MusicSequenceSetAUGraph(inSequence: any, inGraph: any): number;
declare function MusicSequenceGetAUGraph(inSequence: any, outGraph: any): number;
declare function MusicSequenceSetMIDIEndpoint(inSequence: any, inEndpoint: any): number;
declare function MusicSequenceSetSequenceType(inSequence: any, inType: number): number;
declare function MusicSequenceGetSequenceType(inSequence: any, outType: any): number;
declare function MusicSequenceFileLoad(inSequence: any, inFileRef: NSURL, inFileTypeHint: number, inFlags: number): number;
declare function MusicSequenceFileLoadData(inSequence: any, inData: NSData, inFileTypeHint: number, inFlags: number): number;
declare function MusicSequenceFileCreate(inSequence: any, inFileRef: NSURL, inFileType: number, inFlags: number, inResolution: number): number;
declare function MusicSequenceFileCreateData(inSequence: any, inFileType: number, inFlags: number, inResolution: number, outData: any): number;
declare function MusicSequenceReverse(inSequence: any): number;
declare function MusicSequenceGetSecondsForBeats(inSequence: any, inBeats: number, outSeconds: any): number;
declare function MusicSequenceGetBeatsForSeconds(inSequence: any, inSeconds: number, outBeats: any): number;
declare function MusicSequenceSetUserCallback(inSequence: any, inCallback: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: any, arg6: number, arg7: number) => void, inClientData: any): number;
declare function MusicSequenceBeatsToBarBeatTime(inSequence: any, inBeats: number, inSubbeatDivisor: number, outBarBeatTime: any): number;
declare function MusicSequenceBarBeatTimeToBeats(inSequence: any, inBarBeatTime: any, outBeats: any): number;
declare function MusicSequenceGetInfoDictionary(inSequence: any): NSDictionary;
declare function MusicTrackGetSequence(inTrack: any, outSequence: any): number;
declare function MusicTrackSetDestNode(inTrack: any, inNode: number): number;
declare function MusicTrackSetDestMIDIEndpoint(inTrack: any, inEndpoint: any): number;
declare function MusicTrackGetDestNode(inTrack: any, outNode: any): number;
declare function MusicTrackGetDestMIDIEndpoint(inTrack: any, outEndpoint: any): number;
declare function MusicTrackSetProperty(inTrack: any, inPropertyID: number, inData: any, inLength: number): number;
declare function MusicTrackGetProperty(inTrack: any, inPropertyID: number, outData: any, ioLength: any): number;
declare function MusicTrackMoveEvents(inTrack: any, inStartTime: number, inEndTime: number, inMoveTime: number): number;
declare function MusicTrackClear(inTrack: any, inStartTime: number, inEndTime: number): number;
declare function MusicTrackCut(inTrack: any, inStartTime: number, inEndTime: number): number;
declare function MusicTrackCopyInsert(inSourceTrack: any, inSourceStartTime: number, inSourceEndTime: number, inDestTrack: any, inDestInsertTime: number): number;
declare function MusicTrackMerge(inSourceTrack: any, inSourceStartTime: number, inSourceEndTime: number, inDestTrack: any, inDestInsertTime: number): number;
declare function MusicTrackNewMIDINoteEvent(inTrack: any, inTimeStamp: number, inMessage: any): number;
declare function MusicTrackNewMIDIChannelEvent(inTrack: any, inTimeStamp: number, inMessage: any): number;
declare function MusicTrackNewMIDIRawDataEvent(inTrack: any, inTimeStamp: number, inRawData: any): number;
declare function MusicTrackNewExtendedNoteEvent(inTrack: any, inTimeStamp: number, inInfo: any): number;
declare function MusicTrackNewParameterEvent(inTrack: any, inTimeStamp: number, inInfo: any): number;
declare function MusicTrackNewExtendedTempoEvent(inTrack: any, inTimeStamp: number, inBPM: number): number;
declare function MusicTrackNewMetaEvent(inTrack: any, inTimeStamp: number, inMetaEvent: any): number;
declare function MusicTrackNewUserEvent(inTrack: any, inTimeStamp: number, inUserData: any): number;
declare function MusicTrackNewAUPresetEvent(inTrack: any, inTimeStamp: number, inPresetEvent: any): number;
declare function NewMusicEventIterator(inTrack: any, outIterator: any): number;
declare function DisposeMusicEventIterator(inIterator: any): number;
declare function MusicEventIteratorSeek(inIterator: any, inTimeStamp: number): number;
declare function MusicEventIteratorNextEvent(inIterator: any): number;
declare function MusicEventIteratorPreviousEvent(inIterator: any): number;
declare function MusicEventIteratorGetEventInfo(inIterator: any, outTimeStamp: any, outEventType: any, outEventData: any, outEventDataSize: any): number;
declare function MusicEventIteratorSetEventInfo(inIterator: any, inEventType: number, inEventData: any): number;
declare function MusicEventIteratorSetEventTime(inIterator: any, inTimeStamp: number): number;
declare function MusicEventIteratorDeleteEvent(inIterator: any): number;
declare function MusicEventIteratorHasPreviousEvent(inIterator: any, outHasPrevEvent: string): number;
declare function MusicEventIteratorHasNextEvent(inIterator: any, outHasNextEvent: string): number;
declare function MusicEventIteratorHasCurrentEvent(inIterator: any, outHasCurEvent: string): number;
declare function CAShow(inObject: any): void;
declare function CAShowFile(inObject: any, inFile: any): void;
declare function CopyNameFromSoundBank(inURL: NSURL, outName: any): number;
declare function CopyInstrumentInfoFromSoundBank(inURL: NSURL, outInstrumentInfo: any): number;
declare function AudioComponentFindNext(inComponent: any, inDesc: any): any;
declare function AudioComponentCount(inDesc: any): number;
declare function AudioComponentCopyName(inComponent: any, outName: any): number;
declare function AudioComponentGetDescription(inComponent: any, outDesc: any): number;
declare function AudioComponentGetVersion(inComponent: any, outVersion: any): number;
declare function AudioComponentInstanceNew(inComponent: any, outInstance: any): number;
declare function AudioComponentInstanceDispose(inInstance: any): number;
declare function AudioComponentInstanceGetComponent(inInstance: any): any;
declare function AudioComponentInstanceCanDo(inInstance: any, inSelectorID: number): boolean;
declare function AudioComponentRegister(inDesc: any, inName: string, inVersion: number, inFactory: (arg1: any) => any): any;
declare function AudioUnitInitialize(inUnit: any): number;
declare function AudioUnitUninitialize(inUnit: any): number;
declare function AudioUnitGetPropertyInfo(inUnit: any, inID: number, inScope: number, inElement: number, outDataSize: any, outWritable: string): number;
declare function AudioUnitGetProperty(inUnit: any, inID: number, inScope: number, inElement: number, outData: any, ioDataSize: any): number;
declare function AudioUnitSetProperty(inUnit: any, inID: number, inScope: number, inElement: number, inData: any, inDataSize: number): number;
declare function AudioUnitAddPropertyListener(inUnit: any, inID: number, inProc: (arg1: any, arg2: any, arg3: number, arg4: number, arg5: number) => void, inProcUserData: any): number;
declare function AudioUnitRemovePropertyListenerWithUserData(inUnit: any, inID: number, inProc: (arg1: any, arg2: any, arg3: number, arg4: number, arg5: number) => void, inProcUserData: any): number;
declare function AudioUnitAddRenderNotify(inUnit: any, inProc: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: number, arg6: any) => number, inProcUserData: any): number;
declare function AudioUnitRemoveRenderNotify(inUnit: any, inProc: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: number, arg6: any) => number, inProcUserData: any): number;
declare function AudioUnitGetParameter(inUnit: any, inID: number, inScope: number, inElement: number, outValue: any): number;
declare function AudioUnitSetParameter(inUnit: any, inID: number, inScope: number, inElement: number, inValue: number, inBufferOffsetInFrames: number): number;
declare function AudioUnitRender(inUnit: any, ioActionFlags: any, inTimeStamp: any, inOutputBusNumber: number, inNumberFrames: number, ioData: any): number;
declare function AudioUnitProcess(inUnit: any, ioActionFlags: any, inTimeStamp: any, inNumberFrames: number, ioData: any): number;
declare function AudioUnitProcessMultiple(inUnit: any, ioActionFlags: any, inTimeStamp: any, inNumberFrames: number, inNumberInputBufferLists: number, inInputBufferLists: any, inNumberOutputBufferLists: number, ioOutputBufferLists: any): number;
declare function AudioUnitReset(inUnit: any, inScope: number, inElement: number): number;
declare function AudioOutputUnitPublish(inDesc: any, inName: string, inVersion: number, inOutputUnit: any): number;
declare function AudioOutputUnitGetHostIcon(au: any, desiredPointSize: number): UIImage;
declare function AudioComponentGetIcon(comp: any, desiredPointSize: number): UIImage;
declare function AudioComponentGetLastActiveTime(comp: any): number;
declare function AudioOutputUnitStart(ci: any): number;
declare function AudioOutputUnitStop(ci: any): number;
declare function MusicDeviceMIDIEvent(inUnit: any, inStatus: number, inData1: number, inData2: number, inOffsetSampleFrame: number): number;
declare function MusicDeviceSysEx(inUnit: any, inData: string, inLength: number): number;
declare function MusicDeviceStartNote(inUnit: any, inInstrument: number, inGroupID: number, outNoteInstanceID: any, inOffsetSampleFrame: number, inParams: any): number;
declare function MusicDeviceStopNote(inUnit: any, inGroupID: number, inNoteInstanceID: number, inOffsetSampleFrame: number): number;
declare function AVMakeRectWithAspectRatioInsideRect(aspectRatio: CGSize, boundingRect: CGRect): CGRect;
declare function CMTimeMake(value: number, timescale: number): CMTime;
declare function CMTimeMakeWithEpoch(value: number, timescale: number, epoch: number): CMTime;
declare function CMTimeMakeWithSeconds(seconds: number, preferredTimeScale: number): CMTime;
declare function CMTimeGetSeconds(time: CMTime): number;
declare function CMTimeConvertScale(time: CMTime, newTimescale: number, method: number): CMTime;
declare function CMTimeAdd(addend1: CMTime, addend2: CMTime): CMTime;
declare function CMTimeSubtract(minuend: CMTime, subtrahend: CMTime): CMTime;
declare function CMTimeMultiply(time: CMTime, multiplier: number): CMTime;
declare function CMTimeMultiplyByFloat64(time: CMTime, multiplier: number): CMTime;
declare function CMTimeMultiplyByRatio(time: CMTime, multiplier: number, divisor: number): CMTime;
declare function CMTimeCompare(time1: CMTime, time2: CMTime): number;
declare function CMTimeMinimum(time1: CMTime, time2: CMTime): CMTime;
declare function CMTimeMaximum(time1: CMTime, time2: CMTime): CMTime;
declare function CMTimeAbsoluteValue(time: CMTime): CMTime;
declare function CMTimeCopyAsDictionary(time: CMTime, allocator: any): NSDictionary;
declare function CMTimeMakeFromDictionary(dict: NSDictionary): CMTime;
declare function CMTimeCopyDescription(allocator: any, time: CMTime): string;
declare function CMTimeShow(time: CMTime): void;
declare function CMTimeRangeMake(start: CMTime, duration: CMTime): CMTimeRange;
declare function CMTimeRangeGetUnion(range1: CMTimeRange, range2: CMTimeRange): CMTimeRange;
declare function CMTimeRangeGetIntersection(range1: CMTimeRange, range2: CMTimeRange): CMTimeRange;
declare function CMTimeRangeEqual(range1: CMTimeRange, range2: CMTimeRange): boolean;
declare function CMTimeRangeContainsTime(range: CMTimeRange, time: CMTime): boolean;
declare function CMTimeRangeContainsTimeRange(range1: CMTimeRange, range2: CMTimeRange): boolean;
declare function CMTimeRangeGetEnd(range: CMTimeRange): CMTime;
declare function CMTimeMapTimeFromRangeToRange(t: CMTime, fromRange: CMTimeRange, toRange: CMTimeRange): CMTime;
declare function CMTimeClampToRange(time: CMTime, range: CMTimeRange): CMTime;
declare function CMTimeMapDurationFromRangeToRange(dur: CMTime, fromRange: CMTimeRange, toRange: CMTimeRange): CMTime;
declare function CMTimeRangeFromTimeToTime(start: CMTime, end: CMTime): CMTimeRange;
declare function CMTimeRangeCopyAsDictionary(range: CMTimeRange, allocator: any): NSDictionary;
declare function CMTimeRangeMakeFromDictionary(dict: NSDictionary): CMTimeRange;
declare function CMTimeRangeCopyDescription(allocator: any, range: CMTimeRange): string;
declare function CMTimeRangeShow(range: CMTimeRange): void;
declare function CMSetAttachment(target: any, key: string, value: any, attachmentMode: number): void;
declare function CMGetAttachment(target: any, key: string, attachmentModeOut: any): any;
declare function CMRemoveAttachment(target: any, key: string): void;
declare function CMRemoveAllAttachments(target: any): void;
declare function CMCopyDictionaryOfAttachments(allocator: any, target: any, attachmentMode: number): NSDictionary;
declare function CMSetAttachments(target: any, theAttachments: NSDictionary, attachmentMode: number): void;
declare function CMPropagateAttachments(source: any, destination: any): void;
declare function CMBlockBufferCreateEmpty(structureAllocator: any, subBlockCapacity: number, flags: number, newBBufOut: any): number;
declare function CMBlockBufferCreateWithMemoryBlock(structureAllocator: any, memoryBlock: any, blockLength: number, blockAllocator: any, customBlockSource: any, offsetToData: number, dataLength: number, flags: number, newBBufOut: any): number;
declare function CMBlockBufferCreateWithBufferReference(structureAllocator: any, targetBuffer: any, offsetToData: number, dataLength: number, flags: number, newBBufOut: any): number;
declare function CMBlockBufferCreateContiguous(structureAllocator: any, sourceBuffer: any, blockAllocator: any, customBlockSource: any, offsetToData: number, dataLength: number, flags: number, newBBufOut: any): number;
declare function CMBlockBufferGetTypeID(): number;
declare function CMBlockBufferAppendMemoryBlock(theBuffer: any, memoryBlock: any, blockLength: number, blockAllocator: any, customBlockSource: any, offsetToData: number, dataLength: number, flags: number): number;
declare function CMBlockBufferAppendBufferReference(theBuffer: any, targetBBuf: any, offsetToData: number, dataLength: number, flags: number): number;
declare function CMBlockBufferAssureBlockMemory(theBuffer: any): number;
declare function CMBlockBufferAccessDataBytes(theBuffer: any, offset: number, length: number, temporaryBlock: any, returnedPointer: any): number;
declare function CMBlockBufferCopyDataBytes(theSourceBuffer: any, offsetToData: number, dataLength: number, destination: any): number;
declare function CMBlockBufferReplaceDataBytes(sourceBytes: any, destinationBuffer: any, offsetIntoDestination: number, dataLength: number): number;
declare function CMBlockBufferFillDataBytes(fillByte: string, destinationBuffer: any, offsetIntoDestination: number, dataLength: number): number;
declare function CMBlockBufferGetDataPointer(theBuffer: any, offset: number, lengthAtOffset: any, totalLength: any, dataPointer: any): number;
declare function CMBlockBufferGetDataLength(theBuffer: any): number;
declare function CMBlockBufferIsRangeContiguous(theBuffer: any, offset: number, length: number): boolean;
declare function CMBlockBufferIsEmpty(theBuffer: any): boolean;
declare function CMFormatDescriptionCreate(allocator: any, mediaType: number, mediaSubtype: number, extensions: NSDictionary, descOut: any): number;
declare function CMFormatDescriptionGetTypeID(): number;
declare function CMFormatDescriptionEqual(desc1: any, desc2: any): boolean;
declare function CMFormatDescriptionEqualIgnoringExtensionKeys(desc1: any, desc2: any, formatDescriptionExtensionKeysToIgnore: any, sampleDescriptionExtensionAtomKeysToIgnore: any): boolean;
declare function CMFormatDescriptionGetMediaType(desc: any): number;
declare function CMFormatDescriptionGetMediaSubType(desc: any): number;
declare function CMFormatDescriptionGetExtensions(desc: any): NSDictionary;
declare function CMFormatDescriptionGetExtension(desc: any, extensionKey: string): any;
declare function CMAudioFormatDescriptionCreate(allocator: any, asbd: any, layoutSize: number, layout: any, magicCookieSize: number, magicCookie: any, extensions: NSDictionary, outDesc: any): number;
declare function CMAudioFormatDescriptionGetStreamBasicDescription(desc: any): any;
declare function CMAudioFormatDescriptionGetMagicCookie(desc: any, cookieSizeOut: any): any;
declare function CMAudioFormatDescriptionGetChannelLayout(desc: any, layoutSize: any): any;
declare function CMAudioFormatDescriptionGetFormatList(desc: any, formatListSize: any): any;
declare function CMAudioFormatDescriptionGetRichestDecodableFormat(desc: any): any;
declare function CMAudioFormatDescriptionGetMostCompatibleFormat(desc: any): any;
declare function CMAudioFormatDescriptionCreateSummary(allocator: any, formatDescriptionArray: NSArray, flags: number, summaryFormatDescriptionOut: any): number;
declare function CMAudioFormatDescriptionEqual(desc1: any, desc2: any, equalityMask: number, equalityMaskOut: any): boolean;
declare function CMVideoFormatDescriptionCreate(allocator: any, codecType: number, width: number, height: number, extensions: NSDictionary, outDesc: any): number;
declare function CMVideoFormatDescriptionCreateForImageBuffer(allocator: any, imageBuffer: any, outDesc: any): number;
declare function CMVideoFormatDescriptionCreateFromH264ParameterSets(allocator: any, parameterSetCount: number, parameterSetPointers: any, parameterSetSizes: any, NALUnitHeaderLength: number, formatDescriptionOut: any): number;
declare function CMVideoFormatDescriptionGetH264ParameterSetAtIndex(videoDesc: any, parameterSetIndex: number, parameterSetPointerOut: any, parameterSetSizeOut: any, parameterSetCountOut: any, NALUnitHeaderLengthOut: any): number;
declare function CMVideoFormatDescriptionGetDimensions(videoDesc: any): CMVideoDimensions;
declare function CMVideoFormatDescriptionGetPresentationDimensions(videoDesc: any, usePixelAspectRatio: boolean, useCleanAperture: boolean): CGSize;
declare function CMVideoFormatDescriptionGetCleanAperture(videoDesc: any, originIsAtTopLeft: boolean): CGRect;
declare function CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(): NSArray;
declare function CMVideoFormatDescriptionMatchesImageBuffer(desc: any, imageBuffer: any): boolean;
declare function CMMuxedFormatDescriptionCreate(allocator: any, muxType: number, extensions: NSDictionary, outDesc: any): number;
declare function CMTextFormatDescriptionGetDisplayFlags(desc: any, outDisplayFlags: any): number;
declare function CMTextFormatDescriptionGetJustification(desc: any, outHorizontalJust: any, outVerticalJust: any): number;
declare function CMTextFormatDescriptionGetDefaultTextBox(desc: any, originIsAtTopLeft: boolean, heightOfTextTrack: number, outDefaultTextBox: any): number;
declare function CMTextFormatDescriptionGetDefaultStyle(desc: any, outLocalFontID: any, outBold: string, outItalic: string, outUnderline: string, outFontSize: any, outColorComponents: number[]): number;
declare function CMTextFormatDescriptionGetFontName(desc: any, localFontID: number, outFontName: any): number;
declare function CMTimeCodeFormatDescriptionCreate(allocator: any, timeCodeFormatType: number, frameDuration: CMTime, frameQuanta: number, tcFlags: number, extensions: NSDictionary, descOut: any): number;
declare function CMTimeCodeFormatDescriptionGetFrameDuration(timeCodeFormatDescription: any): CMTime;
declare function CMTimeCodeFormatDescriptionGetFrameQuanta(timeCodeFormatDescription: any): number;
declare function CMTimeCodeFormatDescriptionGetTimeCodeFlags(desc: any): number;
declare function CMMetadataFormatDescriptionCreateWithKeys(allocator: any, metadataType: number, keys: NSArray, outDesc: any): number;
declare function CMMetadataFormatDescriptionCreateWithMetadataSpecifications(allocator: any, metadataType: number, metadataSpecifications: NSArray, outDesc: any): number;
declare function CMMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications(allocator: any, srcDesc: any, metadataSpecifications: NSArray, outDesc: any): number;
declare function CMMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions(allocator: any, srcDesc1: any, srcDesc2: any, outDesc: any): number;
declare function CMMetadataFormatDescriptionGetKeyWithLocalID(desc: any, localKeyID: number): NSDictionary;
declare function CMMetadataFormatDescriptionGetIdentifiers(desc: any): NSArray;
declare function CMSampleBufferCreate(allocator: any, dataBuffer: any, dataReady: boolean, makeDataReadyCallback: (arg1: any, arg2: any) => number, makeDataReadyRefcon: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: any, numSampleSizeEntries: number, sampleSizeArray: any, sBufOut: any): number;
declare function CMSampleBufferCreateReady(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, numSampleTimingEntries: number, sampleTimingArray: any, numSampleSizeEntries: number, sampleSizeArray: any, sBufOut: any): number;
declare function CMAudioSampleBufferCreateWithPacketDescriptions(allocator: any, dataBuffer: any, dataReady: boolean, makeDataReadyCallback: (arg1: any, arg2: any) => number, makeDataReadyRefcon: any, formatDescription: any, numSamples: number, sbufPTS: CMTime, packetDescriptions: any, sBufOut: any): number;
declare function CMAudioSampleBufferCreateReadyWithPacketDescriptions(allocator: any, dataBuffer: any, formatDescription: any, numSamples: number, sbufPTS: CMTime, packetDescriptions: any, sBufOut: any): number;
declare function CMSampleBufferCreateForImageBuffer(allocator: any, imageBuffer: any, dataReady: boolean, makeDataReadyCallback: (arg1: any, arg2: any) => number, makeDataReadyRefcon: any, formatDescription: any, sampleTiming: any, sBufOut: any): number;
declare function CMSampleBufferCreateReadyWithImageBuffer(allocator: any, imageBuffer: any, formatDescription: any, sampleTiming: any, sBufOut: any): number;
declare function CMSampleBufferCreateCopy(allocator: any, sbuf: any, sbufCopyOut: any): number;
declare function CMSampleBufferCreateCopyWithNewTiming(allocator: any, originalSBuf: any, numSampleTimingEntries: number, sampleTimingArray: any, sBufCopyOut: any): number;
declare function CMSampleBufferCopySampleBufferForRange(allocator: any, sbuf: any, sampleRange: CFRange, sBufOut: any): number;
declare function CMSampleBufferGetTypeID(): number;
declare function CMSampleBufferSetDataBuffer(sbuf: any, dataBuffer: any): number;
declare function CMSampleBufferGetDataBuffer(sbuf: any): any;
declare function CMSampleBufferGetImageBuffer(sbuf: any): any;
declare function CMSampleBufferSetDataBufferFromAudioBufferList(sbuf: any, bbufStructAllocator: any, bbufMemoryAllocator: any, flags: number, bufferList: any): number;
declare function CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(sbuf: any, bufferListSizeNeededOut: any, bufferListOut: any, bufferListSize: number, bbufStructAllocator: any, bbufMemoryAllocator: any, flags: number, blockBufferOut: any): number;
declare function CMSampleBufferGetAudioStreamPacketDescriptions(sbuf: any, packetDescriptionsSize: number, packetDescriptionsOut: any, packetDescriptionsSizeNeededOut: any): number;
declare function CMSampleBufferGetAudioStreamPacketDescriptionsPtr(sbuf: any, packetDescriptionsPtrOut: any, packetDescriptionsSizeOut: any): number;
declare function CMSampleBufferCopyPCMDataIntoAudioBufferList(sbuf: any, frameOffset: number, numFrames: number, bufferList: any): number;
declare function CMSampleBufferSetDataReady(sbuf: any): number;
declare function CMSampleBufferDataIsReady(sbuf: any): boolean;
declare function CMSampleBufferSetDataFailed(sbuf: any, status: number): number;
declare function CMSampleBufferHasDataFailed(sbuf: any, statusOut: any): boolean;
declare function CMSampleBufferMakeDataReady(sbuf: any): number;
declare function CMSampleBufferTrackDataReadiness(sbuf: any, sbufToTrack: any): number;
declare function CMSampleBufferInvalidate(sbuf: any): number;
declare function CMSampleBufferSetInvalidateCallback(sbuf: any, invalidateCallback: (arg1: any, arg2: number) => void, invalidateRefCon: number): number;
declare function CMSampleBufferSetInvalidateHandler(sbuf: any, invalidateHandler: (arg1: any) => void): number;
declare function CMSampleBufferIsValid(sbuf: any): boolean;
declare function CMSampleBufferGetNumSamples(sbuf: any): number;
declare function CMSampleBufferGetDuration(sbuf: any): CMTime;
declare function CMSampleBufferGetPresentationTimeStamp(sbuf: any): CMTime;
declare function CMSampleBufferGetDecodeTimeStamp(sbuf: any): CMTime;
declare function CMSampleBufferGetOutputDuration(sbuf: any): CMTime;
declare function CMSampleBufferGetOutputPresentationTimeStamp(sbuf: any): CMTime;
declare function CMSampleBufferSetOutputPresentationTimeStamp(sbuf: any, outputPresentationTimeStamp: CMTime): number;
declare function CMSampleBufferGetOutputDecodeTimeStamp(sbuf: any): CMTime;
declare function CMSampleBufferGetSampleTimingInfoArray(sbuf: any, timingArrayEntries: number, timingArrayOut: any, timingArrayEntriesNeededOut: any): number;
declare function CMSampleBufferGetOutputSampleTimingInfoArray(sbuf: any, timingArrayEntries: number, timingArrayOut: any, timingArrayEntriesNeededOut: any): number;
declare function CMSampleBufferGetSampleTimingInfo(sbuf: any, sampleIndex: number, timingInfoOut: any): number;
declare function CMSampleBufferGetSampleSizeArray(sbuf: any, sizeArrayEntries: number, sizeArrayOut: any, sizeArrayEntriesNeededOut: any): number;
declare function CMSampleBufferGetSampleSize(sbuf: any, sampleIndex: number): number;
declare function CMSampleBufferGetTotalSampleSize(sbuf: any): number;
declare function CMSampleBufferGetFormatDescription(sbuf: any): any;
declare function CMSampleBufferGetSampleAttachmentsArray(sbuf: any, createIfNecessary: boolean): NSArray;
declare function CMSampleBufferCallForEachSample(sbuf: any, callback: (arg1: any, arg2: number, arg3: any) => number, refcon: any): number;
declare function CMSampleBufferCallBlockForEachSample(sbuf: any, handler: (arg1: any, arg2: number) => number): number;
declare function CMClockGetTypeID(): number;
declare function CMClockGetHostTimeClock(): any;
declare function CMClockConvertHostTimeToSystemUnits(hostTime: CMTime): number;
declare function CMClockMakeHostTimeFromSystemUnits(hostTime: number): CMTime;
declare function CMClockGetTime(clock: any): CMTime;
declare function CMClockGetAnchorTime(clock: any, outClockTime: any, outReferenceClockTime: any): number;
declare function CMClockMightDrift(clock: any, otherClock: any): boolean;
declare function CMClockInvalidate(clock: any): void;
declare function CMTimebaseGetTypeID(): number;
declare function CMTimebaseCreateWithMasterClock(allocator: any, masterClock: any, timebaseOut: any): number;
declare function CMTimebaseCreateWithMasterTimebase(allocator: any, masterTimebase: any, timebaseOut: any): number;
declare function CMTimebaseGetMasterTimebase(timebase: any): any;
declare function CMTimebaseGetMasterClock(timebase: any): any;
declare function CMTimebaseGetMaster(timebase: any): any;
declare function CMTimebaseGetUltimateMasterClock(timebase: any): any;
declare function CMTimebaseGetTime(timebase: any): CMTime;
declare function CMTimebaseGetTimeWithTimeScale(timebase: any, timescale: number, method: number): CMTime;
declare function CMTimebaseSetTime(timebase: any, time: CMTime): number;
declare function CMTimebaseSetAnchorTime(timebase: any, timebaseTime: CMTime, immediateMasterTime: CMTime): number;
declare function CMTimebaseGetRate(timebase: any): number;
declare function CMTimebaseGetTimeAndRate(timebase: any, outTime: any, outRate: any): number;
declare function CMTimebaseSetRate(timebase: any, rate: number): number;
declare function CMTimebaseSetRateAndAnchorTime(timebase: any, rate: number, timebaseTime: CMTime, immediateMasterTime: CMTime): number;
declare function CMTimebaseGetEffectiveRate(timebase: any): number;
declare function CMTimebaseAddTimer(timebase: any, timer: NSTimer, runloop: any): number;
declare function CMTimebaseRemoveTimer(timebase: any, timer: NSTimer): number;
declare function CMTimebaseSetTimerNextFireTime(timebase: any, timer: NSTimer, fireTime: CMTime, flags: number): number;
declare function CMTimebaseSetTimerToFireImmediately(timebase: any, timer: NSTimer): number;
declare function CMTimebaseAddTimerDispatchSource(timebase: any, timerSource: NSObject): number;
declare function CMTimebaseRemoveTimerDispatchSource(timebase: any, timerSource: NSObject): number;
declare function CMTimebaseSetTimerDispatchSourceNextFireTime(timebase: any, timerSource: NSObject, fireTime: CMTime, flags: number): number;
declare function CMTimebaseSetTimerDispatchSourceToFireImmediately(timebase: any, timerSource: NSObject): number;
declare function CMSyncGetRelativeRate(ofClockOrTimebase: any, relativeToClockOrTimebase: any): number;
declare function CMSyncGetRelativeRateAndAnchorTime(ofClockOrTimebase: any, relativeToClockOrTimebase: any, outRelativeRate: any, outOfClockOrTimebaseAnchorTime: any, outRelativeToClockOrTimebaseAnchorTime: any): number;
declare function CMSyncConvertTime(time: CMTime, fromClockOrTimebase: any, toClockOrTimebase: any): CMTime;
declare function CMSyncMightDrift(clockOrTimebase1: any, clockOrTimebase2: any): boolean;
declare function CMSyncGetTime(clockOrTimebase: any): CMTime;
declare function CMTimebaseNotificationBarrier(timebase: any): number;
declare function CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(allocator: any, imageDescriptionData: string, imageDescriptionSize: number, imageDescriptionStringEncoding: number, imageDescriptionFlavor: string, videoFormatDescriptionOut: any): number;
declare function CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBuffer(allocator: any, imageDescriptionBlockBuffer: any, imageDescriptionStringEncoding: number, imageDescriptionFlavor: string, videoFormatDescriptionOut: any): number;
declare function CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(allocator: any, videoFormatDescription: any, imageDescriptionStringEncoding: number, imageDescriptionFlavor: string, imageDescriptionBlockBufferOut: any): number;
declare function CMSwapBigEndianImageDescriptionToHost(imageDescriptionData: string, imageDescriptionSize: number): number;
declare function CMSwapHostEndianImageDescriptionToBig(imageDescriptionData: string, imageDescriptionSize: number): number;
declare function CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(allocator: any, soundDescriptionData: string, soundDescriptionSize: number, soundDescriptionFlavor: string, audioFormatDescriptionOut: any): number;
declare function CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBuffer(allocator: any, soundDescriptionBlockBuffer: any, soundDescriptionFlavor: string, audioFormatDescriptionOut: any): number;
declare function CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(allocator: any, audioFormatDescription: any, soundDescriptionFlavor: string, soundDescriptionBlockBufferOut: any): number;
declare function CMDoesBigEndianSoundDescriptionRequireLegacyCBRSampleTableLayout(soundDescriptionBlockBuffer: any, soundDescriptionFlavor: string): boolean;
declare function CMSwapBigEndianSoundDescriptionToHost(soundDescriptionData: string, soundDescriptionSize: number): number;
declare function CMSwapHostEndianSoundDescriptionToBig(soundDescriptionData: string, soundDescriptionSize: number): number;
declare function CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(allocator: any, textDescriptionData: string, textDescriptionSize: number, textDescriptionFlavor: string, mediaType: number, textFormatDescriptionOut: any): number;
declare function CMTextFormatDescriptionCreateFromBigEndianTextDescriptionBlockBuffer(allocator: any, textDescriptionBlockBuffer: any, textDescriptionFlavor: string, mediaType: number, textFormatDescriptionOut: any): number;
declare function CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(allocator: any, textFormatDescription: any, textDescriptionFlavor: string, textDescriptionBlockBufferOut: any): number;
declare function CMSwapBigEndianTextDescriptionToHost(textDescriptionData: string, textDescriptionSize: number): number;
declare function CMSwapHostEndianTextDescriptionToBig(textDescriptionData: string, textDescriptionSize: number): number;
declare function CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(allocator: any, closedCaptionDescriptionData: string, closedCaptionDescriptionSize: number, closedCaptionDescriptionFlavor: string, closedCaptionFormatDescriptionOut: any): number;
declare function CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionBlockBuffer(allocator: any, closedCaptionDescriptionBlockBuffer: any, closedCaptionDescriptionFlavor: string, closedCaptionFormatDescriptionOut: any): number;
declare function CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(allocator: any, closedCaptionFormatDescription: any, closedCaptionDescriptionFlavor: string, closedCaptionDescriptionBlockBufferOut: any): number;
declare function CMSwapBigEndianClosedCaptionDescriptionToHost(closedCaptionDescriptionData: string, closedCaptionDescriptionSize: number): number;
declare function CMSwapHostEndianClosedCaptionDescriptionToBig(closedCaptionDescriptionData: string, closedCaptionDescriptionSize: number): number;
declare function CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(allocator: any, timeCodeDescriptionData: string, timeCodeDescriptionSize: number, timeCodeDescriptionFlavor: string, timeCodeFormatDescriptionOut: any): number;
declare function CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionBlockBuffer(allocator: any, timeCodeDescriptionBlockBuffer: any, timeCodeDescriptionFlavor: string, timeCodeFormatDescriptionOut: any): number;
declare function CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(allocator: any, timeCodeFormatDescription: any, timeCodeDescriptionFlavor: string, timeCodeDescriptionBlockBufferOut: any): number;
declare function CMSwapBigEndianTimeCodeDescriptionToHost(timeCodeDescriptionData: string, timeCodeDescriptionSize: number): number;
declare function CMSwapHostEndianTimeCodeDescriptionToBig(timeCodeDescriptionData: string, timeCodeDescriptionSize: number): number;
declare function CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(allocator: any, metadataDescriptionData: string, metadataDescriptionSize: number, metadataDescriptionFlavor: string, metadataFormatDescriptionOut: any): number;
declare function CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(allocator: any, metadataDescriptionBlockBuffer: any, metadataDescriptionFlavor: string, metadataFormatDescriptionOut: any): number;
declare function CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(allocator: any, metadataFormatDescription: any, metadataDescriptionFlavor: string, metadataDescriptionBlockBufferOut: any): number;
declare function CMSwapBigEndianMetadataDescriptionToHost(metadataDescriptionData: string, metadataDescriptionSize: number): number;
declare function CMSwapHostEndianMetadataDescriptionToBig(metadataDescriptionData: string, metadataDescriptionSize: number): number;
declare function CMBufferQueueGetCallbacksForUnsortedSampleBuffers(): any;
declare function CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(): any;
declare function CMBufferQueueCreate(allocator: any, capacity: number, callbacks: any, queueOut: any): number;
declare function CMBufferQueueGetTypeID(): number;
declare function CMBufferQueueEnqueue(queue: any, buf: any): number;
declare function CMBufferQueueDequeueAndRetain(queue: any): any;
declare function CMBufferQueueDequeueIfDataReadyAndRetain(queue: any): any;
declare function CMBufferQueueGetHead(queue: any): any;
declare function CMBufferQueueIsEmpty(queue: any): boolean;
declare function CMBufferQueueMarkEndOfData(queue: any): number;
declare function CMBufferQueueContainsEndOfData(queue: any): boolean;
declare function CMBufferQueueIsAtEndOfData(queue: any): boolean;
declare function CMBufferQueueReset(queue: any): number;
declare function CMBufferQueueResetWithCallback(queue: any, callback: (arg1: any, arg2: any) => void, refcon: any): number;
declare function CMBufferQueueGetBufferCount(queue: any): number;
declare function CMBufferQueueGetDuration(queue: any): CMTime;
declare function CMBufferQueueGetMinDecodeTimeStamp(queue: any): CMTime;
declare function CMBufferQueueGetFirstDecodeTimeStamp(queue: any): CMTime;
declare function CMBufferQueueGetMinPresentationTimeStamp(queue: any): CMTime;
declare function CMBufferQueueGetFirstPresentationTimeStamp(queue: any): CMTime;
declare function CMBufferQueueGetMaxPresentationTimeStamp(queue: any): CMTime;
declare function CMBufferQueueGetEndPresentationTimeStamp(queue: any): CMTime;
declare function CMBufferQueueGetTotalSize(queue: any): number;
declare function CMBufferQueueInstallTrigger(queue: any, triggerCallback: (arg1: any, arg2: any) => void, triggerRefcon: any, triggerCondition: number, triggerTime: CMTime, triggerTokenOut: any): number;
declare function CMBufferQueueInstallTriggerWithIntegerThreshold(queue: any, triggerCallback: (arg1: any, arg2: any) => void, triggerRefcon: any, triggerCondition: number, triggerThreshold: number, triggerTokenOut: any): number;
declare function CMBufferQueueRemoveTrigger(queue: any, triggerToken: any): number;
declare function CMBufferQueueTestTrigger(queue: any, triggerToken: any): boolean;
declare function CMBufferQueueCallForEachBuffer(queue: any, callback: (arg1: any, arg2: any) => number, refcon: any): number;
declare function CMBufferQueueSetValidationCallback(queue: any, validationCallback: (arg1: any, arg2: any, arg3: any) => number, validationRefCon: any): number;
declare function CMSimpleQueueGetTypeID(): number;
declare function CMSimpleQueueCreate(allocator: any, capacity: number, queueOut: any): number;
declare function CMSimpleQueueEnqueue(queue: any, element: any): number;
declare function CMSimpleQueueDequeue(queue: any): any;
declare function CMSimpleQueueGetHead(queue: any): any;
declare function CMSimpleQueueReset(queue: any): number;
declare function CMSimpleQueueGetCapacity(queue: any): number;
declare function CMSimpleQueueGetCount(queue: any): number;
declare function CMMemoryPoolGetTypeID(): number;
declare function CMMemoryPoolCreate(options: NSDictionary): any;
declare function CMMemoryPoolGetAllocator(pool: any): any;
declare function CMMemoryPoolFlush(pool: any): void;
declare function CMMemoryPoolInvalidate(pool: any): void;
declare function CMMetadataCreateIdentifierForKeyAndKeySpace(allocator: any, key: any, keySpace: string, identifierOut: any): number;
declare function CMMetadataCreateKeyFromIdentifier(allocator: any, identifier: string, keyOut: any): number;
declare function CMMetadataCreateKeyFromIdentifierAsCFData(allocator: any, identifier: string, keyOut: any): number;
declare function CMMetadataCreateKeySpaceFromIdentifier(allocator: any, identifier: string, keySpaceOut: any): number;
declare function CMMetadataDataTypeRegistryRegisterDataType(dataType: string, description: string, conformingDataTypes: NSArray): number;
declare function CMMetadataDataTypeRegistryDataTypeIsRegistered(dataType: string): boolean;
declare function CMMetadataDataTypeRegistryGetDataTypeDescription(dataType: string): string;
declare function CMMetadataDataTypeRegistryGetConformingDataTypes(dataType: string): NSArray;
declare function CMMetadataDataTypeRegistryDataTypeConformsToDataType(dataType: string, conformsToDataType: string): boolean;
declare function CMMetadataDataTypeRegistryGetBaseDataTypes(): NSArray;
declare function CMMetadataDataTypeRegistryDataTypeIsBaseDataType(dataType: string): boolean;
declare function CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType: string): string;
declare function CMAudioClockCreate(allocator: any, clockOut: any): number;
declare function MTAudioProcessingTapGetTypeID(): number;
declare function MTAudioProcessingTapCreate(allocator: any, callbacks: any, flags: number, tapOut: any): number;
declare function MTAudioProcessingTapGetStorage(tap: any): any;
declare function MTAudioProcessingTapGetSourceAudio(tap: any, numberFrames: number, bufferListInOut: any, flagsOut: any, timeRangeOut: any, numberFramesOut: any): number;
declare function CLLocationCoordinate2DIsValid(coord: CLLocationCoordinate2D): boolean;
declare function CLLocationCoordinate2DMake(latitude: number, longitude: number): CLLocationCoordinate2D;
declare function GLKMatrixStackCreate(alloc: any): any;
declare function GLKMatrixStackGetTypeID(): number;
declare function GLKMatrixStackPush(stack: any): void;
declare function GLKMatrixStackPop(stack: any): void;
declare function GLKMatrixStackSize(stack: any): number;
declare function GLKMatrixStackMultiplyMatrixStack(stackLeft: any, stackRight: any): void;
declare function GLKMatrixStackTranslate(stack: any, tx: number, ty: number, tz: number): void;
declare function GLKMatrixStackScale(stack: any, sx: number, sy: number, sz: number): void;
declare function GLKMatrixStackRotate(stack: any, radians: number, x: number, y: number, z: number): void;
declare function GLKMatrixStackRotateX(stack: any, radians: number): void;
declare function GLKMatrixStackRotateY(stack: any, radians: number): void;
declare function GLKMatrixStackRotateZ(stack: any, radians: number): void;
declare function MPVolumeSettingsAlertShow(): void;
declare function MPVolumeSettingsAlertHide(): void;
declare function MPVolumeSettingsAlertIsVisible(): boolean;
declare function CGImageMetadataGetTypeID(): number;
declare function CGImageMetadataCreateMutable(): any;
declare function CGImageMetadataCreateMutableCopy(metadata: any): any;
declare function CGImageMetadataTagGetTypeID(): number;
declare function CGImageMetadataTagCreate(xmlns: string, prefix: string, name: string, type: number, value: any): any;
declare function CGImageMetadataTagCopyNamespace(tag: any): string;
declare function CGImageMetadataTagCopyPrefix(tag: any): string;
declare function CGImageMetadataTagCopyName(tag: any): string;
declare function CGImageMetadataTagCopyValue(tag: any): any;
declare function CGImageMetadataTagGetType(tag: any): number;
declare function CGImageMetadataTagCopyQualifiers(tag: any): NSArray;
declare function CGImageMetadataCopyTags(metadata: any): NSArray;
declare function CGImageMetadataCopyTagWithPath(metadata: any, parent: any, path: string): any;
declare function CGImageMetadataCopyStringValueWithPath(metadata: any, parent: any, path: string): string;
declare function CGImageMetadataRegisterNamespaceForPrefix(metadata: any, xmlns: string, prefix: string, err: any): boolean;
declare function CGImageMetadataSetTagWithPath(metadata: any, parent: any, path: string, tag: any): boolean;
declare function CGImageMetadataSetValueWithPath(metadata: any, parent: any, path: string, value: any): boolean;
declare function CGImageMetadataRemoveTagWithPath(metadata: any, parent: any, path: string): boolean;
declare function CGImageMetadataEnumerateTagsUsingBlock(metadata: any, rootPath: string, options: NSDictionary, block: (arg1: string, arg2: any) => boolean): void;
declare function CGImageMetadataCopyTagMatchingImageProperty(metadata: any, dictionaryName: string, propertyName: string): any;
declare function CGImageMetadataSetValueMatchingImageProperty(metadata: any, dictionaryName: string, propertyName: string, value: any): boolean;
declare function CGImageMetadataCreateXMPData(metadata: any, options: NSDictionary): NSData;
declare function CGImageMetadataCreateFromXMPData(data: NSData): any;
declare function CGImageSourceGetTypeID(): number;
declare function CGImageSourceCopyTypeIdentifiers(): NSArray;
declare function CGImageSourceCreateWithDataProvider(provider: any, options: NSDictionary): any;
declare function CGImageSourceCreateWithData(data: NSData, options: NSDictionary): any;
declare function CGImageSourceCreateWithURL(url: NSURL, options: NSDictionary): any;
declare function CGImageSourceGetType(isrc: any): string;
declare function CGImageSourceGetCount(isrc: any): number;
declare function CGImageSourceCopyProperties(isrc: any, options: NSDictionary): NSDictionary;
declare function CGImageSourceCopyPropertiesAtIndex(isrc: any, index: number, options: NSDictionary): NSDictionary;
declare function CGImageSourceCopyMetadataAtIndex(isrc: any, index: number, options: NSDictionary): any;
declare function CGImageSourceCreateImageAtIndex(isrc: any, index: number, options: NSDictionary): any;
declare function CGImageSourceRemoveCacheAtIndex(isrc: any, index: number): void;
declare function CGImageSourceCreateThumbnailAtIndex(isrc: any, index: number, options: NSDictionary): any;
declare function CGImageSourceCreateIncremental(options: NSDictionary): any;
declare function CGImageSourceUpdateData(isrc: any, data: NSData, final: boolean): void;
declare function CGImageSourceUpdateDataProvider(isrc: any, provider: any, final: boolean): void;
declare function CGImageSourceGetStatus(isrc: any): number;
declare function CGImageSourceGetStatusAtIndex(isrc: any, index: number): number;
declare function CGImageDestinationGetTypeID(): number;
declare function CGImageDestinationCopyTypeIdentifiers(): NSArray;
declare function CGImageDestinationCreateWithDataConsumer(consumer: any, type: string, count: number, options: NSDictionary): any;
declare function CGImageDestinationCreateWithData(data: NSMutableData, type: string, count: number, options: NSDictionary): any;
declare function CGImageDestinationCreateWithURL(url: NSURL, type: string, count: number, options: NSDictionary): any;
declare function CGImageDestinationSetProperties(idst: any, properties: NSDictionary): void;
declare function CGImageDestinationAddImage(idst: any, image: any, properties: NSDictionary): void;
declare function CGImageDestinationAddImageFromSource(idst: any, isrc: any, index: number, properties: NSDictionary): void;
declare function CGImageDestinationFinalize(idst: any): boolean;
declare function CGImageDestinationAddImageAndMetadata(idst: any, image: any, metadata: any, options: NSDictionary): void;
declare function CGImageDestinationCopyImageSource(idst: any, isrc: any, options: NSDictionary, err: any): boolean;
declare function JSEvaluateScript(ctx: any, script: any, thisObject: any, sourceURL: any, startingLineNumber: number, exception: any): any;
declare function JSCheckScriptSyntax(ctx: any, script: any, sourceURL: any, startingLineNumber: number, exception: any): boolean;
declare function JSGarbageCollect(ctx: any): void;
declare function JSValueGetType(ctx: any, arg: any): number;
declare function JSValueIsUndefined(ctx: any, value: any): boolean;
declare function JSValueIsNull(ctx: any, value: any): boolean;
declare function JSValueIsBoolean(ctx: any, value: any): boolean;
declare function JSValueIsNumber(ctx: any, value: any): boolean;
declare function JSValueIsString(ctx: any, value: any): boolean;
declare function JSValueIsObject(ctx: any, value: any): boolean;
declare function JSValueIsObjectOfClass(ctx: any, value: any, jsClass: any): boolean;
declare function JSValueIsEqual(ctx: any, a: any, b: any, exception: any): boolean;
declare function JSValueIsStrictEqual(ctx: any, a: any, b: any): boolean;
declare function JSValueIsInstanceOfConstructor(ctx: any, value: any, constructor: any, exception: any): boolean;
declare function JSValueMakeUndefined(ctx: any): any;
declare function JSValueMakeNull(ctx: any): any;
declare function JSValueMakeBoolean(ctx: any, boolean: boolean): any;
declare function JSValueMakeNumber(ctx: any, number: number): any;
declare function JSValueMakeString(ctx: any, string: any): any;
declare function JSValueMakeFromJSONString(ctx: any, string: any): any;
declare function JSValueCreateJSONString(ctx: any, value: any, indent: number, exception: any): any;
declare function JSValueToBoolean(ctx: any, value: any): boolean;
declare function JSValueToNumber(ctx: any, value: any, exception: any): number;
declare function JSValueToStringCopy(ctx: any, value: any, exception: any): any;
declare function JSValueToObject(ctx: any, value: any, exception: any): any;
declare function JSValueProtect(ctx: any, value: any): void;
declare function JSValueUnprotect(ctx: any, value: any): void;
declare function JSClassCreate(definition: any): any;
declare function JSClassRetain(jsClass: any): any;
declare function JSClassRelease(jsClass: any): void;
declare function JSObjectMake(ctx: any, jsClass: any, data: any): any;
declare function JSObjectMakeFunctionWithCallback(ctx: any, name: any, callAsFunction: (arg1: any, arg2: any, arg3: any, arg4: number, arg5: any, arg6: any) => any): any;
declare function JSObjectMakeConstructor(ctx: any, jsClass: any, callAsConstructor: (arg1: any, arg2: any, arg3: number, arg4: any, arg5: any) => any): any;
declare function JSObjectMakeArray(ctx: any, argumentCount: number, args: any, exception: any): any;
declare function JSObjectMakeDate(ctx: any, argumentCount: number, args: any, exception: any): any;
declare function JSObjectMakeError(ctx: any, argumentCount: number, args: any, exception: any): any;
declare function JSObjectMakeRegExp(ctx: any, argumentCount: number, args: any, exception: any): any;
declare function JSObjectMakeFunction(ctx: any, name: any, parameterCount: number, parameterNames: any, body: any, sourceURL: any, startingLineNumber: number, exception: any): any;
declare function JSObjectGetPrototype(ctx: any, object: any): any;
declare function JSObjectSetPrototype(ctx: any, object: any, value: any): void;
declare function JSObjectHasProperty(ctx: any, object: any, propertyName: any): boolean;
declare function JSObjectGetProperty(ctx: any, object: any, propertyName: any, exception: any): any;
declare function JSObjectSetProperty(ctx: any, object: any, propertyName: any, value: any, attributes: number, exception: any): void;
declare function JSObjectDeleteProperty(ctx: any, object: any, propertyName: any, exception: any): boolean;
declare function JSObjectGetPropertyAtIndex(ctx: any, object: any, propertyIndex: number, exception: any): any;
declare function JSObjectSetPropertyAtIndex(ctx: any, object: any, propertyIndex: number, value: any, exception: any): void;
declare function JSObjectGetPrivate(object: any): any;
declare function JSObjectSetPrivate(object: any, data: any): boolean;
declare function JSObjectIsFunction(ctx: any, object: any): boolean;
declare function JSObjectCallAsFunction(ctx: any, object: any, thisObject: any, argumentCount: number, args: any, exception: any): any;
declare function JSObjectIsConstructor(ctx: any, object: any): boolean;
declare function JSObjectCallAsConstructor(ctx: any, object: any, argumentCount: number, args: any, exception: any): any;
declare function JSObjectCopyPropertyNames(ctx: any, object: any): any;
declare function JSPropertyNameArrayRetain(array: any): any;
declare function JSPropertyNameArrayRelease(array: any): void;
declare function JSPropertyNameArrayGetCount(array: any): number;
declare function JSPropertyNameArrayGetNameAtIndex(array: any, index: number): any;
declare function JSPropertyNameAccumulatorAddName(accumulator: any, propertyName: any): void;
declare function JSContextGroupCreate(): any;
declare function JSContextGroupRetain(group: any): any;
declare function JSContextGroupRelease(group: any): void;
declare function JSGlobalContextCreate(globalObjectClass: any): any;
declare function JSGlobalContextCreateInGroup(group: any, globalObjectClass: any): any;
declare function JSGlobalContextRetain(ctx: any): any;
declare function JSGlobalContextRelease(ctx: any): void;
declare function JSContextGetGlobalObject(ctx: any): any;
declare function JSContextGetGroup(ctx: any): any;
declare function JSContextGetGlobalContext(ctx: any): any;
declare function JSGlobalContextCopyName(ctx: any): any;
declare function JSGlobalContextSetName(ctx: any, name: any): void;
declare function JSStringCreateWithCharacters(chars: any, numChars: number): any;
declare function JSStringCreateWithUTF8CString(string: string): any;
declare function JSStringRetain(string: any): any;
declare function JSStringRelease(string: any): void;
declare function JSStringGetLength(string: any): number;
declare function JSStringGetCharactersPtr(string: any): any;
declare function JSStringGetMaximumUTF8CStringSize(string: any): number;
declare function JSStringGetUTF8CString(string: any, buffer: string, bufferSize: number): number;
declare function JSStringIsEqual(a: any, b: any): boolean;
declare function JSStringIsEqualToUTF8CString(a: any, b: string): boolean;
declare function JSStringCreateWithCFString(string: string): any;
declare function JSStringCopyCFString(alloc: any, string: any): string;
declare function MKCoordinateRegionMakeWithDistance(centerCoordinate: CLLocationCoordinate2D, latitudinalMeters: number, longitudinalMeters: number): MKCoordinateRegion;
declare function MKMapPointForCoordinate(coordinate: CLLocationCoordinate2D): MKMapPoint;
declare function MKCoordinateForMapPoint(mapPoint: MKMapPoint): CLLocationCoordinate2D;
declare function MKMetersPerMapPointAtLatitude(latitude: number): number;
declare function MKMapPointsPerMeterAtLatitude(latitude: number): number;
declare function MKMetersBetweenMapPoints(a: MKMapPoint, b: MKMapPoint): number;
declare function MKMapRectUnion(rect1: MKMapRect, rect2: MKMapRect): MKMapRect;
declare function MKMapRectIntersection(rect1: MKMapRect, rect2: MKMapRect): MKMapRect;
declare function MKMapRectInset(rect: MKMapRect, dx: number, dy: number): MKMapRect;
declare function MKMapRectOffset(rect: MKMapRect, dx: number, dy: number): MKMapRect;
declare function MKMapRectDivide(rect: MKMapRect, slice: any, remainder: any, amount: number, edge: number): void;
declare function MKMapRectContainsPoint(rect: MKMapRect, point: MKMapPoint): boolean;
declare function MKMapRectContainsRect(rect1: MKMapRect, rect2: MKMapRect): boolean;
declare function MKMapRectIntersectsRect(rect1: MKMapRect, rect2: MKMapRect): boolean;
declare function MKCoordinateRegionForMapRect(rect: MKMapRect): MKCoordinateRegion;
declare function MKMapRectSpans180thMeridian(rect: MKMapRect): boolean;
declare function MKMapRectRemainder(rect: MKMapRect): MKMapRect;
declare function MKRoadWidthAtZoomScale(zoomScale: number): number;
declare function MACaptionAppearanceAddSelectedLanguage(domain: number, language: string): boolean;
declare function MACaptionAppearanceCopySelectedLanguages(domain: number): NSArray;
declare function MACaptionAppearanceGetDisplayType(domain: number): number;
declare function MACaptionAppearanceSetDisplayType(domain: number, displayType: number): void;
declare function MACaptionAppearanceCopyPreferredCaptioningMediaCharacteristics(domain: number): NSArray;
declare function MACaptionAppearanceCopyForegroundColor(domain: number, behavior: any): any;
declare function MACaptionAppearanceCopyBackgroundColor(domain: number, behavior: any): any;
declare function MACaptionAppearanceCopyWindowColor(domain: number, behavior: any): any;
declare function MACaptionAppearanceGetForegroundOpacity(domain: number, behavior: any): number;
declare function MACaptionAppearanceGetBackgroundOpacity(domain: number, behavior: any): number;
declare function MACaptionAppearanceGetWindowOpacity(domain: number, behavior: any): number;
declare function MACaptionAppearanceGetWindowRoundedCornerRadius(domain: number, behavior: any): number;
declare function MACaptionAppearanceCopyFontDescriptorForStyle(domain: number, behavior: any, fontStyle: number): any;
declare function MACaptionAppearanceGetRelativeCharacterSize(domain: number, behavior: any): number;
declare function MACaptionAppearanceGetTextEdgeStyle(domain: number, behavior: any): number;
declare function MAAudibleMediaCopyPreferredCharacteristics(): NSArray;
declare function UTTypeCreatePreferredIdentifierForTag(inTagClass: string, inTag: string, inConformingToUTI: string): string;
declare function UTTypeCreateAllIdentifiersForTag(inTagClass: string, inTag: string, inConformingToUTI: string): NSArray;
declare function UTTypeCopyPreferredTagWithClass(inUTI: string, inTagClass: string): string;
declare function UTTypeCopyAllTagsWithClass(inUTI: string, inTagClass: string): NSArray;
declare function UTTypeEqual(inUTI1: string, inUTI2: string): boolean;
declare function UTTypeConformsTo(inUTI: string, inConformsToUTI: string): boolean;
declare function UTTypeCopyDescription(inUTI: string): string;
declare function UTTypeIsDeclared(inUTI: string): boolean;
declare function UTTypeIsDynamic(inUTI: string): boolean;
declare function UTTypeCopyDeclaration(inUTI: string): NSDictionary;
declare function UTTypeCopyDeclaringBundleURL(inUTI: string): NSURL;
declare function SKTerminateForInvalidReceipt(): void;
declare function SCNetworkReachabilityCreateWithAddress(allocator: any, address: any): any;
declare function SCNetworkReachabilityCreateWithAddressPair(allocator: any, localAddress: any, remoteAddress: any): any;
declare function SCNetworkReachabilityCreateWithName(allocator: any, nodename: string): any;
declare function SCNetworkReachabilityGetTypeID(): number;
declare function SCNetworkReachabilityGetFlags(target: any, flags: any): boolean;
declare function SCNetworkReachabilitySetCallback(target: any, callout: (arg1: any, arg2: number, arg3: any) => void, context: any): boolean;
declare function SCNetworkReachabilityScheduleWithRunLoop(target: any, runLoop: any, runLoopMode: string): boolean;
declare function SCNetworkReachabilityUnscheduleFromRunLoop(target: any, runLoop: any, runLoopMode: string): boolean;
declare function SCNetworkReachabilitySetDispatchQueue(target: any, queue: NSObject): boolean;
declare function SCCopyLastError(): NSError;
declare function SCError(): number;
declare function SCErrorString(status: number): string;
declare function VTSessionCopySupportedPropertyDictionary(session: any, supportedPropertyDictionaryOut: any): number;
declare function VTSessionSetProperty(session: any, propertyKey: string, propertyValue: any): number;
declare function VTSessionCopyProperty(session: any, propertyKey: string, allocator: any, propertyValueOut: any): number;
declare function VTSessionSetProperties(session: any, propertyDictionary: NSDictionary): number;
declare function VTSessionCopySerializableProperties(session: any, allocator: any, dictionaryOut: any): number;
declare function VTCompressionSessionCreate(allocator: any, width: number, height: number, codecType: number, encoderSpecification: NSDictionary, sourceImageBufferAttributes: NSDictionary, compressedDataAllocator: any, outputCallback: (arg1: any, arg2: any, arg3: number, arg4: number, arg5: any) => void, outputCallbackRefCon: any, compressionSessionOut: any): number;
declare function VTCompressionSessionInvalidate(session: any): void;
declare function VTCompressionSessionGetTypeID(): number;
declare function VTCompressionSessionGetPixelBufferPool(session: any): any;
declare function VTCompressionSessionPrepareToEncodeFrames(session: any): number;
declare function VTCompressionSessionEncodeFrame(session: any, imageBuffer: any, presentationTimeStamp: CMTime, duration: CMTime, frameProperties: NSDictionary, sourceFrameRefCon: any, infoFlagsOut: any): number;
declare function VTCompressionSessionCompleteFrames(session: any, completeUntilPresentationTimeStamp: CMTime): number;
declare function VTCompressionSessionBeginPass(session: any, beginPassFlags: number, reserved: any): number;
declare function VTCompressionSessionEndPass(session: any, furtherPassesRequestedOut: string, reserved: any): number;
declare function VTCompressionSessionGetTimeRangesForNextPass(session: any, timeRangeCountOut: any, timeRangeArrayOut: any): number;
declare function VTDecompressionSessionCreate(allocator: any, videoFormatDescription: any, videoDecoderSpecification: NSDictionary, destinationImageBufferAttributes: NSDictionary, outputCallback: any, decompressionSessionOut: any): number;
declare function VTDecompressionSessionInvalidate(session: any): void;
declare function VTDecompressionSessionGetTypeID(): number;
declare function VTDecompressionSessionDecodeFrame(session: any, sampleBuffer: any, decodeFlags: number, sourceFrameRefCon: any, infoFlagsOut: any): number;
declare function VTDecompressionSessionFinishDelayedFrames(session: any): number;
declare function VTDecompressionSessionCanAcceptFormatDescription(session: any, newFormatDesc: any): boolean;
declare function VTDecompressionSessionWaitForAsynchronousFrames(session: any): number;
declare function VTDecompressionSessionCopyBlackPixelBuffer(session: any, pixelBufferOut: any): number;
declare function VTFrameSiloGetTypeID(): number;
declare function VTFrameSiloCreate(allocator: any, fileURL: NSURL, timeRange: CMTimeRange, options: NSDictionary, siloOut: any): number;
declare function VTFrameSiloAddSampleBuffer(silo: any, sampleBuffer: any): number;
declare function VTFrameSiloSetTimeRangesForNextPass(silo: any, timeRangeCount: number, timeRangeArray: any): number;
declare function VTFrameSiloGetProgressOfCurrentPass(silo: any, progressOut: any): number;
declare function VTFrameSiloCallFunctionForEachSampleBuffer(silo: any, timeRange: CMTimeRange, callbackInfo: any, callback: (arg1: any, arg2: any) => number): number;
declare function VTFrameSiloCallBlockForEachSampleBuffer(silo: any, timeRange: CMTimeRange, handler: (arg1: any) => number): number;
declare function VTMultiPassStorageGetTypeID(): number;
declare function VTMultiPassStorageCreate(allocator: any, fileURL: NSURL, timeRange: CMTimeRange, options: NSDictionary, multiPassStorageOut: any): number;
declare function VTMultiPassStorageClose(multiPassStorage: any): number;
declare function VTCopyVideoEncoderList(options: NSDictionary, listOfVideoEncodersOut: any): number;
declare function sqlite3_libversion(): string;
declare function sqlite3_sourceid(): string;
declare function sqlite3_libversion_number(): number;
declare function sqlite3_compileoption_used(zOptName: string): number;
declare function sqlite3_compileoption_get(N: number): string;
declare function sqlite3_threadsafe(): number;
declare function sqlite3_close(arg: any): number;
declare function sqlite3_exec(arg: any, sql: string, callback: (arg1: any, arg2: number, arg3: any, arg4: any) => number, arg1: any, errmsg: any): number;
declare function sqlite3_initialize(): number;
declare function sqlite3_shutdown(): number;
declare function sqlite3_os_init(): number;
declare function sqlite3_os_end(): number;
declare function sqlite3_extended_result_codes(arg: any, onoff: number): number;
declare function sqlite3_last_insert_rowid(arg: any): number;
declare function sqlite3_changes(arg: any): number;
declare function sqlite3_total_changes(arg: any): number;
declare function sqlite3_interrupt(arg: any): void;
declare function sqlite3_complete(sql: string): number;
declare function sqlite3_complete16(sql: any): number;
declare function sqlite3_busy_handler(arg: any, arg1: (arg1: any, arg2: number) => number, arg2: any): number;
declare function sqlite3_busy_timeout(arg: any, ms: number): number;
declare function sqlite3_get_table(db: any, zSql: string, pazResult: any, pnRow: any, pnColumn: any, pzErrmsg: any): number;
declare function sqlite3_free_table(result: any): void;
declare function sqlite3_malloc(arg: number): any;
declare function sqlite3_realloc(arg: any, arg1: number): any;
declare function sqlite3_free(arg: any): void;
declare function sqlite3_memory_used(): number;
declare function sqlite3_memory_highwater(resetFlag: number): number;
declare function sqlite3_randomness(N: number, P: any): void;
declare function sqlite3_set_authorizer(arg: any, xAuth: (arg1: any, arg2: number, arg3: string, arg4: string, arg5: string, arg6: string) => number, pUserData: any): number;
declare function sqlite3_trace(arg: any, xTrace: (arg1: any, arg2: string) => void, arg1: any): any;
declare function sqlite3_profile(arg: any, xProfile: (arg1: any, arg2: string, arg3: number) => void, arg1: any): any;
declare function sqlite3_progress_handler(arg: any, arg1: number, arg2: (arg1: any) => number, arg3: any): void;
declare function sqlite3_open(filename: string, ppDb: any): number;
declare function sqlite3_open16(filename: any, ppDb: any): number;
declare function sqlite3_open_v2(filename: string, ppDb: any, flags: number, zVfs: string): number;
declare function sqlite3_uri_parameter(zFilename: string, zParam: string): string;
declare function sqlite3_uri_boolean(zFile: string, zParam: string, bDefault: number): number;
declare function sqlite3_uri_int64(arg: string, arg1: string, arg2: number): number;
declare function sqlite3_errcode(db: any): number;
declare function sqlite3_extended_errcode(db: any): number;
declare function sqlite3_errmsg(arg: any): string;
declare function sqlite3_errmsg16(arg: any): any;
declare function sqlite3_limit(arg: any, id: number, newVal: number): number;
declare function sqlite3_prepare(db: any, zSql: string, nByte: number, ppStmt: any, pzTail: any): number;
declare function sqlite3_prepare_v2(db: any, zSql: string, nByte: number, ppStmt: any, pzTail: any): number;
declare function sqlite3_prepare16(db: any, zSql: any, nByte: number, ppStmt: any, pzTail: any): number;
declare function sqlite3_prepare16_v2(db: any, zSql: any, nByte: number, ppStmt: any, pzTail: any): number;
declare function sqlite3_sql(pStmt: any): string;
declare function sqlite3_stmt_readonly(pStmt: any): number;
declare function sqlite3_stmt_busy(arg: any): number;
declare function sqlite3_bind_blob(arg: any, arg1: number, arg2: any, n: number, arg3: (arg1: any) => void): number;
declare function sqlite3_bind_double(arg: any, arg1: number, arg2: number): number;
declare function sqlite3_bind_int(arg: any, arg1: number, arg2: number): number;
declare function sqlite3_bind_int64(arg: any, arg1: number, arg2: number): number;
declare function sqlite3_bind_null(arg: any, arg1: number): number;
declare function sqlite3_bind_text(arg: any, arg1: number, arg2: string, n: number, arg3: (arg1: any) => void): number;
declare function sqlite3_bind_text16(arg: any, arg1: number, arg2: any, arg3: number, arg4: (arg1: any) => void): number;
declare function sqlite3_bind_value(arg: any, arg1: number, arg2: any): number;
declare function sqlite3_bind_zeroblob(arg: any, arg1: number, n: number): number;
declare function sqlite3_bind_parameter_count(arg: any): number;
declare function sqlite3_bind_parameter_name(arg: any, arg1: number): string;
declare function sqlite3_bind_parameter_index(arg: any, zName: string): number;
declare function sqlite3_clear_bindings(arg: any): number;
declare function sqlite3_column_count(pStmt: any): number;
declare function sqlite3_column_name(arg: any, N: number): string;
declare function sqlite3_column_name16(arg: any, N: number): any;
declare function sqlite3_column_decltype(arg: any, arg1: number): string;
declare function sqlite3_column_decltype16(arg: any, arg1: number): any;
declare function sqlite3_step(arg: any): number;
declare function sqlite3_data_count(pStmt: any): number;
declare function sqlite3_column_blob(arg: any, iCol: number): any;
declare function sqlite3_column_bytes(arg: any, iCol: number): number;
declare function sqlite3_column_bytes16(arg: any, iCol: number): number;
declare function sqlite3_column_double(arg: any, iCol: number): number;
declare function sqlite3_column_int(arg: any, iCol: number): number;
declare function sqlite3_column_int64(arg: any, iCol: number): number;
declare function sqlite3_column_text(arg: any, iCol: number): string;
declare function sqlite3_column_text16(arg: any, iCol: number): any;
declare function sqlite3_column_type(arg: any, iCol: number): number;
declare function sqlite3_column_value(arg: any, iCol: number): any;
declare function sqlite3_finalize(pStmt: any): number;
declare function sqlite3_reset(pStmt: any): number;
declare function sqlite3_create_function(db: any, zFunctionName: string, nArg: number, eTextRep: number, pApp: any, xFunc: (arg1: any, arg2: number, arg3: any) => void, xStep: (arg1: any, arg2: number, arg3: any) => void, xFinal: (arg1: any) => void): number;
declare function sqlite3_create_function16(db: any, zFunctionName: any, nArg: number, eTextRep: number, pApp: any, xFunc: (arg1: any, arg2: number, arg3: any) => void, xStep: (arg1: any, arg2: number, arg3: any) => void, xFinal: (arg1: any) => void): number;
declare function sqlite3_create_function_v2(db: any, zFunctionName: string, nArg: number, eTextRep: number, pApp: any, xFunc: (arg1: any, arg2: number, arg3: any) => void, xStep: (arg1: any, arg2: number, arg3: any) => void, xFinal: (arg1: any) => void, xDestroy: (arg1: any) => void): number;
declare function sqlite3_aggregate_count(arg: any): number;
declare function sqlite3_expired(arg: any): number;
declare function sqlite3_transfer_bindings(arg: any, arg1: any): number;
declare function sqlite3_global_recover(): number;
declare function sqlite3_thread_cleanup(): void;
declare function sqlite3_memory_alarm(arg: (arg1: any, arg2: number, arg3: number) => void, arg1: any, arg2: number): number;
declare function sqlite3_value_blob(arg: any): any;
declare function sqlite3_value_bytes(arg: any): number;
declare function sqlite3_value_bytes16(arg: any): number;
declare function sqlite3_value_double(arg: any): number;
declare function sqlite3_value_int(arg: any): number;
declare function sqlite3_value_int64(arg: any): number;
declare function sqlite3_value_text(arg: any): string;
declare function sqlite3_value_text16(arg: any): any;
declare function sqlite3_value_text16le(arg: any): any;
declare function sqlite3_value_text16be(arg: any): any;
declare function sqlite3_value_type(arg: any): number;
declare function sqlite3_value_numeric_type(arg: any): number;
declare function sqlite3_aggregate_context(arg: any, nBytes: number): any;
declare function sqlite3_user_data(arg: any): any;
declare function sqlite3_context_db_handle(arg: any): any;
declare function sqlite3_get_auxdata(arg: any, N: number): any;
declare function sqlite3_set_auxdata(arg: any, N: number, arg1: any, arg2: (arg1: any) => void): void;
declare function sqlite3_result_blob(arg: any, arg1: any, arg2: number, arg3: (arg1: any) => void): void;
declare function sqlite3_result_double(arg: any, arg1: number): void;
declare function sqlite3_result_error(arg: any, arg1: string, arg2: number): void;
declare function sqlite3_result_error16(arg: any, arg1: any, arg2: number): void;
declare function sqlite3_result_error_toobig(arg: any): void;
declare function sqlite3_result_error_nomem(arg: any): void;
declare function sqlite3_result_error_code(arg: any, arg1: number): void;
declare function sqlite3_result_int(arg: any, arg1: number): void;
declare function sqlite3_result_int64(arg: any, arg1: number): void;
declare function sqlite3_result_null(arg: any): void;
declare function sqlite3_result_text(arg: any, arg1: string, arg2: number, arg3: (arg1: any) => void): void;
declare function sqlite3_result_text16(arg: any, arg1: any, arg2: number, arg3: (arg1: any) => void): void;
declare function sqlite3_result_text16le(arg: any, arg1: any, arg2: number, arg3: (arg1: any) => void): void;
declare function sqlite3_result_text16be(arg: any, arg1: any, arg2: number, arg3: (arg1: any) => void): void;
declare function sqlite3_result_value(arg: any, arg1: any): void;
declare function sqlite3_result_zeroblob(arg: any, n: number): void;
declare function sqlite3_create_collation(arg: any, zName: string, eTextRep: number, pArg: any, xCompare: (arg1: any, arg2: number, arg3: any, arg4: number, arg5: any) => number): number;
declare function sqlite3_create_collation_v2(arg: any, zName: string, eTextRep: number, pArg: any, xCompare: (arg1: any, arg2: number, arg3: any, arg4: number, arg5: any) => number, xDestroy: (arg1: any) => void): number;
declare function sqlite3_create_collation16(arg: any, zName: any, eTextRep: number, pArg: any, xCompare: (arg1: any, arg2: number, arg3: any, arg4: number, arg5: any) => number): number;
declare function sqlite3_collation_needed(arg: any, arg1: any, arg2: (arg1: any, arg2: any, arg3: number, arg4: string) => void): number;
declare function sqlite3_collation_needed16(arg: any, arg1: any, arg2: (arg1: any, arg2: any, arg3: number, arg4: any) => void): number;
declare function sqlite3_sleep(arg: number): number;
declare function sqlite3_get_autocommit(arg: any): number;
declare function sqlite3_db_handle(arg: any): any;
declare function sqlite3_db_filename(db: any, zDbName: string): string;
declare function sqlite3_db_readonly(db: any, zDbName: string): number;
declare function sqlite3_next_stmt(pDb: any, pStmt: any): any;
declare function sqlite3_commit_hook(arg: any, arg1: (arg1: any) => number, arg2: any): any;
declare function sqlite3_rollback_hook(arg: any, arg1: (arg1: any) => void, arg2: any): any;
declare function sqlite3_update_hook(arg: any, arg1: (arg1: any, arg2: number, arg3: string, arg4: string, arg5: number) => void, arg2: any): any;
declare function sqlite3_enable_shared_cache(arg: number): number;
declare function sqlite3_release_memory(arg: number): number;
declare function sqlite3_db_release_memory(arg: any): number;
declare function sqlite3_soft_heap_limit64(N: number): number;
declare function sqlite3_soft_heap_limit(N: number): void;
declare function sqlite3_auto_extension(xEntryPoint: () => void): number;
declare function sqlite3_reset_auto_extension(): void;
declare function sqlite3_create_module(db: any, zName: string, p: any, pClientData: any): number;
declare function sqlite3_create_module_v2(db: any, zName: string, p: any, pClientData: any, xDestroy: (arg1: any) => void): number;
declare function sqlite3_declare_vtab(arg: any, zSQL: string): number;
declare function sqlite3_overload_function(arg: any, zFuncName: string, nArg: number): number;
declare function sqlite3_blob_open(arg: any, zDb: string, zTable: string, zColumn: string, iRow: number, flags: number, ppBlob: any): number;
declare function sqlite3_blob_reopen(arg: any, arg1: number): number;
declare function sqlite3_blob_close(arg: any): number;
declare function sqlite3_blob_bytes(arg: any): number;
declare function sqlite3_blob_read(arg: any, Z: any, N: number, iOffset: number): number;
declare function sqlite3_blob_write(arg: any, z: any, n: number, iOffset: number): number;
declare function sqlite3_vfs_find(zVfsName: string): any;
declare function sqlite3_vfs_register(arg: any, makeDflt: number): number;
declare function sqlite3_vfs_unregister(arg: any): number;
declare function sqlite3_mutex_alloc(arg: number): any;
declare function sqlite3_mutex_free(arg: any): void;
declare function sqlite3_mutex_enter(arg: any): void;
declare function sqlite3_mutex_try(arg: any): number;
declare function sqlite3_mutex_leave(arg: any): void;
declare function sqlite3_db_mutex(arg: any): any;
declare function sqlite3_file_control(arg: any, zDbName: string, op: number, arg1: any): number;
declare function sqlite3_status(op: number, pCurrent: any, pHighwater: any, resetFlag: number): number;
declare function sqlite3_db_status(arg: any, op: number, pCur: any, pHiwtr: any, resetFlg: number): number;
declare function sqlite3_stmt_status(arg: any, op: number, resetFlg: number): number;
declare function sqlite3_backup_init(pDest: any, zDestName: string, pSource: any, zSourceName: string): any;
declare function sqlite3_backup_step(p: any, nPage: number): number;
declare function sqlite3_backup_finish(p: any): number;
declare function sqlite3_backup_remaining(p: any): number;
declare function sqlite3_backup_pagecount(p: any): number;
declare function sqlite3_stricmp(arg: string, arg1: string): number;
declare function sqlite3_strnicmp(arg: string, arg1: string, arg2: number): number;
declare function sqlite3_wal_hook(arg: any, arg1: (arg1: any, arg2: any, arg3: string, arg4: number) => number, arg2: any): any;
declare function sqlite3_wal_autocheckpoint(db: any, N: number): number;
declare function sqlite3_wal_checkpoint(db: any, zDb: string): number;
declare function sqlite3_wal_checkpoint_v2(db: any, zDb: string, eMode: number, pnLog: any, pnCkpt: any): number;
declare function sqlite3_vtab_on_conflict(arg: any): number;
declare function sqlite3_rtree_geometry_callback(db: any, zGeom: string, xGeom: (arg1: any, arg2: number, arg3: any, arg4: any) => number, pContext: any): number;
